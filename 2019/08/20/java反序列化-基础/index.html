<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="首先从使用java反序列化开始 序列化与反序列化的正常使用先来看代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.nio.file.attribute.UserDefinedFileAttributeView;import java.ut">
<meta name="keywords" content="web,java,java反序列化">
<meta property="og:type" content="article">
<meta property="og:title" content="java反序列化-基础">
<meta property="og:url" content="http://lalajun.com/2019/08/20/java反序列化-基础/index.html">
<meta property="og:site_name" content="啦啦菌NODE">
<meta property="og:description" content="首先从使用java反序列化开始 序列化与反序列化的正常使用先来看代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.nio.file.attribute.UserDefinedFileAttributeView;import java.ut">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1g666z9wj85j31qa11btd1.jpg">
<meta property="og:updated_time" content="2019-08-20T08:20:15.804Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java反序列化-基础">
<meta name="twitter:description" content="首先从使用java反序列化开始 序列化与反序列化的正常使用先来看代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.nio.file.attribute.UserDefinedFileAttributeView;import java.ut">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/006iKNp3ly1g666z9wj85j31qa11btd1.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>java反序列化-基础</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2019/08/19/java反射机制/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://lalajun.com/2019/08/20/java反序列化-基础/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://lalajun.com/2019/08/20/java反序列化-基础/&text=java反序列化-基础"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://lalajun.com/2019/08/20/java反序列化-基础/&title=java反序列化-基础"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lalajun.com/2019/08/20/java反序列化-基础/&is_video=false&description=java反序列化-基础"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=java反序列化-基础&body=Check out this article: http://lalajun.com/2019/08/20/java反序列化-基础/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://lalajun.com/2019/08/20/java反序列化-基础/&title=java反序列化-基础"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://lalajun.com/2019/08/20/java反序列化-基础/&title=java反序列化-基础"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://lalajun.com/2019/08/20/java反序列化-基础/&title=java反序列化-基础"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://lalajun.com/2019/08/20/java反序列化-基础/&title=java反序列化-基础"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://lalajun.com/2019/08/20/java反序列化-基础/&name=java反序列化-基础&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#序列化与反序列化的正常使用"><span class="toc-number">1.</span> <span class="toc-text">序列化与反序列化的正常使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞原理"><span class="toc-number">2.</span> <span class="toc-text">漏洞原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#那么深究一下为啥呢"><span class="toc-number">2.1.</span> <span class="toc-text">那么深究一下为啥呢</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#不能复写成功的对照组"><span class="toc-number">2.1.1.</span> <span class="toc-text">不能复写成功的对照组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-number">4.</span> <span class="toc-text">参考文章</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        java反序列化-基础
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">啦啦菌NODE</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-08-20T06:58:45.000Z" itemprop="datePublished">2019-08-20</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>, <a class="tag-link" href="/tags/java反序列化/">java反序列化</a>, <a class="tag-link" href="/tags/web/">web</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>首先从使用java反序列化开始</p>
<h2 id="序列化与反序列化的正常使用"><a href="#序列化与反序列化的正常使用" class="headerlink" title="序列化与反序列化的正常使用"></a>序列化与反序列化的正常使用</h2><p>先来看代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.UserDefinedFileAttributeView;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trytry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//整一个需要序列化的对象</span></span><br><span class="line">        user u = <span class="keyword">new</span> user();</span><br><span class="line">        u.setName(<span class="string">"lala"</span>);</span><br><span class="line">        <span class="comment">//序列化输出至屏幕</span></span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(System.out);</span><br><span class="line">        out.writeObject(u);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//序列化写入文件</span></span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.bin"</span>);</span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">        fout.writeObject(u);</span><br><span class="line">        <span class="comment">//序列化写入到变量中</span></span><br><span class="line">        ByteArrayOutputStream bOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(bOut);</span><br><span class="line">        objOut.writeObject(u);</span><br><span class="line">        <span class="keyword">byte</span>[] str= bOut.toByteArray();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(str));</span><br><span class="line">        <span class="comment">//从变量中反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(str));</span><br><span class="line">        user u_d = (user) ois.readObject();</span><br><span class="line">        System.out.println(u_d.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">�� sr user_AO���j L namet Ljava/lang/String;xpt lala</span><br><span class="line">�� sr user_AO���j L namet Ljava/lang/String;xpt lala</span><br><span class="line">lala</span><br></pre></td></tr></table></figure>
<p>一个类的对象想要序列化成功，需要满足两个条件：</p>
<ol>
<li>该类必须实现java.io.Serializable接口</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</li>
</ol>
<p>如果你想知道一个 Java 标准类是否是可序列化的，可以通过查看该类的文档,查看该类有没有实现 java.io.Serializable接口。</p>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>漏洞关键在于调用<code>readObject()</code>,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(str))</span><br><span class="line">user u_d = (user) ois.readObject();</span><br></pre></td></tr></table></figure></p>
<p>那我们试着用网上的payload来复写readObject<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处存在两个注意点：</p>
<ol>
<li>readObject函数必须是<code>private</code>属性</li>
<li>readObject函数必须传参<code>java.io.ObjectInputStream in</code></li>
</ol>
<p>那么问题来了，到底为什么readObject函数要使用private属性，传参java.io.ObjectInputStream呢</p>
<h3 id="那么深究一下为啥呢"><a href="#那么深究一下为啥呢" class="headerlink" title="那么深究一下为啥呢"></a>那么深究一下为啥呢</h3><p>然后在<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;)</code>处下断点，运行。<br>得到如下调用栈</p>
<p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g666z9wj85j31qa11btd1.jpg" alt></p>
<p>根据调用栈的层次来回溯是如何执行到<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;)</code><br>先是<code>ObjectInputStream.java</code>的<code>readObject</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">           <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">       <span class="keyword">int</span> outerHandle = passHandle;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//进入这里，默认传入false</span></span><br><span class="line">           Object obj = readObject0(<span class="keyword">false</span>);</span><br><span class="line">           handles.markDependency(outerHandle, passHandle);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一开始我还以为是如果覆盖了enableOverride为true，直接通过readObjectOverride去调用我们的函数。实际上….完全不是= =</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// ...省略...</span></span><br><span class="line">        <span class="keyword">byte</span> tc;</span><br><span class="line">        <span class="keyword">while</span> ((tc = bin.peekByte()) == TC_RESET) &#123; <span class="comment">//此处bin.peekByte()赋值为115，TC_RESET为121。等式不成立。由于自己太菜，不细究为什么115这些底层细节</span></span><br><span class="line">            bin.readByte();</span><br><span class="line">            handleReset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (tc) &#123;<span class="comment">//此时tc是115</span></span><br><span class="line"><span class="comment">// ...省略...</span></span><br><span class="line">                <span class="keyword">case</span> TC_OBJECT:<span class="comment">//TC_OBJECT为115，感觉可能是反序列化的目标是一个Object的意思？</span></span><br><span class="line">                    <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="comment">//先进入readOrdinaryObject函数，后进入checkResolve函数</span></span><br></pre></td></tr></table></figure>
<p>先看readOrdinaryObject函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//省略一个抛出异常，没看懂</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ObjectStreamClass desc </span>= readClassDesc(<span class="keyword">false</span>);<span class="comment">//此处会形成一个user类的ObjectStreamClass类</span></span><br><span class="line">    desc.checkDeserialize();<span class="comment">//检查是否反序列化？</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();<span class="comment">//获取class user</span></span><br><span class="line">    <span class="keyword">if</span> (cl == String.class || cl == Class.class</span><br><span class="line">            || cl == ObjectStreamClass.class) &#123;<span class="comment">//一些类型不提供支持，报错</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"invalid class descriptor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;<span class="comment">//很关键 先判断是否有构造器，然后获取class user的实例化obj</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            desc.forClass().getName(),</span><br><span class="line">            <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下没搞懂，做一些判断</span></span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(passHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable()) &#123;<span class="comment">//进行一次判断，如果序列化的接口是Externalizable类型，就进入readExternalData，否则进入readSerialData</span></span><br><span class="line">        readExternalData((Externalizable) obj, desc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        readSerialData(obj, desc);<span class="comment">//我们进入这个readSerialData函数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Externalizable类型的反序列化类型，可以指定反序列化一个类的部分数据通过writeExternal()和readExternal()方法。<br>Serializable接口也可以实现类似的机制：将不想要序列化的部分添加一个关键字：transient（临时的）。它声明的变量实行序列化操作的时候不会写入到序列化文件中去。</p>
</blockquote>
<p>继续readSerialData()，这里我们传入了class user的实例obj，以及class user的ObjectStreamClass类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">   ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;<span class="comment">//这边好像是在做遍历需要反序列化的数据</span></span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123;<span class="comment">//判断是否有数据</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span> || handles.lookupException(passHandle) != <span class="keyword">null</span>) &#123;<span class="comment">//做一些不知都是什么的意外判断，总之我们进入了else</span></span><br><span class="line">                defaultReadFields(<span class="keyword">null</span>, slotDesc); <span class="comment">// skip field values</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slotDesc.hasReadObjectMethod()) &#123;<span class="comment">//很关键，判定我们反序列化的当前class是否存在ReadObject函数，结果为真</span></span><br><span class="line">                <span class="comment">//接下来就没看懂在干啥了..好像是在获取上下文？</span></span><br><span class="line">                ThreadDeath t = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">boolean</span> reset = <span class="keyword">false</span>;</span><br><span class="line">                SerialCallbackContext oldContext = curContext;</span><br><span class="line">                <span class="keyword">if</span> (oldContext != <span class="keyword">null</span>)</span><br><span class="line">                    oldContext.check();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="keyword">this</span>);<span class="comment">//进入了这个函数，</span></span><br><span class="line">                    ....</span><br></pre></td></tr></table></figure>
<p><code>slotDesc.invokeReadObject(obj, this);</code></p>
<ul>
<li>slotDesc是我们反序列化的class user的ObjectStreamClass类</li>
<li>obj是class user的实例化</li>
<li>this就是<code>ObjectInputStream in</code>一类</li>
</ul>
<p>继续 invokeReadObject()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeReadObject</span><span class="params">(Object obj, ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> ClassNotFoundException, IOException,</span></span><br><span class="line"><span class="function">              UnsupportedOperationException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       requireInitialized();</span><br><span class="line">       <span class="keyword">if</span> (readObjectMethod != <span class="keyword">null</span>) &#123;<span class="comment">//判断是否有readObjectMethod函数</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               readObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; in &#125;);<span class="comment">//调用了这个函数，并传入了一个ObjectInputStream的Object列表</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">               Throwable th = ex.getTargetException();</span><br><span class="line">               <span class="keyword">if</span> (th <span class="keyword">instanceof</span> ClassNotFoundException) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> (ClassNotFoundException) th;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (th <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> (IOException) th;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 省略...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一开始不是理解透彻反射机制，出了java反射机制一文学习了之后回来继续</p>
</blockquote>
<p><code>readObjectMethod.invoke(obj, new Object[]{ in })</code> 其实就是一处反射机制的使用：</p>
<ul>
<li><code>readObjectMethod</code> 是 Method类型，和反射中getMethod返回的结果一样</li>
<li><code>readObjectMethod.invoke</code>，调用Method类型的invoke方法，传输进入参数去调用该readObjectMethod函数，也就是我们复写的readObject函数</li>
<li>那么invoke方法需要传入的参数是：<ul>
<li>一个之前生成的class user的实例obj</li>
<li>之前传入的ObjectInputStream类型，用new Object[]进行封装（因为<code>invoke()</code>函数接受<code>Object... args</code>作为参数，需要加一层封装保证原始数据，具体参考java反射机制一文）</li>
</ul>
</li>
</ul>
<p>那么这里就使用反射机制完成了我们写入的readObject函数的调用。<br>但是我们依旧没有解决为什么我们的user类中复写的readObject函数要使用private属性，传参java.io.ObjectInputStream呢？</p>
<p>我们需要一个对照组</p>
<h4 id="不能复写成功的对照组"><a href="#不能复写成功的对照组" class="headerlink" title="不能复写成功的对照组"></a>不能复写成功的对照组</h4><p>对照组user class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改以下readObject类 private 为 public</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结之前的调用栈，做一个总的对比，然后细说<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.ReadObject() </span><br><span class="line">-&gt; readObject0() </span><br><span class="line">-&gt; readOrdinaryObject() </span><br><span class="line">-&gt; readSerialData() ===对照组发生分支==&gt; defaultReadFields(obj, slotDesc);</span><br><span class="line">--复写组的调用路径--&gt; invokeReadObject() </span><br><span class="line">-&gt; (反射机制调用)readObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; in &#125;);</span><br></pre></td></tr></table></figure></p>
<p>两组的调用栈前面都是一致的，在<code>readSerialData()</code>中发生了判断分支：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">   ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;<span class="comment">//这边好像是在做遍历需要反序列化的数据</span></span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123;<span class="comment">//判断是否有数据</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span> || handles.lookupException(passHandle) != <span class="keyword">null</span>) &#123;<span class="comment">//做一些不知都是什么的意外判断，总之我们进入了else</span></span><br><span class="line">                defaultReadFields(<span class="keyword">null</span>, slotDesc); <span class="comment">// skip field values</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slotDesc.hasReadObjectMethod()) &#123;<span class="comment">//世界线变动之处，判定我们反序列化的当前class是否存在ReadObject函数，对照组的结果为假</span></span><br><span class="line">                ThreadDeath t = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">boolean</span> reset = <span class="keyword">false</span>;</span><br><span class="line">                SerialCallbackContext oldContext = curContext;</span><br><span class="line">                <span class="keyword">if</span> (oldContext != <span class="keyword">null</span>)</span><br><span class="line">                    oldContext.check();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="keyword">this</span>);<span class="comment">//复写成功的情况，进入了这个函数，</span></span><br><span class="line">                    ....</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                defaultReadFields(obj, slotDesc);<span class="comment">//复写失败的对照组，进入了这个函数，最后调用了本身的readObject</span></span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></p>
<p>那么我们可以知道，readObject的复写成功与否与<code>slotDesc.hasReadObjectMethod()</code>紧密相关，</p>
<p>slotDesc其实就是我们反序列化的class，而hasReadObjectMethod()其实就是判断这个反序列化class的ObjectInputStream类中的readObjectMethod参数是否为空。</p>
<p>那么readObjectMethod其实就是在生成ObjectInputStream类的时候就定义好了，到底是怎么生成的呢？我们需要去ObjectInputStream的构造函数中寻找答案<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ObjectStreamClass</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cl = cl;</span><br><span class="line">    name = cl.getName();</span><br><span class="line">    isProxy = Proxy.isProxyClass(cl);</span><br><span class="line">    isEnum = Enum.class.isAssignableFrom(cl);</span><br><span class="line">    serializable = Serializable.class.isAssignableFrom(cl);</span><br><span class="line">    externalizable = Externalizable.class.isAssignableFrom(cl);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; superCl = cl.getSuperclass();</span><br><span class="line">    superDesc = (superCl != <span class="keyword">null</span>) ? lookup(superCl, <span class="keyword">false</span>) : <span class="keyword">null</span>;</span><br><span class="line">    localDesc = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serializable) &#123;<span class="comment">//查看是否可反序列化</span></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">                    suid = Long.valueOf(<span class="number">0</span>);</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                suid = getDeclaredSUID(cl);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fields = getSerialFields(cl);</span><br><span class="line">                    computeFieldOffsets();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvalidClassException e) &#123;</span><br><span class="line">                    serializeEx = deserializeEx =</span><br><span class="line">                        <span class="keyword">new</span> ExceptionInfo(e.classname, e.getMessage());</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (externalizable) &#123;<span class="comment">//是否Externalizable类型反序列化，为false</span></span><br><span class="line">                    cons = getExternalizableConstructor(cl);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//开始解析该类，并填充ObjectStreamClass类的常量，包括我们关注的readObjectMethod</span></span><br><span class="line">                    cons = getSerializableConstructor(cl);</span><br><span class="line">                    writeObjectMethod = getPrivateMethod(cl, <span class="string">"writeObject"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectOutputStream.class &#125;,</span><br><span class="line">                        Void.TYPE);</span><br><span class="line">                    readObjectMethod = getPrivateMethod(cl, <span class="string">"readObject"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectInputStream.class &#125;,</span><br><span class="line">                        Void.TYPE);<span class="comment">//赋值readObjectMethod</span></span><br></pre></td></tr></table></figure></p>
<p>查看<code>getPrivateMethod()</code>函数,我们传入了以下参数:</p>
<ul>
<li>cl：class user类</li>
<li>name：readObject字符串</li>
<li>argTypes：ObjectInputStream.class 的Class列表封装</li>
<li>returnType：void类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns non-static private method with given signature defined by given</span></span><br><span class="line"><span class="comment"> * class, or null if none found.  Access checks are disabled on the</span></span><br><span class="line"><span class="comment"> * returned method (if any).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">getPrivateMethod</span><span class="params">(Class&lt;?&gt; cl, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Class&lt;?&gt;[] argTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Class&lt;?&gt; returnType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取class user中名为name：readObject字符串，并且接受参数类型为ObjectInputStream.class的方法</span></span><br><span class="line">        Method meth = cl.getDeclaredMethod(name, argTypes);</span><br><span class="line">        <span class="comment">//开放访问限制</span></span><br><span class="line">        meth.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取该方法的修饰符</span></span><br><span class="line">        <span class="keyword">int</span> mods = meth.getModifiers();</span><br><span class="line">        <span class="keyword">return</span> ((meth.getReturnType() == returnType) &amp;&amp;<span class="comment">//该方法的返回类型需要为void</span></span><br><span class="line">                ((mods &amp; Modifier.STATIC) == <span class="number">0</span>) &amp;&amp;<span class="comment">//该方法不能有Static修饰类型</span></span><br><span class="line">                ((mods &amp; Modifier.PRIVATE) != <span class="number">0</span>)) ? meth : <span class="keyword">null</span>;<span class="comment">//该方法需要是private的，满足所有条件，返回这个方法</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么通过<code>getPrivateMethod</code>函数的判定，只有满足以下条件的方法，readObjectMethod才会被赋值（即，readObject才会被赋值，即进入复写的世界线，执行被复写的参数）：</p>
<ul>
<li>方法名为readObject</li>
<li>返回类型为void</li>
<li>传入参数为一个ObjectInputStream.class类型参数</li>
<li>修饰符不能包含static</li>
<li>修饰符必须包含private</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此我们从源码彻底搞清楚了readObject为什么会形成复写，</p>
<p>这不是java设计导致的漏洞，而是本身的设计就是允许readObject复写，甚至详细制定了判定何种参数设定会解析为readObject复写</p>
<p>那么就产生了几个疑问:</p>
<ol>
<li><strong>一直以来java反序列化漏洞频出，为什么java要支持readObject复写？</strong></li>
</ol>
<p>因为类的实例序列化，不会将static变量和transient变量序列化，如果我们需要序列化这些变量就需要复写readObject函数，像下面这样：</p>
<p>(01) 通过writeObject()方法，写入要保存的变量。writeObject的原始定义是在ObjectOutputStream.java中，我们按照如下示例覆盖即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException</span>&#123; </span><br><span class="line">    out.defaultWriteObject();<span class="comment">// 使定制的writeObject()方法可以利用自动序列化中内置的逻辑。 </span></span><br><span class="line">    out.writeInt(ival);      <span class="comment">// 若要保存“int类型的值”，则使用writeInt()</span></span><br><span class="line">    out.writeObject(obj);    <span class="comment">// 若要保存“Object对象”，则使用writeObject()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(02) 通过readObject()方法，读取之前保存的变量。readObject的原始定义是在ObjectInputStream.java中，我们按照如下示例覆盖即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123; </span><br><span class="line">    in.defaultReadObject();       <span class="comment">// 使定制的readObject()方法可以利用自动序列化中内置的逻辑。 </span></span><br><span class="line">    <span class="keyword">int</span> ival = in.readInt();      <span class="comment">// 若要读取“int类型的值”，则使用readInt()</span></span><br><span class="line">    Object obj = in.readObject(); <span class="comment">// 若要读取“Object对象”，则使用readObject()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li><strong>为什么要规定传参，规定private修饰，void返回类型呢？</strong></li>
</ol>
<p>emmm，一个很微妙的问题，可能有为啥，可能….就是没有为啥，一个规范吧。目前母鸡，也没想去多深究了。</p>
<p>最后，在网上看到:</p>
<blockquote>
<p>readObject方法根本就不能被重写，因为原本的readObject方法被申明为final，该类型的方法不能被重写</p>
</blockquote>
<p>这种说法应该是正确的，我们并没有重写readObject，而是执行了一个自定义的全新函数，但是也不知道用词汇去修正这个形容，自己清楚就好。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>解决为何复写函数需要private属性和ObjectInputStream作为参数：<br><a href="https://xz.aliyun.com/t/4761" target="_blank" rel="noopener">膜大佬</a><br><a href="https://www.cnblogs.com/sharkli/p/5607895.html" target="_blank" rel="noopener">膜程序员</a></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#序列化与反序列化的正常使用"><span class="toc-number">1.</span> <span class="toc-text">序列化与反序列化的正常使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞原理"><span class="toc-number">2.</span> <span class="toc-text">漏洞原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#那么深究一下为啥呢"><span class="toc-number">2.1.</span> <span class="toc-text">那么深究一下为啥呢</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#不能复写成功的对照组"><span class="toc-number">2.1.1.</span> <span class="toc-text">不能复写成功的对照组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-number">4.</span> <span class="toc-text">参考文章</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://lalajun.com/2019/08/20/java反序列化-基础/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://lalajun.com/2019/08/20/java反序列化-基础/&text=java反序列化-基础"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://lalajun.com/2019/08/20/java反序列化-基础/&title=java反序列化-基础"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lalajun.com/2019/08/20/java反序列化-基础/&is_video=false&description=java反序列化-基础"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=java反序列化-基础&body=Check out this article: http://lalajun.com/2019/08/20/java反序列化-基础/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://lalajun.com/2019/08/20/java反序列化-基础/&title=java反序列化-基础"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://lalajun.com/2019/08/20/java反序列化-基础/&title=java反序列化-基础"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://lalajun.com/2019/08/20/java反序列化-基础/&title=java反序列化-基础"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://lalajun.com/2019/08/20/java反序列化-基础/&title=java反序列化-基础"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://lalajun.com/2019/08/20/java反序列化-基础/&name=java反序列化-基础&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 LaLa
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/search/">搜索</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/friends/">友链</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'lalajun';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":30,"vOffset":-20},"mobile":{"show":false},"log":false});</script></body>
</html>
